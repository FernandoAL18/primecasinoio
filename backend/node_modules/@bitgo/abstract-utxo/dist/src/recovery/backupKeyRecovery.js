"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.v1Sweep = exports.v1BackupKeyRecovery = exports.backupKeyRecovery = void 0;
const assert = require("assert");
const _ = require("lodash");
const utxolib = require("@bitgo/utxo-lib");
const { getInternalChainCode, scriptTypeForChain, outputScripts, getExternalChainCode } = utxolib.bitgo;
const unspents_1 = require("@bitgo/unspents");
const sdk_core_1 = require("@bitgo/sdk-core");
const RecoveryProvider_1 = require("./RecoveryProvider");
const mempoolApi_1 = require("./mempoolApi");
const coingeckoApi_1 = require("./coingeckoApi");
const sign_1 = require("../sign");
const utxo_lib_1 = require("@bitgo/utxo-lib");
/**
 * This transforms the txInfo from recover into the format that offline-signing-tool expects
 * @param coinName
 * @param txInfo
 * @param txHex
 * @returns {{txHex: *, txInfo: {unspents: *}, feeInfo: {}, coin: void}}
 */
function formatForOfflineVault(coinName, txInfo, txHex) {
    return {
        txHex,
        txInfo: {
            unspents: txInfo.inputs.map((input) => {
                assert(input.valueString);
                return { ...input, valueString: input.valueString };
            }),
        },
        feeInfo: {},
        coin: coinName,
    };
}
/**
 * Get the current market price from a third party to be used for recovery
 * This function is only intended for non-bitgo recovery transactions, when it is necessary
 * to calculate the rough fee needed to pay to Keyternal. We are okay with approximating,
 * because the resulting price of this function only has less than 1 dollar influence on the
 * fee that needs to be paid to Keyternal.
 *
 * See calculateFeeAmount function:  return Math.round(feeAmountUsd / currentPrice * self.getBaseFactor());
 *
 * This end function should not be used as an accurate endpoint, since some coins' prices are missing from the provider
 */
async function getRecoveryMarketPrice(coin) {
    return await new coingeckoApi_1.CoingeckoApi().getUSDPrice(coin.getFamily());
}
/**
 * Calculates the amount (in base units) to pay a KRS provider when building a recovery transaction
 * @param coin
 * @param params
 * @param params.provider {String} the KRS provider that holds the backup key
 * @returns {*}
 */
async function calculateFeeAmount(coin, params) {
    const krsProvider = sdk_core_1.krsProviders[params.provider];
    if (krsProvider === undefined) {
        throw new Error(`no fee structure specified for provider ${params.provider}`);
    }
    if (krsProvider.feeType === 'flatUsd') {
        const feeAmountUsd = krsProvider.feeAmount;
        const currentPrice = await getRecoveryMarketPrice(coin);
        return Math.round((feeAmountUsd / currentPrice) * coin.getBaseFactor());
    }
    else {
        // we can add more fee structures here as needed for different providers, such as percentage of recovery amount
        throw new Error('Fee structure not implemented');
    }
}
function getFormattedAddress(coin, address) {
    // Blockchair uses cashaddr format when querying the API for address information. Convert legacy addresses to cashaddr
    // before querying the API.
    return coin.getChain() === 'bch' || coin.getChain() === 'bcha'
        ? coin.canonicalAddress(address.address, 'cashaddr').split(':')[1]
        : address.address;
}
async function queryBlockchainUnspentsPath(coin, params, walletKeys, chain) {
    var _a;
    const scriptType = scriptTypeForChain(chain);
    const fetchPrevTx = !utxolib.bitgo.outputScripts.hasWitnessData(scriptType) && (0, utxo_lib_1.getMainnet)(coin.network) !== utxo_lib_1.networks.zcash;
    const recoveryProvider = (_a = params.recoveryProvider) !== null && _a !== void 0 ? _a : (0, RecoveryProvider_1.forCoin)(coin.getChain(), params.apiKey);
    const MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS = params.scan || 20;
    let numSequentialAddressesWithoutTxs = 0;
    const prevTxCache = new Map();
    async function getPrevTx(txid) {
        let prevTxHex = prevTxCache.get(txid);
        if (!prevTxHex) {
            prevTxHex = await recoveryProvider.getTransactionHex(txid);
            prevTxCache.set(txid, prevTxHex);
        }
        return prevTxHex;
    }
    async function gatherUnspents(addrIndex) {
        const walletKeysForUnspent = walletKeys.deriveForChainAndIndex(chain, addrIndex);
        const address = coin.createMultiSigAddress(scriptType, 2, walletKeysForUnspent.publicKeys);
        const formattedAddress = getFormattedAddress(coin, address);
        const addrInfo = await recoveryProvider.getAddressInfo(formattedAddress);
        // we use txCount here because it implies usage - having tx'es means the addr was generated and used
        if (addrInfo.txCount === 0) {
            numSequentialAddressesWithoutTxs++;
        }
        else {
            numSequentialAddressesWithoutTxs = 0;
            if (addrInfo.balance > 0) {
                console.log(`Found an address with balance: ${address.address} with balance ${addrInfo.balance}`);
                const addressUnspents = await recoveryProvider.getUnspentsForAddresses([formattedAddress]);
                const processedUnspents = await Promise.all(addressUnspents.map(async (u) => {
                    const { txid, vout } = utxolib.bitgo.parseOutputId(u.id);
                    let val = BigInt(u.value);
                    if (coin.amountType === 'bigint') {
                        // blockchair returns the number with the correct precision, but in number format
                        // json parse won't parse it correctly, so we requery the txid for the tx hex to decode here
                        if (!Number.isSafeInteger(u.value)) {
                            const txHex = await getPrevTx(txid);
                            const tx = coin.createTransactionFromHex(txHex);
                            val = tx.outs[vout].value;
                        }
                    }
                    // the api may return cashaddr's instead of legacy for BCH and BCHA
                    // downstream processes's only expect legacy addresses
                    u = { ...u, address: coin.canonicalAddress(u.address) };
                    return {
                        ...u,
                        value: val,
                        chain: chain,
                        index: addrIndex,
                        prevTx: fetchPrevTx ? Buffer.from(await getPrevTx(txid), 'hex') : undefined,
                    };
                }));
                walletUnspents.push(...processedUnspents);
            }
        }
        if (numSequentialAddressesWithoutTxs >= MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS) {
            // stop searching for addresses with unspents in them, we've found ${MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS} in a row with none
            // we are done
            return;
        }
        return gatherUnspents(addrIndex + 1);
    }
    // get unspents for these addresses
    const walletUnspents = [];
    // This will populate walletAddresses
    await gatherUnspents(0);
    if (walletUnspents.length === 0) {
        // Couldn't find any addresses with funds
        return [];
    }
    return walletUnspents;
}
async function getRecoveryFeePerBytes(coin, { defaultValue }) {
    try {
        return await mempoolApi_1.MempoolApi.forCoin(coin.getChain()).getRecoveryFeePerBytes();
    }
    catch (e) {
        console.dir(e);
        return defaultValue;
    }
}
/**
 * Builds a funds recovery transaction without BitGo.
 *
 * Returns transaction hex in legacy format for unsigned sweep transaction, half signed backup recovery transaction with KRS provider (only keyternal),
 * fully signed backup recovery transaction without a KRS provider.
 *
 * Returns PSBT hex for half signed backup recovery transaction with KRS provider (excluding keyternal)
 * For PSBT hex cases, Unspents are not required in response.
 *
 * @param coin
 * @param bitgo
 * @param params
 * - userKey: [encrypted] xprv, or xpub
 * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
 * - walletPassphrase: necessary if one of the xprvs is encrypted
 * - bitgoKey: xpub
 * - krsProvider: necessary if backup key is held by KRS
 * - recoveryDestination: target address to send recovered funds to
 * - scan: the amount of consecutive addresses without unspents to scan through before stopping
 * - ignoreAddressTypes: (optional) scripts to ignore
 *        for example: ['p2shP2wsh', 'p2wsh'] will prevent code from checking for wrapped-segwit and native-segwit chains on the public block explorers
 */
async function backupKeyRecovery(coin, bitgo, params) {
    if (_.isUndefined(params.userKey)) {
        throw new Error('missing userKey');
    }
    if (_.isUndefined(params.backupKey)) {
        throw new Error('missing backupKey');
    }
    if (_.isUndefined(params.recoveryDestination) ||
        !coin.isValidAddress(params.recoveryDestination, { anyFormat: true })) {
        throw new Error('invalid recoveryDestination');
    }
    if (!_.isUndefined(params.scan) && (!_.isInteger(params.scan) || params.scan < 0)) {
        throw new Error('scan must be a positive integer');
    }
    const isKrsRecovery = (0, sdk_core_1.getIsKrsRecovery)(params);
    const isUnsignedSweep = (0, sdk_core_1.getIsUnsignedSweep)(params);
    const responseTxFormat = isUnsignedSweep || !isKrsRecovery || params.krsProvider === 'keyternal' ? 'legacy' : 'psbt';
    const krsProvider = isKrsRecovery ? (0, sdk_core_1.getKrsProvider)(coin, params.krsProvider) : undefined;
    // check whether key material and password authenticate the users and return parent keys of all three keys of the wallet
    const keys = (0, sdk_core_1.getBip32Keys)(bitgo, params, { requireBitGoXpub: true });
    if (!(0, sdk_core_1.isTriple)(keys)) {
        throw new Error(`expected key triple`);
    }
    const walletKeys = new utxolib.bitgo.RootWalletKeys(keys, [
        params.userKeyPath || utxolib.bitgo.RootWalletKeys.defaultPrefix,
        utxolib.bitgo.RootWalletKeys.defaultPrefix,
        utxolib.bitgo.RootWalletKeys.defaultPrefix,
    ]);
    const unspents = (await Promise.all(outputScripts.scriptTypes2Of3
        .filter((addressType) => { var _a; return coin.supportsAddressType(addressType) && !((_a = params.ignoreAddressTypes) === null || _a === void 0 ? void 0 : _a.includes(addressType)); })
        .reduce((queries, addressType) => [
        ...queries,
        queryBlockchainUnspentsPath(coin, params, walletKeys, getExternalChainCode(addressType)),
        queryBlockchainUnspentsPath(coin, params, walletKeys, getInternalChainCode(addressType)),
    ], []))).flat();
    // Execute the queries and gather the unspents
    const totalInputAmount = utxolib.bitgo.unspentSum(unspents, 'bigint');
    if (totalInputAmount <= BigInt(0)) {
        throw new sdk_core_1.ErrorNoInputToRecover();
    }
    // Build the psbt
    const psbt = utxolib.bitgo.createPsbtForNetwork({ network: coin.network });
    // xpubs can become handy for many things.
    utxolib.bitgo.addXpubsToPsbt(psbt, walletKeys);
    const txInfo = {};
    const feePerByte = await getRecoveryFeePerBytes(coin, { defaultValue: 100 });
    // KRS recovery transactions have a 2nd output to pay the recovery fee, like paygo fees. Use p2wsh outputs because
    // they are the largest outputs and thus the most conservative estimate to use in calculating fees. Also use
    // segwit overhead size and p2sh inputs for the same reason.
    const outputSize = (isKrsRecovery ? 2 : 1) * unspents_1.VirtualSizes.txP2wshOutputSize;
    const approximateSize = unspents_1.VirtualSizes.txSegOverheadVSize + outputSize + unspents_1.VirtualSizes.txP2shInputSize * unspents.length;
    const approximateFee = BigInt(approximateSize * feePerByte);
    txInfo.inputs =
        responseTxFormat === 'legacy'
            ? unspents.map((u) => ({ ...u, value: Number(u.value), valueString: u.value.toString(), prevTx: undefined }))
            : undefined;
    unspents.forEach((unspent) => {
        utxolib.bitgo.addWalletUnspentToPsbt(psbt, unspent, walletKeys, 'user', 'backup');
    });
    let krsFee = BigInt(0);
    if (isKrsRecovery && params.krsProvider) {
        try {
            krsFee = BigInt(await calculateFeeAmount(coin, { provider: params.krsProvider }));
        }
        catch (err) {
            // Don't let this error block the recovery -
            console.dir(err);
        }
    }
    const recoveryAmount = totalInputAmount - approximateFee - krsFee;
    if (recoveryAmount < BigInt(0)) {
        throw new Error(`this wallet\'s balance is too low to pay the fees specified by the KRS provider. 
          Existing balance on wallet: ${totalInputAmount.toString()}. Estimated network fee for the recovery transaction
          : ${approximateFee.toString()}, KRS fee to pay: ${krsFee.toString()}. After deducting fees, your total 
          recoverable balance is ${recoveryAmount.toString()}`);
    }
    const recoveryOutputScript = utxolib.address.toOutputScript(params.recoveryDestination, coin.network);
    psbt.addOutput({ script: recoveryOutputScript, value: recoveryAmount });
    if (krsProvider && krsFee > BigInt(0)) {
        if (!krsProvider.feeAddresses) {
            throw new Error(`keyProvider must define feeAddresses`);
        }
        const krsFeeAddress = krsProvider.feeAddresses[coin.getChain()];
        if (!krsFeeAddress) {
            throw new Error('this KRS provider has not configured their fee structure yet - recovery cannot be completed');
        }
        const krsFeeOutputScript = utxolib.address.toOutputScript(krsFeeAddress, coin.network);
        psbt.addOutput({ script: krsFeeOutputScript, value: krsFee });
    }
    if (isUnsignedSweep) {
        // TODO BTC-317 - When ready to PSBTify OVC, send psbt hex and skip unspents in response.
        const txHex = psbt.getUnsignedTx().toBuffer().toString('hex');
        return formatForOfflineVault(coin.getChain(), txInfo, txHex);
    }
    else {
        (0, sign_1.signAndVerifyPsbt)(psbt, walletKeys.user, { isLastSignature: false });
        if (isKrsRecovery) {
            // The KRS provider keyternal solely supports P2SH, P2WSH, and P2SH-P2WSH input script types.
            // It currently uses an outdated BitGoJS SDK, which relies on a legacy transaction builder for cosigning.
            // Unfortunately, upgrading the keyternal code presents challenges,
            // which hinders the integration of the latest BitGoJS SDK with PSBT signing support.
            txInfo.transactionHex =
                params.krsProvider === 'keyternal'
                    ? utxolib.bitgo.extractP2msOnlyHalfSignedTx(psbt).toBuffer().toString('hex')
                    : psbt.toHex();
        }
        else {
            const tx = (0, sign_1.signAndVerifyPsbt)(psbt, walletKeys.backup, { isLastSignature: true });
            txInfo.transactionHex = tx.toBuffer().toString('hex');
        }
    }
    if (isKrsRecovery) {
        txInfo.coin = coin.getChain();
        txInfo.backupKey = params.backupKey;
        txInfo.recoveryAmount = Number(recoveryAmount);
        txInfo.recoveryAmountString = recoveryAmount.toString();
    }
    return txInfo;
}
exports.backupKeyRecovery = backupKeyRecovery;
async function v1BackupKeyRecovery(coin, bitgo, params) {
    if (_.isUndefined(params.recoveryDestination) ||
        !coin.isValidAddress(params.recoveryDestination, { anyFormat: true })) {
        throw new Error('invalid recoveryDestination');
    }
    const recoveryFeePerByte = await getRecoveryFeePerBytes(coin, { defaultValue: 100 });
    const v1wallet = await bitgo.wallets().get({ id: params.walletId });
    return await v1wallet.recover({
        ...params,
        feeRate: recoveryFeePerByte,
    });
}
exports.v1BackupKeyRecovery = v1BackupKeyRecovery;
async function v1Sweep(coin, bitgo, params) {
    if (_.isUndefined(params.recoveryDestination) ||
        !coin.isValidAddress(params.recoveryDestination, { anyFormat: true })) {
        throw new Error('invalid recoveryDestination');
    }
    let recoveryFeePerByte = 100;
    if (bitgo.env === 'prod') {
        recoveryFeePerByte = await getRecoveryFeePerBytes(coin, { defaultValue: 100 });
    }
    const v1wallet = await bitgo.wallets().get({ id: params.walletId });
    return await v1wallet.sweep({
        ...params,
        feeRate: recoveryFeePerByte,
    });
}
exports.v1Sweep = v1Sweep;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja3VwS2V5UmVjb3ZlcnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcmVjb3ZlcnkvYmFja3VwS2V5UmVjb3ZlcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSCxpQ0FBaUM7QUFDakMsNEJBQTRCO0FBQzVCLDJDQUEyQztBQUMzQyxNQUFNLEVBQUUsb0JBQW9CLEVBQUUsa0JBQWtCLEVBQUUsYUFBYSxFQUFFLG9CQUFvQixFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztBQVV4Ryw4Q0FBK0M7QUFFL0MsOENBU3lCO0FBR3pCLHlEQUErRDtBQUMvRCw2Q0FBMEM7QUFDMUMsaURBQThDO0FBQzlDLGtDQUE0QztBQUM1Qyw4Q0FBdUQ7QUFldkQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxxQkFBcUIsQ0FDNUIsUUFBZ0IsRUFDaEIsTUFBMEIsRUFDMUIsS0FBYTtJQUViLE9BQU87UUFDTCxLQUFLO1FBQ0wsTUFBTSxFQUFFO1lBQ04sUUFBUSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ3BDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQzFCLE9BQU8sRUFBRSxHQUFHLEtBQUssRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ3RELENBQUMsQ0FBQztTQUNIO1FBQ0QsT0FBTyxFQUFFLEVBQUU7UUFDWCxJQUFJLEVBQUUsUUFBUTtLQUNmLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7R0FVRztBQUNILEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxJQUFzQjtJQUMxRCxPQUFPLE1BQU0sSUFBSSwyQkFBWSxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0FBQ2hFLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxLQUFLLFVBQVUsa0JB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LElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7S0FDaEQ7SUFFRCxJQUFJLGtCQUFrQixHQUFHLEdBQUcsQ0FBQztJQUM3QixJQUFJLEtBQUssQ0FBQyxHQUFHLEtBQUssTUFBTSxFQUFFO1FBQ3hCLGtCQUFrQixHQUFHLE1BQU0sc0JBQXNCLENBQUMsSUFBSSxFQUFFLEVBQUUsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7S0FDaEY7SUFFRCxNQUFNLFFBQVEsR0FBRyxNQUFNLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7SUFDcEUsT0FBTyxNQUFNLFFBQVEsQ0FBQyxLQUFLLENBQUM7UUFDMUIsR0FBRyxNQUFNO1FBQ1QsT0FBTyxFQUFFLGtCQUFrQjtLQUM1QixDQUFDLENBQUM7QUFDTCxDQUFDO0FBMUJELDBCQTBCQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cblxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyB1dHhvbGliIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5jb25zdCB7IGdldEludGVybmFsQ2hhaW5Db2RlLCBzY3JpcHRUeXBlRm9yQ2hhaW4sIG91dHB1dFNjcmlwdHMsIGdldEV4dGVybmFsQ2hhaW5Db2RlIH0gPSB1dHhvbGliLmJpdGdvO1xuXG50eXBlIENoYWluQ29kZSA9IHV0eG9saWIuYml0Z28uQ2hhaW5Db2RlO1xudHlwZSBSb290V2FsbGV0S2V5cyA9IHV0eG9saWIuYml0Z28uUm9vdFdhbGxldEtleXM7XG50eXBlIFdhbGxldFVuc3BlbnQ8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4gPSB1dHhvbGliLmJpdGdvLldhbGxldFVuc3BlbnQ8VE51bWJlcj47XG50eXBlIFdhbGxldFVuc3BlbnRKU09OID0gdXR4b2xpYi5iaXRnby5XYWxsZXRVbnNwZW50ICYge1xuICB2YWx1ZVN0cmluZzogc3RyaW5nO1xufTtcbnR5cGUgU2NyaXB0VHlwZTJPZjMgPSB1dHhvbGliLmJpdGdvLm91dHB1dFNjcmlwdHMuU2NyaXB0VHlwZTJPZjM7XG5cbmltcG9ydCB7IFZpcnR1YWxTaXplcyB9IGZyb20gJ0BiaXRnby91bnNwZW50cyc7XG5cbmltcG9ydCB7XG4gIEJpdEdvQmFzZSxcbiAgRXJyb3JOb0lucHV0VG9SZWNvdmVyLFxuICBnZXRLcnNQcm92aWRlcixcbiAgZ2V0QmlwMzJLZXlzLFxuICBnZXRJc0tyc1JlY292ZXJ5LFxuICBnZXRJc1Vuc2lnbmVkU3dlZXAsXG4gIGlzVHJpcGxlLFxuICBrcnNQcm92aWRlcnMsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdFV0eG9Db2luLCBNdWx0aVNpZ0FkZHJlc3MgfSBmcm9tICcuLi9hYnN0cmFjdFV0eG9Db2luJztcblxuaW1wb3J0IHsgZm9yQ29pbiwgUmVjb3ZlcnlQcm92aWRlciB9IGZyb20gJy4vUmVjb3ZlcnlQcm92aWRlcic7XG5pbXBvcnQgeyBNZW1wb29sQXBpIH0gZnJvbSAnLi9tZW1wb29sQXBpJztcbmltcG9ydCB7IENvaW5nZWNrb0FwaSB9IGZyb20gJy4vY29pbmdlY2tvQXBpJztcbmltcG9ydCB7IHNpZ25BbmRWZXJpZnlQc2J0IH0gZnJvbSAnLi4vc2lnbic7XG5pbXBvcnQgeyBnZXRNYWlubmV0LCBuZXR3b3JrcyB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgaW5wdXRzOiBXYWxsZXRVbnNwZW50PG51bWJlcj5bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXR0ZWRPZmZsaW5lVmF1bHRUeEluZm8ge1xuICB0eEluZm86IHtcbiAgICB1bnNwZW50czogV2FsbGV0VW5zcGVudEpTT05bXTtcbiAgfTtcbiAgdHhIZXg6IHN0cmluZztcbiAgZmVlSW5mbzogUmVjb3JkPHN0cmluZywgbmV2ZXI+O1xuICBjb2luOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhpcyB0cmFuc2Zvcm1zIHRoZSB0eEluZm8gZnJvbSByZWNvdmVyIGludG8gdGhlIGZvcm1hdCB0aGF0IG9mZmxpbmUtc2lnbmluZy10b29sIGV4cGVjdHNcbiAqIEBwYXJhbSBjb2luTmFtZVxuICogQHBhcmFtIHR4SW5mb1xuICogQHBhcmFtIHR4SGV4XG4gKiBAcmV0dXJucyB7e3R4SGV4OiAqLCB0eEluZm86IHt1bnNwZW50czogKn0sIGZlZUluZm86IHt9LCBjb2luOiB2b2lkfX1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KFxuICBjb2luTmFtZTogc3RyaW5nLFxuICB0eEluZm86IE9mZmxpbmVWYXVsdFR4SW5mbyxcbiAgdHhIZXg6IHN0cmluZ1xuKTogRm9ybWF0dGVkT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgcmV0dXJuIHtcbiAgICB0eEhleCxcbiAgICB0eEluZm86IHtcbiAgICAgIHVuc3BlbnRzOiB0eEluZm8uaW5wdXRzLm1hcCgoaW5wdXQpID0+IHtcbiAgICAgICAgYXNzZXJ0KGlucHV0LnZhbHVlU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHsgLi4uaW5wdXQsIHZhbHVlU3RyaW5nOiBpbnB1dC52YWx1ZVN0cmluZyB9O1xuICAgICAgfSksXG4gICAgfSxcbiAgICBmZWVJbmZvOiB7fSxcbiAgICBjb2luOiBjb2luTmFtZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgbWFya2V0IHByaWNlIGZyb20gYSB0aGlyZCBwYXJ0eSB0byBiZSB1c2VkIGZvciByZWNvdmVyeVxuICogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGludGVuZGVkIGZvciBub24tYml0Z28gcmVjb3ZlcnkgdHJhbnNhY3Rpb25zLCB3aGVuIGl0IGlzIG5lY2Vzc2FyeVxuICogdG8gY2FsY3VsYXRlIHRoZSByb3VnaCBmZWUgbmVlZGVkIHRvIHBheSB0byBLZXl0ZXJuYWwuIFdlIGFyZSBva2F5IHdpdGggYXBwcm94aW1hdGluZyxcbiAqIGJlY2F1c2UgdGhlIHJlc3VsdGluZyBwcmljZSBvZiB0aGlzIGZ1bmN0aW9uIG9ubHkgaGFzIGxlc3MgdGhhbiAxIGRvbGxhciBpbmZsdWVuY2Ugb24gdGhlXG4gKiBmZWUgdGhhdCBuZWVkcyB0byBiZSBwYWlkIHRvIEtleXRlcm5hbC5cbiAqXG4gKiBTZWUgY2FsY3VsYXRlRmVlQW1vdW50IGZ1bmN0aW9uOiAgcmV0dXJuIE1hdGgucm91bmQoZmVlQW1vdW50VXNkIC8gY3VycmVudFByaWNlICogc2VsZi5nZXRCYXNlRmFjdG9yKCkpO1xuICpcbiAqIFRoaXMgZW5kIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgdXNlZCBhcyBhbiBhY2N1cmF0ZSBlbmRwb2ludCwgc2luY2Ugc29tZSBjb2lucycgcHJpY2VzIGFyZSBtaXNzaW5nIGZyb20gdGhlIHByb3ZpZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFJlY292ZXJ5TWFya2V0UHJpY2UoY29pbjogQWJzdHJhY3RVdHhvQ29pbik6IFByb21pc2U8bnVtYmVyPiB7XG4gIHJldHVybiBhd2FpdCBuZXcgQ29pbmdlY2tvQXBpKCkuZ2V0VVNEUHJpY2UoY29pbi5nZXRGYW1pbHkoKSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYW1vdW50IChpbiBiYXNlIHVuaXRzKSB0byBwYXkgYSBLUlMgcHJvdmlkZXIgd2hlbiBidWlsZGluZyBhIHJlY292ZXJ5IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gY29pblxuICogQHBhcmFtIHBhcmFtc1xuICogQHBhcmFtIHBhcmFtcy5wcm92aWRlciB7U3RyaW5nfSB0aGUgS1JTIHByb3ZpZGVyIHRoYXQgaG9sZHMgdGhlIGJhY2t1cCBrZXlcbiAqIEByZXR1cm5zIHsqfVxuICovXG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVGZWVBbW91bnQoY29pbjogQWJzdHJhY3RVdHhvQ29pbiwgcGFyYW1zOiB7IHByb3ZpZGVyOiBzdHJpbmcgfSk6IFByb21pc2U8bnVtYmVyPiB7XG4gIGNvbnN0IGtyc1Byb3ZpZGVyID0ga3JzUHJvdmlkZXJzW3BhcmFtcy5wcm92aWRlcl07XG5cbiAgaWYgKGtyc1Byb3ZpZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGZlZSBzdHJ1Y3R1cmUgc3BlY2lmaWVkIGZvciBwcm92aWRlciAke3BhcmFtcy5wcm92aWRlcn1gKTtcbiAgfVxuXG4gIGlmIChrcnNQcm92aWRlci5mZWVUeXBlID09PSAnZmxhdFVzZCcpIHtcbiAgICBjb25zdCBmZWVBbW91bnRVc2QgPSBrcnNQcm92aWRlci5mZWVBbW91bnQ7XG4gICAgY29uc3QgY3VycmVudFByaWNlOiBudW1iZXIgPSBhd2FpdCBnZXRSZWNvdmVyeU1hcmtldFByaWNlKGNvaW4pO1xuXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGZlZUFtb3VudFVzZCAvIGN1cnJlbnRQcmljZSkgKiBjb2luLmdldEJhc2VGYWN0b3IoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2UgY2FuIGFkZCBtb3JlIGZlZSBzdHJ1Y3R1cmVzIGhlcmUgYXMgbmVlZGVkIGZvciBkaWZmZXJlbnQgcHJvdmlkZXJzLCBzdWNoIGFzIHBlcmNlbnRhZ2Ugb2YgcmVjb3ZlcnkgYW1vdW50XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGZWUgc3RydWN0dXJlIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlclBhcmFtcyB7XG4gIHNjYW4/OiBudW1iZXI7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIGJpdGdvS2V5OiBzdHJpbmc7XG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZztcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG4gIGlnbm9yZUFkZHJlc3NUeXBlczogU2NyaXB0VHlwZTJPZjNbXTtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgYXBpS2V5Pzogc3RyaW5nO1xuICB1c2VyS2V5UGF0aD86IHN0cmluZztcbiAgcmVjb3ZlcnlQcm92aWRlcj86IFJlY292ZXJ5UHJvdmlkZXI7XG59XG5cbmZ1bmN0aW9uIGdldEZvcm1hdHRlZEFkZHJlc3MoY29pbjogQWJzdHJhY3RVdHhvQ29pbiwgYWRkcmVzczogTXVsdGlTaWdBZGRyZXNzKSB7XG4gIC8vIEJsb2NrY2hhaXIgdXNlcyBjYXNoYWRkciBmb3JtYXQgd2hlbiBxdWVyeWluZyB0aGUgQVBJIGZvciBhZGRyZXNzIGluZm9ybWF0aW9uLiBDb252ZXJ0IGxlZ2FjeSBhZGRyZXNzZXMgdG8gY2FzaGFkZHJcbiAgLy8gYmVmb3JlIHF1ZXJ5aW5nIHRoZSBBUEkuXG4gIHJldHVybiBjb2luLmdldENoYWluKCkgPT09ICdiY2gnIHx8IGNvaW4uZ2V0Q2hhaW4oKSA9PT0gJ2JjaGEnXG4gICAgPyBjb2luLmNhbm9uaWNhbEFkZHJlc3MoYWRkcmVzcy5hZGRyZXNzLCAnY2FzaGFkZHInKS5zcGxpdCgnOicpWzFdXG4gICAgOiBhZGRyZXNzLmFkZHJlc3M7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHF1ZXJ5QmxvY2tjaGFpblVuc3BlbnRzUGF0aChcbiAgY29pbjogQWJzdHJhY3RVdHhvQ29pbixcbiAgcGFyYW1zOiBSZWNvdmVyUGFyYW1zLFxuICB3YWxsZXRLZXlzOiBSb290V2FsbGV0S2V5cyxcbiAgY2hhaW46IENoYWluQ29kZVxuKTogUHJvbWlzZTxXYWxsZXRVbnNwZW50PGJpZ2ludD5bXT4ge1xuICBjb25zdCBzY3JpcHRUeXBlID0gc2NyaXB0VHlwZUZvckNoYWluKGNoYWluKTtcbiAgY29uc3QgZmV0Y2hQcmV2VHggPVxuICAgICF1dHhvbGliLmJpdGdvLm91dHB1dFNjcmlwdHMuaGFzV2l0bmVzc0RhdGEoc2NyaXB0VHlwZSkgJiYgZ2V0TWFpbm5ldChjb2luLm5ldHdvcmspICE9PSBuZXR3b3Jrcy56Y2FzaDtcbiAgY29uc3QgcmVjb3ZlcnlQcm92aWRlciA9IHBhcmFtcy5yZWNvdmVyeVByb3ZpZGVyID8/IGZvckNvaW4oY29pbi5nZXRDaGFpbigpLCBwYXJhbXMuYXBpS2V5KTtcbiAgY29uc3QgTUFYX1NFUVVFTlRJQUxfQUREUkVTU0VTX1dJVEhPVVRfVFhTID0gcGFyYW1zLnNjYW4gfHwgMjA7XG4gIGxldCBudW1TZXF1ZW50aWFsQWRkcmVzc2VzV2l0aG91dFR4cyA9IDA7XG4gIGNvbnN0IHByZXZUeENhY2hlID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblxuICBhc3luYyBmdW5jdGlvbiBnZXRQcmV2VHgodHhpZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBsZXQgcHJldlR4SGV4ID0gcHJldlR4Q2FjaGUuZ2V0KHR4aWQpO1xuICAgIGlmICghcHJldlR4SGV4KSB7XG4gICAgICBwcmV2VHhIZXggPSBhd2FpdCByZWNvdmVyeVByb3ZpZGVyLmdldFRyYW5zYWN0aW9uSGV4KHR4aWQpO1xuICAgICAgcHJldlR4Q2FjaGUuc2V0KHR4aWQsIHByZXZUeEhleCk7XG4gICAgfVxuICAgIHJldHVybiBwcmV2VHhIZXg7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBnYXRoZXJVbnNwZW50cyhhZGRySW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IHdhbGxldEtleXNGb3JVbnNwZW50ID0gd2FsbGV0S2V5cy5kZXJpdmVGb3JDaGFpbkFuZEluZGV4KGNoYWluLCBhZGRySW5kZXgpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSBjb2luLmNyZWF0ZU11bHRpU2lnQWRkcmVzcyhzY3JpcHRUeXBlLCAyLCB3YWxsZXRLZXlzRm9yVW5zcGVudC5wdWJsaWNLZXlzKTtcblxuICAgIGNvbnN0IGZvcm1hdHRlZEFkZHJlc3MgPSBnZXRGb3JtYXR0ZWRBZGRyZXNzKGNvaW4sIGFkZHJlc3MpO1xuICAgIGNvbnN0IGFkZHJJbmZvID0gYXdhaXQgcmVjb3ZlcnlQcm92aWRlci5nZXRBZGRyZXNzSW5mbyhmb3JtYXR0ZWRBZGRyZXNzKTtcbiAgICAvLyB3ZSB1c2UgdHhDb3VudCBoZXJlIGJlY2F1c2UgaXQgaW1wbGllcyB1c2FnZSAtIGhhdmluZyB0eCdlcyBtZWFucyB0aGUgYWRkciB3YXMgZ2VuZXJhdGVkIGFuZCB1c2VkXG4gICAgaWYgKGFkZHJJbmZvLnR4Q291bnQgPT09IDApIHtcbiAgICAgIG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzID0gMDtcblxuICAgICAgaWYgKGFkZHJJbmZvLmJhbGFuY2UgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBhbiBhZGRyZXNzIHdpdGggYmFsYW5jZTogJHthZGRyZXNzLmFkZHJlc3N9IHdpdGggYmFsYW5jZSAke2FkZHJJbmZvLmJhbGFuY2V9YCk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NVbnNwZW50cyA9IGF3YWl0IHJlY292ZXJ5UHJvdmlkZXIuZ2V0VW5zcGVudHNGb3JBZGRyZXNzZXMoW2Zvcm1hdHRlZEFkZHJlc3NdKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkVW5zcGVudHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBhZGRyZXNzVW5zcGVudHMubWFwKGFzeW5jICh1KTogUHJvbWlzZTxXYWxsZXRVbnNwZW50PGJpZ2ludD4+ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHhpZCwgdm91dCB9ID0gdXR4b2xpYi5iaXRnby5wYXJzZU91dHB1dElkKHUuaWQpO1xuICAgICAgICAgICAgbGV0IHZhbCA9IEJpZ0ludCh1LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb2luLmFtb3VudFR5cGUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgIC8vIGJsb2NrY2hhaXIgcmV0dXJucyB0aGUgbnVtYmVyIHdpdGggdGhlIGNvcnJlY3QgcHJlY2lzaW9uLCBidXQgaW4gbnVtYmVyIGZvcm1hdFxuICAgICAgICAgICAgICAvLyBqc29uIHBhcnNlIHdvbid0IHBhcnNlIGl0IGNvcnJlY3RseSwgc28gd2UgcmVxdWVyeSB0aGUgdHhpZCBmb3IgdGhlIHR4IGhleCB0byBkZWNvZGUgaGVyZVxuICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhIZXggPSBhd2FpdCBnZXRQcmV2VHgodHhpZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSBjb2luLmNyZWF0ZVRyYW5zYWN0aW9uRnJvbUhleDxiaWdpbnQ+KHR4SGV4KTtcbiAgICAgICAgICAgICAgICB2YWwgPSB0eC5vdXRzW3ZvdXRdLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgYXBpIG1heSByZXR1cm4gY2FzaGFkZHIncyBpbnN0ZWFkIG9mIGxlZ2FjeSBmb3IgQkNIIGFuZCBCQ0hBXG4gICAgICAgICAgICAvLyBkb3duc3RyZWFtIHByb2Nlc3NlcydzIG9ubHkgZXhwZWN0IGxlZ2FjeSBhZGRyZXNzZXNcbiAgICAgICAgICAgIHUgPSB7IC4uLnUsIGFkZHJlc3M6IGNvaW4uY2Fub25pY2FsQWRkcmVzcyh1LmFkZHJlc3MpIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi51LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICAgIGluZGV4OiBhZGRySW5kZXgsXG4gICAgICAgICAgICAgIHByZXZUeDogZmV0Y2hQcmV2VHggPyBCdWZmZXIuZnJvbShhd2FpdCBnZXRQcmV2VHgodHhpZCksICdoZXgnKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0gYXMgV2FsbGV0VW5zcGVudDxiaWdpbnQ+O1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgd2FsbGV0VW5zcGVudHMucHVzaCguLi5wcm9jZXNzZWRVbnNwZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzID49IE1BWF9TRVFVRU5USUFMX0FERFJFU1NFU19XSVRIT1VUX1RYUykge1xuICAgICAgLy8gc3RvcCBzZWFyY2hpbmcgZm9yIGFkZHJlc3NlcyB3aXRoIHVuc3BlbnRzIGluIHRoZW0sIHdlJ3ZlIGZvdW5kICR7TUFYX1NFUVVFTlRJQUxfQUREUkVTU0VTX1dJVEhPVVRfVFhTfSBpbiBhIHJvdyB3aXRoIG5vbmVcbiAgICAgIC8vIHdlIGFyZSBkb25lXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGdhdGhlclVuc3BlbnRzKGFkZHJJbmRleCArIDEpO1xuICB9XG5cbiAgLy8gZ2V0IHVuc3BlbnRzIGZvciB0aGVzZSBhZGRyZXNzZXNcblxuICBjb25zdCB3YWxsZXRVbnNwZW50czogV2FsbGV0VW5zcGVudDxiaWdpbnQ+W10gPSBbXTtcbiAgLy8gVGhpcyB3aWxsIHBvcHVsYXRlIHdhbGxldEFkZHJlc3Nlc1xuICBhd2FpdCBnYXRoZXJVbnNwZW50cygwKTtcblxuICBpZiAod2FsbGV0VW5zcGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gQ291bGRuJ3QgZmluZCBhbnkgYWRkcmVzc2VzIHdpdGggZnVuZHNcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gd2FsbGV0VW5zcGVudHM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlY292ZXJ5RmVlUGVyQnl0ZXMoXG4gIGNvaW46IEFic3RyYWN0VXR4b0NvaW4sXG4gIHsgZGVmYXVsdFZhbHVlIH06IHsgZGVmYXVsdFZhbHVlOiBudW1iZXIgfVxuKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgTWVtcG9vbEFwaS5mb3JDb2luKGNvaW4uZ2V0Q2hhaW4oKSkuZ2V0UmVjb3ZlcnlGZWVQZXJCeXRlcygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5kaXIoZSk7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBCYWNrdXBLZXlSZWNvdmVyeVRyYW5zYW5zYWN0aW9uID0ge1xuICBpbnB1dHM/OiBXYWxsZXRVbnNwZW50PG51bWJlcj5bXTtcbiAgdHJhbnNhY3Rpb25IZXg6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgcmVjb3ZlcnlBbW91bnQ6IG51bWJlcjtcbiAgcmVjb3ZlcnlBbW91bnRTdHJpbmc6IHN0cmluZztcbn07XG5cbi8qKlxuICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHby5cbiAqXG4gKiBSZXR1cm5zIHRyYW5zYWN0aW9uIGhleCBpbiBsZWdhY3kgZm9ybWF0IGZvciB1bnNpZ25lZCBzd2VlcCB0cmFuc2FjdGlvbiwgaGFsZiBzaWduZWQgYmFja3VwIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGggS1JTIHByb3ZpZGVyIChvbmx5IGtleXRlcm5hbCksXG4gKiBmdWxseSBzaWduZWQgYmFja3VwIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgYSBLUlMgcHJvdmlkZXIuXG4gKlxuICogUmV0dXJucyBQU0JUIGhleCBmb3IgaGFsZiBzaWduZWQgYmFja3VwIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGggS1JTIHByb3ZpZGVyIChleGNsdWRpbmcga2V5dGVybmFsKVxuICogRm9yIFBTQlQgaGV4IGNhc2VzLCBVbnNwZW50cyBhcmUgbm90IHJlcXVpcmVkIGluIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSBjb2luXG4gKiBAcGFyYW0gYml0Z29cbiAqIEBwYXJhbSBwYXJhbXNcbiAqIC0gdXNlcktleTogW2VuY3J5cHRlZF0geHBydiwgb3IgeHB1YlxuICogLSBiYWNrdXBLZXk6IFtlbmNyeXB0ZWRdIHhwcnYsIG9yIHhwdWIgaWYgdGhlIHhwcnYgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSB4cHJ2cyBpcyBlbmNyeXB0ZWRcbiAqIC0gYml0Z29LZXk6IHhwdWJcbiAqIC0ga3JzUHJvdmlkZXI6IG5lY2Vzc2FyeSBpZiBiYWNrdXAga2V5IGlzIGhlbGQgYnkgS1JTXG4gKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gKiAtIHNjYW46IHRoZSBhbW91bnQgb2YgY29uc2VjdXRpdmUgYWRkcmVzc2VzIHdpdGhvdXQgdW5zcGVudHMgdG8gc2NhbiB0aHJvdWdoIGJlZm9yZSBzdG9wcGluZ1xuICogLSBpZ25vcmVBZGRyZXNzVHlwZXM6IChvcHRpb25hbCkgc2NyaXB0cyB0byBpZ25vcmVcbiAqICAgICAgICBmb3IgZXhhbXBsZTogWydwMnNoUDJ3c2gnLCAncDJ3c2gnXSB3aWxsIHByZXZlbnQgY29kZSBmcm9tIGNoZWNraW5nIGZvciB3cmFwcGVkLXNlZ3dpdCBhbmQgbmF0aXZlLXNlZ3dpdCBjaGFpbnMgb24gdGhlIHB1YmxpYyBibG9jayBleHBsb3JlcnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhY2t1cEtleVJlY292ZXJ5KFxuICBjb2luOiBBYnN0cmFjdFV0eG9Db2luLFxuICBiaXRnbzogQml0R29CYXNlLFxuICBwYXJhbXM6IFJlY292ZXJQYXJhbXNcbik6IFByb21pc2U8QmFja3VwS2V5UmVjb3ZlcnlUcmFuc2Fuc2FjdGlvbiB8IEZvcm1hdHRlZE9mZmxpbmVWYXVsdFR4SW5mbz4ge1xuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudXNlcktleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdXNlcktleScpO1xuICB9XG5cbiAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmJhY2t1cEtleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYmFja3VwS2V5Jyk7XG4gIH1cblxuICBpZiAoXG4gICAgXy5pc1VuZGVmaW5lZChwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikgfHxcbiAgICAhY29pbi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiwgeyBhbnlGb3JtYXQ6IHRydWUgfSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuc2NhbikgJiYgKCFfLmlzSW50ZWdlcihwYXJhbXMuc2NhbikgfHwgcGFyYW1zLnNjYW4gPCAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICB9XG5cbiAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IGdldElzS3JzUmVjb3ZlcnkocGFyYW1zKTtcbiAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gZ2V0SXNVbnNpZ25lZFN3ZWVwKHBhcmFtcyk7XG4gIGNvbnN0IHJlc3BvbnNlVHhGb3JtYXQgPSBpc1Vuc2lnbmVkU3dlZXAgfHwgIWlzS3JzUmVjb3ZlcnkgfHwgcGFyYW1zLmtyc1Byb3ZpZGVyID09PSAna2V5dGVybmFsJyA/ICdsZWdhY3knIDogJ3BzYnQnO1xuXG4gIGNvbnN0IGtyc1Byb3ZpZGVyID0gaXNLcnNSZWNvdmVyeSA/IGdldEtyc1Byb3ZpZGVyKGNvaW4sIHBhcmFtcy5rcnNQcm92aWRlcikgOiB1bmRlZmluZWQ7XG5cbiAgLy8gY2hlY2sgd2hldGhlciBrZXkgbWF0ZXJpYWwgYW5kIHBhc3N3b3JkIGF1dGhlbnRpY2F0ZSB0aGUgdXNlcnMgYW5kIHJldHVybiBwYXJlbnQga2V5cyBvZiBhbGwgdGhyZWUga2V5cyBvZiB0aGUgd2FsbGV0XG4gIGNvbnN0IGtleXMgPSBnZXRCaXAzMktleXMoYml0Z28sIHBhcmFtcywgeyByZXF1aXJlQml0R29YcHViOiB0cnVlIH0pO1xuICBpZiAoIWlzVHJpcGxlKGtleXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBrZXkgdHJpcGxlYCk7XG4gIH1cbiAgY29uc3Qgd2FsbGV0S2V5cyA9IG5ldyB1dHhvbGliLmJpdGdvLlJvb3RXYWxsZXRLZXlzKGtleXMsIFtcbiAgICBwYXJhbXMudXNlcktleVBhdGggfHwgdXR4b2xpYi5iaXRnby5Sb290V2FsbGV0S2V5cy5kZWZhdWx0UHJlZml4LFxuICAgIHV0eG9saWIuYml0Z28uUm9vdFdhbGxldEtleXMuZGVmYXVsdFByZWZpeCxcbiAgICB1dHhvbGliLmJpdGdvLlJvb3RXYWxsZXRLZXlzLmRlZmF1bHRQcmVmaXgsXG4gIF0pO1xuXG4gIGNvbnN0IHVuc3BlbnRzOiBXYWxsZXRVbnNwZW50PGJpZ2ludD5bXSA9IChcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG91dHB1dFNjcmlwdHMuc2NyaXB0VHlwZXMyT2YzXG4gICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgKGFkZHJlc3NUeXBlKSA9PiBjb2luLnN1cHBvcnRzQWRkcmVzc1R5cGUoYWRkcmVzc1R5cGUpICYmICFwYXJhbXMuaWdub3JlQWRkcmVzc1R5cGVzPy5pbmNsdWRlcyhhZGRyZXNzVHlwZSlcbiAgICAgICAgKVxuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIChxdWVyaWVzLCBhZGRyZXNzVHlwZSkgPT4gW1xuICAgICAgICAgICAgLi4ucXVlcmllcyxcbiAgICAgICAgICAgIHF1ZXJ5QmxvY2tjaGFpblVuc3BlbnRzUGF0aChjb2luLCBwYXJhbXMsIHdhbGxldEtleXMsIGdldEV4dGVybmFsQ2hhaW5Db2RlKGFkZHJlc3NUeXBlKSksXG4gICAgICAgICAgICBxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoY29pbiwgcGFyYW1zLCB3YWxsZXRLZXlzLCBnZXRJbnRlcm5hbENoYWluQ29kZShhZGRyZXNzVHlwZSkpLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgW10gYXMgUHJvbWlzZTxXYWxsZXRVbnNwZW50PGJpZ2ludD5bXT5bXVxuICAgICAgICApXG4gICAgKVxuICApLmZsYXQoKTtcblxuICAvLyBFeGVjdXRlIHRoZSBxdWVyaWVzIGFuZCBnYXRoZXIgdGhlIHVuc3BlbnRzXG4gIGNvbnN0IHRvdGFsSW5wdXRBbW91bnQgPSB1dHhvbGliLmJpdGdvLnVuc3BlbnRTdW0odW5zcGVudHMsICdiaWdpbnQnKTtcbiAgaWYgKHRvdGFsSW5wdXRBbW91bnQgPD0gQmlnSW50KDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yTm9JbnB1dFRvUmVjb3ZlcigpO1xuICB9XG5cbiAgLy8gQnVpbGQgdGhlIHBzYnRcbiAgY29uc3QgcHNidCA9IHV0eG9saWIuYml0Z28uY3JlYXRlUHNidEZvck5ldHdvcmsoeyBuZXR3b3JrOiBjb2luLm5ldHdvcmsgfSk7XG4gIC8vIHhwdWJzIGNhbiBiZWNvbWUgaGFuZHkgZm9yIG1hbnkgdGhpbmdzLlxuICB1dHhvbGliLmJpdGdvLmFkZFhwdWJzVG9Qc2J0KHBzYnQsIHdhbGxldEtleXMpO1xuICBjb25zdCB0eEluZm8gPSB7fSBhcyBCYWNrdXBLZXlSZWNvdmVyeVRyYW5zYW5zYWN0aW9uO1xuICBjb25zdCBmZWVQZXJCeXRlOiBudW1iZXIgPSBhd2FpdCBnZXRSZWNvdmVyeUZlZVBlckJ5dGVzKGNvaW4sIHsgZGVmYXVsdFZhbHVlOiAxMDAgfSk7XG5cbiAgLy8gS1JTIHJlY292ZXJ5IHRyYW5zYWN0aW9ucyBoYXZlIGEgMm5kIG91dHB1dCB0byBwYXkgdGhlIHJlY292ZXJ5IGZlZSwgbGlrZSBwYXlnbyBmZWVzLiBVc2UgcDJ3c2ggb3V0cHV0cyBiZWNhdXNlXG4gIC8vIHRoZXkgYXJlIHRoZSBsYXJnZXN0IG91dHB1dHMgYW5kIHRodXMgdGhlIG1vc3QgY29uc2VydmF0aXZlIGVzdGltYXRlIHRvIHVzZSBpbiBjYWxjdWxhdGluZyBmZWVzLiBBbHNvIHVzZVxuICAvLyBzZWd3aXQgb3ZlcmhlYWQgc2l6ZSBhbmQgcDJzaCBpbnB1dHMgZm9yIHRoZSBzYW1lIHJlYXNvbi5cbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IChpc0tyc1JlY292ZXJ5ID8gMiA6IDEpICogVmlydHVhbFNpemVzLnR4UDJ3c2hPdXRwdXRTaXplO1xuICBjb25zdCBhcHByb3hpbWF0ZVNpemUgPSBWaXJ0dWFsU2l6ZXMudHhTZWdPdmVyaGVhZFZTaXplICsgb3V0cHV0U2l6ZSArIFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemUgKiB1bnNwZW50cy5sZW5ndGg7XG4gIGNvbnN0IGFwcHJveGltYXRlRmVlID0gQmlnSW50KGFwcHJveGltYXRlU2l6ZSAqIGZlZVBlckJ5dGUpO1xuXG4gIHR4SW5mby5pbnB1dHMgPVxuICAgIHJlc3BvbnNlVHhGb3JtYXQgPT09ICdsZWdhY3knXG4gICAgICA/IHVuc3BlbnRzLm1hcCgodSkgPT4gKHsgLi4udSwgdmFsdWU6IE51bWJlcih1LnZhbHVlKSwgdmFsdWVTdHJpbmc6IHUudmFsdWUudG9TdHJpbmcoKSwgcHJldlR4OiB1bmRlZmluZWQgfSkpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICB1bnNwZW50cy5mb3JFYWNoKCh1bnNwZW50KSA9PiB7XG4gICAgdXR4b2xpYi5iaXRnby5hZGRXYWxsZXRVbnNwZW50VG9Qc2J0KHBzYnQsIHVuc3BlbnQsIHdhbGxldEtleXMsICd1c2VyJywgJ2JhY2t1cCcpO1xuICB9KTtcblxuICBsZXQga3JzRmVlID0gQmlnSW50KDApO1xuICBpZiAoaXNLcnNSZWNvdmVyeSAmJiBwYXJhbXMua3JzUHJvdmlkZXIpIHtcbiAgICB0cnkge1xuICAgICAga3JzRmVlID0gQmlnSW50KGF3YWl0IGNhbGN1bGF0ZUZlZUFtb3VudChjb2luLCB7IHByb3ZpZGVyOiBwYXJhbXMua3JzUHJvdmlkZXIgfSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gRG9uJ3QgbGV0IHRoaXMgZXJyb3IgYmxvY2sgdGhlIHJlY292ZXJ5IC1cbiAgICAgIGNvbnNvbGUuZGlyKGVycik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVjb3ZlcnlBbW91bnQgPSB0b3RhbElucHV0QW1vdW50IC0gYXBwcm94aW1hdGVGZWUgLSBrcnNGZWU7XG5cbiAgaWYgKHJlY292ZXJ5QW1vdW50IDwgQmlnSW50KDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB0aGlzIHdhbGxldFxcJ3MgYmFsYW5jZSBpcyB0b28gbG93IHRvIHBheSB0aGUgZmVlcyBzcGVjaWZpZWQgYnkgdGhlIEtSUyBwcm92aWRlci4gXG4gICAgICAgICAgRXhpc3RpbmcgYmFsYW5jZSBvbiB3YWxsZXQ6ICR7dG90YWxJbnB1dEFtb3VudC50b1N0cmluZygpfS4gRXN0aW1hdGVkIG5ldHdvcmsgZmVlIGZvciB0aGUgcmVjb3ZlcnkgdHJhbnNhY3Rpb25cbiAgICAgICAgICA6ICR7YXBwcm94aW1hdGVGZWUudG9TdHJpbmcoKX0sIEtSUyBmZWUgdG8gcGF5OiAke2tyc0ZlZS50b1N0cmluZygpfS4gQWZ0ZXIgZGVkdWN0aW5nIGZlZXMsIHlvdXIgdG90YWwgXG4gICAgICAgICAgcmVjb3ZlcmFibGUgYmFsYW5jZSBpcyAke3JlY292ZXJ5QW1vdW50LnRvU3RyaW5nKCl9YCk7XG4gIH1cblxuICBjb25zdCByZWNvdmVyeU91dHB1dFNjcmlwdCA9IHV0eG9saWIuYWRkcmVzcy50b091dHB1dFNjcmlwdChwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiwgY29pbi5uZXR3b3JrKTtcbiAgcHNidC5hZGRPdXRwdXQoeyBzY3JpcHQ6IHJlY292ZXJ5T3V0cHV0U2NyaXB0LCB2YWx1ZTogcmVjb3ZlcnlBbW91bnQgfSk7XG5cbiAgaWYgKGtyc1Byb3ZpZGVyICYmIGtyc0ZlZSA+IEJpZ0ludCgwKSkge1xuICAgIGlmICgha3JzUHJvdmlkZXIuZmVlQWRkcmVzc2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleVByb3ZpZGVyIG11c3QgZGVmaW5lIGZlZUFkZHJlc3Nlc2ApO1xuICAgIH1cblxuICAgIGNvbnN0IGtyc0ZlZUFkZHJlc3MgPSBrcnNQcm92aWRlci5mZWVBZGRyZXNzZXNbY29pbi5nZXRDaGFpbigpXTtcblxuICAgIGlmICgha3JzRmVlQWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzIEtSUyBwcm92aWRlciBoYXMgbm90IGNvbmZpZ3VyZWQgdGhlaXIgZmVlIHN0cnVjdHVyZSB5ZXQgLSByZWNvdmVyeSBjYW5ub3QgYmUgY29tcGxldGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qga3JzRmVlT3V0cHV0U2NyaXB0ID0gdXR4b2xpYi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KGtyc0ZlZUFkZHJlc3MsIGNvaW4ubmV0d29yayk7XG4gICAgcHNidC5hZGRPdXRwdXQoeyBzY3JpcHQ6IGtyc0ZlZU91dHB1dFNjcmlwdCwgdmFsdWU6IGtyc0ZlZSB9KTtcbiAgfVxuXG4gIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAvLyBUT0RPIEJUQy0zMTcgLSBXaGVuIHJlYWR5IHRvIFBTQlRpZnkgT1ZDLCBzZW5kIHBzYnQgaGV4IGFuZCBza2lwIHVuc3BlbnRzIGluIHJlc3BvbnNlLlxuICAgIGNvbnN0IHR4SGV4ID0gcHNidC5nZXRVbnNpZ25lZFR4KCkudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgcmV0dXJuIGZvcm1hdEZvck9mZmxpbmVWYXVsdChjb2luLmdldENoYWluKCksIHR4SW5mbyBhcyBPZmZsaW5lVmF1bHRUeEluZm8sIHR4SGV4KTtcbiAgfSBlbHNlIHtcbiAgICBzaWduQW5kVmVyaWZ5UHNidChwc2J0LCB3YWxsZXRLZXlzLnVzZXIsIHsgaXNMYXN0U2lnbmF0dXJlOiBmYWxzZSB9KTtcbiAgICBpZiAoaXNLcnNSZWNvdmVyeSkge1xuICAgICAgLy8gVGhlIEtSUyBwcm92aWRlciBrZXl0ZXJuYWwgc29sZWx5IHN1cHBvcnRzIFAyU0gsIFAyV1NILCBhbmQgUDJTSC1QMldTSCBpbnB1dCBzY3JpcHQgdHlwZXMuXG4gICAgICAvLyBJdCBjdXJyZW50bHkgdXNlcyBhbiBvdXRkYXRlZCBCaXRHb0pTIFNESywgd2hpY2ggcmVsaWVzIG9uIGEgbGVnYWN5IHRyYW5zYWN0aW9uIGJ1aWxkZXIgZm9yIGNvc2lnbmluZy5cbiAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHVwZ3JhZGluZyB0aGUga2V5dGVybmFsIGNvZGUgcHJlc2VudHMgY2hhbGxlbmdlcyxcbiAgICAgIC8vIHdoaWNoIGhpbmRlcnMgdGhlIGludGVncmF0aW9uIG9mIHRoZSBsYXRlc3QgQml0R29KUyBTREsgd2l0aCBQU0JUIHNpZ25pbmcgc3VwcG9ydC5cbiAgICAgIHR4SW5mby50cmFuc2FjdGlvbkhleCA9XG4gICAgICAgIHBhcmFtcy5rcnNQcm92aWRlciA9PT0gJ2tleXRlcm5hbCdcbiAgICAgICAgICA/IHV0eG9saWIuYml0Z28uZXh0cmFjdFAybXNPbmx5SGFsZlNpZ25lZFR4KHBzYnQpLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgOiBwc2J0LnRvSGV4KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR4ID0gc2lnbkFuZFZlcmlmeVBzYnQocHNidCwgd2FsbGV0S2V5cy5iYWNrdXAsIHsgaXNMYXN0U2lnbmF0dXJlOiB0cnVlIH0pO1xuICAgICAgdHhJbmZvLnRyYW5zYWN0aW9uSGV4ID0gdHgudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICB0eEluZm8uY29pbiA9IGNvaW4uZ2V0Q2hhaW4oKTtcbiAgICB0eEluZm8uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICB0eEluZm8ucmVjb3ZlcnlBbW91bnQgPSBOdW1iZXIocmVjb3ZlcnlBbW91bnQpO1xuICAgIHR4SW5mby5yZWNvdmVyeUFtb3VudFN0cmluZyA9IHJlY292ZXJ5QW1vdW50LnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXR1cm4gdHhJbmZvO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJpdEdvVjFVbnNwZW50IHtcbiAgdHhfaGFzaDogc3RyaW5nO1xuICB0eF9vdXRwdXRfbjogbnVtYmVyO1xuICB2YWx1ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFYxU3dlZXBQYXJhbXMge1xuICB3YWxsZXRJZDogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG4gIHVuc3BlbnRzOiBCaXRHb1YxVW5zcGVudFtdO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgb3RwOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVjFSZWNvdmVyUGFyYW1zIGV4dGVuZHMgT21pdDxWMVN3ZWVwUGFyYW1zLCAnb3RwJz4ge1xuICBiYWNrdXBLZXk6IHN0cmluZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHYxQmFja3VwS2V5UmVjb3ZlcnkoXG4gIGNvaW46IEFic3RyYWN0VXR4b0NvaW4sXG4gIGJpdGdvOiBCaXRHb0Jhc2UsXG4gIHBhcmFtczogVjFSZWNvdmVyUGFyYW1zXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAoXG4gICAgXy5pc1VuZGVmaW5lZChwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikgfHxcbiAgICAhY29pbi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiwgeyBhbnlGb3JtYXQ6IHRydWUgfSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgfVxuXG4gIGNvbnN0IHJlY292ZXJ5RmVlUGVyQnl0ZSA9IGF3YWl0IGdldFJlY292ZXJ5RmVlUGVyQnl0ZXMoY29pbiwgeyBkZWZhdWx0VmFsdWU6IDEwMCB9KTtcbiAgY29uc3QgdjF3YWxsZXQgPSBhd2FpdCBiaXRnby53YWxsZXRzKCkuZ2V0KHsgaWQ6IHBhcmFtcy53YWxsZXRJZCB9KTtcbiAgcmV0dXJuIGF3YWl0IHYxd2FsbGV0LnJlY292ZXIoe1xuICAgIC4uLnBhcmFtcyxcbiAgICBmZWVSYXRlOiByZWNvdmVyeUZlZVBlckJ5dGUsXG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdjFTd2VlcChcbiAgY29pbjogQWJzdHJhY3RVdHhvQ29pbixcbiAgYml0Z286IEJpdEdvQmFzZSxcbiAgcGFyYW1zOiBWMVN3ZWVwUGFyYW1zXG4pOiBQcm9taXNlPHtcbiAgdHg6IHN0cmluZztcbiAgaGFzaDogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbn0+IHtcbiAgaWYgKFxuICAgIF8uaXNVbmRlZmluZWQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pIHx8XG4gICAgIWNvaW4uaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sIHsgYW55Rm9ybWF0OiB0cnVlIH0pXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeURlc3RpbmF0aW9uJyk7XG4gIH1cblxuICBsZXQgcmVjb3ZlcnlGZWVQZXJCeXRlID0gMTAwO1xuICBpZiAoYml0Z28uZW52ID09PSAncHJvZCcpIHtcbiAgICByZWNvdmVyeUZlZVBlckJ5dGUgPSBhd2FpdCBnZXRSZWNvdmVyeUZlZVBlckJ5dGVzKGNvaW4sIHsgZGVmYXVsdFZhbHVlOiAxMDAgfSk7XG4gIH1cblxuICBjb25zdCB2MXdhbGxldCA9IGF3YWl0IGJpdGdvLndhbGxldHMoKS5nZXQoeyBpZDogcGFyYW1zLndhbGxldElkIH0pO1xuICByZXR1cm4gYXdhaXQgdjF3YWxsZXQuc3dlZXAoe1xuICAgIC4uLnBhcmFtcyxcbiAgICBmZWVSYXRlOiByZWNvdmVyeUZlZVBlckJ5dGUsXG4gIH0pO1xufVxuIl19