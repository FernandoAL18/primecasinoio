"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOutput = void 0;
const debugLib = require("debug");
const _ = require("lodash");
const sdk_core_1 = require("@bitgo/sdk-core");
const abstractUtxoCoin_1 = require("./abstractUtxoCoin");
const debug = debugLib('bitgo:v2:parseoutput');
/**
 * Check an address which failed initial validation to see if it's the base address of a migrated v1 bch wallet.
 *
 * The wallet in question could be a migrated SafeHD BCH wallet, and the transaction we
 * are currently parsing is trying to spend change back to the v1 wallet base address.
 *
 * It does this since we don't allow new address creation for these wallets,
 * and instead return the base address from the v1 wallet when a new address is requested.
 * If this new address is requested for the purposes of spending change back to the wallet,
 * the change will go to the v1 wallet base address. This address *is* on the wallet,
 * but it will still cause an error to be thrown by verifyAddress, since the derivation path
 * used for this address is non-standard. (I have seen these addresses derived using paths m/0/0 and m/101,
 * whereas the v2 addresses are derived using path  m/0/0/${chain}/${index}).
 *
 * This means we need to check for this case explicitly in this catch block, and classify
 * these types of outputs as internal instead of external. Failing to do so would cause the
 * transaction's implicit external outputs (ie, outputs which go to addresses not specified in
 * the recipients array) to add up to more than the 150 basis point limit which we enforce on
 * pay-as-you-go outputs (which should be the only implicit external outputs on our transactions).
 *
 * The 150 basis point limit for implicit external sends is enforced in verifyTransaction,
 * which calls this function to get information on the total external/internal spend amounts
 * for a transaction. The idea here is to protect from the transaction being maliciously modified
 * to add more implicit external spends (eg, to an attacker-controlled wallet).
 *
 * See verifyTransaction for more information on how transaction prebuilds are verified before signing.
 *
 * @param wallet {Wallet} wallet which is making the transaction
 * @param currentAddress {string} address to check for externality relative to v1 wallet base address
 */
function isMigratedAddress(wallet, currentAddress) {
    if (_.isString(wallet.migratedFrom()) && wallet.migratedFrom() === currentAddress) {
        debug('found address %s which was migrated from v1 wallet, address is not external', currentAddress);
        return true;
    }
    return false;
}
/**
 * Check to see if an address is derived from the given custom change keys
 * @param {VerifyCustomChangeAddressOptions} params
 * @return {boolean}
 */
async function verifyCustomChangeAddress(params) {
    const { coin, customChangeKeys, addressType, addressDetails, currentAddress } = params;
    try {
        return await coin.verifyAddress(_.extend({ addressType }, addressDetails, {
            keychains: customChangeKeys,
            address: currentAddress,
        }));
    }
    catch (e) {
        debug('failed to verify custom change address %s', currentAddress);
        return false;
    }
}
async function handleVerifyAddressError({ e, currentAddress, wallet, txParams, customChangeKeys, coin, addressDetails, addressType, considerMigratedFromAddressInternal, }) {
    // Todo: name server-side errors to avoid message-based checking [BG-5124]
    const walletAddressNotFound = e.message.includes('wallet address not found');
    const unexpectedAddress = e instanceof sdk_core_1.UnexpectedAddressError;
    if (walletAddressNotFound || unexpectedAddress) {
        if (unexpectedAddress && !walletAddressNotFound) {
            // check to see if this is a migrated v1 bch address - it could be internal
            const isMigrated = isMigratedAddress(wallet, currentAddress);
            if (isMigrated) {
                return { external: considerMigratedFromAddressInternal === false };
            }
            debug('Address %s was found on wallet but could not be reconstructed', currentAddress);
            // attempt to verify address using custom change address keys if the wallet has that feature enabled
            if (customChangeKeys &&
                (await verifyCustomChangeAddress({ coin, addressDetails, addressType, currentAddress, customChangeKeys }))) {
                // address is valid against the custom change keys. Mark address as not external
                // and request signature verification for the custom change keys
                debug('Address %s verified as derived from the custom change keys', currentAddress);
                return { external: false, needsCustomChangeKeySignatureVerification: true };
            }
        }
        // the address was found, but not on the wallet, which simply means it's external
        debug('Address %s presumed external', currentAddress);
        return { external: true };
    }
    else if (e instanceof sdk_core_1.InvalidAddressDerivationPropertyError && currentAddress === txParams.changeAddress) {
        // expect to see this error when passing in a custom changeAddress with no chain or index
        return { external: false };
    }
    console.error('Address classification failed for address', currentAddress);
    console.trace(e);
    /**
     * It might be a completely invalid address or a bad validation attempt or something else completely, in
     * which case we do not proceed and rather rethrow the error, which is safer than assuming that the address
     * validation failed simply because it's external to the wallet.
     */
    throw e;
}
async function fetchAddressDetails({ reqId, disableNetworking, addressDetailsPrebuild, addressDetailsVerification, currentAddress, wallet, }) {
    let addressDetails = _.extend({}, addressDetailsPrebuild, addressDetailsVerification);
    debug('Locally available address %s details: %O', currentAddress, addressDetails);
    if (_.isEmpty(addressDetails) && !disableNetworking) {
        addressDetails = await wallet.getAddress({ address: currentAddress, reqId });
        debug('Downloaded address %s details: %O', currentAddress, addressDetails);
    }
    return addressDetails;
}
async function parseOutput({ currentOutput, coin, txPrebuild, verification, keychainArray, wallet, txParams, customChange, reqId, }) {
    var _a, _b;
    const disableNetworking = !!verification.disableNetworking;
    const currentAddress = currentOutput.address;
    // attempt to grab the address details from either the prebuilt tx, or the verification params.
    // If both of these are empty, then we will try to get the address details from bitgo instead
    const addressDetailsPrebuild = _.get(txPrebuild, `txInfo.walletAddressDetails.${currentAddress}`, {});
    const addressDetailsVerification = (_b = (_a = verification === null || verification === void 0 ? void 0 : verification.addresses) === null || _a === void 0 ? void 0 : _a[currentAddress]) !== null && _b !== void 0 ? _b : {};
    debug('Parsing address details for %s', currentAddress);
    let currentAddressDetails = undefined;
    let currentAddressType = undefined;
    const RECIPIENT_THRESHOLD = 1000;
    try {
        // In the case of PSBTs, we can already determine the internal/external status of the output addresses
        // based on the derivation information being included in the PSBT. We can short circuit GET v2.wallet.address
        // and save on network requests. Since we have the derivation information already, we can still verify the address
        if (currentOutput.external !== undefined) {
            // In the case that we have a custom change wallet, we need to verify the address against the custom change keys
            // and not the wallet keys. This check is done in the handleVerifyAddressError function if this error is thrown.
            if (customChange !== undefined) {
                throw new sdk_core_1.UnexpectedAddressError('`address validation failure');
            }
            // If it is an internal address, we can skip the network request and just verify the address locally with the
            // derivation information we have. Otherwise, if the address is external, which is the only remaining case, we
            // can just return the current output as is without contacting the server.
            if ((0, abstractUtxoCoin_1.isWalletOutput)(currentOutput)) {
                const res = await coin.isWalletAddress({
                    addressType: abstractUtxoCoin_1.AbstractUtxoCoin.inferAddressType({ chain: currentOutput.chain }) || undefined,
                    keychains: keychainArray,
                    address: currentAddress,
                    chain: currentOutput.chain,
                    index: currentOutput.index,
                });
                if (!res) {
                    throw new sdk_core_1.UnexpectedAddressError();
                }
            }
            return currentOutput;
        }
        /**
         * The only way to determine whether an address is known on the wallet is to initiate a network request and
         * fetch it. Should the request fail and return a 404, it will throw and therefore has to be caught. For that
         * reason, address wallet ownership detection is wrapped in a try/catch. Additionally, once the address
         * details are fetched on the wallet, a local address validation is run, whose errors however are generated
         * client-side and can therefore be analyzed with more granularity and type checking.
         */
        /**
         * In order to minimize API requests, we assume that explicit recipients are always external when the
         * recipient list is > 1000 This is not always a valid assumption and could lead greater apparent spend (but never lower)
         */
        if (txParams.recipients !== undefined && txParams.recipients.length > RECIPIENT_THRESHOLD) {
            const isCurrentAddressInRecipients = txParams.recipients.some((recipient) => recipient.address.includes(currentAddress));
            if (isCurrentAddressInRecipients) {
                return { ...currentOutput };
            }
        }
        const addressDetails = await fetchAddressDetails({
            reqId,
            addressDetailsVerification,
            addressDetailsPrebuild,
            currentAddress,
            disableNetworking,
            wallet,
        });
        // verify that the address is on the wallet. verifyAddress throws if
        // it fails to correctly rederive the address, meaning it's external
        currentAddressType = abstractUtxoCoin_1.AbstractUtxoCoin.inferAddressType(addressDetails) || undefined;
        currentAddressDetails = addressDetails;
        await coin.verifyAddress(_.extend({ addressType: currentAddressType }, addressDetails, {
            keychains: keychainArray,
            address: currentAddress,
        }));
        debug('Address %s verification passed', currentAddress);
        // verify address succeeded without throwing, so the address was
        // correctly rederived from the wallet keychains, making it not external
        return _.extend({}, currentOutput, addressDetails, { external: false });
    }
    catch (e) {
        debug('Address %s verification threw an error:', currentAddress, e);
        return _.extend({}, currentOutput, await handleVerifyAddressError({
            e,
            coin,
            currentAddress,
            wallet,
            txParams,
            customChangeKeys: customChange && customChange.keys,
            addressDetails: currentAddressDetails,
            addressType: currentAddressType,
            considerMigratedFromAddressInternal: verification.considerMigratedFromAddressInternal,
        }));
    }
}
exports.parseOutput = parseOutput;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VPdXRwdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGFyc2VPdXRwdXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSCxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLDhDQVN5QjtBQUN6Qix5REFBaUc7QUFFakcsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFPL0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJHO0FBQ0gsU0FBUyxpQkFBaUIsQ0FBQyxNQUFlLEVBQUUsY0FBc0I7SUFDaEUsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxZQUFZLEVBQUUsS0FBSyxjQUFjLEVBQUU7UUFDakYsS0FBSyxDQUFDLDZFQUE2RSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ3JHLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFVRDs7OztHQUlHO0FBQ0gsS0FBSyxVQUFVLHlCQUF5QixDQUFDLE1BQXdDO0lBQy9FLE1BQU0sRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsR0FBRyxNQUFNLENBQUM7SUFDdkYsSUFBSTtRQUNGLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUM3QixDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsV0FBVyxFQUFFLEVBQUUsY0FBYyxFQUFFO1lBQ3hDLFNBQVMsRUFBRSxnQkFBZ0I7WUFDM0IsT0FBTyxFQUFFLGNBQWM7U0FDeEIsQ0FBQyxDQUNILENBQUM7S0FDSDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsS0FBSyxDQUFDLDJDQUEyQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ25FLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDSCxDQUFDO0FBY0Qs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QUFDO1FBRXhELGdFQUFnRTtRQUNoRSx3RUFBd0U7UUFDeEUsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7S0FDekU7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLEtBQUssQ0FBQyx5Q0FBeUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDcEUsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUNiLEVBQUUsRUFDRixhQUFhLEVBQ2IsTUFBTSx3QkFBd0IsQ0FBQztZQUM3QixDQUFDO1lBQ0QsSUFBSTtZQUNKLGNBQWM7WUFDZCxNQUFNO1lBQ04sUUFBUTtZQUNSLGdCQUFnQixFQUFFLFlBQVksSUFBSSxZQUFZLENBQUMsSUFBSTtZQUNuRCxjQUFjLEVBQUUscUJBQXFCO1lBQ3JDLFdBQVcsRUFBRSxrQkFBa0I7WUFDL0IsbUNBQW1DLEVBQUUsWUFBWSxDQUFDLG1DQUFtQztTQUN0RixDQUFDLENBQ0gsQ0FBQztLQUNIO0FBQ0gsQ0FBQztBQWhIRCxrQ0FnSEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbmltcG9ydCAqIGFzIGRlYnVnTGliIGZyb20gJ2RlYnVnJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7XG4gIEFkZHJlc3NWZXJpZmljYXRpb25EYXRhLFxuICBJUmVxdWVzdFRyYWNlcixcbiAgSW52YWxpZEFkZHJlc3NEZXJpdmF0aW9uUHJvcGVydHlFcnJvcixcbiAgSVdhbGxldCxcbiAgS2V5Y2hhaW4sXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IsXG4gIFZlcmlmaWNhdGlvbk9wdGlvbnMsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdFV0eG9Db2luLCBPdXRwdXQsIFRyYW5zYWN0aW9uUGFyYW1zLCBpc1dhbGxldE91dHB1dCB9IGZyb20gJy4vYWJzdHJhY3RVdHhvQ29pbic7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOnYyOnBhcnNlb3V0cHV0Jyk7XG5cbmludGVyZmFjZSBIYW5kbGVWZXJpZnlBZGRyZXNzRXJyb3JSZXNwb25zZSB7XG4gIGV4dGVybmFsOiBib29sZWFuO1xuICBuZWVkc0N1c3RvbUNoYW5nZUtleVNpZ25hdHVyZVZlcmlmaWNhdGlvbj86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQ2hlY2sgYW4gYWRkcmVzcyB3aGljaCBmYWlsZWQgaW5pdGlhbCB2YWxpZGF0aW9uIHRvIHNlZSBpZiBpdCdzIHRoZSBiYXNlIGFkZHJlc3Mgb2YgYSBtaWdyYXRlZCB2MSBiY2ggd2FsbGV0LlxuICpcbiAqIFRoZSB3YWxsZXQgaW4gcXVlc3Rpb24gY291bGQgYmUgYSBtaWdyYXRlZCBTYWZlSEQgQkNIIHdhbGxldCwgYW5kIHRoZSB0cmFuc2FjdGlvbiB3ZVxuICogYXJlIGN1cnJlbnRseSBwYXJzaW5nIGlzIHRyeWluZyB0byBzcGVuZCBjaGFuZ2UgYmFjayB0byB0aGUgdjEgd2FsbGV0IGJhc2UgYWRkcmVzcy5cbiAqXG4gKiBJdCBkb2VzIHRoaXMgc2luY2Ugd2UgZG9uJ3QgYWxsb3cgbmV3IGFkZHJlc3MgY3JlYXRpb24gZm9yIHRoZXNlIHdhbGxldHMsXG4gKiBhbmQgaW5zdGVhZCByZXR1cm4gdGhlIGJhc2UgYWRkcmVzcyBmcm9tIHRoZSB2MSB3YWxsZXQgd2hlbiBhIG5ldyBhZGRyZXNzIGlzIHJlcXVlc3RlZC5cbiAqIElmIHRoaXMgbmV3IGFkZHJlc3MgaXMgcmVxdWVzdGVkIGZvciB0aGUgcHVycG9zZXMgb2Ygc3BlbmRpbmcgY2hhbmdlIGJhY2sgdG8gdGhlIHdhbGxldCxcbiAqIHRoZSBjaGFuZ2Ugd2lsbCBnbyB0byB0aGUgdjEgd2FsbGV0IGJhc2UgYWRkcmVzcy4gVGhpcyBhZGRyZXNzICppcyogb24gdGhlIHdhbGxldCxcbiAqIGJ1dCBpdCB3aWxsIHN0aWxsIGNhdXNlIGFuIGVycm9yIHRvIGJlIHRocm93biBieSB2ZXJpZnlBZGRyZXNzLCBzaW5jZSB0aGUgZGVyaXZhdGlvbiBwYXRoXG4gKiB1c2VkIGZvciB0aGlzIGFkZHJlc3MgaXMgbm9uLXN0YW5kYXJkLiAoSSBoYXZlIHNlZW4gdGhlc2UgYWRkcmVzc2VzIGRlcml2ZWQgdXNpbmcgcGF0aHMgbS8wLzAgYW5kIG0vMTAxLFxuICogd2hlcmVhcyB0aGUgdjIgYWRkcmVzc2VzIGFyZSBkZXJpdmVkIHVzaW5nIHBhdGggIG0vMC8wLyR7Y2hhaW59LyR7aW5kZXh9KS5cbiAqXG4gKiBUaGlzIG1lYW5zIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHRoaXMgY2FzZSBleHBsaWNpdGx5IGluIHRoaXMgY2F0Y2ggYmxvY2ssIGFuZCBjbGFzc2lmeVxuICogdGhlc2UgdHlwZXMgb2Ygb3V0cHV0cyBhcyBpbnRlcm5hbCBpbnN0ZWFkIG9mIGV4dGVybmFsLiBGYWlsaW5nIHRvIGRvIHNvIHdvdWxkIGNhdXNlIHRoZVxuICogdHJhbnNhY3Rpb24ncyBpbXBsaWNpdCBleHRlcm5hbCBvdXRwdXRzIChpZSwgb3V0cHV0cyB3aGljaCBnbyB0byBhZGRyZXNzZXMgbm90IHNwZWNpZmllZCBpblxuICogdGhlIHJlY2lwaWVudHMgYXJyYXkpIHRvIGFkZCB1cCB0byBtb3JlIHRoYW4gdGhlIDE1MCBiYXNpcyBwb2ludCBsaW1pdCB3aGljaCB3ZSBlbmZvcmNlIG9uXG4gKiBwYXktYXMteW91LWdvIG91dHB1dHMgKHdoaWNoIHNob3VsZCBiZSB0aGUgb25seSBpbXBsaWNpdCBleHRlcm5hbCBvdXRwdXRzIG9uIG91ciB0cmFuc2FjdGlvbnMpLlxuICpcbiAqIFRoZSAxNTAgYmFzaXMgcG9pbnQgbGltaXQgZm9yIGltcGxpY2l0IGV4dGVybmFsIHNlbmRzIGlzIGVuZm9yY2VkIGluIHZlcmlmeVRyYW5zYWN0aW9uLFxuICogd2hpY2ggY2FsbHMgdGhpcyBmdW5jdGlvbiB0byBnZXQgaW5mb3JtYXRpb24gb24gdGhlIHRvdGFsIGV4dGVybmFsL2ludGVybmFsIHNwZW5kIGFtb3VudHNcbiAqIGZvciBhIHRyYW5zYWN0aW9uLiBUaGUgaWRlYSBoZXJlIGlzIHRvIHByb3RlY3QgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYmVpbmcgbWFsaWNpb3VzbHkgbW9kaWZpZWRcbiAqIHRvIGFkZCBtb3JlIGltcGxpY2l0IGV4dGVybmFsIHNwZW5kcyAoZWcsIHRvIGFuIGF0dGFja2VyLWNvbnRyb2xsZWQgd2FsbGV0KS5cbiAqXG4gKiBTZWUgdmVyaWZ5VHJhbnNhY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRyYW5zYWN0aW9uIHByZWJ1aWxkcyBhcmUgdmVyaWZpZWQgYmVmb3JlIHNpZ25pbmcuXG4gKlxuICogQHBhcmFtIHdhbGxldCB7V2FsbGV0fSB3YWxsZXQgd2hpY2ggaXMgbWFraW5nIHRoZSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGN1cnJlbnRBZGRyZXNzIHtzdHJpbmd9IGFkZHJlc3MgdG8gY2hlY2sgZm9yIGV4dGVybmFsaXR5IHJlbGF0aXZlIHRvIHYxIHdhbGxldCBiYXNlIGFkZHJlc3NcbiAqL1xuZnVuY3Rpb24gaXNNaWdyYXRlZEFkZHJlc3Mod2FsbGV0OiBJV2FsbGV0LCBjdXJyZW50QWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmIChfLmlzU3RyaW5nKHdhbGxldC5taWdyYXRlZEZyb20oKSkgJiYgd2FsbGV0Lm1pZ3JhdGVkRnJvbSgpID09PSBjdXJyZW50QWRkcmVzcykge1xuICAgIGRlYnVnKCdmb3VuZCBhZGRyZXNzICVzIHdoaWNoIHdhcyBtaWdyYXRlZCBmcm9tIHYxIHdhbGxldCwgYWRkcmVzcyBpcyBub3QgZXh0ZXJuYWwnLCBjdXJyZW50QWRkcmVzcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmludGVyZmFjZSBWZXJpZnlDdXN0b21DaGFuZ2VBZGRyZXNzT3B0aW9ucyB7XG4gIGNvaW46IEFic3RyYWN0VXR4b0NvaW47XG4gIGN1c3RvbUNoYW5nZUtleXM6IEhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvck9wdGlvbnNbJ2N1c3RvbUNoYW5nZUtleXMnXTtcbiAgYWRkcmVzc1R5cGU6IEhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvck9wdGlvbnNbJ2FkZHJlc3NUeXBlJ107XG4gIGFkZHJlc3NEZXRhaWxzOiBIYW5kbGVWZXJpZnlBZGRyZXNzRXJyb3JPcHRpb25zWydhZGRyZXNzRGV0YWlscyddO1xuICBjdXJyZW50QWRkcmVzczogSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9uc1snY3VycmVudEFkZHJlc3MnXTtcbn1cblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgYW4gYWRkcmVzcyBpcyBkZXJpdmVkIGZyb20gdGhlIGdpdmVuIGN1c3RvbSBjaGFuZ2Uga2V5c1xuICogQHBhcmFtIHtWZXJpZnlDdXN0b21DaGFuZ2VBZGRyZXNzT3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlDdXN0b21DaGFuZ2VBZGRyZXNzKHBhcmFtczogVmVyaWZ5Q3VzdG9tQ2hhbmdlQWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgeyBjb2luLCBjdXN0b21DaGFuZ2VLZXlzLCBhZGRyZXNzVHlwZSwgYWRkcmVzc0RldGFpbHMsIGN1cnJlbnRBZGRyZXNzIH0gPSBwYXJhbXM7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGNvaW4udmVyaWZ5QWRkcmVzcyhcbiAgICAgIF8uZXh0ZW5kKHsgYWRkcmVzc1R5cGUgfSwgYWRkcmVzc0RldGFpbHMsIHtcbiAgICAgICAga2V5Y2hhaW5zOiBjdXN0b21DaGFuZ2VLZXlzLFxuICAgICAgICBhZGRyZXNzOiBjdXJyZW50QWRkcmVzcyxcbiAgICAgIH0pXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCdmYWlsZWQgdG8gdmVyaWZ5IGN1c3RvbSBjaGFuZ2UgYWRkcmVzcyAlcycsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuaW50ZXJmYWNlIEhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvck9wdGlvbnMge1xuICBlOiBFcnJvcjtcbiAgY3VycmVudEFkZHJlc3M6IHN0cmluZztcbiAgd2FsbGV0OiBJV2FsbGV0O1xuICB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXM7XG4gIGN1c3RvbUNoYW5nZUtleXM/OiBDdXN0b21DaGFuZ2VPcHRpb25zWydrZXlzJ107XG4gIGNvaW46IEFic3RyYWN0VXR4b0NvaW47XG4gIGFkZHJlc3NEZXRhaWxzPzogYW55O1xuICBhZGRyZXNzVHlwZT86IHN0cmluZztcbiAgY29uc2lkZXJNaWdyYXRlZEZyb21BZGRyZXNzSW50ZXJuYWw/OiBib29sZWFuO1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVWZXJpZnlBZGRyZXNzRXJyb3Ioe1xuICBlLFxuICBjdXJyZW50QWRkcmVzcyxcbiAgd2FsbGV0LFxuICB0eFBhcmFtcyxcbiAgY3VzdG9tQ2hhbmdlS2V5cyxcbiAgY29pbixcbiAgYWRkcmVzc0RldGFpbHMsXG4gIGFkZHJlc3NUeXBlLFxuICBjb25zaWRlck1pZ3JhdGVkRnJvbUFkZHJlc3NJbnRlcm5hbCxcbn06IEhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvck9wdGlvbnMpOiBQcm9taXNlPEhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvclJlc3BvbnNlPiB7XG4gIC8vIFRvZG86IG5hbWUgc2VydmVyLXNpZGUgZXJyb3JzIHRvIGF2b2lkIG1lc3NhZ2UtYmFzZWQgY2hlY2tpbmcgW0JHLTUxMjRdXG4gIGNvbnN0IHdhbGxldEFkZHJlc3NOb3RGb3VuZCA9IGUubWVzc2FnZS5pbmNsdWRlcygnd2FsbGV0IGFkZHJlc3Mgbm90IGZvdW5kJyk7XG4gIGNvbnN0IHVuZXhwZWN0ZWRBZGRyZXNzID0gZSBpbnN0YW5jZW9mIFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3I7XG4gIGlmICh3YWxsZXRBZGRyZXNzTm90Rm91bmQgfHwgdW5leHBlY3RlZEFkZHJlc3MpIHtcbiAgICBpZiAodW5leHBlY3RlZEFkZHJlc3MgJiYgIXdhbGxldEFkZHJlc3NOb3RGb3VuZCkge1xuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgYSBtaWdyYXRlZCB2MSBiY2ggYWRkcmVzcyAtIGl0IGNvdWxkIGJlIGludGVybmFsXG4gICAgICBjb25zdCBpc01pZ3JhdGVkID0gaXNNaWdyYXRlZEFkZHJlc3Mod2FsbGV0LCBjdXJyZW50QWRkcmVzcyk7XG4gICAgICBpZiAoaXNNaWdyYXRlZCkge1xuICAgICAgICByZXR1cm4geyBleHRlcm5hbDogY29uc2lkZXJNaWdyYXRlZEZyb21BZGRyZXNzSW50ZXJuYWwgPT09IGZhbHNlIH07XG4gICAgICB9XG5cbiAgICAgIGRlYnVnKCdBZGRyZXNzICVzIHdhcyBmb3VuZCBvbiB3YWxsZXQgYnV0IGNvdWxkIG5vdCBiZSByZWNvbnN0cnVjdGVkJywgY3VycmVudEFkZHJlc3MpO1xuXG4gICAgICAvLyBhdHRlbXB0IHRvIHZlcmlmeSBhZGRyZXNzIHVzaW5nIGN1c3RvbSBjaGFuZ2UgYWRkcmVzcyBrZXlzIGlmIHRoZSB3YWxsZXQgaGFzIHRoYXQgZmVhdHVyZSBlbmFibGVkXG4gICAgICBpZiAoXG4gICAgICAgIGN1c3RvbUNoYW5nZUtleXMgJiZcbiAgICAgICAgKGF3YWl0IHZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3MoeyBjb2luLCBhZGRyZXNzRGV0YWlscywgYWRkcmVzc1R5cGUsIGN1cnJlbnRBZGRyZXNzLCBjdXN0b21DaGFuZ2VLZXlzIH0pKVxuICAgICAgKSB7XG4gICAgICAgIC8vIGFkZHJlc3MgaXMgdmFsaWQgYWdhaW5zdCB0aGUgY3VzdG9tIGNoYW5nZSBrZXlzLiBNYXJrIGFkZHJlc3MgYXMgbm90IGV4dGVybmFsXG4gICAgICAgIC8vIGFuZCByZXF1ZXN0IHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZm9yIHRoZSBjdXN0b20gY2hhbmdlIGtleXNcbiAgICAgICAgZGVidWcoJ0FkZHJlc3MgJXMgdmVyaWZpZWQgYXMgZGVyaXZlZCBmcm9tIHRoZSBjdXN0b20gY2hhbmdlIGtleXMnLCBjdXJyZW50QWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB7IGV4dGVybmFsOiBmYWxzZSwgbmVlZHNDdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVWZXJpZmljYXRpb246IHRydWUgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGUgYWRkcmVzcyB3YXMgZm91bmQsIGJ1dCBub3Qgb24gdGhlIHdhbGxldCwgd2hpY2ggc2ltcGx5IG1lYW5zIGl0J3MgZXh0ZXJuYWxcbiAgICBkZWJ1ZygnQWRkcmVzcyAlcyBwcmVzdW1lZCBleHRlcm5hbCcsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICByZXR1cm4geyBleHRlcm5hbDogdHJ1ZSB9O1xuICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBJbnZhbGlkQWRkcmVzc0Rlcml2YXRpb25Qcm9wZXJ0eUVycm9yICYmIGN1cnJlbnRBZGRyZXNzID09PSB0eFBhcmFtcy5jaGFuZ2VBZGRyZXNzKSB7XG4gICAgLy8gZXhwZWN0IHRvIHNlZSB0aGlzIGVycm9yIHdoZW4gcGFzc2luZyBpbiBhIGN1c3RvbSBjaGFuZ2VBZGRyZXNzIHdpdGggbm8gY2hhaW4gb3IgaW5kZXhcbiAgICByZXR1cm4geyBleHRlcm5hbDogZmFsc2UgfTtcbiAgfVxuXG4gIGNvbnNvbGUuZXJyb3IoJ0FkZHJlc3MgY2xhc3NpZmljYXRpb24gZmFpbGVkIGZvciBhZGRyZXNzJywgY3VycmVudEFkZHJlc3MpO1xuICBjb25zb2xlLnRyYWNlKGUpO1xuICAvKipcbiAgICogSXQgbWlnaHQgYmUgYSBjb21wbGV0ZWx5IGludmFsaWQgYWRkcmVzcyBvciBhIGJhZCB2YWxpZGF0aW9uIGF0dGVtcHQgb3Igc29tZXRoaW5nIGVsc2UgY29tcGxldGVseSwgaW5cbiAgICogd2hpY2ggY2FzZSB3ZSBkbyBub3QgcHJvY2VlZCBhbmQgcmF0aGVyIHJldGhyb3cgdGhlIGVycm9yLCB3aGljaCBpcyBzYWZlciB0aGFuIGFzc3VtaW5nIHRoYXQgdGhlIGFkZHJlc3NcbiAgICogdmFsaWRhdGlvbiBmYWlsZWQgc2ltcGx5IGJlY2F1c2UgaXQncyBleHRlcm5hbCB0byB0aGUgd2FsbGV0LlxuICAgKi9cbiAgdGhyb3cgZTtcbn1cblxuaW50ZXJmYWNlIEZldGNoQWRkcmVzc0RldGFpbHNPcHRpb25zIHtcbiAgcmVxSWQ/OiBJUmVxdWVzdFRyYWNlcjtcbiAgZGlzYWJsZU5ldHdvcmtpbmc6IGJvb2xlYW47XG4gIGFkZHJlc3NEZXRhaWxzUHJlYnVpbGQ6IGFueTtcbiAgYWRkcmVzc0RldGFpbHNWZXJpZmljYXRpb246IGFueTtcbiAgY3VycmVudEFkZHJlc3M6IHN0cmluZztcbiAgd2FsbGV0OiBJV2FsbGV0O1xufVxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaEFkZHJlc3NEZXRhaWxzKHtcbiAgcmVxSWQsXG4gIGRpc2FibGVOZXR3b3JraW5nLFxuICBhZGRyZXNzRGV0YWlsc1ByZWJ1aWxkLFxuICBhZGRyZXNzRGV0YWlsc1ZlcmlmaWNhdGlvbixcbiAgY3VycmVudEFkZHJlc3MsXG4gIHdhbGxldCxcbn06IEZldGNoQWRkcmVzc0RldGFpbHNPcHRpb25zKSB7XG4gIGxldCBhZGRyZXNzRGV0YWlscyA9IF8uZXh0ZW5kKHt9LCBhZGRyZXNzRGV0YWlsc1ByZWJ1aWxkLCBhZGRyZXNzRGV0YWlsc1ZlcmlmaWNhdGlvbik7XG4gIGRlYnVnKCdMb2NhbGx5IGF2YWlsYWJsZSBhZGRyZXNzICVzIGRldGFpbHM6ICVPJywgY3VycmVudEFkZHJlc3MsIGFkZHJlc3NEZXRhaWxzKTtcbiAgaWYgKF8uaXNFbXB0eShhZGRyZXNzRGV0YWlscykgJiYgIWRpc2FibGVOZXR3b3JraW5nKSB7XG4gICAgYWRkcmVzc0RldGFpbHMgPSBhd2FpdCB3YWxsZXQuZ2V0QWRkcmVzcyh7IGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLCByZXFJZCB9KTtcbiAgICBkZWJ1ZygnRG93bmxvYWRlZCBhZGRyZXNzICVzIGRldGFpbHM6ICVPJywgY3VycmVudEFkZHJlc3MsIGFkZHJlc3NEZXRhaWxzKTtcbiAgfVxuICByZXR1cm4gYWRkcmVzc0RldGFpbHM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tQ2hhbmdlT3B0aW9ucyB7XG4gIGtleXM6IFtLZXljaGFpbiwgS2V5Y2hhaW4sIEtleWNoYWluXTtcbiAgc2lnbmF0dXJlczogW3N0cmluZywgc3RyaW5nLCBzdHJpbmddO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlT3V0cHV0T3B0aW9ucyB7XG4gIGN1cnJlbnRPdXRwdXQ6IE91dHB1dDtcbiAgY29pbjogQWJzdHJhY3RVdHhvQ29pbjtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgdmVyaWZpY2F0aW9uOiBWZXJpZmljYXRpb25PcHRpb25zO1xuICBrZXljaGFpbkFycmF5OiBbS2V5Y2hhaW4sIEtleWNoYWluLCBLZXljaGFpbl07XG4gIHdhbGxldDogSVdhbGxldDtcbiAgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zO1xuICBjdXN0b21DaGFuZ2U/OiBDdXN0b21DaGFuZ2VPcHRpb25zO1xuICByZXFJZD86IElSZXF1ZXN0VHJhY2VyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VPdXRwdXQoe1xuICBjdXJyZW50T3V0cHV0LFxuICBjb2luLFxuICB0eFByZWJ1aWxkLFxuICB2ZXJpZmljYXRpb24sXG4gIGtleWNoYWluQXJyYXksXG4gIHdhbGxldCxcbiAgdHhQYXJhbXMsXG4gIGN1c3RvbUNoYW5nZSxcbiAgcmVxSWQsXG59OiBQYXJzZU91dHB1dE9wdGlvbnMpOiBQcm9taXNlPE91dHB1dD4ge1xuICBjb25zdCBkaXNhYmxlTmV0d29ya2luZyA9ICEhdmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nO1xuICBjb25zdCBjdXJyZW50QWRkcmVzcyA9IGN1cnJlbnRPdXRwdXQuYWRkcmVzcztcblxuICAvLyBhdHRlbXB0IHRvIGdyYWIgdGhlIGFkZHJlc3MgZGV0YWlscyBmcm9tIGVpdGhlciB0aGUgcHJlYnVpbHQgdHgsIG9yIHRoZSB2ZXJpZmljYXRpb24gcGFyYW1zLlxuICAvLyBJZiBib3RoIG9mIHRoZXNlIGFyZSBlbXB0eSwgdGhlbiB3ZSB3aWxsIHRyeSB0byBnZXQgdGhlIGFkZHJlc3MgZGV0YWlscyBmcm9tIGJpdGdvIGluc3RlYWRcbiAgY29uc3QgYWRkcmVzc0RldGFpbHNQcmVidWlsZCA9IF8uZ2V0KHR4UHJlYnVpbGQsIGB0eEluZm8ud2FsbGV0QWRkcmVzc0RldGFpbHMuJHtjdXJyZW50QWRkcmVzc31gLCB7fSk7XG4gIGNvbnN0IGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uOiBBZGRyZXNzVmVyaWZpY2F0aW9uRGF0YSA9IHZlcmlmaWNhdGlvbj8uYWRkcmVzc2VzPy5bY3VycmVudEFkZHJlc3NdID8/IHt9O1xuICBkZWJ1ZygnUGFyc2luZyBhZGRyZXNzIGRldGFpbHMgZm9yICVzJywgY3VycmVudEFkZHJlc3MpO1xuICBsZXQgY3VycmVudEFkZHJlc3NEZXRhaWxzID0gdW5kZWZpbmVkO1xuICBsZXQgY3VycmVudEFkZHJlc3NUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGNvbnN0IFJFQ0lQSUVOVF9USFJFU0hPTEQgPSAxMDAwO1xuICB0cnkge1xuICAgIC8vIEluIHRoZSBjYXNlIG9mIFBTQlRzLCB3ZSBjYW4gYWxyZWFkeSBkZXRlcm1pbmUgdGhlIGludGVybmFsL2V4dGVybmFsIHN0YXR1cyBvZiB0aGUgb3V0cHV0IGFkZHJlc3Nlc1xuICAgIC8vIGJhc2VkIG9uIHRoZSBkZXJpdmF0aW9uIGluZm9ybWF0aW9uIGJlaW5nIGluY2x1ZGVkIGluIHRoZSBQU0JULiBXZSBjYW4gc2hvcnQgY2lyY3VpdCBHRVQgdjIud2FsbGV0LmFkZHJlc3NcbiAgICAvLyBhbmQgc2F2ZSBvbiBuZXR3b3JrIHJlcXVlc3RzLiBTaW5jZSB3ZSBoYXZlIHRoZSBkZXJpdmF0aW9uIGluZm9ybWF0aW9uIGFscmVhZHksIHdlIGNhbiBzdGlsbCB2ZXJpZnkgdGhlIGFkZHJlc3NcbiAgICBpZiAoY3VycmVudE91dHB1dC5leHRlcm5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IHdlIGhhdmUgYSBjdXN0b20gY2hhbmdlIHdhbGxldCwgd2UgbmVlZCB0byB2ZXJpZnkgdGhlIGFkZHJlc3MgYWdhaW5zdCB0aGUgY3VzdG9tIGNoYW5nZSBrZXlzXG4gICAgICAvLyBhbmQgbm90IHRoZSB3YWxsZXQga2V5cy4gVGhpcyBjaGVjayBpcyBkb25lIGluIHRoZSBoYW5kbGVWZXJpZnlBZGRyZXNzRXJyb3IgZnVuY3Rpb24gaWYgdGhpcyBlcnJvciBpcyB0aHJvd24uXG4gICAgICBpZiAoY3VzdG9tQ2hhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoJ2BhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZScpO1xuICAgICAgfVxuICAgICAgLy8gSWYgaXQgaXMgYW4gaW50ZXJuYWwgYWRkcmVzcywgd2UgY2FuIHNraXAgdGhlIG5ldHdvcmsgcmVxdWVzdCBhbmQganVzdCB2ZXJpZnkgdGhlIGFkZHJlc3MgbG9jYWxseSB3aXRoIHRoZVxuICAgICAgLy8gZGVyaXZhdGlvbiBpbmZvcm1hdGlvbiB3ZSBoYXZlLiBPdGhlcndpc2UsIGlmIHRoZSBhZGRyZXNzIGlzIGV4dGVybmFsLCB3aGljaCBpcyB0aGUgb25seSByZW1haW5pbmcgY2FzZSwgd2VcbiAgICAgIC8vIGNhbiBqdXN0IHJldHVybiB0aGUgY3VycmVudCBvdXRwdXQgYXMgaXMgd2l0aG91dCBjb250YWN0aW5nIHRoZSBzZXJ2ZXIuXG4gICAgICBpZiAoaXNXYWxsZXRPdXRwdXQoY3VycmVudE91dHB1dCkpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY29pbi5pc1dhbGxldEFkZHJlc3Moe1xuICAgICAgICAgIGFkZHJlc3NUeXBlOiBBYnN0cmFjdFV0eG9Db2luLmluZmVyQWRkcmVzc1R5cGUoeyBjaGFpbjogY3VycmVudE91dHB1dC5jaGFpbiB9KSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAga2V5Y2hhaW5zOiBrZXljaGFpbkFycmF5IGFzIHsgcHViOiBzdHJpbmc7IGNvbW1vbktleWNoYWluPzogc3RyaW5nIHwgdW5kZWZpbmVkIH1bXSxcbiAgICAgICAgICBhZGRyZXNzOiBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgICBjaGFpbjogY3VycmVudE91dHB1dC5jaGFpbixcbiAgICAgICAgICBpbmRleDogY3VycmVudE91dHB1dC5pbmRleCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnRPdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBvbmx5IHdheSB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBhZGRyZXNzIGlzIGtub3duIG9uIHRoZSB3YWxsZXQgaXMgdG8gaW5pdGlhdGUgYSBuZXR3b3JrIHJlcXVlc3QgYW5kXG4gICAgICogZmV0Y2ggaXQuIFNob3VsZCB0aGUgcmVxdWVzdCBmYWlsIGFuZCByZXR1cm4gYSA0MDQsIGl0IHdpbGwgdGhyb3cgYW5kIHRoZXJlZm9yZSBoYXMgdG8gYmUgY2F1Z2h0LiBGb3IgdGhhdFxuICAgICAqIHJlYXNvbiwgYWRkcmVzcyB3YWxsZXQgb3duZXJzaGlwIGRldGVjdGlvbiBpcyB3cmFwcGVkIGluIGEgdHJ5L2NhdGNoLiBBZGRpdGlvbmFsbHksIG9uY2UgdGhlIGFkZHJlc3NcbiAgICAgKiBkZXRhaWxzIGFyZSBmZXRjaGVkIG9uIHRoZSB3YWxsZXQsIGEgbG9jYWwgYWRkcmVzcyB2YWxpZGF0aW9uIGlzIHJ1biwgd2hvc2UgZXJyb3JzIGhvd2V2ZXIgYXJlIGdlbmVyYXRlZFxuICAgICAqIGNsaWVudC1zaWRlIGFuZCBjYW4gdGhlcmVmb3JlIGJlIGFuYWx5emVkIHdpdGggbW9yZSBncmFudWxhcml0eSBhbmQgdHlwZSBjaGVja2luZy5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEluIG9yZGVyIHRvIG1pbmltaXplIEFQSSByZXF1ZXN0cywgd2UgYXNzdW1lIHRoYXQgZXhwbGljaXQgcmVjaXBpZW50cyBhcmUgYWx3YXlzIGV4dGVybmFsIHdoZW4gdGhlXG4gICAgICogcmVjaXBpZW50IGxpc3QgaXMgPiAxMDAwIFRoaXMgaXMgbm90IGFsd2F5cyBhIHZhbGlkIGFzc3VtcHRpb24gYW5kIGNvdWxkIGxlYWQgZ3JlYXRlciBhcHBhcmVudCBzcGVuZCAoYnV0IG5ldmVyIGxvd2VyKVxuICAgICAqL1xuICAgIGlmICh0eFBhcmFtcy5yZWNpcGllbnRzICE9PSB1bmRlZmluZWQgJiYgdHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGggPiBSRUNJUElFTlRfVEhSRVNIT0xEKSB7XG4gICAgICBjb25zdCBpc0N1cnJlbnRBZGRyZXNzSW5SZWNpcGllbnRzID0gdHhQYXJhbXMucmVjaXBpZW50cy5zb21lKChyZWNpcGllbnQpID0+XG4gICAgICAgIHJlY2lwaWVudC5hZGRyZXNzLmluY2x1ZGVzKGN1cnJlbnRBZGRyZXNzKVxuICAgICAgKTtcblxuICAgICAgaWYgKGlzQ3VycmVudEFkZHJlc3NJblJlY2lwaWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uY3VycmVudE91dHB1dCB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gYXdhaXQgZmV0Y2hBZGRyZXNzRGV0YWlscyh7XG4gICAgICByZXFJZCxcbiAgICAgIGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uLFxuICAgICAgYWRkcmVzc0RldGFpbHNQcmVidWlsZCxcbiAgICAgIGN1cnJlbnRBZGRyZXNzLFxuICAgICAgZGlzYWJsZU5ldHdvcmtpbmcsXG4gICAgICB3YWxsZXQsXG4gICAgfSk7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhlIGFkZHJlc3MgaXMgb24gdGhlIHdhbGxldC4gdmVyaWZ5QWRkcmVzcyB0aHJvd3MgaWZcbiAgICAvLyBpdCBmYWlscyB0byBjb3JyZWN0bHkgcmVkZXJpdmUgdGhlIGFkZHJlc3MsIG1lYW5pbmcgaXQncyBleHRlcm5hbFxuICAgIGN1cnJlbnRBZGRyZXNzVHlwZSA9IEFic3RyYWN0VXR4b0NvaW4uaW5mZXJBZGRyZXNzVHlwZShhZGRyZXNzRGV0YWlscykgfHwgdW5kZWZpbmVkO1xuICAgIGN1cnJlbnRBZGRyZXNzRGV0YWlscyA9IGFkZHJlc3NEZXRhaWxzO1xuICAgIGF3YWl0IGNvaW4udmVyaWZ5QWRkcmVzcyhcbiAgICAgIF8uZXh0ZW5kKHsgYWRkcmVzc1R5cGU6IGN1cnJlbnRBZGRyZXNzVHlwZSB9LCBhZGRyZXNzRGV0YWlscywge1xuICAgICAgICBrZXljaGFpbnM6IGtleWNoYWluQXJyYXksXG4gICAgICAgIGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgfSlcbiAgICApO1xuICAgIGRlYnVnKCdBZGRyZXNzICVzIHZlcmlmaWNhdGlvbiBwYXNzZWQnLCBjdXJyZW50QWRkcmVzcyk7XG5cbiAgICAvLyB2ZXJpZnkgYWRkcmVzcyBzdWNjZWVkZWQgd2l0aG91dCB0aHJvd2luZywgc28gdGhlIGFkZHJlc3Mgd2FzXG4gICAgLy8gY29ycmVjdGx5IHJlZGVyaXZlZCBmcm9tIHRoZSB3YWxsZXQga2V5Y2hhaW5zLCBtYWtpbmcgaXQgbm90IGV4dGVybmFsXG4gICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBjdXJyZW50T3V0cHV0LCBhZGRyZXNzRGV0YWlscywgeyBleHRlcm5hbDogZmFsc2UgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZygnQWRkcmVzcyAlcyB2ZXJpZmljYXRpb24gdGhyZXcgYW4gZXJyb3I6JywgY3VycmVudEFkZHJlc3MsIGUpO1xuICAgIHJldHVybiBfLmV4dGVuZChcbiAgICAgIHt9LFxuICAgICAgY3VycmVudE91dHB1dCxcbiAgICAgIGF3YWl0IGhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvcih7XG4gICAgICAgIGUsXG4gICAgICAgIGNvaW4sXG4gICAgICAgIGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICB3YWxsZXQsXG4gICAgICAgIHR4UGFyYW1zLFxuICAgICAgICBjdXN0b21DaGFuZ2VLZXlzOiBjdXN0b21DaGFuZ2UgJiYgY3VzdG9tQ2hhbmdlLmtleXMsXG4gICAgICAgIGFkZHJlc3NEZXRhaWxzOiBjdXJyZW50QWRkcmVzc0RldGFpbHMsXG4gICAgICAgIGFkZHJlc3NUeXBlOiBjdXJyZW50QWRkcmVzc1R5cGUsXG4gICAgICAgIGNvbnNpZGVyTWlncmF0ZWRGcm9tQWRkcmVzc0ludGVybmFsOiB2ZXJpZmljYXRpb24uY29uc2lkZXJNaWdyYXRlZEZyb21BZGRyZXNzSW50ZXJuYWwsXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiJdfQ==