/// <reference types="bn.js" />
/// <reference types="node" />
/**
 * @prettier
 */
import { AbstractEthLikeCoin, OfflineVaultTxInfo, RecoverOptions, RecoveryInfo } from '@bitgo/abstract-eth';
import { BaseCoin, BitGoBase, Recipient } from '@bitgo/sdk-core';
import { BaseCoin as StaticsBaseCoin, EthereumNetwork as EthLikeNetwork } from '@bitgo/statics';
import { TransactionBuilder } from './lib';
import { Buffer } from 'buffer';
import { BN } from 'ethereumjs-util';
export declare class Etc extends AbstractEthLikeCoin {
    readonly staticsCoin?: Readonly<StaticsBaseCoin>;
    protected readonly sendMethodName: 'sendMultiSig' | 'sendMultiSigToken';
    protected constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    isValidPub(pub: string): boolean;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param {string} params.userKey - [encrypted] xprv
     * @param {string} params.backupKey - [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param {string} params.walletPassphrase - used to decrypt userKey and backupKey
     * @param {string} params.walletContractAddress - the ETH address of the wallet contract
     * @param {string} params.krsProvider - necessary if backup key is held by KRS
     * @param {string} params.recoveryDestination - target address to send recovered funds to
     * @param {string} params.bitgoFeeAddress - wrong chain wallet fee address for evm based cross chain recovery txn
     * @param {string} params.bitgoDestinationAddress - target bitgo address where fee will be sent for evm based cross chain recovery txn
     */
    recover(params: RecoverOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    getTransactionBuilder(): TransactionBuilder;
    /**
     * Make a query to etc.network for information such as balance, token balance, solidity calls
     * @param {Object} query â€” key-value pairs of parameters to append after /api
     * @returns {Promise<Object>} response from etc.network
     */
    recoveryBlockchainExplorerQuery(query: Record<string, any>): Promise<any>;
    /**
     * Method to validate recovery params
     * @param {RecoverOptions} params
     * @returns {void}
     */
    validateRecoveryParams(params: RecoverOptions): void;
    /**
     * Queries public block explorer to get the next ETHLike coin's nonce that should be used for the given ETH address
     * @param {string} address
     * @returns {Promise<number>}
     */
    getAddressNonce(address: string): Promise<number>;
    /**
     * Queries etc.network for the balance of an address
     * @param {string} address - the ETC address
     * @returns {Promise<BigNumber>} address balance
     */
    queryAddressBalance(address: string): Promise<BN>;
    /**
     * Queries the contract (via explorer API) for the next sequence ID
     * @param {String} address - address of the contract
     * @returns {Promise<Number>} sequence ID
     */
    querySequenceId(address: string): Promise<number>;
    /**
     * Check whether the gas price passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param {number} userGasPrice - user defined gas price
     * @returns {number} the gas price to use for this transaction
     */
    setGasPrice(userGasPrice?: number): number;
    /**
     * Check whether gas limit passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param {number} userGasLimit user defined gas limit
     * @returns {number} the gas limit to use for this transaction
     */
    setGasLimit(userGasLimit?: number): number;
    /**
     * @param {Recipient[]} recipients - the recipients of the transaction
     * @param {number} expireTime - the expire time of the transaction
     * @param {number} contractSequenceId - the contract sequence id of the transaction
     * @returns {string}
     */
    getOperationSha3ForExecuteAndConfirm(recipients: Recipient[], expireTime: number, contractSequenceId: number): string;
    /**
     * Get transfer operation for coin
     * @param {Recipient} recipient - recipient info
     * @param {number} expireTime - expiry time
     * @param {number} contractSequenceId - sequence id
     * @returns {Array} operation array
     */
    getOperation(recipient: Recipient, expireTime: number, contractSequenceId: number): (string | Buffer)[][];
    /**
     * Method to return the coin's network object
     * @returns {EthLikeNetwork | undefined}
     */
    getNetwork(): EthLikeNetwork | undefined;
}
//# sourceMappingURL=etc.d.ts.map