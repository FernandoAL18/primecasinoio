"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
const keyring_1 = require("@polkadot/keyring");
const pair_1 = require("@polkadot/keyring/pair");
const sdk_core_1 = require("@bitgo/sdk-core");
const bs58_1 = __importDefault(require("bs58"));
const utils_1 = __importDefault(require("./utils"));
const nacl = __importStar(require("tweetnacl"));
const TYPE = 'ed25519';
const keyring = new keyring_1.Keyring({ type: TYPE });
class KeyPair extends sdk_core_1.Ed25519KeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    constructor(source) {
        super(source);
    }
    /**
     * Helper function to create the KeyringPair for signing a dot transaction.
     *
     * @returns {KeyringPair} dot KeyringPair
     *
     * @see https://polkadot.js.org/docs/api/start/keyring
     */
    createPolkadotPair() {
        const secretKey = this.keyPair.prv ? new Uint8Array(Buffer.from(this.keyPair.prv, 'hex')) : undefined;
        const publicKey = new Uint8Array(Buffer.from(this.keyPair.pub, 'hex'));
        return (0, pair_1.createPair)({ toSS58: keyring.encodeAddress, type: TYPE }, { secretKey, publicKey });
    }
    /**
     // https://wiki.polkadot.network/docs/learn-accounts#address-format
     * Returns the address in either mainnet polkadot format (starts with 1)
     * or substrate format used for westend (starts with 5)
     */
    getAddress(format) {
        let encodedAddress = this.createPolkadotPair().address;
        encodedAddress = keyring.encodeAddress(encodedAddress, format);
        return encodedAddress;
    }
    /** @inheritdoc */
    getKeys() {
        const result = { pub: this.keyPair.pub };
        if (this.keyPair.prv) {
            result.prv = this.keyPair.prv;
        }
        return result;
    }
    /** @inheritdoc */
    recordKeysFromPrivateKeyInProtocolFormat(prv) {
        const decodedSeed = utils_1.default.decodeSeed(prv);
        const bufferFromSeed = Buffer.from(decodedSeed.seed);
        return utils_1.default.keyPairFromSeed(bufferFromSeed).keyPair;
    }
    /** @inheritdoc */
    recordKeysFromPublicKeyInProtocolFormat(pub) {
        const publicKey = keyring.addFromPair({
            // tss common pub is in base58 format and decodes to length of 32
            publicKey: (0, sdk_core_1.isBase58)(pub, 32) ? new Uint8Array(bs58_1.default.decode(pub)) : new Uint8Array(Buffer.from(pub, 'hex')),
            secretKey: new Uint8Array(),
        }).publicKey;
        return { pub: (0, sdk_core_1.toHex)(publicKey) };
    }
    /**
     *  Sign the message in Uint8Array
     *
     * @param {Uint8Array} message to be signed
     * @returns {Uint8Array} signed message
     */
    signMessageinUint8Array(message) {
        const { prv } = this.keyPair;
        if (!prv) {
            throw new Error('Missing private key');
        }
        return nacl.sign.detached(message, nacl.sign.keyPair.fromSeed((0, sdk_core_1.toUint8Array)(prv)).secretKey);
    }
}
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtDQUE0QztBQUM1QyxpREFBb0Q7QUFFcEQsOENBUXlCO0FBQ3pCLGdEQUF3QjtBQUN4QixvREFBNEI7QUFDNUIsZ0RBQWtDO0FBRWxDLE1BQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQztBQUN2QixNQUFNLE9BQU8sR0FBRyxJQUFJLGlCQUFPLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUU1QyxNQUFhLE9BQVEsU0FBUSx5QkFBYztJQUN6Qzs7OztPQUlHO0lBQ0gsWUFBWSxNQUF1QjtRQUNqQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLGtCQUFrQjtRQUMxQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDdEcsTUFBTSxTQUFTLEdBQUcsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLE9BQU8sSUFBQSxpQkFBVSxFQUFDLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxhQUFhLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDN0YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsTUFBd0I7UUFDakMsSUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUMsT0FBTyxDQUFDO1FBQ3ZELGNBQWMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLGNBQWMsRUFBRSxNQUFnQixDQUFDLENBQUM7UUFFekUsT0FBTyxjQUFjLENBQUM7SUFDeEIsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixPQUFPO1FBQ0wsTUFBTSxNQUFNLEdBQWdCLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdEQsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRTtZQUNwQixNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1NBQy9CO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELGtCQUFrQjtJQUNsQix3Q0FBd0MsQ0FBQyxHQUFXO1FBQ2xELE1BQU0sV0FBVyxHQUFHLGVBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDMUMsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckQsT0FBTyxlQUFLLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUN2RCxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLHVDQUF1QyxDQUFDLEdBQVc7UUFDakQsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQztZQUNwQyxpRUFBaUU7WUFDakUsU0FBUyxFQUFFLElBQUEsbUJBQVEsRUFBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLGNBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDekcsU0FBUyxFQUFFLElBQUksVUFBVSxFQUFFO1NBQzVCLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDYixPQUFPLEVBQUUsR0FBRyxFQUFFLElBQUEsZ0JBQUssRUFBQyxTQUFTLENBQUMsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHVCQUF1QixDQUFDLE9BQW1CO1FBQ3pDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQzdCLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDUixNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7U0FDeEM7UUFDRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBQSx1QkFBWSxFQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDOUYsQ0FBQztDQUNGO0FBMUVELDBCQTBFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEtleXJpbmcgfSBmcm9tICdAcG9sa2Fkb3Qva2V5cmluZyc7XG5pbXBvcnQgeyBjcmVhdGVQYWlyIH0gZnJvbSAnQHBvbGthZG90L2tleXJpbmcvcGFpcic7XG5pbXBvcnQgeyBLZXlyaW5nUGFpciB9IGZyb20gJ0Bwb2xrYWRvdC9rZXlyaW5nL3R5cGVzJztcbmltcG9ydCB7XG4gIERvdEFkZHJlc3NGb3JtYXQsXG4gIERlZmF1bHRLZXlzLFxuICBFZDI1NTE5S2V5UGFpcixcbiAgaXNCYXNlNTgsXG4gIEtleVBhaXJPcHRpb25zLFxuICB0b0hleCxcbiAgdG9VaW50OEFycmF5LFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IGJzNTggZnJvbSAnYnM1OCc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgKiBhcyBuYWNsIGZyb20gJ3R3ZWV0bmFjbCc7XG5cbmNvbnN0IFRZUEUgPSAnZWQyNTUxOSc7XG5jb25zdCBrZXlyaW5nID0gbmV3IEtleXJpbmcoeyB0eXBlOiBUWVBFIH0pO1xuXG5leHBvcnQgY2xhc3MgS2V5UGFpciBleHRlbmRzIEVkMjU1MTlLZXlQYWlyIHtcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IEtleVBhaXJPcHRpb25zIH0gc291cmNlIEVpdGhlciBhIG1hc3RlciBzZWVkLCBhIHByaXZhdGUga2V5LCBvciBhIHB1YmxpYyBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZT86IEtleVBhaXJPcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBLZXlyaW5nUGFpciBmb3Igc2lnbmluZyBhIGRvdCB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0tleXJpbmdQYWlyfSBkb3QgS2V5cmluZ1BhaXJcbiAgICpcbiAgICogQHNlZSBodHRwczovL3BvbGthZG90LmpzLm9yZy9kb2NzL2FwaS9zdGFydC9rZXlyaW5nXG4gICAqL1xuICBwcm90ZWN0ZWQgY3JlYXRlUG9sa2Fkb3RQYWlyKCk6IEtleXJpbmdQYWlyIHtcbiAgICBjb25zdCBzZWNyZXRLZXkgPSB0aGlzLmtleVBhaXIucHJ2ID8gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20odGhpcy5rZXlQYWlyLnBydiwgJ2hleCcpKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSh0aGlzLmtleVBhaXIucHViLCAnaGV4JykpO1xuICAgIHJldHVybiBjcmVhdGVQYWlyKHsgdG9TUzU4OiBrZXlyaW5nLmVuY29kZUFkZHJlc3MsIHR5cGU6IFRZUEUgfSwgeyBzZWNyZXRLZXksIHB1YmxpY0tleSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgLy8gaHR0cHM6Ly93aWtpLnBvbGthZG90Lm5ldHdvcmsvZG9jcy9sZWFybi1hY2NvdW50cyNhZGRyZXNzLWZvcm1hdFxuICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzIGluIGVpdGhlciBtYWlubmV0IHBvbGthZG90IGZvcm1hdCAoc3RhcnRzIHdpdGggMSlcbiAgICogb3Igc3Vic3RyYXRlIGZvcm1hdCB1c2VkIGZvciB3ZXN0ZW5kIChzdGFydHMgd2l0aCA1KVxuICAgKi9cbiAgZ2V0QWRkcmVzcyhmb3JtYXQ6IERvdEFkZHJlc3NGb3JtYXQpOiBzdHJpbmcge1xuICAgIGxldCBlbmNvZGVkQWRkcmVzcyA9IHRoaXMuY3JlYXRlUG9sa2Fkb3RQYWlyKCkuYWRkcmVzcztcbiAgICBlbmNvZGVkQWRkcmVzcyA9IGtleXJpbmcuZW5jb2RlQWRkcmVzcyhlbmNvZGVkQWRkcmVzcywgZm9ybWF0IGFzIG51bWJlcik7XG5cbiAgICByZXR1cm4gZW5jb2RlZEFkZHJlc3M7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgZ2V0S2V5cygpOiBEZWZhdWx0S2V5cyB7XG4gICAgY29uc3QgcmVzdWx0OiBEZWZhdWx0S2V5cyA9IHsgcHViOiB0aGlzLmtleVBhaXIucHViIH07XG4gICAgaWYgKHRoaXMua2V5UGFpci5wcnYpIHtcbiAgICAgIHJlc3VsdC5wcnYgPSB0aGlzLmtleVBhaXIucHJ2O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHJlY29yZEtleXNGcm9tUHJpdmF0ZUtleUluUHJvdG9jb2xGb3JtYXQocHJ2OiBzdHJpbmcpOiBEZWZhdWx0S2V5cyB7XG4gICAgY29uc3QgZGVjb2RlZFNlZWQgPSB1dGlscy5kZWNvZGVTZWVkKHBydik7XG4gICAgY29uc3QgYnVmZmVyRnJvbVNlZWQgPSBCdWZmZXIuZnJvbShkZWNvZGVkU2VlZC5zZWVkKTtcbiAgICByZXR1cm4gdXRpbHMua2V5UGFpckZyb21TZWVkKGJ1ZmZlckZyb21TZWVkKS5rZXlQYWlyO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHJlY29yZEtleXNGcm9tUHVibGljS2V5SW5Qcm90b2NvbEZvcm1hdChwdWI6IHN0cmluZyk6IERlZmF1bHRLZXlzIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBrZXlyaW5nLmFkZEZyb21QYWlyKHtcbiAgICAgIC8vIHRzcyBjb21tb24gcHViIGlzIGluIGJhc2U1OCBmb3JtYXQgYW5kIGRlY29kZXMgdG8gbGVuZ3RoIG9mIDMyXG4gICAgICBwdWJsaWNLZXk6IGlzQmFzZTU4KHB1YiwgMzIpID8gbmV3IFVpbnQ4QXJyYXkoYnM1OC5kZWNvZGUocHViKSkgOiBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShwdWIsICdoZXgnKSksXG4gICAgICBzZWNyZXRLZXk6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfSkucHVibGljS2V5O1xuICAgIHJldHVybiB7IHB1YjogdG9IZXgocHVibGljS2V5KSB9O1xuICB9XG5cbiAgLyoqXG4gICAqICBTaWduIHRoZSBtZXNzYWdlIGluIFVpbnQ4QXJyYXlcbiAgICpcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBtZXNzYWdlIHRvIGJlIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gc2lnbmVkIG1lc3NhZ2VcbiAgICovXG4gIHNpZ25NZXNzYWdlaW5VaW50OEFycmF5KG1lc3NhZ2U6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgICBjb25zdCB7IHBydiB9ID0gdGhpcy5rZXlQYWlyO1xuICAgIGlmICghcHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hY2wuc2lnbi5kZXRhY2hlZChtZXNzYWdlLCBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCh0b1VpbnQ4QXJyYXkocHJ2KSkuc2VjcmV0S2V5KTtcbiAgfVxufVxuIl19