/// <reference types="node" />
import { SignSession } from '@silencelaboratories/dkls-wasm-ll-node';
import { DeserializedBroadcastMessage, DeserializedDklsSignature, DeserializedMessages, DsgState } from './types';
declare type NodeWasmer = typeof import('@silencelaboratories/dkls-wasm-ll-node');
declare type WebWasmer = typeof import('@silencelaboratories/dkls-wasm-ll-web');
declare type BundlerWasmer = typeof import('@silencelaboratories/dkls-wasm-ll-bundler');
declare type DklsWasm = NodeWasmer | WebWasmer | BundlerWasmer;
export declare class Dsg {
    protected dsgSession: SignSession | undefined;
    protected dsgSessionBytes: Uint8Array;
    private _signature;
    protected keyShareBytes: Buffer;
    protected messageHash: Buffer;
    protected derivationPath: string;
    protected partyIdx: number;
    protected dsgState: DsgState;
    protected dklsWasm: DklsWasm | null;
    constructor(keyShare: Buffer, partyIdx: number, derivationPath: string, messageHash: Buffer, dklsWasm?: BundlerWasmer);
    private _restoreSession;
    private _deserializeState;
    private loadDklsWasm;
    private getDklsWasm;
    /**
     * Returns the current DSG session as a base64 string.
     * @returns {string} - base64 string of the current DSG session
     */
    getSession(): string;
    /**
     * Sets the DSG session from a base64 string.
     * @param {string} session - base64 string of the DSG session
     */
    setSession(session: string): Promise<void>;
    init(): Promise<DeserializedBroadcastMessage>;
    get signature(): DeserializedDklsSignature;
    /**
     * Ends the DSG session by freeing any heap allocations from wasm. Note that the session is freed if a signature is produced.
     */
    endSession(): void;
    /**
     * Proccesses incoming messages to this party in the DKLs DSG protocol and
     * produces messages from this party to other parties for the next round.
     * @param messagesForIthRound - messages to process the current round
     * @returns {DeserializedMessages} - messages to send to other parties for the next round
     */
    handleIncomingMessages(messagesForIthRound: DeserializedMessages): DeserializedMessages;
}
export {};
//# sourceMappingURL=dsg.d.ts.map