"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultExpireTime = exports.recoveryBlockchainExplorerQuery = exports.decodeForwarderCreationData = exports.getCreateForwarderParamsAndTypes = exports.getAddressInitDataAllForwarderVersions = exports.getV1AddressInitializationData = exports.getV1WalletInitializationData = exports.getToken = exports.getBufferedByteCode = exports.getRawDecoded = exports.hasSignature = exports.toStringSig = exports.getProxyInitcode = exports.calculateForwarderV1Address = exports.calculateForwarderAddress = exports.hexStringToNumber = exports.numberToHexString = exports.classifyTransaction = exports.decodeFlushTokensData = exports.decodeNativeTransferData = exports.decodeERC1155TransferData = exports.decodeERC721TransferData = exports.decodeTokenTransferData = exports.decodeTransferData = exports.decodeWalletCreationData = exports.isValidAmount = exports.isValidEthAddress = exports.getAddressInitializationData = exports.flushCoinsData = exports.flushTokensData = exports.sendMultiSigTokenData = exports.sendMultiSigData = exports.sign = exports.signInternal = exports.getCommon = void 0;
const buffer_1 = require("buffer");
const superagent_1 = __importDefault(require("superagent"));
const assert_1 = __importDefault(require("assert"));
const ethereumjs_util_1 = require("ethereumjs-util");
const statics_1 = require("@bitgo/statics");
const ethereumjs_abi_1 = __importDefault(require("ethereumjs-abi"));
const common_1 = __importDefault(require("@ethereumjs/common"));
const bn_js_1 = __importDefault(require("bn.js"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sdk_core_1 = require("@bitgo/sdk-core");
const walletUtil_1 = require("./walletUtil");
const types_1 = require("./types");
/**
 * @param network
 */
function getCommon(network) {
    return common_1.default.forCustomChain(
    // use the mainnet config as a base, override chain ids and network name
    'mainnet', {
        name: network.type,
        networkId: network.chainId,
        chainId: network.chainId,
    }, 'london');
}
exports.getCommon = getCommon;
/**
 * Signs the transaction using the appropriate algorithm
 * and the provided common for the blockchain
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @param {EthereumCommon} customCommon the network's custom common
 * @returns {string} the transaction signed and encoded
 */
async function signInternal(transactionData, keyPair, customCommon) {
    if (!keyPair.getKeys().prv) {
        throw new sdk_core_1.SigningError('Missing private key');
    }
    const ethTx = types_1.EthTransactionData.fromJson(transactionData, customCommon);
    ethTx.sign(keyPair);
    return ethTx.toSerialized();
}
exports.signInternal = signInternal;
/**
 * Signs the transaction using the appropriate algorithm
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @returns {string} the transaction signed and encoded
 */
async function sign(transactionData, keyPair) {
    return signInternal(transactionData, keyPair, getCommon(statics_1.coins.get('teth').network));
}
exports.sign = sign;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} data aditional method call data
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
function sendMultiSigData(to, value, data, expireTime, sequenceId, signature) {
    const params = [to, value, (0, ethereumjs_util_1.toBuffer)(data), expireTime, sequenceId, (0, ethereumjs_util_1.toBuffer)(signature)];
    const method = ethereumjs_abi_1.default.methodID('sendMultiSig', walletUtil_1.sendMultiSigTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.sendMultiSigTypes, params);
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.sendMultiSigData = sendMultiSigData;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} tokenContractAddress the address of the erc20 token contract
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
function sendMultiSigTokenData(to, value, tokenContractAddress, expireTime, sequenceId, signature) {
    const params = [to, value, tokenContractAddress, expireTime, sequenceId, (0, ethereumjs_util_1.toBuffer)(signature)];
    const method = ethereumjs_abi_1.default.methodID('sendMultiSigToken', walletUtil_1.sendMultiSigTokenTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.sendMultiSigTokenTypes, params);
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.sendMultiSigTokenData = sendMultiSigTokenData;
/**
 * Get the data required to make a flush tokens contract call
 *
 * @param forwarderAddress The forwarder address to flush
 * @param tokenAddress The token address to flush from
 */
function flushTokensData(forwarderAddress, tokenAddress, forwarderVersion) {
    let params;
    let method;
    let args;
    if (forwarderVersion >= 4) {
        params = [tokenAddress];
        method = ethereumjs_abi_1.default.methodID('flushTokens', walletUtil_1.flushTokensTypesv4);
        args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushTokensTypesv4, params);
    }
    else {
        params = [forwarderAddress, tokenAddress];
        method = ethereumjs_abi_1.default.methodID('flushForwarderTokens', walletUtil_1.flushTokensTypes);
        args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushTokensTypes, params);
    }
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.flushTokensData = flushTokensData;
/**
 * Get the data required to make a flush native coins contract call
 */
function flushCoinsData() {
    const params = [];
    const method = ethereumjs_abi_1.default.methodID('flush', walletUtil_1.flushCoinsTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushCoinsTypes, params);
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.flushCoinsData = flushCoinsData;
/**
 * Returns the create forwarder method calling data
 *
 * @returns {string} - the createForwarder method encoded
 */
function getAddressInitializationData() {
    return walletUtil_1.createForwarderMethodId;
}
exports.getAddressInitializationData = getAddressInitializationData;
/**
 * Returns whether or not the string is a valid Eth address
 *
 * @param {string} address - the tx hash to validate
 * @returns {boolean} - the validation result
 */
function isValidEthAddress(address) {
    return (0, ethereumjs_util_1.isValidAddress)(address);
}
exports.isValidEthAddress = isValidEthAddress;
/**
 * Returns whether or not the string is a valid amount number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    const bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThanOrEqualTo(0);
}
exports.isValidAmount = isValidAmount;
/**
 * Returns the smart contract encoded data
 *
 * @param {string} data The wallet creation data to decode
 * @returns {string[]} - The list of signer addresses
 */
function decodeWalletCreationData(data) {
    if (!(data.startsWith(walletUtil_1.walletInitializationFirstBytes) || data.startsWith(walletUtil_1.v1CreateWalletMethodId))) {
        throw new sdk_core_1.BuildTransactionError(`Invalid wallet bytecode: ${data}`);
    }
    if (data.startsWith(walletUtil_1.walletInitializationFirstBytes)) {
        const dataBuffer = buffer_1.Buffer.from(data.slice(2), 'hex');
        // the last 160 bytes contain the serialized address array
        const serializedSigners = dataBuffer.slice(-160);
        const resultEncodedParameters = ethereumjs_abi_1.default.rawDecode(walletUtil_1.walletSimpleConstructor, serializedSigners);
        if (resultEncodedParameters.length !== 1) {
            throw new sdk_core_1.BuildTransactionError(`Could not decode wallet constructor bytecode: ${resultEncodedParameters}`);
        }
        const addresses = resultEncodedParameters[0];
        if (addresses.length !== 3) {
            throw new sdk_core_1.BuildTransactionError(`invalid number of addresses in parsed constructor: ${addresses}`);
        }
        // sometimes ethereumjs-abi removes 0 padding at the start of addresses,
        // so we should pad until they are the standard 20 bytes
        const paddedAddresses = addresses.map((address) => (0, ethereumjs_util_1.stripHexPrefix)(address.toString('hex')).padStart(40, '0'));
        return { owners: paddedAddresses.map((address) => (0, ethereumjs_util_1.addHexPrefix)(address)) };
    }
    else {
        const decodedDataForWalletCreation = getRawDecoded(walletUtil_1.createV1WalletTypes, getBufferedByteCode(walletUtil_1.v1CreateWalletMethodId, data));
        const addresses = decodedDataForWalletCreation[0];
        const saltBuffer = decodedDataForWalletCreation[1];
        const salt = (0, ethereumjs_util_1.bufferToHex)(saltBuffer);
        const paddedAddresses = addresses.map((address) => (0, ethereumjs_util_1.stripHexPrefix)(address.toString()).padStart(40, '0'));
        const owners = paddedAddresses.map((address) => (0, ethereumjs_util_1.addHexPrefix)(address));
        return {
            owners,
            salt,
        };
    }
}
exports.decodeWalletCreationData = decodeWalletCreationData;
/**
 * Decode the given ABI-encoded transfer data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeTransferData(data) {
    if (data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        return decodeNativeTransferData(data);
    }
    else if (data.startsWith(walletUtil_1.sendMultisigTokenMethodId)) {
        return decodeTokenTransferData(data);
    }
    else {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
}
exports.decodeTransferData = decodeTransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisigToken function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed token transfer data
 */
function decodeTokenTransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigTokenMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, tokenContractAddress, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTokenTypes, getBufferedByteCode(walletUtil_1.sendMultisigTokenMethodId, data));
    return {
        to: (0, ethereumjs_util_1.addHexPrefix)(to),
        amount: new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(amount)).toFixed(),
        expireTime: (0, ethereumjs_util_1.bufferToInt)(expireTime),
        sequenceId: (0, ethereumjs_util_1.bufferToInt)(sequenceId),
        signature: (0, ethereumjs_util_1.bufferToHex)(signature),
        tokenContractAddress: (0, ethereumjs_util_1.addHexPrefix)(tokenContractAddress),
    };
}
exports.decodeTokenTransferData = decodeTokenTransferData;
function decodeERC721TransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, internalData, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data));
    const internalDataHex = (0, ethereumjs_util_1.bufferToHex)(internalData);
    if (!internalDataHex.startsWith(walletUtil_1.ERC721SafeTransferTypeMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [from, receiver, tokenId, userSentData] = getRawDecoded(walletUtil_1.ERC721SafeTransferTypes, getBufferedByteCode(walletUtil_1.ERC721SafeTransferTypeMethodId, internalDataHex));
    return {
        to: (0, ethereumjs_util_1.addHexPrefix)(receiver),
        from: (0, ethereumjs_util_1.addHexPrefix)(from),
        expireTime: (0, ethereumjs_util_1.bufferToInt)(expireTime),
        amount: new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(amount)).toFixed(),
        tokenId: new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(tokenId)).toFixed(),
        sequenceId: (0, ethereumjs_util_1.bufferToInt)(sequenceId),
        signature: (0, ethereumjs_util_1.bufferToHex)(signature),
        tokenContractAddress: (0, ethereumjs_util_1.addHexPrefix)(to),
        userData: (0, ethereumjs_util_1.bufferToHex)(userSentData),
    };
}
exports.decodeERC721TransferData = decodeERC721TransferData;
function decodeERC1155TransferData(data) {
    let from, receiver, userSentData;
    let tokenIds;
    let values;
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, internalData, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data));
    const internalDataHex = (0, ethereumjs_util_1.bufferToHex)(internalData);
    if (internalDataHex.startsWith(walletUtil_1.ERC1155SafeTransferTypeMethodId)) {
        let tokenId;
        let value;
        [from, receiver, tokenId, value, userSentData] = getRawDecoded(walletUtil_1.ERC1155SafeTransferTypes, getBufferedByteCode(walletUtil_1.ERC1155SafeTransferTypeMethodId, internalDataHex));
        tokenIds = [new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(tokenId)).toFixed()];
        values = [new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(value)).toFixed()];
    }
    else if ((0, ethereumjs_util_1.bufferToHex)(internalData).startsWith(walletUtil_1.ERC1155BatchTransferTypeMethodId)) {
        let tempTokenIds, tempValues;
        [from, receiver, tempTokenIds, tempValues, userSentData] = getRawDecoded(walletUtil_1.ERC1155BatchTransferTypes, getBufferedByteCode(walletUtil_1.ERC1155BatchTransferTypeMethodId, internalDataHex));
        tokenIds = tempTokenIds.map((x) => new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(x)).toFixed());
        values = tempValues.map((x) => new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(x)).toFixed());
    }
    else {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    return {
        to: (0, ethereumjs_util_1.addHexPrefix)(receiver),
        from: (0, ethereumjs_util_1.addHexPrefix)(from),
        expireTime: (0, ethereumjs_util_1.bufferToInt)(expireTime),
        amount: new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(amount)).toFixed(),
        tokenIds,
        values,
        sequenceId: (0, ethereumjs_util_1.bufferToInt)(sequenceId),
        signature: (0, ethereumjs_util_1.bufferToHex)(signature),
        tokenContractAddress: (0, ethereumjs_util_1.addHexPrefix)(to),
        userData: userSentData,
    };
}
exports.decodeERC1155TransferData = decodeERC1155TransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisig function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeNativeTransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, internalData, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data));
    return {
        to: (0, ethereumjs_util_1.addHexPrefix)(to),
        amount: new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(amount)).toFixed(),
        expireTime: (0, ethereumjs_util_1.bufferToInt)(expireTime),
        sequenceId: (0, ethereumjs_util_1.bufferToInt)(sequenceId),
        signature: (0, ethereumjs_util_1.bufferToHex)(signature),
        data: (0, ethereumjs_util_1.bufferToHex)(internalData),
    };
}
exports.decodeNativeTransferData = decodeNativeTransferData;
/**
 * Decode the given ABI-encoded flush tokens data and return parsed fields
 *
 * @param data The data to decode
 * @param to Optional to parameter of tx
 * @returns parsed transfer data
 */
function decodeFlushTokensData(data, to) {
    if (data.startsWith(walletUtil_1.flushForwarderTokensMethodId)) {
        const [forwarderAddress, tokenAddress] = getRawDecoded(walletUtil_1.flushTokensTypes, getBufferedByteCode(walletUtil_1.flushForwarderTokensMethodId, data));
        return {
            forwarderAddress: (0, ethereumjs_util_1.addHexPrefix)(forwarderAddress),
            tokenAddress: (0, ethereumjs_util_1.addHexPrefix)(tokenAddress),
        };
    }
    else if (data.startsWith(walletUtil_1.flushForwarderTokensMethodIdV4)) {
        const [tokenAddress] = getRawDecoded(walletUtil_1.flushTokensTypesv4, getBufferedByteCode(walletUtil_1.flushForwarderTokensMethodIdV4, data));
        if (!to) {
            throw new sdk_core_1.BuildTransactionError(`Missing to address: ${to}`);
        }
        return {
            forwarderAddress: to,
            tokenAddress: (0, ethereumjs_util_1.addHexPrefix)(tokenAddress),
            forwarderVersion: 4,
        };
    }
    else {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
}
exports.decodeFlushTokensData = decodeFlushTokensData;
/**
 * Classify the given transaction data based as a transaction type.
 * ETH transactions are defined by the first 8 bytes of the transaction data, also known as the method id
 *
 * @param {string} data The data to classify the transaction with
 * @returns {TransactionType} The classified transaction type
 */
function classifyTransaction(data) {
    if (data.length < 10) {
        // contract calls must have at least 4 bytes (method id) and '0x'
        // if it doesn't have enough data to be a contract call it must be a single sig send
        return sdk_core_1.TransactionType.SingleSigSend;
    }
    // TODO(STLX-1970): validate if we are going to constraint to some methods allowed
    let transactionType = transactionTypesMap[data.slice(0, 10).toLowerCase()];
    if (transactionType === undefined) {
        transactionType = sdk_core_1.TransactionType.ContractCall;
    }
    return transactionType;
}
exports.classifyTransaction = classifyTransaction;
/**
 * A transaction types map according to the starting part of the encoded data
 */
const transactionTypesMap = {
    [walletUtil_1.walletInitializationFirstBytes]: sdk_core_1.TransactionType.WalletInitialization,
    [walletUtil_1.recoveryWalletInitializationFirstBytes]: sdk_core_1.TransactionType.RecoveryWalletDeployment,
    [walletUtil_1.v1CreateWalletMethodId]: sdk_core_1.TransactionType.WalletInitialization,
    [walletUtil_1.createForwarderMethodId]: sdk_core_1.TransactionType.AddressInitialization,
    [walletUtil_1.v1CreateForwarderMethodId]: sdk_core_1.TransactionType.AddressInitialization,
    [walletUtil_1.v4CreateForwarderMethodId]: sdk_core_1.TransactionType.AddressInitialization,
    [walletUtil_1.sendMultisigMethodId]: sdk_core_1.TransactionType.Send,
    [walletUtil_1.flushForwarderTokensMethodId]: sdk_core_1.TransactionType.FlushTokens,
    [walletUtil_1.flushForwarderTokensMethodIdV4]: sdk_core_1.TransactionType.FlushTokens,
    [walletUtil_1.flushCoinsMethodId]: sdk_core_1.TransactionType.FlushCoins,
    [walletUtil_1.sendMultisigTokenMethodId]: sdk_core_1.TransactionType.Send,
    [sdk_core_1.LockMethodId]: sdk_core_1.TransactionType.StakingLock,
    [sdk_core_1.VoteMethodId]: sdk_core_1.TransactionType.StakingVote,
    [sdk_core_1.ActivateMethodId]: sdk_core_1.TransactionType.StakingActivate,
    [sdk_core_1.UnvoteMethodId]: sdk_core_1.TransactionType.StakingUnvote,
    [sdk_core_1.UnlockMethodId]: sdk_core_1.TransactionType.StakingUnlock,
    [sdk_core_1.WithdrawMethodId]: sdk_core_1.TransactionType.StakingWithdraw,
};
/**
 *
 * @param {number} num number to be converted to hex
 * @returns {string} the hex number
 */
function numberToHexString(num) {
    const hex = num.toString(16);
    return hex.length % 2 === 0 ? '0x' + hex : '0x0' + hex;
}
exports.numberToHexString = numberToHexString;
/**
 *
 * @param {string} hex The hex string to be converted
 * @returns {number} the resulting number
 */
function hexStringToNumber(hex) {
    return parseInt(hex.slice(2), 16);
}
exports.hexStringToNumber = hexStringToNumber;
/**
 * Generates an address of the forwarder address to be deployed
 *
 * @param {string} contractAddress the address which is creating this new address
 * @param {number} contractCounter the nonce of the contract address
 * @returns {string} the calculated forwarder contract address
 */
function calculateForwarderAddress(contractAddress, contractCounter) {
    const forwarderAddress = (0, ethereumjs_util_1.generateAddress)(buffer_1.Buffer.from((0, ethereumjs_util_1.stripHexPrefix)(contractAddress), 'hex'), buffer_1.Buffer.from((0, ethereumjs_util_1.padToEven)((0, ethereumjs_util_1.stripHexPrefix)(numberToHexString(contractCounter))), 'hex'));
    return (0, ethereumjs_util_1.addHexPrefix)(forwarderAddress.toString('hex'));
}
exports.calculateForwarderAddress = calculateForwarderAddress;
/**
 * Calculate the forwarder v1 address that will be generated if `creatorAddress` creates it with salt `salt`
 * and initcode `inicode using the create2 opcode
 * @param {string} creatorAddress The address that is sending the tx to create a new address, hex string
 * @param {string} salt The salt to create the address with using create2, hex string
 * @param {string} initcode The initcode that will be deployed to the address, hex string
 * @return {string} The calculated address
 */
function calculateForwarderV1Address(creatorAddress, salt, initcode) {
    const forwarderV1Address = (0, ethereumjs_util_1.generateAddress2)(buffer_1.Buffer.from((0, ethereumjs_util_1.stripHexPrefix)(creatorAddress), 'hex'), buffer_1.Buffer.from((0, ethereumjs_util_1.stripHexPrefix)(salt), 'hex'), buffer_1.Buffer.from((0, ethereumjs_util_1.padToEven)((0, ethereumjs_util_1.stripHexPrefix)(initcode)), 'hex'));
    return (0, ethereumjs_util_1.addHexPrefix)(forwarderV1Address.toString('hex'));
}
exports.calculateForwarderV1Address = calculateForwarderV1Address;
/**
 * Take the implementation address for the proxy contract, and get the binary initcode for the associated proxy
 * @param {string} implementationAddress The address of the implementation contract for the proxy
 * @return {string} Binary hex string of the proxy
 */
function getProxyInitcode(implementationAddress) {
    const target = (0, ethereumjs_util_1.stripHexPrefix)(implementationAddress.toLowerCase()).padStart(40, '0');
    // bytecode of the proxy, from:
    // https://github.com/BitGo/eth-multisig-v4/blob/d546a937f90f93e83b3423a5bf933d1d77c677c3/contracts/CloneFactory.sol#L42-L56
    return `0x3d602d80600a3d3981f3363d3d373d3d3d363d73${target}5af43d82803e903d91602b57fd5bf3`;
}
exports.getProxyInitcode = getProxyInitcode;
/**
 * Convert the given signature parts to a string representation
 *
 * @param {SignatureParts} sig The signature to convert to string
 * @returns {string} String representation of the signature
 */
function toStringSig(sig) {
    return (0, ethereumjs_util_1.bufferToHex)(buffer_1.Buffer.concat([
        (0, ethereumjs_util_1.setLengthLeft)(buffer_1.Buffer.from((0, ethereumjs_util_1.stripHexPrefix)(sig.r), 'hex'), 32),
        (0, ethereumjs_util_1.setLengthLeft)(buffer_1.Buffer.from((0, ethereumjs_util_1.stripHexPrefix)(sig.s), 'hex'), 32),
        (0, ethereumjs_util_1.toBuffer)(sig.v),
    ]));
}
exports.toStringSig = toStringSig;
/**
 * Return whether or not the given tx data has a signature
 *
 * @param {TxData} txData The transaction data to check for signature
 * @returns {boolean} true if the tx has a signature, else false
 */
function hasSignature(txData) {
    return (txData.v !== undefined &&
        txData.r !== undefined &&
        txData.s !== undefined &&
        txData.v.length > 0 &&
        txData.r.length > 0 &&
        txData.s.length > 0);
}
exports.hasSignature = hasSignature;
/**
 * Get the raw data decoded for some types
 *
 * @param {string[]} types ABI types definition
 * @param {Buffer} serializedArgs encoded args
 * @returns {Buffer[]} the decoded raw
 */
function getRawDecoded(types, serializedArgs) {
    function normalize(v, i) {
        if (bn_js_1.default.isBN(v)) {
            return v;
        }
        else if (typeof v === 'string' || buffer_1.Buffer.isBuffer(v)) {
            return v;
        }
        else if (Array.isArray(v)) {
            return v.map(normalize);
        }
        else {
            throw new Error(`For ${types}[${i}] got ${typeof v}`);
        }
    }
    return ethereumjs_abi_1.default.rawDecode(types, serializedArgs).map(normalize);
}
exports.getRawDecoded = getRawDecoded;
/**
 * Get the buffered bytecode from rawData using a methodId as delimiter
 *
 * @param {string} methodId the hex encoded method Id
 * @param {string} rawData the hex encoded raw data
 * @returns {Buffer} data buffered bytecode
 */
function getBufferedByteCode(methodId, rawData) {
    const splitBytecode = rawData.split(methodId);
    if (splitBytecode.length !== 2) {
        throw new sdk_core_1.BuildTransactionError(`Invalid send bytecode: ${rawData}`);
    }
    if (splitBytecode[1].length % 2 !== 0) {
        throw new sdk_core_1.BuildTransactionError(`Invalid send bytecode: ${rawData} (wrong lenght)`);
    }
    return buffer_1.Buffer.from(splitBytecode[1], 'hex');
}
exports.getBufferedByteCode = getBufferedByteCode;
/**
 * Get the statics coin object matching a given contract address if it exists
 *
 * @param tokenContractAddress The contract address to match against
 * @param network - the coin network
 * @param family - the coin family
 * @returns statics BaseCoin object for the matching token
 */
function getToken(tokenContractAddress, network, family) {
    // filter the coins array to find the token with the matching contract address, network and coin family
    // coin family is needed to avoid causing issues when a token has same contract address on two different chains
    const tokens = statics_1.coins.filter((coin) => {
        if (coin instanceof statics_1.ContractAddressDefinedToken) {
            return (coin.network.type === network.type &&
                coin.family === family &&
                coin.contractAddress.toLowerCase() === tokenContractAddress.toLowerCase());
        }
        return false;
    });
    // if length of tokens is 1, return the first, else return undefined
    // Can't directly index into tokens, or call `length`, so we use map to get an array
    const tokensArray = tokens.map((token) => token);
    if (tokensArray.length >= 1) {
        // there should never be two tokens with the same contract address, so we assert that here
        (0, assert_1.default)(tokensArray.length === 1);
        return tokensArray[0];
    }
    return undefined;
}
exports.getToken = getToken;
/**
 * Returns the create wallet method calling data for v1 wallets
 *
 * @param {string[]} walletOwners - wallet owner addresses for wallet initialization transactions
 * @param {string} salt - The salt for wallet initialization transactions
 * @returns {string} - the createWallet method encoded
 */
function getV1WalletInitializationData(walletOwners, salt) {
    const saltBuffer = (0, ethereumjs_util_1.setLengthLeft)((0, ethereumjs_util_1.toBuffer)(salt), 32);
    const params = [walletOwners, saltBuffer];
    const method = ethereumjs_abi_1.default.methodID('createWallet', walletUtil_1.createV1WalletTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.createV1WalletTypes, params);
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.getV1WalletInitializationData = getV1WalletInitializationData;
/**
 * Returns the create address method calling data for v1, v2, v4 forwarders
 *
 * @param {string} baseAddress - The address of the wallet contract
 * @param {string} salt - The salt for address initialization transactions
 * @param {string} feeAddress - The fee address for the enterprise
 * @returns {string} - the createForwarder method encoded
 */
function getV1AddressInitializationData(baseAddress, salt, feeAddress) {
    const saltBuffer = (0, ethereumjs_util_1.setLengthLeft)((0, ethereumjs_util_1.toBuffer)(salt), 32);
    const { createForwarderParams, createForwarderTypes } = getCreateForwarderParamsAndTypes(baseAddress, saltBuffer, feeAddress);
    const method = ethereumjs_abi_1.default.methodID('createForwarder', createForwarderTypes);
    const args = ethereumjs_abi_1.default.rawEncode(createForwarderTypes, createForwarderParams);
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.getV1AddressInitializationData = getV1AddressInitializationData;
/**
 * Returns the create address method calling data for all forwarder versions
 *
 * @param {number} forwarderVersion - The version of the forwarder to create
 * @param {string} baseAddress - The address of the wallet contract
 * @param {string} salt - The salt for address initialization transactions
 * @param {string} feeAddress - The fee address for the enterprise
 * @returns {string} - the createForwarder method encoded
 *
 */
function getAddressInitDataAllForwarderVersions(forwarderVersion, baseAddress, salt, feeAddress) {
    if (forwarderVersion === walletUtil_1.defaultForwarderVersion) {
        return getAddressInitializationData();
    }
    else {
        return getV1AddressInitializationData(baseAddress, salt, feeAddress);
    }
}
exports.getAddressInitDataAllForwarderVersions = getAddressInitDataAllForwarderVersions;
/**
 * Returns the createForwarderTypes and createForwarderParams for all forwarder versions
 *
 * @param {string} baseAddress - The address of the wallet contract
 * @param {Buffer} saltBuffer - The salt for address initialization transaction
 * @param {string} feeAddress - The fee address for the enterprise
 * @returns {createForwarderParams: (string | Buffer)[], createForwarderTypes: string[]}
 */
function getCreateForwarderParamsAndTypes(baseAddress, saltBuffer, feeAddress) {
    let createForwarderParams = [baseAddress, saltBuffer];
    let createForwarderTypes = walletUtil_1.createV1ForwarderTypes;
    if (feeAddress) {
        createForwarderParams = [baseAddress, feeAddress, saltBuffer];
        createForwarderTypes = walletUtil_1.createV4ForwarderTypes;
    }
    return { createForwarderParams, createForwarderTypes };
}
exports.getCreateForwarderParamsAndTypes = getCreateForwarderParamsAndTypes;
/**
 * Decode the given ABI-encoded create forwarder data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeForwarderCreationData(data) {
    if (!(data.startsWith(walletUtil_1.v4CreateForwarderMethodId) ||
        data.startsWith(walletUtil_1.v1CreateForwarderMethodId) ||
        data.startsWith(walletUtil_1.createForwarderMethodId))) {
        throw new sdk_core_1.BuildTransactionError(`Invalid address bytecode: ${data}`);
    }
    if (data.startsWith(walletUtil_1.createForwarderMethodId)) {
        return {
            baseAddress: undefined,
            addressCreationSalt: undefined,
            feeAddress: undefined,
        };
    }
    else if (data.startsWith(walletUtil_1.v1CreateForwarderMethodId)) {
        const [baseAddress, saltBuffer] = getRawDecoded(walletUtil_1.createV1ForwarderTypes, getBufferedByteCode(walletUtil_1.v1CreateForwarderMethodId, data));
        return {
            baseAddress: (0, ethereumjs_util_1.addHexPrefix)(baseAddress),
            addressCreationSalt: (0, ethereumjs_util_1.bufferToHex)(saltBuffer),
            feeAddress: undefined,
        };
    }
    else {
        const [baseAddress, feeAddress, saltBuffer] = getRawDecoded(walletUtil_1.createV4ForwarderTypes, getBufferedByteCode(walletUtil_1.v4CreateForwarderMethodId, data));
        return {
            baseAddress: (0, ethereumjs_util_1.addHexPrefix)(baseAddress),
            addressCreationSalt: (0, ethereumjs_util_1.bufferToHex)(saltBuffer),
            feeAddress: (0, ethereumjs_util_1.addHexPrefix)(feeAddress),
        };
    }
}
exports.decodeForwarderCreationData = decodeForwarderCreationData;
/**
 * Make a query to explorer for information such as balance, token balance, solidity calls
 * @param {Object} query key-value pairs of parameters to append after /api
 * @param {string} token the API token to use for the request
 * @param {string} explorerUrl the URL of the explorer
 * @returns {Promise<Object>} response from explorer
 */
async function recoveryBlockchainExplorerQuery(query, explorerUrl, token) {
    if (token) {
        query.apikey = token;
    }
    const response = await superagent_1.default.get(`${explorerUrl}/api`).query(query);
    if (!response.ok) {
        throw new Error('could not reach explorer');
    }
    if (response.body.status === '0' && response.body.message === 'NOTOK') {
        throw new Error('Explorer rate limit reached');
    }
    return response.body;
}
exports.recoveryBlockchainExplorerQuery = recoveryBlockchainExplorerQuery;
/**
 * Default expire time for a contract call (1 week)
 * @returns {number} Time in seconds
 */
function getDefaultExpireTime() {
    return Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 7;
}
exports.getDefaultExpireTime = getDefaultExpireTime;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1DQUFnQztBQUNoQyw0REFBaUM7QUFDakMsb0RBQTRCO0FBQzVCLHFEQVd5QjtBQUN6Qiw0Q0FBNEc7QUFDNUcsb0VBQXlDO0FBQ3pDLGdFQUFnRDtBQUNoRCxrREFBdUI7QUFDdkIsZ0VBQXFDO0FBQ3JDLDhDQVV5QjtBQWV6Qiw2Q0E0QnNCO0FBQ3RCLG1DQUE2QztBQUU3Qzs7R0FFRztBQUNILFNBQWdCLFNBQVMsQ0FBQyxPQUF3QjtJQUNoRCxPQUFPLGdCQUFjLENBQUMsY0FBYztJQUNsQyx3RUFBd0U7SUFDeEUsU0FBUyxFQUNUO1FBQ0UsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJO1FBQ2xCLFNBQVMsRUFBRSxPQUFPLENBQUMsT0FBTztRQUMxQixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU87S0FDekIsRUFDRCxRQUFRLENBQ1QsQ0FBQztBQUNKLENBQUM7QUFYRCw4QkFXQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0ksS0FBSyxVQUFVLFlBQVksQ0FDaEMsZUFBdUIsRUFDdkIsT0FBZ0IsRUFDaEIsWUFBNEI7SUFFNUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUU7UUFDMUIsTUFBTSxJQUFJLHVCQUFZLENBQUMscUJBQXFCLENBQUMsQ0FBQztLQUMvQztJQUNELE1BQU0sS0FBSyxHQUFHLDBCQUFrQixDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDekUsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNwQixPQUFPLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztBQUM5QixDQUFDO0FBWEQsb0NBV0M7QUFFRDs7Ozs7O0dBTUc7QUFDSSxLQUFLLFVBQVUsSUFBSSxDQUFDLGVBQXVCLEVBQUUsT0FB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O1FBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztLQUM3QztJQUVELElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLEtBQUssR0FBRyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxLQUFLLE9BQU8sRUFBRTtRQUNyRSxNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7S0FDaEQ7SUFDRCxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUM7QUFDdkIsQ0FBQztBQWxCRCwwRUFrQkM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixvQkFBb0I7SUFDbEMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3BFLENBQUM7QUFGRCxvREFFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7XG4gIGFkZEhleFByZWZpeCxcbiAgYnVmZmVyVG9IZXgsXG4gIGJ1ZmZlclRvSW50LFxuICBnZW5lcmF0ZUFkZHJlc3MsXG4gIGlzVmFsaWRBZGRyZXNzLFxuICBzZXRMZW5ndGhMZWZ0LFxuICBzdHJpcEhleFByZWZpeCxcbiAgdG9CdWZmZXIsXG4gIGdlbmVyYXRlQWRkcmVzczIsXG4gIHBhZFRvRXZlbixcbn0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IEJhc2VDb2luLCBCYXNlTmV0d29yaywgY29pbnMsIENvbnRyYWN0QWRkcmVzc0RlZmluZWRUb2tlbiwgRXRoZXJldW1OZXR3b3JrIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IEV0aGVyZXVtQWJpIGZyb20gJ2V0aGVyZXVtanMtYWJpJztcbmltcG9ydCBFdGhlcmV1bUNvbW1vbiBmcm9tICdAZXRoZXJldW1qcy9jb21tb24nO1xuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7XG4gIEFjdGl2YXRlTWV0aG9kSWQsXG4gIEJ1aWxkVHJhbnNhY3Rpb25FcnJvcixcbiAgTG9ja01ldGhvZElkLFxuICBTaWduaW5nRXJyb3IsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgVW5sb2NrTWV0aG9kSWQsXG4gIFVudm90ZU1ldGhvZElkLFxuICBWb3RlTWV0aG9kSWQsXG4gIFdpdGhkcmF3TWV0aG9kSWQsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5cbmltcG9ydCB7XG4gIEVSQzExNTVUcmFuc2ZlckRhdGEsXG4gIEVSQzcyMVRyYW5zZmVyRGF0YSxcbiAgRmx1c2hUb2tlbnNEYXRhLFxuICBOYXRpdmVUcmFuc2ZlckRhdGEsXG4gIFNpZ25hdHVyZVBhcnRzLFxuICBUb2tlblRyYW5zZmVyRGF0YSxcbiAgVHJhbnNmZXJEYXRhLFxuICBUeERhdGEsXG4gIFdhbGxldEluaXRpYWxpemF0aW9uRGF0YSxcbiAgRm9yd2FyZGVySW5pdGlhbGl6YXRpb25EYXRhLFxufSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuL2tleVBhaXInO1xuaW1wb3J0IHtcbiAgY3JlYXRlRm9yd2FyZGVyTWV0aG9kSWQsXG4gIEVSQzExNTVCYXRjaFRyYW5zZmVyVHlwZU1ldGhvZElkLFxuICBFUkMxMTU1QmF0Y2hUcmFuc2ZlclR5cGVzLFxuICBFUkMxMTU1U2FmZVRyYW5zZmVyVHlwZU1ldGhvZElkLFxuICBFUkMxMTU1U2FmZVRyYW5zZmVyVHlwZXMsXG4gIEVSQzcyMVNhZmVUcmFuc2ZlclR5cGVNZXRob2RJZCxcbiAgRVJDNzIxU2FmZVRyYW5zZmVyVHlwZXMsXG4gIGZsdXNoQ29pbnNNZXRob2RJZCxcbiAgZmx1c2hDb2luc1R5cGVzLFxuICBmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkLFxuICBmbHVzaFRva2Vuc1R5cGVzLFxuICBzZW5kTXVsdGlzaWdNZXRob2RJZCxcbiAgc2VuZE11bHRpc2lnVG9rZW5NZXRob2RJZCxcbiAgc2VuZE11bHRpU2lnVG9rZW5UeXBlcyxcbiAgc2VuZE11bHRpU2lnVHlwZXMsXG4gIHdhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlcyxcbiAgdjFDcmVhdGVGb3J3YXJkZXJNZXRob2RJZCxcbiAgd2FsbGV0U2ltcGxlQ29uc3RydWN0b3IsXG4gIGNyZWF0ZVYxV2FsbGV0VHlwZXMsXG4gIHYxQ3JlYXRlV2FsbGV0TWV0aG9kSWQsXG4gIGNyZWF0ZVYxRm9yd2FyZGVyVHlwZXMsXG4gIHJlY292ZXJ5V2FsbGV0SW5pdGlhbGl6YXRpb25GaXJzdEJ5dGVzLFxuICBkZWZhdWx0Rm9yd2FyZGVyVmVyc2lvbixcbiAgY3JlYXRlVjRGb3J3YXJkZXJUeXBlcyxcbiAgdjRDcmVhdGVGb3J3YXJkZXJNZXRob2RJZCxcbiAgZmx1c2hUb2tlbnNUeXBlc3Y0LFxuICBmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkVjQsXG59IGZyb20gJy4vd2FsbGV0VXRpbCc7XG5pbXBvcnQgeyBFdGhUcmFuc2FjdGlvbkRhdGEgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBAcGFyYW0gbmV0d29ya1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tbW9uKG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayk6IEV0aGVyZXVtQ29tbW9uIHtcbiAgcmV0dXJuIEV0aGVyZXVtQ29tbW9uLmZvckN1c3RvbUNoYWluKFxuICAgIC8vIHVzZSB0aGUgbWFpbm5ldCBjb25maWcgYXMgYSBiYXNlLCBvdmVycmlkZSBjaGFpbiBpZHMgYW5kIG5ldHdvcmsgbmFtZVxuICAgICdtYWlubmV0JyxcbiAgICB7XG4gICAgICBuYW1lOiBuZXR3b3JrLnR5cGUsXG4gICAgICBuZXR3b3JrSWQ6IG5ldHdvcmsuY2hhaW5JZCxcbiAgICAgIGNoYWluSWQ6IG5ldHdvcmsuY2hhaW5JZCxcbiAgICB9LFxuICAgICdsb25kb24nXG4gICk7XG59XG5cbi8qKlxuICogU2lnbnMgdGhlIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBhbGdvcml0aG1cbiAqIGFuZCB0aGUgcHJvdmlkZWQgY29tbW9uIGZvciB0aGUgYmxvY2tjaGFpblxuICpcbiAqIEBwYXJhbSB7VHhEYXRhfSB0cmFuc2FjdGlvbkRhdGEgdGhlIHRyYW5zYWN0aW9uIGRhdGEgdG8gc2lnblxuICogQHBhcmFtIHtLZXlQYWlyfSBrZXlQYWlyIHRoZSBzaWduZXIncyBrZXlwYWlyXG4gKiBAcGFyYW0ge0V0aGVyZXVtQ29tbW9ufSBjdXN0b21Db21tb24gdGhlIG5ldHdvcmsncyBjdXN0b20gY29tbW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdHJhbnNhY3Rpb24gc2lnbmVkIGFuZCBlbmNvZGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW50ZXJuYWwoXG4gIHRyYW5zYWN0aW9uRGF0YTogVHhEYXRhLFxuICBrZXlQYWlyOiBLZXlQYWlyLFxuICBjdXN0b21Db21tb246IEV0aGVyZXVtQ29tbW9uXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAoIWtleVBhaXIuZ2V0S2V5cygpLnBydikge1xuICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgfVxuICBjb25zdCBldGhUeCA9IEV0aFRyYW5zYWN0aW9uRGF0YS5mcm9tSnNvbih0cmFuc2FjdGlvbkRhdGEsIGN1c3RvbUNvbW1vbik7XG4gIGV0aFR4LnNpZ24oa2V5UGFpcik7XG4gIHJldHVybiBldGhUeC50b1NlcmlhbGl6ZWQoKTtcbn1cblxuLyoqXG4gKiBTaWducyB0aGUgdHJhbnNhY3Rpb24gdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGFsZ29yaXRobVxuICpcbiAqIEBwYXJhbSB7VHhEYXRhfSB0cmFuc2FjdGlvbkRhdGEgdGhlIHRyYW5zYWN0aW9uIGRhdGEgdG8gc2lnblxuICogQHBhcmFtIHtLZXlQYWlyfSBrZXlQYWlyIHRoZSBzaWduZXIncyBrZXlwYWlyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdHJhbnNhY3Rpb24gc2lnbmVkIGFuZCBlbmNvZGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduKHRyYW5zYWN0aW9uRGF0YTogVHhEYXRhLCBrZXlQYWlyOiBLZXlQYWlyKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIHNpZ25JbnRlcm5hbCh0cmFuc2FjdGlvbkRhdGEsIGtleVBhaXIsIGdldENvbW1vbihjb2lucy5nZXQoJ3RldGgnKS5uZXR3b3JrIGFzIEV0aGVyZXVtTmV0d29yaykpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRyYWN0IG1ldGhvZCBlbmNvZGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG8gZGVzdGluYXRpb24gYWRkcmVzc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIEFtb3VudCB0byB0cmFuZmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBhZGl0aW9uYWwgbWV0aG9kIGNhbGwgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGV4cGlyZVRpbWUgZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gc2Vjb25kc1xuICogQHBhcmFtIHtudW1iZXJ9IHNlcXVlbmNlSWQgc2VxdWVuY2UgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgc2lnbmF0dXJlIG9mIHRoZSBjYWxsXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtLSB0aGUgY29udHJhY3QgbWV0aG9kIGVuY29kZWQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VuZE11bHRpU2lnRGF0YShcbiAgdG86IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyxcbiAgZGF0YTogc3RyaW5nLFxuICBleHBpcmVUaW1lOiBudW1iZXIsXG4gIHNlcXVlbmNlSWQ6IG51bWJlcixcbiAgc2lnbmF0dXJlOiBzdHJpbmdcbik6IHN0cmluZyB7XG4gIGNvbnN0IHBhcmFtcyA9IFt0bywgdmFsdWUsIHRvQnVmZmVyKGRhdGEpLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCB0b0J1ZmZlcihzaWduYXR1cmUpXTtcbiAgY29uc3QgbWV0aG9kID0gRXRoZXJldW1BYmkubWV0aG9kSUQoJ3NlbmRNdWx0aVNpZycsIHNlbmRNdWx0aVNpZ1R5cGVzKTtcbiAgY29uc3QgYXJncyA9IEV0aGVyZXVtQWJpLnJhd0VuY29kZShzZW5kTXVsdGlTaWdUeXBlcywgcGFyYW1zKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChCdWZmZXIuY29uY2F0KFttZXRob2QsIGFyZ3NdKS50b1N0cmluZygnaGV4JykpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRyYWN0IG1ldGhvZCBlbmNvZGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG8gZGVzdGluYXRpb24gYWRkcmVzc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIEFtb3VudCB0byB0cmFuZmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5Db250cmFjdEFkZHJlc3MgdGhlIGFkZHJlc3Mgb2YgdGhlIGVyYzIwIHRva2VuIGNvbnRyYWN0XG4gKiBAcGFyYW0ge251bWJlcn0gZXhwaXJlVGltZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpbiBzZWNvbmRzXG4gKiBAcGFyYW0ge251bWJlcn0gc2VxdWVuY2VJZCBzZXF1ZW5jZSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSBzaWduYXR1cmUgb2YgdGhlIGNhbGxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0tIHRoZSBjb250cmFjdCBtZXRob2QgZW5jb2RlZCBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kTXVsdGlTaWdUb2tlbkRhdGEoXG4gIHRvOiBzdHJpbmcsXG4gIHZhbHVlOiBzdHJpbmcsXG4gIHRva2VuQ29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGV4cGlyZVRpbWU6IG51bWJlcixcbiAgc2VxdWVuY2VJZDogbnVtYmVyLFxuICBzaWduYXR1cmU6IHN0cmluZ1xuKTogc3RyaW5nIHtcbiAgY29uc3QgcGFyYW1zID0gW3RvLCB2YWx1ZSwgdG9rZW5Db250cmFjdEFkZHJlc3MsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHRvQnVmZmVyKHNpZ25hdHVyZSldO1xuXG4gIGNvbnN0IG1ldGhvZCA9IEV0aGVyZXVtQWJpLm1ldGhvZElEKCdzZW5kTXVsdGlTaWdUb2tlbicsIHNlbmRNdWx0aVNpZ1Rva2VuVHlwZXMpO1xuICBjb25zdCBhcmdzID0gRXRoZXJldW1BYmkucmF3RW5jb2RlKHNlbmRNdWx0aVNpZ1Rva2VuVHlwZXMsIHBhcmFtcyk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoQnVmZmVyLmNvbmNhdChbbWV0aG9kLCBhcmdzXSkudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRhdGEgcmVxdWlyZWQgdG8gbWFrZSBhIGZsdXNoIHRva2VucyBjb250cmFjdCBjYWxsXG4gKlxuICogQHBhcmFtIGZvcndhcmRlckFkZHJlc3MgVGhlIGZvcndhcmRlciBhZGRyZXNzIHRvIGZsdXNoXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIFRoZSB0b2tlbiBhZGRyZXNzIHRvIGZsdXNoIGZyb21cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoVG9rZW5zRGF0YShmb3J3YXJkZXJBZGRyZXNzOiBzdHJpbmcsIHRva2VuQWRkcmVzczogc3RyaW5nLCBmb3J3YXJkZXJWZXJzaW9uOiBudW1iZXIpOiBzdHJpbmcge1xuICBsZXQgcGFyYW1zOiBzdHJpbmdbXTtcbiAgbGV0IG1ldGhvZDogVWludDhBcnJheTtcbiAgbGV0IGFyZ3M6IFVpbnQ4QXJyYXk7XG5cbiAgaWYgKGZvcndhcmRlclZlcnNpb24gPj0gNCkge1xuICAgIHBhcmFtcyA9IFt0b2tlbkFkZHJlc3NdO1xuICAgIG1ldGhvZCA9IEV0aGVyZXVtQWJpLm1ldGhvZElEKCdmbHVzaFRva2VucycsIGZsdXNoVG9rZW5zVHlwZXN2NCk7XG4gICAgYXJncyA9IEV0aGVyZXVtQWJpLnJhd0VuY29kZShmbHVzaFRva2Vuc1R5cGVzdjQsIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zID0gW2ZvcndhcmRlckFkZHJlc3MsIHRva2VuQWRkcmVzc107XG4gICAgbWV0aG9kID0gRXRoZXJldW1BYmkubWV0aG9kSUQoJ2ZsdXNoRm9yd2FyZGVyVG9rZW5zJywgZmx1c2hUb2tlbnNUeXBlcyk7XG4gICAgYXJncyA9IEV0aGVyZXVtQWJpLnJhd0VuY29kZShmbHVzaFRva2Vuc1R5cGVzLCBwYXJhbXMpO1xuICB9XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoQnVmZmVyLmNvbmNhdChbbWV0aG9kLCBhcmdzXSkudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRhdGEgcmVxdWlyZWQgdG8gbWFrZSBhIGZsdXNoIG5hdGl2ZSBjb2lucyBjb250cmFjdCBjYWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaENvaW5zRGF0YSgpOiBzdHJpbmcge1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgY29uc3QgbWV0aG9kID0gRXRoZXJldW1BYmkubWV0aG9kSUQoJ2ZsdXNoJywgZmx1c2hDb2luc1R5cGVzKTtcbiAgY29uc3QgYXJncyA9IEV0aGVyZXVtQWJpLnJhd0VuY29kZShmbHVzaENvaW5zVHlwZXMsIHBhcmFtcyk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoQnVmZmVyLmNvbmNhdChbbWV0aG9kLCBhcmdzXSkudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjcmVhdGUgZm9yd2FyZGVyIG1ldGhvZCBjYWxsaW5nIGRhdGFcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBjcmVhdGVGb3J3YXJkZXIgbWV0aG9kIGVuY29kZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3NJbml0aWFsaXphdGlvbkRhdGEoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNyZWF0ZUZvcndhcmRlck1ldGhvZElkO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIEV0aCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSB0aGUgdHggaGFzaCB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRXRoQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIGFtb3VudCBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50IC0gdGhlIHN0cmluZyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQW1vdW50KGFtb3VudDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGJpZ051bWJlckFtb3VudCA9IG5ldyBCaWdOdW1iZXIoYW1vdW50KTtcbiAgcmV0dXJuIGJpZ051bWJlckFtb3VudC5pc0ludGVnZXIoKSAmJiBiaWdOdW1iZXJBbW91bnQuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbygwKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzbWFydCBjb250cmFjdCBlbmNvZGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBUaGUgd2FsbGV0IGNyZWF0aW9uIGRhdGEgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gVGhlIGxpc3Qgb2Ygc2lnbmVyIGFkZHJlc3Nlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlV2FsbGV0Q3JlYXRpb25EYXRhKGRhdGE6IHN0cmluZyk6IFdhbGxldEluaXRpYWxpemF0aW9uRGF0YSB7XG4gIGlmICghKGRhdGEuc3RhcnRzV2l0aCh3YWxsZXRJbml0aWFsaXphdGlvbkZpcnN0Qnl0ZXMpIHx8IGRhdGEuc3RhcnRzV2l0aCh2MUNyZWF0ZVdhbGxldE1ldGhvZElkKSkpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHdhbGxldCBieXRlY29kZTogJHtkYXRhfWApO1xuICB9XG5cbiAgaWYgKGRhdGEuc3RhcnRzV2l0aCh3YWxsZXRJbml0aWFsaXphdGlvbkZpcnN0Qnl0ZXMpKSB7XG4gICAgY29uc3QgZGF0YUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEuc2xpY2UoMiksICdoZXgnKTtcblxuICAgIC8vIHRoZSBsYXN0IDE2MCBieXRlcyBjb250YWluIHRoZSBzZXJpYWxpemVkIGFkZHJlc3MgYXJyYXlcbiAgICBjb25zdCBzZXJpYWxpemVkU2lnbmVycyA9IGRhdGFCdWZmZXIuc2xpY2UoLTE2MCk7XG5cbiAgICBjb25zdCByZXN1bHRFbmNvZGVkUGFyYW1ldGVycyA9IEV0aGVyZXVtQWJpLnJhd0RlY29kZSh3YWxsZXRTaW1wbGVDb25zdHJ1Y3Rvciwgc2VyaWFsaXplZFNpZ25lcnMpO1xuICAgIGlmIChyZXN1bHRFbmNvZGVkUGFyYW1ldGVycy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYENvdWxkIG5vdCBkZWNvZGUgd2FsbGV0IGNvbnN0cnVjdG9yIGJ5dGVjb2RlOiAke3Jlc3VsdEVuY29kZWRQYXJhbWV0ZXJzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NlczogQk5bXSA9IHJlc3VsdEVuY29kZWRQYXJhbWV0ZXJzWzBdO1xuICAgIGlmIChhZGRyZXNzZXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBpbnZhbGlkIG51bWJlciBvZiBhZGRyZXNzZXMgaW4gcGFyc2VkIGNvbnN0cnVjdG9yOiAke2FkZHJlc3Nlc31gKTtcbiAgICB9XG5cbiAgICAvLyBzb21ldGltZXMgZXRoZXJldW1qcy1hYmkgcmVtb3ZlcyAwIHBhZGRpbmcgYXQgdGhlIHN0YXJ0IG9mIGFkZHJlc3NlcyxcbiAgICAvLyBzbyB3ZSBzaG91bGQgcGFkIHVudGlsIHRoZXkgYXJlIHRoZSBzdGFuZGFyZCAyMCBieXRlc1xuICAgIGNvbnN0IHBhZGRlZEFkZHJlc3NlcyA9IGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IHN0cmlwSGV4UHJlZml4KGFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKS5wYWRTdGFydCg0MCwgJzAnKSk7XG5cbiAgICByZXR1cm4geyBvd25lcnM6IHBhZGRlZEFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IGFkZEhleFByZWZpeChhZGRyZXNzKSkgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkZWNvZGVkRGF0YUZvcldhbGxldENyZWF0aW9uID0gZ2V0UmF3RGVjb2RlZChcbiAgICAgIGNyZWF0ZVYxV2FsbGV0VHlwZXMsXG4gICAgICBnZXRCdWZmZXJlZEJ5dGVDb2RlKHYxQ3JlYXRlV2FsbGV0TWV0aG9kSWQsIGRhdGEpXG4gICAgKTtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBkZWNvZGVkRGF0YUZvcldhbGxldENyZWF0aW9uWzBdIGFzIHN0cmluZ1tdO1xuICAgIGNvbnN0IHNhbHRCdWZmZXIgPSBkZWNvZGVkRGF0YUZvcldhbGxldENyZWF0aW9uWzFdO1xuICAgIGNvbnN0IHNhbHQgPSBidWZmZXJUb0hleChzYWx0QnVmZmVyIGFzIEJ1ZmZlcik7XG4gICAgY29uc3QgcGFkZGVkQWRkcmVzc2VzID0gYWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gc3RyaXBIZXhQcmVmaXgoYWRkcmVzcy50b1N0cmluZygpKS5wYWRTdGFydCg0MCwgJzAnKSk7XG4gICAgY29uc3Qgb3duZXJzID0gcGFkZGVkQWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gYWRkSGV4UHJlZml4KGFkZHJlc3MpKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3duZXJzLFxuICAgICAgc2FsdCxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBBQkktZW5jb2RlZCB0cmFuc2ZlciBkYXRhIGFuZCByZXR1cm4gcGFyc2VkIGZpZWxkc1xuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29kZVxuICogQHJldHVybnMgcGFyc2VkIHRyYW5zZmVyIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRyYW5zZmVyRGF0YShkYXRhOiBzdHJpbmcpOiBUcmFuc2ZlckRhdGEge1xuICBpZiAoZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ01ldGhvZElkKSkge1xuICAgIHJldHVybiBkZWNvZGVOYXRpdmVUcmFuc2ZlckRhdGEoZGF0YSk7XG4gIH0gZWxzZSBpZiAoZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ1Rva2VuTWV0aG9kSWQpKSB7XG4gICAgcmV0dXJuIGRlY29kZVRva2VuVHJhbnNmZXJEYXRhKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIERlY29kZSB0aGUgZ2l2ZW4gQUJJLWVuY29kZWQgdHJhbnNmZXIgZGF0YSBmb3IgdGhlIHNlbmRNdWx0aXNpZ1Rva2VuIGZ1bmN0aW9uIGFuZCByZXR1cm4gcGFyc2VkIGZpZWxkc1xuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29kZVxuICogQHJldHVybnMgcGFyc2VkIHRva2VuIHRyYW5zZmVyIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRva2VuVHJhbnNmZXJEYXRhKGRhdGE6IHN0cmluZyk6IFRva2VuVHJhbnNmZXJEYXRhIHtcbiAgaWYgKCFkYXRhLnN0YXJ0c1dpdGgoc2VuZE11bHRpc2lnVG9rZW5NZXRob2RJZCkpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICBjb25zdCBbdG8sIGFtb3VudCwgdG9rZW5Db250cmFjdEFkZHJlc3MsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHNpZ25hdHVyZV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgIHNlbmRNdWx0aVNpZ1Rva2VuVHlwZXMsXG4gICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShzZW5kTXVsdGlzaWdUb2tlbk1ldGhvZElkLCBkYXRhKVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgdG86IGFkZEhleFByZWZpeCh0byBhcyBzdHJpbmcpLFxuICAgIGFtb3VudDogbmV3IEJpZ051bWJlcihidWZmZXJUb0hleChhbW91bnQgYXMgQnVmZmVyKSkudG9GaXhlZCgpLFxuICAgIGV4cGlyZVRpbWU6IGJ1ZmZlclRvSW50KGV4cGlyZVRpbWUgYXMgQnVmZmVyKSxcbiAgICBzZXF1ZW5jZUlkOiBidWZmZXJUb0ludChzZXF1ZW5jZUlkIGFzIEJ1ZmZlciksXG4gICAgc2lnbmF0dXJlOiBidWZmZXJUb0hleChzaWduYXR1cmUgYXMgQnVmZmVyKSxcbiAgICB0b2tlbkNvbnRyYWN0QWRkcmVzczogYWRkSGV4UHJlZml4KHRva2VuQ29udHJhY3RBZGRyZXNzIGFzIHN0cmluZyksXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVFUkM3MjFUcmFuc2ZlckRhdGEoZGF0YTogc3RyaW5nKTogRVJDNzIxVHJhbnNmZXJEYXRhIHtcbiAgaWYgKCFkYXRhLnN0YXJ0c1dpdGgoc2VuZE11bHRpc2lnTWV0aG9kSWQpKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCB0cmFuc2ZlciBieXRlY29kZTogJHtkYXRhfWApO1xuICB9XG5cbiAgY29uc3QgW3RvLCBhbW91bnQsIGludGVybmFsRGF0YSwgZXhwaXJlVGltZSwgc2VxdWVuY2VJZCwgc2lnbmF0dXJlXSA9IGdldFJhd0RlY29kZWQoXG4gICAgc2VuZE11bHRpU2lnVHlwZXMsXG4gICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShzZW5kTXVsdGlzaWdNZXRob2RJZCwgZGF0YSlcbiAgKTtcblxuICBjb25zdCBpbnRlcm5hbERhdGFIZXggPSBidWZmZXJUb0hleChpbnRlcm5hbERhdGEgYXMgQnVmZmVyKTtcbiAgaWYgKCFpbnRlcm5hbERhdGFIZXguc3RhcnRzV2l0aChFUkM3MjFTYWZlVHJhbnNmZXJUeXBlTWV0aG9kSWQpKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCB0cmFuc2ZlciBieXRlY29kZTogJHtkYXRhfWApO1xuICB9XG5cbiAgY29uc3QgW2Zyb20sIHJlY2VpdmVyLCB0b2tlbklkLCB1c2VyU2VudERhdGFdID0gZ2V0UmF3RGVjb2RlZChcbiAgICBFUkM3MjFTYWZlVHJhbnNmZXJUeXBlcyxcbiAgICBnZXRCdWZmZXJlZEJ5dGVDb2RlKEVSQzcyMVNhZmVUcmFuc2ZlclR5cGVNZXRob2RJZCwgaW50ZXJuYWxEYXRhSGV4KVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgdG86IGFkZEhleFByZWZpeChyZWNlaXZlciBhcyBzdHJpbmcpLFxuICAgIGZyb206IGFkZEhleFByZWZpeChmcm9tIGFzIHN0cmluZyksXG4gICAgZXhwaXJlVGltZTogYnVmZmVyVG9JbnQoZXhwaXJlVGltZSBhcyBCdWZmZXIpLFxuICAgIGFtb3VudDogbmV3IEJpZ051bWJlcihidWZmZXJUb0hleChhbW91bnQgYXMgQnVmZmVyKSkudG9GaXhlZCgpLFxuICAgIHRva2VuSWQ6IG5ldyBCaWdOdW1iZXIoYnVmZmVyVG9IZXgodG9rZW5JZCBhcyBCdWZmZXIpKS50b0ZpeGVkKCksXG4gICAgc2VxdWVuY2VJZDogYnVmZmVyVG9JbnQoc2VxdWVuY2VJZCBhcyBCdWZmZXIpLFxuICAgIHNpZ25hdHVyZTogYnVmZmVyVG9IZXgoc2lnbmF0dXJlIGFzIEJ1ZmZlciksXG4gICAgdG9rZW5Db250cmFjdEFkZHJlc3M6IGFkZEhleFByZWZpeCh0byBhcyBzdHJpbmcpLFxuICAgIHVzZXJEYXRhOiBidWZmZXJUb0hleCh1c2VyU2VudERhdGEgYXMgQnVmZmVyKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUVSQzExNTVUcmFuc2ZlckRhdGEoZGF0YTogc3RyaW5nKTogRVJDMTE1NVRyYW5zZmVyRGF0YSB7XG4gIGxldCBmcm9tLCByZWNlaXZlciwgdXNlclNlbnREYXRhO1xuICBsZXQgdG9rZW5JZHM6IHN0cmluZ1tdO1xuICBsZXQgdmFsdWVzOiBzdHJpbmdbXTtcblxuICBpZiAoIWRhdGEuc3RhcnRzV2l0aChzZW5kTXVsdGlzaWdNZXRob2RJZCkpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICBjb25zdCBbdG8sIGFtb3VudCwgaW50ZXJuYWxEYXRhLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCBzaWduYXR1cmVdID0gZ2V0UmF3RGVjb2RlZChcbiAgICBzZW5kTXVsdGlTaWdUeXBlcyxcbiAgICBnZXRCdWZmZXJlZEJ5dGVDb2RlKHNlbmRNdWx0aXNpZ01ldGhvZElkLCBkYXRhKVxuICApO1xuXG4gIGNvbnN0IGludGVybmFsRGF0YUhleCA9IGJ1ZmZlclRvSGV4KGludGVybmFsRGF0YSBhcyBCdWZmZXIpO1xuICBpZiAoaW50ZXJuYWxEYXRhSGV4LnN0YXJ0c1dpdGgoRVJDMTE1NVNhZmVUcmFuc2ZlclR5cGVNZXRob2RJZCkpIHtcbiAgICBsZXQgdG9rZW5JZDtcbiAgICBsZXQgdmFsdWU7XG5cbiAgICBbZnJvbSwgcmVjZWl2ZXIsIHRva2VuSWQsIHZhbHVlLCB1c2VyU2VudERhdGFdID0gZ2V0UmF3RGVjb2RlZChcbiAgICAgIEVSQzExNTVTYWZlVHJhbnNmZXJUeXBlcyxcbiAgICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoRVJDMTE1NVNhZmVUcmFuc2ZlclR5cGVNZXRob2RJZCwgaW50ZXJuYWxEYXRhSGV4KVxuICAgICk7XG5cbiAgICB0b2tlbklkcyA9IFtuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KHRva2VuSWQpKS50b0ZpeGVkKCldO1xuICAgIHZhbHVlcyA9IFtuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KHZhbHVlKSkudG9GaXhlZCgpXTtcbiAgfSBlbHNlIGlmIChidWZmZXJUb0hleChpbnRlcm5hbERhdGEgYXMgQnVmZmVyKS5zdGFydHNXaXRoKEVSQzExNTVCYXRjaFRyYW5zZmVyVHlwZU1ldGhvZElkKSkge1xuICAgIGxldCB0ZW1wVG9rZW5JZHMsIHRlbXBWYWx1ZXM7XG4gICAgW2Zyb20sIHJlY2VpdmVyLCB0ZW1wVG9rZW5JZHMsIHRlbXBWYWx1ZXMsIHVzZXJTZW50RGF0YV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgICAgRVJDMTE1NUJhdGNoVHJhbnNmZXJUeXBlcyxcbiAgICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoRVJDMTE1NUJhdGNoVHJhbnNmZXJUeXBlTWV0aG9kSWQsIGludGVybmFsRGF0YUhleClcbiAgICApO1xuICAgIHRva2VuSWRzID0gdGVtcFRva2VuSWRzLm1hcCgoeCkgPT4gbmV3IEJpZ051bWJlcihidWZmZXJUb0hleCh4KSkudG9GaXhlZCgpKTtcbiAgICB2YWx1ZXMgPSB0ZW1wVmFsdWVzLm1hcCgoeCkgPT4gbmV3IEJpZ051bWJlcihidWZmZXJUb0hleCh4KSkudG9GaXhlZCgpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvOiBhZGRIZXhQcmVmaXgocmVjZWl2ZXIpLFxuICAgIGZyb206IGFkZEhleFByZWZpeChmcm9tKSxcbiAgICBleHBpcmVUaW1lOiBidWZmZXJUb0ludChleHBpcmVUaW1lIGFzIEJ1ZmZlciksXG4gICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KGFtb3VudCBhcyBCdWZmZXIpKS50b0ZpeGVkKCksXG4gICAgdG9rZW5JZHMsXG4gICAgdmFsdWVzLFxuICAgIHNlcXVlbmNlSWQ6IGJ1ZmZlclRvSW50KHNlcXVlbmNlSWQgYXMgQnVmZmVyKSxcbiAgICBzaWduYXR1cmU6IGJ1ZmZlclRvSGV4KHNpZ25hdHVyZSBhcyBCdWZmZXIpLFxuICAgIHRva2VuQ29udHJhY3RBZGRyZXNzOiBhZGRIZXhQcmVmaXgodG8gYXMgc3RyaW5nKSxcbiAgICB1c2VyRGF0YTogdXNlclNlbnREYXRhLFxuICB9O1xufVxuXG4vKipcbiAqIERlY29kZSB0aGUgZ2l2ZW4gQUJJLWVuY29kZWQgdHJhbnNmZXIgZGF0YSBmb3IgdGhlIHNlbmRNdWx0aXNpZyBmdW5jdGlvbiBhbmQgcmV0dXJuIHBhcnNlZCBmaWVsZHNcbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHBhcnNlZCB0cmFuc2ZlciBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVOYXRpdmVUcmFuc2ZlckRhdGEoZGF0YTogc3RyaW5nKTogTmF0aXZlVHJhbnNmZXJEYXRhIHtcbiAgaWYgKCFkYXRhLnN0YXJ0c1dpdGgoc2VuZE11bHRpc2lnTWV0aG9kSWQpKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCB0cmFuc2ZlciBieXRlY29kZTogJHtkYXRhfWApO1xuICB9XG5cbiAgY29uc3QgW3RvLCBhbW91bnQsIGludGVybmFsRGF0YSwgZXhwaXJlVGltZSwgc2VxdWVuY2VJZCwgc2lnbmF0dXJlXSA9IGdldFJhd0RlY29kZWQoXG4gICAgc2VuZE11bHRpU2lnVHlwZXMsXG4gICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShzZW5kTXVsdGlzaWdNZXRob2RJZCwgZGF0YSlcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHRvOiBhZGRIZXhQcmVmaXgodG8gYXMgc3RyaW5nKSxcbiAgICBhbW91bnQ6IG5ldyBCaWdOdW1iZXIoYnVmZmVyVG9IZXgoYW1vdW50IGFzIEJ1ZmZlcikpLnRvRml4ZWQoKSxcbiAgICBleHBpcmVUaW1lOiBidWZmZXJUb0ludChleHBpcmVUaW1lIGFzIEJ1ZmZlciksXG4gICAgc2VxdWVuY2VJZDogYnVmZmVyVG9JbnQoc2VxdWVuY2VJZCBhcyBCdWZmZXIpLFxuICAgIHNpZ25hdHVyZTogYnVmZmVyVG9IZXgoc2lnbmF0dXJlIGFzIEJ1ZmZlciksXG4gICAgZGF0YTogYnVmZmVyVG9IZXgoaW50ZXJuYWxEYXRhIGFzIEJ1ZmZlciksXG4gIH07XG59XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBBQkktZW5jb2RlZCBmbHVzaCB0b2tlbnMgZGF0YSBhbmQgcmV0dXJuIHBhcnNlZCBmaWVsZHNcbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvZGVcbiAqIEBwYXJhbSB0byBPcHRpb25hbCB0byBwYXJhbWV0ZXIgb2YgdHhcbiAqIEByZXR1cm5zIHBhcnNlZCB0cmFuc2ZlciBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVGbHVzaFRva2Vuc0RhdGEoZGF0YTogc3RyaW5nLCB0bz86IHN0cmluZyk6IEZsdXNoVG9rZW5zRGF0YSB7XG4gIGlmIChkYXRhLnN0YXJ0c1dpdGgoZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZCkpIHtcbiAgICBjb25zdCBbZm9yd2FyZGVyQWRkcmVzcywgdG9rZW5BZGRyZXNzXSA9IGdldFJhd0RlY29kZWQoXG4gICAgICBmbHVzaFRva2Vuc1R5cGVzLFxuICAgICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkLCBkYXRhKVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcndhcmRlckFkZHJlc3M6IGFkZEhleFByZWZpeChmb3J3YXJkZXJBZGRyZXNzIGFzIHN0cmluZyksXG4gICAgICB0b2tlbkFkZHJlc3M6IGFkZEhleFByZWZpeCh0b2tlbkFkZHJlc3MgYXMgc3RyaW5nKSxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRhdGEuc3RhcnRzV2l0aChmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkVjQpKSB7XG4gICAgY29uc3QgW3Rva2VuQWRkcmVzc10gPSBnZXRSYXdEZWNvZGVkKGZsdXNoVG9rZW5zVHlwZXN2NCwgZ2V0QnVmZmVyZWRCeXRlQ29kZShmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkVjQsIGRhdGEpKTtcbiAgICBpZiAoIXRvKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBNaXNzaW5nIHRvIGFkZHJlc3M6ICR7dG99YCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmb3J3YXJkZXJBZGRyZXNzOiB0byxcbiAgICAgIHRva2VuQWRkcmVzczogYWRkSGV4UHJlZml4KHRva2VuQWRkcmVzcyBhcyBzdHJpbmcpLFxuICAgICAgZm9yd2FyZGVyVmVyc2lvbjogNCxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzaWZ5IHRoZSBnaXZlbiB0cmFuc2FjdGlvbiBkYXRhIGJhc2VkIGFzIGEgdHJhbnNhY3Rpb24gdHlwZS5cbiAqIEVUSCB0cmFuc2FjdGlvbnMgYXJlIGRlZmluZWQgYnkgdGhlIGZpcnN0IDggYnl0ZXMgb2YgdGhlIHRyYW5zYWN0aW9uIGRhdGEsIGFsc28ga25vd24gYXMgdGhlIG1ldGhvZCBpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGNsYXNzaWZ5IHRoZSB0cmFuc2FjdGlvbiB3aXRoXG4gKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25UeXBlfSBUaGUgY2xhc3NpZmllZCB0cmFuc2FjdGlvbiB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc2lmeVRyYW5zYWN0aW9uKGRhdGE6IHN0cmluZyk6IFRyYW5zYWN0aW9uVHlwZSB7XG4gIGlmIChkYXRhLmxlbmd0aCA8IDEwKSB7XG4gICAgLy8gY29udHJhY3QgY2FsbHMgbXVzdCBoYXZlIGF0IGxlYXN0IDQgYnl0ZXMgKG1ldGhvZCBpZCkgYW5kICcweCdcbiAgICAvLyBpZiBpdCBkb2Vzbid0IGhhdmUgZW5vdWdoIGRhdGEgdG8gYmUgYSBjb250cmFjdCBjYWxsIGl0IG11c3QgYmUgYSBzaW5nbGUgc2lnIHNlbmRcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlNpbmdsZVNpZ1NlbmQ7XG4gIH1cblxuICAvLyBUT0RPKFNUTFgtMTk3MCk6IHZhbGlkYXRlIGlmIHdlIGFyZSBnb2luZyB0byBjb25zdHJhaW50IHRvIHNvbWUgbWV0aG9kcyBhbGxvd2VkXG4gIGxldCB0cmFuc2FjdGlvblR5cGUgPSB0cmFuc2FjdGlvblR5cGVzTWFwW2RhdGEuc2xpY2UoMCwgMTApLnRvTG93ZXJDYXNlKCldO1xuICBpZiAodHJhbnNhY3Rpb25UeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0cmFuc2FjdGlvblR5cGUgPSBUcmFuc2FjdGlvblR5cGUuQ29udHJhY3RDYWxsO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zYWN0aW9uVHlwZTtcbn1cblxuLyoqXG4gKiBBIHRyYW5zYWN0aW9uIHR5cGVzIG1hcCBhY2NvcmRpbmcgdG8gdGhlIHN0YXJ0aW5nIHBhcnQgb2YgdGhlIGVuY29kZWQgZGF0YVxuICovXG5jb25zdCB0cmFuc2FjdGlvblR5cGVzTWFwID0ge1xuICBbd2FsbGV0SW5pdGlhbGl6YXRpb25GaXJzdEJ5dGVzXTogVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uLFxuICBbcmVjb3ZlcnlXYWxsZXRJbml0aWFsaXphdGlvbkZpcnN0Qnl0ZXNdOiBUcmFuc2FjdGlvblR5cGUuUmVjb3ZlcnlXYWxsZXREZXBsb3ltZW50LFxuICBbdjFDcmVhdGVXYWxsZXRNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbixcbiAgW2NyZWF0ZUZvcndhcmRlck1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLkFkZHJlc3NJbml0aWFsaXphdGlvbixcbiAgW3YxQ3JlYXRlRm9yd2FyZGVyTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuQWRkcmVzc0luaXRpYWxpemF0aW9uLFxuICBbdjRDcmVhdGVGb3J3YXJkZXJNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5BZGRyZXNzSW5pdGlhbGl6YXRpb24sXG4gIFtzZW5kTXVsdGlzaWdNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TZW5kLFxuICBbZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5GbHVzaFRva2VucyxcbiAgW2ZsdXNoRm9yd2FyZGVyVG9rZW5zTWV0aG9kSWRWNF06IFRyYW5zYWN0aW9uVHlwZS5GbHVzaFRva2VucyxcbiAgW2ZsdXNoQ29pbnNNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5GbHVzaENvaW5zLFxuICBbc2VuZE11bHRpc2lnVG9rZW5NZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TZW5kLFxuICBbTG9ja01ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdMb2NrLFxuICBbVm90ZU1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdWb3RlLFxuICBbQWN0aXZhdGVNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nQWN0aXZhdGUsXG4gIFtVbnZvdGVNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nVW52b3RlLFxuICBbVW5sb2NrTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1VubG9jayxcbiAgW1dpdGhkcmF3TWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1dpdGhkcmF3LFxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBudW1iZXIgdG8gYmUgY29udmVydGVkIHRvIGhleFxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGhleCBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4U3RyaW5nKG51bTogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggJSAyID09PSAwID8gJzB4JyArIGhleCA6ICcweDAnICsgaGV4O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4IFRoZSBoZXggc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxuICogQHJldHVybnMge251bWJlcn0gdGhlIHJlc3VsdGluZyBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFN0cmluZ1RvTnVtYmVyKGhleDogc3RyaW5nKTogbnVtYmVyIHtcbiAgcmV0dXJuIHBhcnNlSW50KGhleC5zbGljZSgyKSwgMTYpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIHRoZSBmb3J3YXJkZXIgYWRkcmVzcyB0byBiZSBkZXBsb3llZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgdGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRyYWN0Q291bnRlciB0aGUgbm9uY2Ugb2YgdGhlIGNvbnRyYWN0IGFkZHJlc3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjYWxjdWxhdGVkIGZvcndhcmRlciBjb250cmFjdCBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVGb3J3YXJkZXJBZGRyZXNzKGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLCBjb250cmFjdENvdW50ZXI6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGZvcndhcmRlckFkZHJlc3MgPSBnZW5lcmF0ZUFkZHJlc3MoXG4gICAgQnVmZmVyLmZyb20oc3RyaXBIZXhQcmVmaXgoY29udHJhY3RBZGRyZXNzKSwgJ2hleCcpLFxuICAgIEJ1ZmZlci5mcm9tKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChudW1iZXJUb0hleFN0cmluZyhjb250cmFjdENvdW50ZXIpKSksICdoZXgnKVxuICApO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGZvcndhcmRlckFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGZvcndhcmRlciB2MSBhZGRyZXNzIHRoYXQgd2lsbCBiZSBnZW5lcmF0ZWQgaWYgYGNyZWF0b3JBZGRyZXNzYCBjcmVhdGVzIGl0IHdpdGggc2FsdCBgc2FsdGBcbiAqIGFuZCBpbml0Y29kZSBgaW5pY29kZSB1c2luZyB0aGUgY3JlYXRlMiBvcGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjcmVhdG9yQWRkcmVzcyBUaGUgYWRkcmVzcyB0aGF0IGlzIHNlbmRpbmcgdGhlIHR4IHRvIGNyZWF0ZSBhIG5ldyBhZGRyZXNzLCBoZXggc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc2FsdCBUaGUgc2FsdCB0byBjcmVhdGUgdGhlIGFkZHJlc3Mgd2l0aCB1c2luZyBjcmVhdGUyLCBoZXggc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5pdGNvZGUgVGhlIGluaXRjb2RlIHRoYXQgd2lsbCBiZSBkZXBsb3llZCB0byB0aGUgYWRkcmVzcywgaGV4IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY2FsY3VsYXRlZCBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVGb3J3YXJkZXJWMUFkZHJlc3MoY3JlYXRvckFkZHJlc3M6IHN0cmluZywgc2FsdDogc3RyaW5nLCBpbml0Y29kZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZm9yd2FyZGVyVjFBZGRyZXNzID0gZ2VuZXJhdGVBZGRyZXNzMihcbiAgICBCdWZmZXIuZnJvbShzdHJpcEhleFByZWZpeChjcmVhdG9yQWRkcmVzcyksICdoZXgnKSxcbiAgICBCdWZmZXIuZnJvbShzdHJpcEhleFByZWZpeChzYWx0KSwgJ2hleCcpLFxuICAgIEJ1ZmZlci5mcm9tKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChpbml0Y29kZSkpLCAnaGV4JylcbiAgKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChmb3J3YXJkZXJWMUFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBUYWtlIHRoZSBpbXBsZW1lbnRhdGlvbiBhZGRyZXNzIGZvciB0aGUgcHJveHkgY29udHJhY3QsIGFuZCBnZXQgdGhlIGJpbmFyeSBpbml0Y29kZSBmb3IgdGhlIGFzc29jaWF0ZWQgcHJveHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbXBsZW1lbnRhdGlvbkFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIGltcGxlbWVudGF0aW9uIGNvbnRyYWN0IGZvciB0aGUgcHJveHlcbiAqIEByZXR1cm4ge3N0cmluZ30gQmluYXJ5IGhleCBzdHJpbmcgb2YgdGhlIHByb3h5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm94eUluaXRjb2RlKGltcGxlbWVudGF0aW9uQWRkcmVzczogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdGFyZ2V0ID0gc3RyaXBIZXhQcmVmaXgoaW1wbGVtZW50YXRpb25BZGRyZXNzLnRvTG93ZXJDYXNlKCkpLnBhZFN0YXJ0KDQwLCAnMCcpO1xuXG4gIC8vIGJ5dGVjb2RlIG9mIHRoZSBwcm94eSwgZnJvbTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0JpdEdvL2V0aC1tdWx0aXNpZy12NC9ibG9iL2Q1NDZhOTM3ZjkwZjkzZTgzYjM0MjNhNWJmOTMzZDFkNzdjNjc3YzMvY29udHJhY3RzL0Nsb25lRmFjdG9yeS5zb2wjTDQyLUw1NlxuICByZXR1cm4gYDB4M2Q2MDJkODA2MDBhM2QzOTgxZjMzNjNkM2QzNzNkM2QzZDM2M2Q3MyR7dGFyZ2V0fTVhZjQzZDgyODAzZTkwM2Q5MTYwMmI1N2ZkNWJmM2A7XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gc2lnbmF0dXJlIHBhcnRzIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTaWduYXR1cmVQYXJ0c30gc2lnIFRoZSBzaWduYXR1cmUgdG8gY29udmVydCB0byBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZ1NpZyhzaWc6IFNpZ25hdHVyZVBhcnRzKTogc3RyaW5nIHtcbiAgcmV0dXJuIGJ1ZmZlclRvSGV4KFxuICAgIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgc2V0TGVuZ3RoTGVmdChCdWZmZXIuZnJvbShzdHJpcEhleFByZWZpeChzaWcuciksICdoZXgnKSwgMzIpLFxuICAgICAgc2V0TGVuZ3RoTGVmdChCdWZmZXIuZnJvbShzdHJpcEhleFByZWZpeChzaWcucyksICdoZXgnKSwgMzIpLFxuICAgICAgdG9CdWZmZXIoc2lnLnYpLFxuICAgIF0pXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB0eCBkYXRhIGhhcyBhIHNpZ25hdHVyZVxuICpcbiAqIEBwYXJhbSB7VHhEYXRhfSB0eERhdGEgVGhlIHRyYW5zYWN0aW9uIGRhdGEgdG8gY2hlY2sgZm9yIHNpZ25hdHVyZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHR4IGhhcyBhIHNpZ25hdHVyZSwgZWxzZSBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzU2lnbmF0dXJlKHR4RGF0YTogVHhEYXRhKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHhEYXRhLnYgIT09IHVuZGVmaW5lZCAmJlxuICAgIHR4RGF0YS5yICE9PSB1bmRlZmluZWQgJiZcbiAgICB0eERhdGEucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgdHhEYXRhLnYubGVuZ3RoID4gMCAmJlxuICAgIHR4RGF0YS5yLmxlbmd0aCA+IDAgJiZcbiAgICB0eERhdGEucy5sZW5ndGggPiAwXG4gICk7XG59XG5cbnR5cGUgUmVjdXJzaXZlQnVmZmVyT3JTdHJpbmcgPSBzdHJpbmcgfCBCdWZmZXIgfCBCTiB8IFJlY3Vyc2l2ZUJ1ZmZlck9yU3RyaW5nW107XG5cbi8qKlxuICogR2V0IHRoZSByYXcgZGF0YSBkZWNvZGVkIGZvciBzb21lIHR5cGVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gdHlwZXMgQUJJIHR5cGVzIGRlZmluaXRpb25cbiAqIEBwYXJhbSB7QnVmZmVyfSBzZXJpYWxpemVkQXJncyBlbmNvZGVkIGFyZ3NcbiAqIEByZXR1cm5zIHtCdWZmZXJbXX0gdGhlIGRlY29kZWQgcmF3XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYXdEZWNvZGVkKHR5cGVzOiBzdHJpbmdbXSwgc2VyaWFsaXplZEFyZ3M6IEJ1ZmZlcik6IFJlY3Vyc2l2ZUJ1ZmZlck9yU3RyaW5nW10ge1xuICBmdW5jdGlvbiBub3JtYWxpemUodjogdW5rbm93biwgaTogbnVtYmVyKTogdW5rbm93biB7XG4gICAgaWYgKEJOLmlzQk4odikpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICByZXR1cm4gdi5tYXAobm9ybWFsaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3IgJHt0eXBlc31bJHtpfV0gZ290ICR7dHlwZW9mIHZ9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEV0aGVyZXVtQWJpLnJhd0RlY29kZSh0eXBlcywgc2VyaWFsaXplZEFyZ3MpLm1hcChub3JtYWxpemUpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYnVmZmVyZWQgYnl0ZWNvZGUgZnJvbSByYXdEYXRhIHVzaW5nIGEgbWV0aG9kSWQgYXMgZGVsaW1pdGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZElkIHRoZSBoZXggZW5jb2RlZCBtZXRob2QgSWRcbiAqIEBwYXJhbSB7c3RyaW5nfSByYXdEYXRhIHRoZSBoZXggZW5jb2RlZCByYXcgZGF0YVxuICogQHJldHVybnMge0J1ZmZlcn0gZGF0YSBidWZmZXJlZCBieXRlY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnVmZmVyZWRCeXRlQ29kZShtZXRob2RJZDogc3RyaW5nLCByYXdEYXRhOiBzdHJpbmcpOiBCdWZmZXIge1xuICBjb25zdCBzcGxpdEJ5dGVjb2RlID0gcmF3RGF0YS5zcGxpdChtZXRob2RJZCk7XG4gIGlmIChzcGxpdEJ5dGVjb2RlLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgc2VuZCBieXRlY29kZTogJHtyYXdEYXRhfWApO1xuICB9XG4gIGlmIChzcGxpdEJ5dGVjb2RlWzFdLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHNlbmQgYnl0ZWNvZGU6ICR7cmF3RGF0YX0gKHdyb25nIGxlbmdodClgKTtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oc3BsaXRCeXRlY29kZVsxXSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3RhdGljcyBjb2luIG9iamVjdCBtYXRjaGluZyBhIGdpdmVuIGNvbnRyYWN0IGFkZHJlc3MgaWYgaXQgZXhpc3RzXG4gKlxuICogQHBhcmFtIHRva2VuQ29udHJhY3RBZGRyZXNzIFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIG1hdGNoIGFnYWluc3RcbiAqIEBwYXJhbSBuZXR3b3JrIC0gdGhlIGNvaW4gbmV0d29ya1xuICogQHBhcmFtIGZhbWlseSAtIHRoZSBjb2luIGZhbWlseVxuICogQHJldHVybnMgc3RhdGljcyBCYXNlQ29pbiBvYmplY3QgZm9yIHRoZSBtYXRjaGluZyB0b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW4oXG4gIHRva2VuQ29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIG5ldHdvcms6IEJhc2VOZXR3b3JrLFxuICBmYW1pbHk6IHN0cmluZ1xuKTogUmVhZG9ubHk8QmFzZUNvaW4+IHwgdW5kZWZpbmVkIHtcbiAgLy8gZmlsdGVyIHRoZSBjb2lucyBhcnJheSB0byBmaW5kIHRoZSB0b2tlbiB3aXRoIHRoZSBtYXRjaGluZyBjb250cmFjdCBhZGRyZXNzLCBuZXR3b3JrIGFuZCBjb2luIGZhbWlseVxuICAvLyBjb2luIGZhbWlseSBpcyBuZWVkZWQgdG8gYXZvaWQgY2F1c2luZyBpc3N1ZXMgd2hlbiBhIHRva2VuIGhhcyBzYW1lIGNvbnRyYWN0IGFkZHJlc3Mgb24gdHdvIGRpZmZlcmVudCBjaGFpbnNcbiAgY29uc3QgdG9rZW5zID0gY29pbnMuZmlsdGVyKChjb2luKSA9PiB7XG4gICAgaWYgKGNvaW4gaW5zdGFuY2VvZiBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNvaW4ubmV0d29yay50eXBlID09PSBuZXR3b3JrLnR5cGUgJiZcbiAgICAgICAgY29pbi5mYW1pbHkgPT09IGZhbWlseSAmJlxuICAgICAgICBjb2luLmNvbnRyYWN0QWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0b2tlbkNvbnRyYWN0QWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuXG4gIC8vIGlmIGxlbmd0aCBvZiB0b2tlbnMgaXMgMSwgcmV0dXJuIHRoZSBmaXJzdCwgZWxzZSByZXR1cm4gdW5kZWZpbmVkXG4gIC8vIENhbid0IGRpcmVjdGx5IGluZGV4IGludG8gdG9rZW5zLCBvciBjYWxsIGBsZW5ndGhgLCBzbyB3ZSB1c2UgbWFwIHRvIGdldCBhbiBhcnJheVxuICBjb25zdCB0b2tlbnNBcnJheSA9IHRva2Vucy5tYXAoKHRva2VuKSA9PiB0b2tlbik7XG4gIGlmICh0b2tlbnNBcnJheS5sZW5ndGggPj0gMSkge1xuICAgIC8vIHRoZXJlIHNob3VsZCBuZXZlciBiZSB0d28gdG9rZW5zIHdpdGggdGhlIHNhbWUgY29udHJhY3QgYWRkcmVzcywgc28gd2UgYXNzZXJ0IHRoYXQgaGVyZVxuICAgIGFzc2VydCh0b2tlbnNBcnJheS5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0b2tlbnNBcnJheVswXTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNyZWF0ZSB3YWxsZXQgbWV0aG9kIGNhbGxpbmcgZGF0YSBmb3IgdjEgd2FsbGV0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IHdhbGxldE93bmVycyAtIHdhbGxldCBvd25lciBhZGRyZXNzZXMgZm9yIHdhbGxldCBpbml0aWFsaXphdGlvbiB0cmFuc2FjdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzYWx0IC0gVGhlIHNhbHQgZm9yIHdhbGxldCBpbml0aWFsaXphdGlvbiB0cmFuc2FjdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGNyZWF0ZVdhbGxldCBtZXRob2QgZW5jb2RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VjFXYWxsZXRJbml0aWFsaXphdGlvbkRhdGEod2FsbGV0T3duZXJzOiBzdHJpbmdbXSwgc2FsdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc2FsdEJ1ZmZlciA9IHNldExlbmd0aExlZnQodG9CdWZmZXIoc2FsdCksIDMyKTtcbiAgY29uc3QgcGFyYW1zID0gW3dhbGxldE93bmVycywgc2FsdEJ1ZmZlcl07XG4gIGNvbnN0IG1ldGhvZCA9IEV0aGVyZXVtQWJpLm1ldGhvZElEKCdjcmVhdGVXYWxsZXQnLCBjcmVhdGVWMVdhbGxldFR5cGVzKTtcbiAgY29uc3QgYXJncyA9IEV0aGVyZXVtQWJpLnJhd0VuY29kZShjcmVhdGVWMVdhbGxldFR5cGVzLCBwYXJhbXMpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KEJ1ZmZlci5jb25jYXQoW21ldGhvZCwgYXJnc10pLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3JlYXRlIGFkZHJlc3MgbWV0aG9kIGNhbGxpbmcgZGF0YSBmb3IgdjEsIHYyLCB2NCBmb3J3YXJkZXJzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCBjb250cmFjdFxuICogQHBhcmFtIHtzdHJpbmd9IHNhbHQgLSBUaGUgc2FsdCBmb3IgYWRkcmVzcyBpbml0aWFsaXphdGlvbiB0cmFuc2FjdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWVBZGRyZXNzIC0gVGhlIGZlZSBhZGRyZXNzIGZvciB0aGUgZW50ZXJwcmlzZVxuICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgY3JlYXRlRm9yd2FyZGVyIG1ldGhvZCBlbmNvZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWMUFkZHJlc3NJbml0aWFsaXphdGlvbkRhdGEoYmFzZUFkZHJlc3M6IHN0cmluZywgc2FsdDogc3RyaW5nLCBmZWVBZGRyZXNzPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc2FsdEJ1ZmZlciA9IHNldExlbmd0aExlZnQodG9CdWZmZXIoc2FsdCksIDMyKTtcbiAgY29uc3QgeyBjcmVhdGVGb3J3YXJkZXJQYXJhbXMsIGNyZWF0ZUZvcndhcmRlclR5cGVzIH0gPSBnZXRDcmVhdGVGb3J3YXJkZXJQYXJhbXNBbmRUeXBlcyhcbiAgICBiYXNlQWRkcmVzcyxcbiAgICBzYWx0QnVmZmVyLFxuICAgIGZlZUFkZHJlc3NcbiAgKTtcblxuICBjb25zdCBtZXRob2QgPSBFdGhlcmV1bUFiaS5tZXRob2RJRCgnY3JlYXRlRm9yd2FyZGVyJywgY3JlYXRlRm9yd2FyZGVyVHlwZXMpO1xuICBjb25zdCBhcmdzID0gRXRoZXJldW1BYmkucmF3RW5jb2RlKGNyZWF0ZUZvcndhcmRlclR5cGVzLCBjcmVhdGVGb3J3YXJkZXJQYXJhbXMpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KEJ1ZmZlci5jb25jYXQoW21ldGhvZCwgYXJnc10pLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3JlYXRlIGFkZHJlc3MgbWV0aG9kIGNhbGxpbmcgZGF0YSBmb3IgYWxsIGZvcndhcmRlciB2ZXJzaW9uc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3J3YXJkZXJWZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIGZvcndhcmRlciB0byBjcmVhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlQWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgY29udHJhY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBzYWx0IC0gVGhlIHNhbHQgZm9yIGFkZHJlc3MgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVlQWRkcmVzcyAtIFRoZSBmZWUgYWRkcmVzcyBmb3IgdGhlIGVudGVycHJpc2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGNyZWF0ZUZvcndhcmRlciBtZXRob2QgZW5jb2RlZFxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3NJbml0RGF0YUFsbEZvcndhcmRlclZlcnNpb25zKFxuICBmb3J3YXJkZXJWZXJzaW9uOiBudW1iZXIsXG4gIGJhc2VBZGRyZXNzOiBzdHJpbmcsXG4gIHNhbHQ6IHN0cmluZyxcbiAgZmVlQWRkcmVzcz86IHN0cmluZ1xuKTogc3RyaW5nIHtcbiAgaWYgKGZvcndhcmRlclZlcnNpb24gPT09IGRlZmF1bHRGb3J3YXJkZXJWZXJzaW9uKSB7XG4gICAgcmV0dXJuIGdldEFkZHJlc3NJbml0aWFsaXphdGlvbkRhdGEoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0VjFBZGRyZXNzSW5pdGlhbGl6YXRpb25EYXRhKGJhc2VBZGRyZXNzLCBzYWx0LCBmZWVBZGRyZXNzKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNyZWF0ZUZvcndhcmRlclR5cGVzIGFuZCBjcmVhdGVGb3J3YXJkZXJQYXJhbXMgZm9yIGFsbCBmb3J3YXJkZXIgdmVyc2lvbnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZUFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0IGNvbnRyYWN0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2FsdEJ1ZmZlciAtIFRoZSBzYWx0IGZvciBhZGRyZXNzIGluaXRpYWxpemF0aW9uIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVlQWRkcmVzcyAtIFRoZSBmZWUgYWRkcmVzcyBmb3IgdGhlIGVudGVycHJpc2VcbiAqIEByZXR1cm5zIHtjcmVhdGVGb3J3YXJkZXJQYXJhbXM6IChzdHJpbmcgfCBCdWZmZXIpW10sIGNyZWF0ZUZvcndhcmRlclR5cGVzOiBzdHJpbmdbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZUZvcndhcmRlclBhcmFtc0FuZFR5cGVzKFxuICBiYXNlQWRkcmVzczogc3RyaW5nLFxuICBzYWx0QnVmZmVyOiBCdWZmZXIsXG4gIGZlZUFkZHJlc3M/OiBzdHJpbmdcbik6IHsgY3JlYXRlRm9yd2FyZGVyUGFyYW1zOiAoc3RyaW5nIHwgQnVmZmVyKVtdOyBjcmVhdGVGb3J3YXJkZXJUeXBlczogc3RyaW5nW10gfSB7XG4gIGxldCBjcmVhdGVGb3J3YXJkZXJQYXJhbXMgPSBbYmFzZUFkZHJlc3MsIHNhbHRCdWZmZXJdO1xuICBsZXQgY3JlYXRlRm9yd2FyZGVyVHlwZXMgPSBjcmVhdGVWMUZvcndhcmRlclR5cGVzO1xuICBpZiAoZmVlQWRkcmVzcykge1xuICAgIGNyZWF0ZUZvcndhcmRlclBhcmFtcyA9IFtiYXNlQWRkcmVzcywgZmVlQWRkcmVzcywgc2FsdEJ1ZmZlcl07XG4gICAgY3JlYXRlRm9yd2FyZGVyVHlwZXMgPSBjcmVhdGVWNEZvcndhcmRlclR5cGVzO1xuICB9XG4gIHJldHVybiB7IGNyZWF0ZUZvcndhcmRlclBhcmFtcywgY3JlYXRlRm9yd2FyZGVyVHlwZXMgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIEFCSS1lbmNvZGVkIGNyZWF0ZSBmb3J3YXJkZXIgZGF0YSBhbmQgcmV0dXJuIHBhcnNlZCBmaWVsZHNcbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHBhcnNlZCB0cmFuc2ZlciBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVGb3J3YXJkZXJDcmVhdGlvbkRhdGEoZGF0YTogc3RyaW5nKTogRm9yd2FyZGVySW5pdGlhbGl6YXRpb25EYXRhIHtcbiAgaWYgKFxuICAgICEoXG4gICAgICBkYXRhLnN0YXJ0c1dpdGgodjRDcmVhdGVGb3J3YXJkZXJNZXRob2RJZCkgfHxcbiAgICAgIGRhdGEuc3RhcnRzV2l0aCh2MUNyZWF0ZUZvcndhcmRlck1ldGhvZElkKSB8fFxuICAgICAgZGF0YS5zdGFydHNXaXRoKGNyZWF0ZUZvcndhcmRlck1ldGhvZElkKVxuICAgIClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBhZGRyZXNzIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICBpZiAoZGF0YS5zdGFydHNXaXRoKGNyZWF0ZUZvcndhcmRlck1ldGhvZElkKSkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlQWRkcmVzczogdW5kZWZpbmVkLFxuICAgICAgYWRkcmVzc0NyZWF0aW9uU2FsdDogdW5kZWZpbmVkLFxuICAgICAgZmVlQWRkcmVzczogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZGF0YS5zdGFydHNXaXRoKHYxQ3JlYXRlRm9yd2FyZGVyTWV0aG9kSWQpKSB7XG4gICAgY29uc3QgW2Jhc2VBZGRyZXNzLCBzYWx0QnVmZmVyXSA9IGdldFJhd0RlY29kZWQoXG4gICAgICBjcmVhdGVWMUZvcndhcmRlclR5cGVzLFxuICAgICAgZ2V0QnVmZmVyZWRCeXRlQ29kZSh2MUNyZWF0ZUZvcndhcmRlck1ldGhvZElkLCBkYXRhKVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUFkZHJlc3M6IGFkZEhleFByZWZpeChiYXNlQWRkcmVzcyBhcyBzdHJpbmcpLFxuICAgICAgYWRkcmVzc0NyZWF0aW9uU2FsdDogYnVmZmVyVG9IZXgoc2FsdEJ1ZmZlciBhcyBCdWZmZXIpLFxuICAgICAgZmVlQWRkcmVzczogdW5kZWZpbmVkLFxuICAgIH0gYXMgY29uc3Q7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW2Jhc2VBZGRyZXNzLCBmZWVBZGRyZXNzLCBzYWx0QnVmZmVyXSA9IGdldFJhd0RlY29kZWQoXG4gICAgICBjcmVhdGVWNEZvcndhcmRlclR5cGVzLFxuICAgICAgZ2V0QnVmZmVyZWRCeXRlQ29kZSh2NENyZWF0ZUZvcndhcmRlck1ldGhvZElkLCBkYXRhKVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUFkZHJlc3M6IGFkZEhleFByZWZpeChiYXNlQWRkcmVzcyBhcyBzdHJpbmcpLFxuICAgICAgYWRkcmVzc0NyZWF0aW9uU2FsdDogYnVmZmVyVG9IZXgoc2FsdEJ1ZmZlciBhcyBCdWZmZXIpLFxuICAgICAgZmVlQWRkcmVzczogYWRkSGV4UHJlZml4KGZlZUFkZHJlc3MgYXMgc3RyaW5nKSxcbiAgICB9IGFzIGNvbnN0O1xuICB9XG59XG5cbi8qKlxuICogTWFrZSBhIHF1ZXJ5IHRvIGV4cGxvcmVyIGZvciBpbmZvcm1hdGlvbiBzdWNoIGFzIGJhbGFuY2UsIHRva2VuIGJhbGFuY2UsIHNvbGlkaXR5IGNhbGxzXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnkga2V5LXZhbHVlIHBhaXJzIG9mIHBhcmFtZXRlcnMgdG8gYXBwZW5kIGFmdGVyIC9hcGlcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiB0aGUgQVBJIHRva2VuIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBsb3JlclVybCB0aGUgVVJMIG9mIHRoZSBleHBsb3JlclxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gcmVzcG9uc2UgZnJvbSBleHBsb3JlclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeShcbiAgcXVlcnk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gIGV4cGxvcmVyVXJsOiBzdHJpbmcsXG4gIHRva2VuPzogc3RyaW5nXG4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gIGlmICh0b2tlbikge1xuICAgIHF1ZXJ5LmFwaWtleSA9IHRva2VuO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5nZXQoYCR7ZXhwbG9yZXJVcmx9L2FwaWApLnF1ZXJ5KHF1ZXJ5KTtcblxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhY2ggZXhwbG9yZXInKTtcbiAgfVxuXG4gIGlmIChyZXNwb25zZS5ib2R5LnN0YXR1cyA9PT0gJzAnICYmIHJlc3BvbnNlLmJvZHkubWVzc2FnZSA9PT0gJ05PVE9LJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwbG9yZXIgcmF0ZSBsaW1pdCByZWFjaGVkJyk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG59XG5cbi8qKlxuICogRGVmYXVsdCBleHBpcmUgdGltZSBmb3IgYSBjb250cmFjdCBjYWxsICgxIHdlZWspXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaW1lIGluIHNlY29uZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRFeHBpcmVUaW1lKCk6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyA2MCAqIDYwICogMjQgKiA3O1xufVxuIl19