"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStellarKeys = void 0;
const stellar = __importStar(require("stellar-sdk"));
const lib_1 = require("./lib");
function getStellarKeys(bitgo, params) {
    const keys = [];
    let userKey = params.userKey;
    let backupKey = params.backupKey;
    // Stellar's Ed25519 public keys start with a G, while private keys start with an S
    const isKrsRecovery = backupKey.startsWith('G') && !userKey.startsWith('G');
    const isUnsignedSweep = backupKey.startsWith('G') && userKey.startsWith('G');
    try {
        if (!userKey.startsWith('S') && !userKey.startsWith('G')) {
            userKey = bitgo.decrypt({
                input: userKey,
                password: params.walletPassphrase,
            });
            // After decryption, we could have a root key, so we need to encode it to a Stellar format key
            if (lib_1.Utils.isValidRootPrivateKey(userKey)) {
                userKey = lib_1.Utils.encodePrivateKey(Buffer.from(userKey.slice(0, 64), 'hex'));
            }
            else if (lib_1.Utils.isValidRootPublicKey(userKey)) {
                userKey = lib_1.Utils.encodePublicKey(Buffer.from(userKey, 'hex'));
            }
        }
        const userKeyPair = isUnsignedSweep ? stellar.Keypair.fromPublicKey(userKey) : stellar.Keypair.fromSecret(userKey);
        keys.push(userKeyPair);
    }
    catch (e) {
        throw new Error('Failed to decrypt user key with passcode - try again!');
    }
    try {
        if (!backupKey.startsWith('S') && !isKrsRecovery && !isUnsignedSweep) {
            backupKey = bitgo.decrypt({
                input: backupKey,
                password: params.walletPassphrase,
            });
            // After decryption we could have a root key, so we need to encode it to a Stellar format key
            if (lib_1.Utils.isValidRootPrivateKey(backupKey)) {
                backupKey = lib_1.Utils.encodePrivateKey(Buffer.from(backupKey.slice(0, 64), 'hex'));
            }
            else if (lib_1.Utils.isValidRootPublicKey(backupKey)) {
                backupKey = lib_1.Utils.encodePublicKey(Buffer.from(backupKey, 'hex'));
            }
        }
        if (isKrsRecovery || isUnsignedSweep) {
            keys.push(stellar.Keypair.fromPublicKey(backupKey));
        }
        else {
            keys.push(stellar.Keypair.fromSecret(backupKey));
        }
    }
    catch (e) {
        throw new Error('Failed to decrypt backup key with passcode - try again!');
    }
    return keys;
}
exports.getStellarKeys = getStellarKeys;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0U3RlbGxhcktleXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZ2V0U3RlbGxhcktleXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxxREFBdUM7QUFDdkMsK0JBQThCO0FBRTlCLFNBQWdCLGNBQWMsQ0FBQyxLQUFnQixFQUFFLE1BQStCO0lBQzlFLE1BQU0sSUFBSSxHQUFzQixFQUFFLENBQUM7SUFDbkMsSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUM3QixJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO0lBRWpDLG1GQUFtRjtJQUNuRixNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM1RSxNQUFNLGVBQWUsR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFN0UsSUFBSTtRQUNGLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUN4RCxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztnQkFDdEIsS0FBSyxFQUFFLE9BQU87Z0JBQ2QsUUFBUSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0I7YUFDbEMsQ0FBQyxDQUFDO1lBRUgsOEZBQThGO1lBQzlGLElBQUksV0FBSyxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUN4QyxPQUFPLEdBQUcsV0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUM1RTtpQkFBTSxJQUFJLFdBQUssQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDOUMsT0FBTyxHQUFHLFdBQUssQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUM5RDtTQUNGO1FBRUQsTUFBTSxXQUFXLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbkgsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztLQUN4QjtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO0tBQzFFO0lBRUQsSUFBSTtRQUNGLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3BFLFNBQVMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO2dCQUN4QixLQUFLLEVBQUUsU0FBUztnQkFDaEIsUUFBUSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0I7YUFDbEMsQ0FBQyxDQUFDO1lBRUgsNkZBQTZGO1lBQzdGLElBQUksV0FBSyxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUMxQyxTQUFTLEdBQUcsV0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUNoRjtpQkFBTSxJQUFJLFdBQUssQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDaEQsU0FBUyxHQUFHLFdBQUssQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUNsRTtTQUNGO1FBRUQsSUFBSSxhQUFhLElBQUksZUFBZSxFQUFFO1lBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztTQUNyRDthQUFNO1lBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1NBQ2xEO0tBQ0Y7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMseURBQXlELENBQUMsQ0FBQztLQUM1RTtJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQXZERCx3Q0F1REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCaXRHb0Jhc2UsIEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCAqIGFzIHN0ZWxsYXIgZnJvbSAnc3RlbGxhci1zZGsnO1xuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuL2xpYic7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGVsbGFyS2V5cyhiaXRnbzogQml0R29CYXNlLCBwYXJhbXM6IEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zKTogc3RlbGxhci5LZXlwYWlyW10ge1xuICBjb25zdCBrZXlzOiBzdGVsbGFyLktleXBhaXJbXSA9IFtdO1xuICBsZXQgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5O1xuICBsZXQgYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcblxuICAvLyBTdGVsbGFyJ3MgRWQyNTUxOSBwdWJsaWMga2V5cyBzdGFydCB3aXRoIGEgRywgd2hpbGUgcHJpdmF0ZSBrZXlzIHN0YXJ0IHdpdGggYW4gU1xuICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ0cnKSAmJiAhdXNlcktleS5zdGFydHNXaXRoKCdHJyk7XG4gIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9IGJhY2t1cEtleS5zdGFydHNXaXRoKCdHJykgJiYgdXNlcktleS5zdGFydHNXaXRoKCdHJyk7XG5cbiAgdHJ5IHtcbiAgICBpZiAoIXVzZXJLZXkuc3RhcnRzV2l0aCgnUycpICYmICF1c2VyS2V5LnN0YXJ0c1dpdGgoJ0cnKSkge1xuICAgICAgdXNlcktleSA9IGJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBpbnB1dDogdXNlcktleSxcbiAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFmdGVyIGRlY3J5cHRpb24sIHdlIGNvdWxkIGhhdmUgYSByb290IGtleSwgc28gd2UgbmVlZCB0byBlbmNvZGUgaXQgdG8gYSBTdGVsbGFyIGZvcm1hdCBrZXlcbiAgICAgIGlmIChVdGlscy5pc1ZhbGlkUm9vdFByaXZhdGVLZXkodXNlcktleSkpIHtcbiAgICAgICAgdXNlcktleSA9IFV0aWxzLmVuY29kZVByaXZhdGVLZXkoQnVmZmVyLmZyb20odXNlcktleS5zbGljZSgwLCA2NCksICdoZXgnKSk7XG4gICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzVmFsaWRSb290UHVibGljS2V5KHVzZXJLZXkpKSB7XG4gICAgICAgIHVzZXJLZXkgPSBVdGlscy5lbmNvZGVQdWJsaWNLZXkoQnVmZmVyLmZyb20odXNlcktleSwgJ2hleCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB1c2VyS2V5UGFpciA9IGlzVW5zaWduZWRTd2VlcCA/IHN0ZWxsYXIuS2V5cGFpci5mcm9tUHVibGljS2V5KHVzZXJLZXkpIDogc3RlbGxhci5LZXlwYWlyLmZyb21TZWNyZXQodXNlcktleSk7XG4gICAga2V5cy5wdXNoKHVzZXJLZXlQYWlyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgdXNlciBrZXkgd2l0aCBwYXNzY29kZSAtIHRyeSBhZ2FpbiEnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKCFiYWNrdXBLZXkuc3RhcnRzV2l0aCgnUycpICYmICFpc0tyc1JlY292ZXJ5ICYmICFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIGJhY2t1cEtleSA9IGJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBpbnB1dDogYmFja3VwS2V5LFxuICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gQWZ0ZXIgZGVjcnlwdGlvbiB3ZSBjb3VsZCBoYXZlIGEgcm9vdCBrZXksIHNvIHdlIG5lZWQgdG8gZW5jb2RlIGl0IHRvIGEgU3RlbGxhciBmb3JtYXQga2V5XG4gICAgICBpZiAoVXRpbHMuaXNWYWxpZFJvb3RQcml2YXRlS2V5KGJhY2t1cEtleSkpIHtcbiAgICAgICAgYmFja3VwS2V5ID0gVXRpbHMuZW5jb2RlUHJpdmF0ZUtleShCdWZmZXIuZnJvbShiYWNrdXBLZXkuc2xpY2UoMCwgNjQpLCAnaGV4JykpO1xuICAgICAgfSBlbHNlIGlmIChVdGlscy5pc1ZhbGlkUm9vdFB1YmxpY0tleShiYWNrdXBLZXkpKSB7XG4gICAgICAgIGJhY2t1cEtleSA9IFV0aWxzLmVuY29kZVB1YmxpY0tleShCdWZmZXIuZnJvbShiYWNrdXBLZXksICdoZXgnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkgfHwgaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICBrZXlzLnB1c2goc3RlbGxhci5LZXlwYWlyLmZyb21QdWJsaWNLZXkoYmFja3VwS2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaChzdGVsbGFyLktleXBhaXIuZnJvbVNlY3JldChiYWNrdXBLZXkpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IGJhY2t1cCBrZXkgd2l0aCBwYXNzY29kZSAtIHRyeSBhZ2FpbiEnKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuIl19