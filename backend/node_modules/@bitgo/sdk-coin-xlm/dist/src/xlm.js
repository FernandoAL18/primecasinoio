"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xlm = void 0;
const assert_1 = __importDefault(require("assert"));
const _ = __importStar(require("lodash"));
const querystring = __importStar(require("querystring"));
const url = __importStar(require("url"));
const request = __importStar(require("superagent"));
const stellar = __importStar(require("stellar-sdk"));
const bignumber_js_1 = require("bignumber.js");
const Utils = __importStar(require("./lib/utils"));
const keyPair_1 = require("./lib/keyPair");
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_api_1 = require("@bitgo/sdk-api");
const getStellarKeys_1 = require("./getStellarKeys");
class Xlm extends sdk_core_1.BaseCoin {
    constructor(bitgo) {
        super(bitgo);
        this.homeDomain = 'bitgo.com'; // used for reverse federation lookup
    }
    static createInstance(bitgo) {
        return new Xlm(bitgo);
    }
    getStellarNetwork() {
        return stellar.Networks.PUBLIC;
    }
    /**
     * Factor between the base unit and its smallest subdivison
     */
    getBaseFactor() {
        return 1e7;
    }
    /**
     * Identifier for the blockchain which supports this coin
     */
    getChain() {
        return 'xlm';
    }
    /**
     * Identifier for the coin family
     */
    getFamily() {
        return 'xlm';
    }
    /**
     * Complete human-readable name of this coin
     */
    getFullName() {
        return 'Stellar';
    }
    /**
     * Url at which the stellar federation server can be reached
     */
    getFederationServerUrl() {
        return sdk_core_1.common.Environments[this.bitgo.getEnv()].stellarFederationServerUrl;
    }
    /**
     * Url at which horizon can be reached
     */
    getHorizonUrl() {
        return 'https://horizon.stellar.org';
    }
    /** inheritdoc */
    generateKeyPair(seed) {
        const keyPair = seed ? new keyPair_1.KeyPair({ seed }) : new keyPair_1.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return { pub: keys.pub, prv: keys.prv };
    }
    generateRootKeyPair(seed) {
        const keyPair = seed ? new keyPair_1.KeyPair({ seed }) : new keyPair_1.KeyPair();
        const keys = keyPair.getKeys(true);
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return { prv: keys.prv + keys.pub, pub: keys.pub };
    }
    /**
     * Get encoded ed25519 public key from raw data
     *
     * @param pub Raw public key
     * @returns Encoded public key
     */
    getPubFromRaw(pub) {
        return Utils.encodePublicKey(Buffer.from(pub, 'hex'));
    }
    /**
     * Get encoded ed25519 private key from raw data
     *
     * @param prv Raw private key
     * @returns Encoded private key
     */
    getPrvFromRaw(prv) {
        return Utils.encodePrivateKey(Buffer.from(prv, 'hex'));
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param pub the pub to be checked
     * @returns is it valid?
     */
    isValidPub(pub) {
        // Stellar's validation method only allows keys in Stellar-specific format, with a 'G' prefix
        // We need to allow for both Stellar and raw root keys
        return Utils.isValidRootPublicKey(pub) || Utils.isValidStellarPublicKey(pub);
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        // Stellar's validation method only allows keys in Stellar-specific format, with an 'S' prefix
        // We need to allow for both Stellar and raw root private keys
        return Utils.isValidRootPrivateKey(prv) || Utils.isValidStellarPrivateKey(prv);
    }
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId) {
        let memoIdNumber;
        try {
            stellar.Memo.id(memoId); // throws if the value is not valid memo id
            memoIdNumber = new bignumber_js_1.BigNumber(memoId);
        }
        catch (e) {
            return false;
        }
        return memoIdNumber.gte(0) && memoIdNumber.lt(Xlm.maxMemoId);
    }
    supportsDeriveKeyWithSeed() {
        return false;
    }
    /**
     * Evaluates whether a memo is valid
     *
     * @param value value of the memo
     * @param type type of the memo
     * @returns true if value and type are a valid
     */
    isValidMemo({ value, type }) {
        if (!value || !type) {
            return false;
        }
        try {
            // throws if the value is not valid for the type
            // valid types are: 'id', 'text', 'hash', 'return'
            // See https://www.stellar.org/developers/guides/concepts/transactions.html#memo
            stellar.Memo[type](value);
        }
        catch (e) {
            return false;
        }
        return true;
    }
    /**
     * Create instance of stellar.MuxedAccount from M address
     * See: https://developers.stellar.org/docs/glossary/muxed-accounts
     */
    getMuxedAccount(address) {
        try {
            return stellar.MuxedAccount.fromAddress(address, '0');
        }
        catch (e) {
            throw new Error(`invalid muxed address: ${address}`);
        }
    }
    /**
     * Return boolean indicating whether a muxed address is valid
     * See: https://developers.stellar.org/docs/glossary/muxed-accounts
     *
     * @param address
     * @returns {boolean}
     */
    isValidMuxedAddress(address) {
        if (!_.isString(address) || !address.startsWith('M')) {
            return false;
        }
        try {
            // return true if muxed account is valid or throw
            return !!stellar.MuxedAccount.fromAddress(address, '0');
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Minimum balance of a 2-of-3 multisig wallet
     * @returns minimum balance in stroops
     */
    async getMinimumReserve() {
        const server = new stellar.Server(this.getHorizonUrl());
        const horizonLedgerInfo = await server.ledgers().order('desc').limit(1).call();
        if (!horizonLedgerInfo) {
            throw new Error('unable to connect to Horizon for reserve requirement data');
        }
        const baseReserve = horizonLedgerInfo.records[0].base_reserve_in_stroops;
        // 2-of-3 wallets have a minimum reserve of 5x the base reserve
        return 5 * baseReserve;
    }
    /**
     * Transaction fee for each operation
     * @returns transaction fee in stroops
     */
    async getBaseTransactionFee() {
        const server = new stellar.Server(this.getHorizonUrl());
        const horizonLedgerInfo = await server.ledgers().order('desc').limit(1).call();
        if (!horizonLedgerInfo) {
            throw new Error('unable to connect to Horizon for reserve requirement data');
        }
        return horizonLedgerInfo.records[0].base_fee_in_stroops;
    }
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    getAddressDetails(address) {
        if (address.startsWith('M')) {
            if (this.isValidMuxedAddress(address)) {
                const muxedAccount = this.getMuxedAccount(address);
                return {
                    baseAddress: muxedAccount.baseAccount().accountId(),
                    address,
                    id: muxedAccount.id(),
                    memoId: undefined,
                };
            }
            else {
                throw new sdk_core_1.InvalidAddressError(`invalid muxed address: ${address}`);
            }
        }
        const destinationDetails = url.parse(address);
        const destinationAddress = destinationDetails.pathname || '';
        if (!destinationAddress || !stellar.StrKey.isValidEd25519PublicKey(destinationAddress)) {
            throw new Error(`invalid address: ${address}`);
        }
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                baseAddress: address,
                address: address,
                id: undefined,
                memoId: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (Array.isArray(queryDetails.memoId)) {
            throw new sdk_core_1.InvalidAddressError(`memoId may only be given at most once, but found ${queryDetails.memoId.length} instances in address ${address}`);
        }
        if (Array.isArray(queryDetails.memoId) && queryDetails.memoId.length !== 1) {
            // valid addresses can only contain one memo id
            throw new sdk_core_1.InvalidAddressError(`invalid address '${address}', must contain exactly one memoId`);
        }
        const [memoId] = _.castArray(queryDetails.memoId) || undefined;
        if (!this.isValidMemoId(memoId)) {
            throw new sdk_core_1.InvalidMemoIdError(`invalid address: '${address}', memoId is not valid`);
        }
        return {
            baseAddress: destinationAddress,
            address: destinationAddress,
            id: undefined,
            memoId,
        };
    }
    /**
     * Validate and return address with appended memo id or muxed address
     *
     * @param address address
     * @param memoId memo id
     * @returns address with memo id
     */
    normalizeAddress({ address, memoId }) {
        if (this.isValidMuxedAddress(address)) {
            return address;
        }
        if (!stellar.StrKey.isValidEd25519PublicKey(address)) {
            throw new Error(`invalid address details: ${address}`);
        }
        if (memoId && this.isValidMemoId(memoId)) {
            return `${address}?memoId=${memoId}`;
        }
        return address;
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param address the pub to be checked
     * @returns is it valid?
     */
    isValidAddress(address) {
        try {
            const addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return a Stellar Asset in coin:token form (i.e. (t)xlm:<code>-<issuer>)
     * If the asset is XLM, return the chain
     * @param {stellar.Asset} asset - instance of Stellar Asset
     */
    getTokenNameFromStellarAsset(asset) {
        const code = asset.getCode();
        const issuer = asset.getIssuer();
        if (asset.isNative()) {
            return this.getChain();
        }
        return `${this.getChain()}${sdk_core_1.BaseCoin.coinTokenPatternSeparator}${code}${Xlm.tokenPatternSeparator}${issuer}`;
    }
    /**
     * Evaluate whether a stellar username has valid format
     * This method is used by the client when a stellar address is being added to a wallet
     * Example of a common stellar username: foo@bar.baz
     * The above example would result in the Stellar address: foo@bar.baz*bitgo.com
     *
     * @param username - stellar username
     * @return true if stellar username is valid
     */
    isValidStellarUsername(username) {
        return /^[a-z0-9\-_.+@]+$/.test(username);
    }
    /**
     * Get an instance of FederationServer for BitGo lookups
     *
     * @returns instance of BitGo Federation Server
     */
    getBitGoFederationServer() {
        // Identify the URI scheme in case we need to allow connecting to HTTP server.
        const isNonSecureEnv = !_.startsWith(sdk_core_1.common.Environments[this.bitgo.env].uri, 'https');
        const federationServerOptions = { allowHttp: isNonSecureEnv };
        return new stellar.FederationServer(this.getFederationServerUrl(), 'bitgo.com', federationServerOptions);
    }
    /**
     * Perform federation lookups
     * Our federation server handles lookups for bitgo as well as for other federation domains
     *
     * @param {String} [address] - address to look up
     * @param {String} [accountId] - account id to look up
     */
    async federationLookup({ address, accountId, }) {
        try {
            const federationServer = this.getBitGoFederationServer();
            if (address) {
                return await federationServer.resolveAddress(address);
            }
            else if (accountId) {
                return await federationServer.resolveAccountId(accountId);
            }
            else {
                throw new Error('invalid argument - must provide Stellar address or account id');
            }
        }
        catch (e) {
            const error = _.get(e, 'response.data.detail');
            if (error) {
                throw new sdk_core_1.StellarFederationUserNotFoundError(error);
            }
            else {
                throw e;
            }
        }
    }
    /**
     * Attempt to resolve a stellar address into a stellar account
     *
     * @param {String} address - stellar address to look for
     */
    async federationLookupByName(address) {
        if (!address) {
            throw new Error('invalid Stellar address');
        }
        return this.federationLookup({ address });
    }
    /**
     * Attempt to resolve an account id into a stellar account
     * Only works for accounts that can be resolved by our federation server
     *
     * @param {String} accountId - stellar account id
     */
    async federationLookupByAccountId(accountId) {
        if (!accountId) {
            throw new Error('invalid Stellar account');
        }
        return this.federationLookup({ accountId });
    }
    /**
     * Check if address is a valid XLM address, and then make sure it matches the root address.
     *
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    async isWalletAddress({ address, rootAddress }) {
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const addressDetails = this.getAddressDetails(address);
        const rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.baseAddress !== rootAddressDetails.address) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${addressDetails.baseAddress} vs ${rootAddressDetails.address}`);
        }
        return true;
    }
    /**
     * Get extra parameters for prebuilding a tx
     * Set empty recipients array in trustline txs
     */
    async getExtraPrebuildParams(buildParams) {
        const params = {};
        if (buildParams.type === 'trustline') {
            params.recipients = [];
        }
        return params;
    }
    /**
     * @deprecated
     */
    initiateRecovery(params) {
        throw new Error('deprecated method');
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] Stellar private key
     * - backupKey: [encrypted] Stellar private key, or public key if the private key is held by a KRS provider
     * - walletPassphrase: necessary if one of the private keys is encrypted
     * - rootAddress: base address of the wallet to recover funds from
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     */
    async recover(params) {
        // Check if unencrypted root keys were provided, convert to Stellar format if necessary
        if (Utils.isValidRootPrivateKey(params.userKey)) {
            params.userKey = Utils.encodePrivateKey(Buffer.from(params.userKey.slice(0, 64), 'hex'));
        }
        else if (Utils.isValidRootPublicKey(params.userKey)) {
            params.userKey = Utils.encodePublicKey(Buffer.from(params.userKey, 'hex'));
        }
        if (Utils.isValidRootPrivateKey(params.backupKey)) {
            params.backupKey = Utils.encodePrivateKey(Buffer.from(params.backupKey.slice(0, 64), 'hex'));
        }
        else if (Utils.isValidRootPublicKey(params.backupKey)) {
            params.backupKey = Utils.encodePublicKey(Buffer.from(params.backupKey, 'hex'));
        }
        // Stellar's Ed25519 public keys start with a G, while private keys start with an S
        const isKrsRecovery = params.backupKey.startsWith('G') && !params.userKey.startsWith('G');
        const isUnsignedSweep = params.backupKey.startsWith('G') && params.userKey.startsWith('G');
        if (isKrsRecovery) {
            (0, sdk_core_1.checkKrsProvider)(this, params.krsProvider);
        }
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new sdk_core_1.InvalidAddressError('Invalid destination address!');
        }
        const [userKey, backupKey] = (0, getStellarKeys_1.getStellarKeys)(this.bitgo, params);
        if (!params.rootAddress || !stellar.StrKey.isValidEd25519PublicKey(params.rootAddress)) {
            throw new Error(`Invalid wallet address: ${params.rootAddress}`);
        }
        const accountDataUrl = `${this.getHorizonUrl()}/accounts/${params.rootAddress}`;
        const destinationUrl = `${this.getHorizonUrl()}/accounts/${params.recoveryDestination}`;
        let accountData;
        try {
            accountData = await (0, sdk_api_1.toBitgoRequest)(request.get(accountDataUrl)).result();
        }
        catch (e) {
            throw new Error('Unable to reach the Stellar network via Horizon.');
        }
        // Now check if the destination account is empty or not
        let unfundedDestination = false;
        try {
            await request.get(destinationUrl);
        }
        catch (e) {
            if (e.status === 404) {
                // If the destination account does not yet exist, horizon responds with 404
                unfundedDestination = true;
            }
        }
        if (!accountData.sequence || !accountData.balances) {
            throw new Error('Horizon server error - unable to retrieve sequence ID or account balance');
        }
        const account = new stellar.Account(params.rootAddress, accountData.sequence);
        // Stellar supports multiple assets on chain, we're only interested in the balances entry whose type is "native" (XLM)
        const nativeBalanceInfo = accountData.balances.find((assetBalance) => assetBalance['asset_type'] === 'native');
        if (!nativeBalanceInfo) {
            throw new Error('Provided wallet has a balance of 0 XLM, recovery aborted');
        }
        const walletBalance = Number(this.bigUnitsToBaseUnits(nativeBalanceInfo.balance));
        const minimumReserve = await this.getMinimumReserve();
        const baseTxFee = await this.getBaseTransactionFee();
        const recoveryAmount = walletBalance - minimumReserve - baseTxFee;
        const formattedRecoveryAmount = this.baseUnitsToBigUnits(recoveryAmount).toString();
        const txBuilder = new stellar.TransactionBuilder(account, {
            fee: baseTxFee.toFixed(0),
            networkPassphrase: this.getStellarNetwork(),
        });
        const operation = unfundedDestination
            ? // In this case, we need to create the account
                stellar.Operation.createAccount({
                    destination: params.recoveryDestination,
                    startingBalance: formattedRecoveryAmount,
                })
            : // Otherwise if the account already exists, we do a normal send
                stellar.Operation.payment({
                    destination: params.recoveryDestination,
                    asset: stellar.Asset.native(),
                    amount: formattedRecoveryAmount,
                });
        const tx = txBuilder.addOperation(operation).setTimeout(stellar.TimeoutInfinite).build();
        const feeInfo = {
            fee: new bignumber_js_1.BigNumber(tx.fee).toNumber(),
            feeString: tx.fee,
        };
        if (!isUnsignedSweep) {
            tx.sign(userKey);
        }
        if (!isKrsRecovery && !isUnsignedSweep) {
            tx.sign(backupKey);
        }
        const transaction = {
            txBase64: Xlm.txToString(tx),
            recoveryAmount,
        };
        if (isKrsRecovery) {
            transaction.backupKey = params.backupKey;
        }
        transaction.coin = this.getChain();
        transaction.feeInfo = feeInfo;
        return transaction;
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<HalfSignedTransaction>}
     */
    async signTransaction(params) {
        var _a, _b;
        const { txPrebuild, prv } = params;
        if (_.isUndefined(txPrebuild)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isObject(txPrebuild)) {
            throw new Error(`txPrebuild must be an object, got type ${typeof txPrebuild}`);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error(`prv must be a string, got type ${typeof prv}`);
        }
        const keyPair = Utils.createStellarKeypairFromPrv(prv);
        const tx = new stellar.Transaction(txPrebuild.txBase64, this.getStellarNetwork());
        tx.sign(keyPair);
        const txBase64 = Xlm.txToString(tx);
        const type = (_a = txPrebuild === null || txPrebuild === void 0 ? void 0 : txPrebuild.buildParams) === null || _a === void 0 ? void 0 : _a.type;
        const recipients = (_b = txPrebuild === null || txPrebuild === void 0 ? void 0 : txPrebuild.buildParams) === null || _b === void 0 ? void 0 : _b.recipients;
        if (type === 'enabletoken') {
            return {
                halfSigned: { txBase64 },
                type,
                recipients,
            };
        }
        else {
            return { halfSigned: { txBase64 } };
        }
    }
    /**
     * Extend walletParams with extra params required for generating an XLM wallet
     *
     * Stellar wallets have three keychains on them. Two are generated by the platform, and the last is generated by the user.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root prv is not provided, a random one is generated.
     */
    async supplementGenerateWallet(walletParams) {
        let seed;
        const rootPrv = walletParams.rootPrivateKey;
        if (rootPrv) {
            if (!this.isValidPrv(rootPrv)) {
                throw new Error('rootPrivateKey needs to be valid ed25519 secret seed');
            }
            seed = stellar.StrKey.decodeEd25519SecretSeed(rootPrv);
        }
        const keyPair = this.generateKeyPair(seed);
        // extend the wallet initialization params
        walletParams.rootPrivateKey = keyPair.prv;
        return walletParams;
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        if (!this.isValidPrv(key.prv)) {
            throw new Error(`invalid prv: ${key.prv}`);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        const keypair = Utils.createStellarKeypairFromPrv(key.prv);
        return keypair.sign(message);
    }
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub public key
     * @param message signed message
     * @param signature signature to verify
     * @returns true if signature is valid.
     */
    verifySignature(pub, message, signature) {
        if (!this.isValidPub(pub)) {
            throw new Error(`invalid pub: ${pub}`);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        const keyPair = Utils.createStellarKeypairFromPub(pub);
        return keyPair.verify(message, signature);
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params) {
        const { txHex, txBase64 } = params;
        let tx = undefined;
        if (!txHex && !txBase64) {
            throw new Error('explainTransaction missing txHex or txBase64 parameter, must have at least one');
        }
        try {
            if (txHex) {
                tx = new stellar.Transaction(Buffer.from(txHex, 'hex').toString('base64'), this.getStellarNetwork());
            }
            else if (txBase64) {
                tx = new stellar.Transaction(txBase64, this.getStellarNetwork());
            }
        }
        catch (e) {
            throw new Error('txBase64 needs to be a valid tx encoded as base64 string');
        }
        if (!tx) {
            throw new Error('tx needs to be defined in order to explain transaction');
        }
        const id = tx.hash().toString('hex');
        // In a Stellar tx, the _memo property is an object with the methods:
        // value() and arm() that provide memo value and type, respectively.
        const memo = _.result(tx, '_memo.value') && _.result(tx, '_memo.arm')
            ? {
                value: _.result(tx, '_memo.value').toString(),
                type: _.result(tx, '_memo.arm'),
            }
            : {};
        let spendAmount = new bignumber_js_1.BigNumber(0); // amount of XLM used in XLM-only txs
        const spendAmounts = {}; // track both xlm and token amounts
        if (_.isEmpty(tx.operations)) {
            throw new Error('missing operations');
        }
        const outputs = [];
        const operations = []; // non-payment operations
        _.forEach(tx.operations, (op) => {
            if (op.type === 'createAccount' || op.type === 'payment') {
                // TODO Remove memoId from address
                // Get memo to attach to address, if type is 'id'
                const memoId = _.get(memo, 'type') === 'id' && !_.get(memo, 'value') ? `?memoId=${memo.value}` : '';
                let asset;
                if (op.type === 'payment') {
                    if (op.asset.getAssetType() === 'liquidity_pool_shares') {
                        throw new Error('Invalid asset type');
                    }
                    asset = op.asset;
                }
                else {
                    asset = stellar.Asset.native();
                }
                const coin = this.getTokenNameFromStellarAsset(asset); // coin or token id
                const output = {
                    amount: this.bigUnitsToBaseUnits(op.startingBalance || op.amount),
                    address: op.destination + memoId,
                    coin,
                };
                if (!_.isUndefined(spendAmounts[coin])) {
                    spendAmounts[coin] = spendAmounts[coin].plus(output.amount);
                }
                else {
                    spendAmounts[coin] = new bignumber_js_1.BigNumber(output.amount);
                }
                if (asset.isNative()) {
                    spendAmount = spendAmount.plus(output.amount);
                }
                outputs.push(output);
            }
            else if (op.type === 'changeTrust') {
                if (op.line.getAssetType() === 'liquidity_pool_shares') {
                    throw new Error('Invalid asset type');
                }
                const asset = op.line;
                operations.push({
                    type: op.type,
                    coin: this.getTokenNameFromStellarAsset(asset),
                    asset,
                    limit: this.bigUnitsToBaseUnits(op.limit),
                });
            }
        });
        const outputAmount = spendAmount.toFixed(0);
        const outputAmounts = _.mapValues(spendAmounts, (amount) => amount.toFixed(0));
        const fee = {
            fee: new bignumber_js_1.BigNumber(tx.fee).toFixed(0),
            feeRate: null,
            size: null,
        };
        return {
            displayOrder: [
                'id',
                'outputAmount',
                'outputAmounts',
                'changeAmount',
                'outputs',
                'changeOutputs',
                'fee',
                'memo',
                'operations',
            ],
            id,
            outputs,
            outputAmount,
            outputAmounts,
            changeOutputs: [],
            changeAmount: '0',
            memo,
            fee,
            operations,
        };
    }
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    verifyEnableTokenTxOperations(operations, txParams) {
        const trustlineOperations = _.filter(operations, ['type', 'changeTrust']);
        if (trustlineOperations.length !== _.get(txParams, 'recipients', []).length) {
            throw new Error('transaction prebuild does not match expected trustline operations');
        }
        _.forEach(trustlineOperations, (op) => {
            if (op.type !== 'changeTrust') {
                throw new Error('Invalid asset type');
            }
            if (op.line.getAssetType() === 'liquidity_pool_shares') {
                throw new Error('Invalid asset type');
            }
            const asset = op.line;
            const opToken = this.getTokenNameFromStellarAsset(asset);
            const tokenTrustline = _.find(txParams.recipients, (recipient) => {
                // trustline params use limits in base units
                const opLimitBaseUnits = this.bigUnitsToBaseUnits(op.limit);
                // Enable token limit is set to Xlm.maxTrustlineLimit by default
                return recipient.tokenName === opToken && opLimitBaseUnits === Xlm.maxTrustlineLimit;
            });
            if (!tokenTrustline) {
                throw new Error('transaction prebuild does not match expected trustline tokens');
            }
        });
    }
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    verifyTrustlineTxOperations(operations, txParams) {
        const trustlineOperations = _.filter(operations, ['type', 'changeTrust']);
        if (trustlineOperations.length !== _.get(txParams, 'trustlines', []).length) {
            throw new Error('transaction prebuild does not match expected trustline operations');
        }
        _.forEach(trustlineOperations, (op) => {
            if (op.type !== 'changeTrust') {
                throw new Error('Invalid asset type');
            }
            if (op.line.getAssetType() === 'liquidity_pool_shares') {
                throw new Error('Invalid asset type');
            }
            const asset = op.line;
            const opToken = this.getTokenNameFromStellarAsset(asset);
            const tokenTrustline = _.find(txParams.trustlines, (trustline) => {
                // trustline params use limits in base units
                const opLimitBaseUnits = this.bigUnitsToBaseUnits(op.limit);
                // Prepare the conditions to check for
                // Limit will always be set in the operation, even if it was omitted from txParams in the following cases:
                // 1. Action is 'add' - limit is set to Xlm.maxTrustlineLimit by default
                // 2. Action is 'remove' - limit is set to '0'
                const noLimit = _.isUndefined(trustline.limit);
                const addTrustlineWithDefaultLimit = trustline.action === 'add' && opLimitBaseUnits === Xlm.maxTrustlineLimit;
                const removeTrustline = trustline.action === 'remove' && opLimitBaseUnits === '0';
                return (trustline.token === opToken &&
                    (trustline.limit === opLimitBaseUnits || (noLimit && (addTrustlineWithDefaultLimit || removeTrustline))));
            });
            if (!tokenTrustline) {
                throw new Error('transaction prebuild does not match expected trustline tokens');
            }
        });
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param options
     * @param options.txPrebuild prebuild object returned by platform
     * @param options.txPrebuild.txBase64 prebuilt transaction encoded as base64 string
     * @param options.wallet wallet object to obtain keys to verify against
     * @param options.verification specifying some verification parameters
     * @param options.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param options.verification.keychains Pass keychains manually rather than fetching them by id
     */
    async verifyTransaction(options) {
        // TODO BG-5600 Add parseTransaction / improve verification
        const { txParams, txPrebuild, wallet, verification = {} } = options;
        const disableNetworking = !!verification.disableNetworking;
        if (!txPrebuild.txBase64) {
            throw new Error('missing required tx prebuild property txBase64');
        }
        const tx = new stellar.Transaction(txPrebuild.txBase64, this.getStellarNetwork());
        if (txParams.recipients && txParams.recipients.length > 1) {
            throw new Error('cannot specify more than 1 recipient');
        }
        // Stellar txs are made up of operations. We only care about Create Account and Payment for sending funds.
        const outputOperations = _.filter(tx.operations, (operation) => operation.type === 'createAccount' || operation.type === 'payment');
        if (txParams.type === 'enabletoken') {
            this.verifyEnableTokenTxOperations(tx.operations, txParams);
        }
        else if (txParams.type === 'trustline') {
            this.verifyTrustlineTxOperations(tx.operations, txParams);
        }
        else {
            if (_.isEmpty(outputOperations)) {
                throw new Error('transaction prebuild does not have any operations');
            }
            _.forEach(txParams.recipients, (expectedOutput, index) => {
                const expectedOutputAddressDetails = this.getAddressDetails(expectedOutput.address);
                const expectedOutputAddress = expectedOutputAddressDetails.address;
                const output = outputOperations[index];
                if (output.destination !== expectedOutputAddress) {
                    throw new Error('transaction prebuild does not match expected recipient');
                }
                const expectedOutputAmount = new bignumber_js_1.BigNumber(expectedOutput.amount);
                // The output amount is expressed as startingBalance in createAccount operations and as amount in payment operations.
                const outputAmountString = output.type === 'createAccount' ? output.startingBalance : output.amount;
                const outputAmount = new bignumber_js_1.BigNumber(this.bigUnitsToBaseUnits(outputAmountString));
                if (!outputAmount.eq(expectedOutputAmount)) {
                    throw new Error('transaction prebuild does not match expected amount');
                }
            });
        }
        // Verify the user signature, if the tx is half-signed
        if (!_.isEmpty(tx.signatures)) {
            const userSignature = tx.signatures[0].signature();
            // obtain the keychains and key signatures
            let keychains = verification.keychains;
            if (!keychains && disableNetworking) {
                throw new Error('cannot fetch keychains without networking');
            }
            else if (!keychains) {
                keychains = await (0, sdk_core_1.promiseProps)({
                    user: this.keychains().get({ id: wallet.keyIds()[sdk_core_1.KeyIndices.USER] }),
                    backup: this.keychains().get({ id: wallet.keyIds()[sdk_core_1.KeyIndices.BACKUP] }),
                });
            }
            if (!keychains || !keychains.backup || !keychains.user) {
                throw new Error('keychains are required, but could not be fetched');
            }
            (0, assert_1.default)(keychains.backup.pub);
            if (this.verifySignature(keychains.backup.pub, tx.hash(), userSignature)) {
                throw new Error('transaction signed with wrong key');
            }
            (0, assert_1.default)(keychains.user.pub);
            if (!this.verifySignature(keychains.user.pub, tx.hash(), userSignature)) {
                throw new Error('transaction signature invalid');
            }
        }
        return true;
    }
    /** inheritdoc */
    deriveKeyWithSeed() {
        throw new sdk_core_1.NotSupported('method deriveKeyWithSeed not supported for eddsa curve');
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Gets config for how token enablements work for this coin
     * @returns
     *    requiresTokenEnablement: True if tokens need to be enabled for this coin
     *    supportsMultipleTokenEnablements: True if multiple tokens can be enabled in one transaction
     */
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: true,
            supportsMultipleTokenEnablements: false,
        };
    }
}
exports.Xlm = Xlm;
Xlm.tokenPatternSeparator = '-'; // separator for token code and issuer
Xlm.maxMemoId = '0xFFFFFFFFFFFFFFFF'; // max unsigned 64-bit number = 18446744073709551615
// max int64 number supported by the network (2^63)-1
// See: https://www.stellar.org/developers/guides/concepts/assets.html#amount-precision-and-representation
Xlm.maxTrustlineLimit = '9223372036854775807';
/**
 * stellar-sdk has two overloads for toXDR, and typescript can't seem to figure out the
 * correct one to use, so we have to be very explicit as to which one we want.
 * @param tx transaction to convert
 */
Xlm.txToString = (tx) => tx.toEnvelope().toXDR('base64');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGxtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3hsbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9EQUE0QjtBQUM1QiwwQ0FBNEI7QUFDNUIseURBQTJDO0FBQzNDLHlDQUEyQjtBQUMzQixvREFBc0M7QUFDdEMscURBQXVDO0FBQ3ZDLCtDQUF5QztBQUN6QyxtREFBcUM7QUFDckMsMkNBQTBEO0FBRTFELDhDQTBCeUI7QUFDekIsNENBQWdEO0FBQ2hELHFEQUFrRDtBQWlIbEQsTUFBYSxHQUFJLFNBQVEsbUJBQVE7SUFRL0IsWUFBWSxLQUFnQjtRQUMxQixLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDYixJQUFJLENBQUMsVUFBVSxHQUFHLFdBQVcsQ0FBQyxDQUFDLHFDQUFxQztJQUN0RSxDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFnQjtRQUNwQyxPQUFPLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFUyxpQkFBaUI7UUFDekIsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztJQUNqQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxhQUFhO1FBQ1gsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSCxRQUFRO1FBQ04sT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCxTQUFTO1FBQ1AsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCxXQUFXO1FBQ1QsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsc0JBQXNCO1FBQ3BCLE9BQU8saUJBQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLDBCQUEwQixDQUFDO0lBQzdFLENBQUM7SUFFRDs7T0FFRztJ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LENBQUMsd0RBQXdELENBQUMsQ0FBQztJQUNuRixDQUFDO0lBVUQsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BQStCO1FBQ3BELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsd0JBQXdCO1FBQ3RCLE9BQU87WUFDTCx1QkFBdUIsRUFBRSxJQUFJO1lBQzdCLGdDQUFnQyxFQUFFLEtBQUs7U0FDeEMsQ0FBQztJQUNKLENBQUM7O0FBdGdDSCxrQkF1Z0NDO0FBcmdDd0IseUJBQXFCLEdBQUcsR0FBRyxDQUFDLENBQUMsc0NBQXNDO0FBQzFFLGFBQVMsR0FBVyxvQkFBb0IsQ0FBQyxDQUFDLG9EQUFvRDtBQUM5RyxxREFBcUQ7QUFDckQsMEdBQTBHO0FBQzFGLHFCQUFpQixHQUFXLHFCQUFxQixDQUFDO0FBeStCbEU7Ozs7R0FJRztBQUNjLGNBQVUsR0FBRyxDQUFDLEVBQXVCLEVBQVUsRUFBRSxDQUMvRCxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsS0FBK0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJztcbmltcG9ydCAqIGFzIHVybCBmcm9tICd1cmwnO1xuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIHN0ZWxsYXIgZnJvbSAnc3RlbGxhci1zZGsnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4vbGliL3V0aWxzJztcbmltcG9ydCB7IEtleVBhaXIgYXMgU3RlbGxhcktleVBhaXIgfSBmcm9tICcuL2xpYi9rZXlQYWlyJztcblxuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgY2hlY2tLcnNQcm92aWRlcixcbiAgY29tbW9uLFxuICBFeHRyYVByZWJ1aWxkUGFyYW1zT3B0aW9ucyxcbiAgSW52YWxpZEFkZHJlc3NFcnJvcixcbiAgSW52YWxpZE1lbW9JZEVycm9yLFxuICBJVHJhbnNhY3Rpb25SZWNpcGllbnQsXG4gIEtleUluZGljZXMsXG4gIEtleVBhaXIsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgcHJvbWlzZVByb3BzLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTdGVsbGFyRmVkZXJhdGlvblVzZXJOb3RGb3VuZEVycm9yLFxuICBUb2tlbkVuYWJsZW1lbnRDb25maWcsXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24gYXMgQmFzZVRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG4gIFRyYW5zYWN0aW9uUGFyYW1zIGFzIEJhc2VUcmFuc2FjdGlvblBhcmFtcyxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXMgQmFzZVRyYW5zYWN0aW9uT3V0cHV0LFxuICBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyBhcyBCYXNlVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBXYWxsZXQsXG4gIE5vdFN1cHBvcnRlZCxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IHRvQml0Z29SZXF1ZXN0IH0gZnJvbSAnQGJpdGdvL3Nkay1hcGknO1xuaW1wb3J0IHsgZ2V0U3RlbGxhcktleXMgfSBmcm9tICcuL2dldFN0ZWxsYXJLZXlzJztcblxuLyoqXG4gKiBYTE0gYWNjb3VudHMgc3VwcG9ydCB2aXJ0dWFsIChtdXhlZCkgYWRkcmVzc2VzXG4gKiBBIGJhc2UgYWRkcmVzcyBzdGFydHMgd2l0aCBcIkdcIiBhbmQgaXMgdGllZCB0byB0aGUgdW5kZXJseWluZyBcInJlYWxcIiBhY2NvdW50XG4gKiBBIG11eGVkIGFkZHJlc3Mgc3RhcnRzIHdpdGggXCJNXCIgYW5kIGNvbWJpbmVzIHRoZSBiYXNlIGFkZHJlc3Mgd2l0aCBhIDY0LWJpdCBpbnRlZ2VyIElEIGluIG9yZGVyIHRvIHByb3ZpZGVcbiAqIGFuIGFsdGVybmF0aXZlIHRvIG1lbW8gaWRzLlxuICovXG5pbnRlcmZhY2UgQWRkcmVzc0RldGFpbHMge1xuICBiYXNlQWRkcmVzczogc3RyaW5nO1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGlkPzogc3RyaW5nO1xuICBtZW1vSWQ/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59XG5cbmludGVyZmFjZSBNZW1vIHtcbiAgdHlwZTogc3RlbGxhci5NZW1vVHlwZTtcbiAgdmFsdWU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zIHtcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICBrcnNQcm92aWRlcj86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5T3B0aW9ucyBleHRlbmRzIEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZWNvdmVyeVRyYW5zYWN0aW9uIHtcbiAgdHhCYXNlNjQ6IHN0cmluZztcbiAgcmVjb3ZlcnlBbW91bnQ6IG51bWJlcjtcbiAgY29pbj86IHN0cmluZztcbiAgYmFja3VwS2V5Pzogc3RyaW5nO1xuICB0eEluZm8/OiBhbnk7XG4gIGZlZUluZm8/OiBhbnk7XG59XG5cbmludGVyZmFjZSBCdWlsZE9wdGlvbnMge1xuICB3YWxsZXQ/OiBXYWxsZXQ7XG4gIHJlY2lwaWVudHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+W107XG4gIHR5cGU/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIFtpbmRleDogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4QmFzZTY0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEhhbGZTaWduZWRUcmFuc2FjdGlvbiB7XG4gIGhhbGZTaWduZWQ6IHtcbiAgICB0eEJhc2U2NDogc3RyaW5nO1xuICB9O1xuICByZWNpcGllbnRzPzogSVRyYW5zYWN0aW9uUmVjaXBpZW50W107XG4gIHR5cGU/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zIHtcbiAgcm9vdFByaXZhdGVLZXk/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg/OiBzdHJpbmc7XG4gIHR4QmFzZTY0Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25NZW1vIHtcbiAgdmFsdWU/OiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk9wZXJhdGlvbiB7XG4gIHR5cGU6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBsaW1pdD86IHN0cmluZztcbiAgYXNzZXQ/OiBzdGVsbGFyLkFzc2V0O1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25PdXRwdXQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25PdXRwdXQge1xuICBjb2luOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICBtZW1vOiBUcmFuc2FjdGlvbk1lbW87XG59XG5cbmludGVyZmFjZSBWZXJpZnlBZGRyZXNzT3B0aW9ucyBleHRlbmRzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyB7XG4gIHJvb3RBZGRyZXNzOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcnVzdGxpbmVPcHRpb25zIHtcbiAgdG9rZW46IHN0cmluZztcbiAgYWN0aW9uOiBzdHJpbmc7XG4gIGxpbWl0Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25QYXJhbXMgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QYXJhbXMge1xuICB0cnVzdGxpbmVzPzogVHJ1c3RsaW5lT3B0aW9uc1tdO1xufVxuXG5pbnRlcmZhY2UgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UGFyYW1zOiBUcmFuc2FjdGlvblBhcmFtcztcbn1cblxuZXhwb3J0IGNsYXNzIFhsbSBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIHJlYWRvbmx5IGhvbWVEb21haW46IHN0cmluZztcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSB0b2tlblBhdHRlcm5TZXBhcmF0b3IgPSAnLSc7IC8vIHNlcGFyYXRvciBmb3IgdG9rZW4gY29kZSBhbmQgaXNzdWVyXG4gIHN0YXRpYyByZWFkb25seSBtYXhNZW1vSWQ6IHN0cmluZyA9ICcweEZGRkZGRkZGRkZGRkZGRkYnOyAvLyBtYXggdW5zaWduZWQgNjQtYml0IG51bWJlciA9IDE4NDQ2NzQ0MDczNzA5NTUxNjE1XG4gIC8vIG1heCBpbnQ2NCBudW1iZXIgc3VwcG9ydGVkIGJ5IHRoZSBuZXR3b3JrICgyXjYzKS0xXG4gIC8vIFNlZTogaHR0cHM6Ly93d3cuc3RlbGxhci5vcmcvZGV2ZWxvcGVycy9ndWlkZXMvY29uY2VwdHMvYXNzZXRzLmh0bWwjYW1vdW50LXByZWNpc2lvbi1hbmQtcmVwcmVzZW50YXRpb25cbiAgc3RhdGljIHJlYWRvbmx5IG1heFRydXN0bGluZUxpbWl0OiBzdHJpbmcgPSAnOTIyMzM3MjAzNjg1NDc3NTgwNyc7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSkge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgICB0aGlzLmhvbWVEb21haW4gPSAnYml0Z28uY29tJzsgLy8gdXNlZCBmb3IgcmV2ZXJzZSBmZWRlcmF0aW9uIGxvb2t1cFxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHb0Jhc2UpOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBYbG0oYml0Z28pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldFN0ZWxsYXJOZXR3b3JrKCk6IHN0ZWxsYXIuTmV0d29ya3Mge1xuICAgIHJldHVybiBzdGVsbGFyLk5ldHdvcmtzLlBVQkxJQztcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3IgYmV0d2VlbiB0aGUgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKi9cbiAgZ2V0QmFzZUZhY3RvcigpIHtcbiAgICByZXR1cm4gMWU3O1xuICB9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIHdoaWNoIHN1cHBvcnRzIHRoaXMgY29pblxuICAgKi9cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3hsbSc7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGNvaW4gZmFtaWx5XG4gICAqL1xuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3hsbSc7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGlzIGNvaW5cbiAgICovXG4gIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdTdGVsbGFyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcmwgYXQgd2hpY2ggdGhlIHN0ZWxsYXIgZmVkZXJhdGlvbiBzZXJ2ZXIgY2FuIGJlIHJlYWNoZWRcbiAgICovXG4gIGdldEZlZGVyYXRpb25TZXJ2ZXJVcmwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmJpdGdvLmdldEVudigpXS5zdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcmwgYXQgd2hpY2ggaG9yaXpvbiBjYW4gYmUgcmVhY2hlZFxuICAgKi9cbiAgZ2V0SG9yaXpvblVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnaHR0cHM6Ly9ob3Jpem9uLnN0ZWxsYXIub3JnJztcbiAgfVxuXG4gIC8qKiBpbmhlcml0ZG9jICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3Qga2V5UGFpciA9IHNlZWQgPyBuZXcgU3RlbGxhcktleVBhaXIoeyBzZWVkIH0pIDogbmV3IFN0ZWxsYXJLZXlQYWlyKCk7XG4gICAgY29uc3Qga2V5cyA9IGtleVBhaXIuZ2V0S2V5cygpO1xuICAgIGlmICgha2V5cy5wcnYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcnYgaW4ga2V5IGdlbmVyYXRpb24uJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHB1Yjoga2V5cy5wdWIsIHBydjoga2V5cy5wcnYgfTtcbiAgfVxuXG4gIGdlbmVyYXRlUm9vdEtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IGtleVBhaXIgPSBzZWVkID8gbmV3IFN0ZWxsYXJLZXlQYWlyKHsgc2VlZCB9KSA6IG5ldyBTdGVsbGFyS2V5UGFpcigpO1xuICAgIGNvbnN0IGtleXMgPSBrZXlQYWlyLmdldEtleXModHJ1ZSk7XG4gICAgaWYgKCFrZXlzLnBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBydiBpbiBrZXkgZ2VuZXJhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcHJ2OiBrZXlzLnBydiArIGtleXMucHViLCBwdWI6IGtleXMucHViIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGVuY29kZWQgZWQyNTUxOSBwdWJsaWMga2V5IGZyb20gcmF3IGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHB1YiBSYXcgcHVibGljIGtleVxuICAgKiBAcmV0dXJucyBFbmNvZGVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGdldFB1YkZyb21SYXcocHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBVdGlscy5lbmNvZGVQdWJsaWNLZXkoQnVmZmVyLmZyb20ocHViLCAnaGV4JykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBlbmNvZGVkIGVkMjU1MTkgcHJpdmF0ZSBrZXkgZnJvbSByYXcgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gcHJ2IFJhdyBwcml2YXRlIGtleVxuICAgKiBAcmV0dXJucyBFbmNvZGVkIHByaXZhdGUga2V5XG4gICAqL1xuICBnZXRQcnZGcm9tUmF3KHBydjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gVXRpbHMuZW5jb2RlUHJpdmF0ZUtleShCdWZmZXIuZnJvbShwcnYsICdoZXgnKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBTdGVsbGFyJ3MgdmFsaWRhdGlvbiBtZXRob2Qgb25seSBhbGxvd3Mga2V5cyBpbiBTdGVsbGFyLXNwZWNpZmljIGZvcm1hdCwgd2l0aCBhICdHJyBwcmVmaXhcbiAgICAvLyBXZSBuZWVkIHRvIGFsbG93IGZvciBib3RoIFN0ZWxsYXIgYW5kIHJhdyByb290IGtleXNcbiAgICByZXR1cm4gVXRpbHMuaXNWYWxpZFJvb3RQdWJsaWNLZXkocHViKSB8fCBVdGlscy5pc1ZhbGlkU3RlbGxhclB1YmxpY0tleShwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwcml2YXRlIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gU3RlbGxhcidzIHZhbGlkYXRpb24gbWV0aG9kIG9ubHkgYWxsb3dzIGtleXMgaW4gU3RlbGxhci1zcGVjaWZpYyBmb3JtYXQsIHdpdGggYW4gJ1MnIHByZWZpeFxuICAgIC8vIFdlIG5lZWQgdG8gYWxsb3cgZm9yIGJvdGggU3RlbGxhciBhbmQgcmF3IHJvb3QgcHJpdmF0ZSBrZXlzXG4gICAgcmV0dXJuIFV0aWxzLmlzVmFsaWRSb290UHJpdmF0ZUtleShwcnYpIHx8IFV0aWxzLmlzVmFsaWRTdGVsbGFyUHJpdmF0ZUtleShwcnYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIG1lbW8gaWQgaXMgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIG1lbW9JZCBtZW1vIGlkXG4gICAqIEByZXR1cm5zIHRydWUgaWYgbWVtbyBpZCBpcyB2YWxpZFxuICAgKi9cbiAgaXNWYWxpZE1lbW9JZChtZW1vSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGxldCBtZW1vSWROdW1iZXI7XG4gICAgdHJ5IHtcbiAgICAgIHN0ZWxsYXIuTWVtby5pZChtZW1vSWQpOyAvLyB0aHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCB2YWxpZCBtZW1vIGlkXG4gICAgICBtZW1vSWROdW1iZXIgPSBuZXcgQmlnTnVtYmVyKG1lbW9JZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vSWROdW1iZXIuZ3RlKDApICYmIG1lbW9JZE51bWJlci5sdChYbG0ubWF4TWVtb0lkKTtcbiAgfVxuXG4gIHN1cHBvcnRzRGVyaXZlS2V5V2l0aFNlZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyB3aGV0aGVyIGEgbWVtbyBpcyB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgb2YgdGhlIG1lbW9cbiAgICogQHBhcmFtIHR5cGUgdHlwZSBvZiB0aGUgbWVtb1xuICAgKiBAcmV0dXJucyB0cnVlIGlmIHZhbHVlIGFuZCB0eXBlIGFyZSBhIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkTWVtbyh7IHZhbHVlLCB0eXBlIH06IE1lbW8pOiBib29sZWFuIHtcbiAgICBpZiAoIXZhbHVlIHx8ICF0eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyB0aHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCB2YWxpZCBmb3IgdGhlIHR5cGVcbiAgICAgIC8vIHZhbGlkIHR5cGVzIGFyZTogJ2lkJywgJ3RleHQnLCAnaGFzaCcsICdyZXR1cm4nXG4gICAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3RlbGxhci5vcmcvZGV2ZWxvcGVycy9ndWlkZXMvY29uY2VwdHMvdHJhbnNhY3Rpb25zLmh0bWwjbWVtb1xuICAgICAgc3RlbGxhci5NZW1vW3R5cGVdKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBpbnN0YW5jZSBvZiBzdGVsbGFyLk11eGVkQWNjb3VudCBmcm9tIE0gYWRkcmVzc1xuICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5zdGVsbGFyLm9yZy9kb2NzL2dsb3NzYXJ5L211eGVkLWFjY291bnRzXG4gICAqL1xuICBnZXRNdXhlZEFjY291bnQoYWRkcmVzczogc3RyaW5nKTogc3RlbGxhci5NdXhlZEFjY291bnQge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3RlbGxhci5NdXhlZEFjY291bnQuZnJvbUFkZHJlc3MoYWRkcmVzcywgJzAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbXV4ZWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSBtdXhlZCBhZGRyZXNzIGlzIHZhbGlkXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXJzLnN0ZWxsYXIub3JnL2RvY3MvZ2xvc3NhcnkvbXV4ZWQtYWNjb3VudHNcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1ZhbGlkTXV4ZWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghXy5pc1N0cmluZyhhZGRyZXNzKSB8fCAhYWRkcmVzcy5zdGFydHNXaXRoKCdNJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gcmV0dXJuIHRydWUgaWYgbXV4ZWQgYWNjb3VudCBpcyB2YWxpZCBvciB0aHJvd1xuICAgICAgcmV0dXJuICEhc3RlbGxhci5NdXhlZEFjY291bnQuZnJvbUFkZHJlc3MoYWRkcmVzcywgJzAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1pbmltdW0gYmFsYW5jZSBvZiBhIDItb2YtMyBtdWx0aXNpZyB3YWxsZXRcbiAgICogQHJldHVybnMgbWluaW11bSBiYWxhbmNlIGluIHN0cm9vcHNcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1SZXNlcnZlKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3Qgc2VydmVyID0gbmV3IHN0ZWxsYXIuU2VydmVyKHRoaXMuZ2V0SG9yaXpvblVybCgpKTtcblxuICAgIGNvbnN0IGhvcml6b25MZWRnZXJJbmZvID0gYXdhaXQgc2VydmVyLmxlZGdlcnMoKS5vcmRlcignZGVzYycpLmxpbWl0KDEpLmNhbGwoKTtcblxuICAgIGlmICghaG9yaXpvbkxlZGdlckluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGNvbm5lY3QgdG8gSG9yaXpvbiBmb3IgcmVzZXJ2ZSByZXF1aXJlbWVudCBkYXRhJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVJlc2VydmUgPSBob3Jpem9uTGVkZ2VySW5mby5yZWNvcmRzWzBdLmJhc2VfcmVzZXJ2ZV9pbl9zdHJvb3BzO1xuXG4gICAgLy8gMi1vZi0zIHdhbGxldHMgaGF2ZSBhIG1pbmltdW0gcmVzZXJ2ZSBvZiA1eCB0aGUgYmFzZSByZXNlcnZlXG4gICAgcmV0dXJuIDUgKiBiYXNlUmVzZXJ2ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2FjdGlvbiBmZWUgZm9yIGVhY2ggb3BlcmF0aW9uXG4gICAqIEByZXR1cm5zIHRyYW5zYWN0aW9uIGZlZSBpbiBzdHJvb3BzXG4gICAqL1xuICBhc3luYyBnZXRCYXNlVHJhbnNhY3Rpb25GZWUoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCBzZXJ2ZXIgPSBuZXcgc3RlbGxhci5TZXJ2ZXIodGhpcy5nZXRIb3Jpem9uVXJsKCkpO1xuXG4gICAgY29uc3QgaG9yaXpvbkxlZGdlckluZm8gPSBhd2FpdCBzZXJ2ZXIubGVkZ2VycygpLm9yZGVyKCdkZXNjJykubGltaXQoMSkuY2FsbCgpO1xuXG4gICAgaWYgKCFob3Jpem9uTGVkZ2VySW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gY29ubmVjdCB0byBIb3Jpem9uIGZvciByZXNlcnZlIHJlcXVpcmVtZW50IGRhdGEnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9yaXpvbkxlZGdlckluZm8ucmVjb3Jkc1swXS5iYXNlX2ZlZV9pbl9zdHJvb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYWRkcmVzcyBpbnRvIGFkZHJlc3MgYW5kIG1lbW8gaWRcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgdGhlIGFkZHJlc3NcbiAgICogQHJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgYWRkcmVzcyBhbmQgbWVtbyBpZFxuICAgKi9cbiAgZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzczogc3RyaW5nKTogQWRkcmVzc0RldGFpbHMge1xuICAgIGlmIChhZGRyZXNzLnN0YXJ0c1dpdGgoJ00nKSkge1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZE11eGVkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICBjb25zdCBtdXhlZEFjY291bnQgPSB0aGlzLmdldE11eGVkQWNjb3VudChhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBiYXNlQWRkcmVzczogbXV4ZWRBY2NvdW50LmJhc2VBY2NvdW50KCkuYWNjb3VudElkKCksXG4gICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICBpZDogbXV4ZWRBY2NvdW50LmlkKCksXG4gICAgICAgICAgbWVtb0lkOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBtdXhlZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGVzdGluYXRpb25EZXRhaWxzID0gdXJsLnBhcnNlKGFkZHJlc3MpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQWRkcmVzcyA9IGRlc3RpbmF0aW9uRGV0YWlscy5wYXRobmFtZSB8fCAnJztcbiAgICBpZiAoIWRlc3RpbmF0aW9uQWRkcmVzcyB8fCAhc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkoZGVzdGluYXRpb25BZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gICAgLy8gYWRkcmVzcyBkb2Vzbid0IGhhdmUgYSBtZW1vIGlkXG4gICAgaWYgKGRlc3RpbmF0aW9uRGV0YWlscy5wYXRobmFtZSA9PT0gYWRkcmVzcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZUFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICAgIG1lbW9JZDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5RGV0YWlscyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKGRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSk7XG4gICAgaWYgKCFxdWVyeURldGFpbHMubWVtb0lkKSB7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBwcm9wZXJ0aWVzLCB0aGUgcXVlcnkgZGV0YWlscyBuZWVkIHRvIGNvbnRhaW4gdGhlIG1lbW8gaWQgcHJvcGVydHlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeURldGFpbHMubWVtb0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoXG4gICAgICAgIGBtZW1vSWQgbWF5IG9ubHkgYmUgZ2l2ZW4gYXQgbW9zdCBvbmNlLCBidXQgZm91bmQgJHtxdWVyeURldGFpbHMubWVtb0lkLmxlbmd0aH0gaW5zdGFuY2VzIGluIGFkZHJlc3MgJHthZGRyZXNzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlEZXRhaWxzLm1lbW9JZCkgJiYgcXVlcnlEZXRhaWxzLm1lbW9JZC5sZW5ndGggIT09IDEpIHtcbiAgICAgIC8vIHZhbGlkIGFkZHJlc3NlcyBjYW4gb25seSBjb250YWluIG9uZSBtZW1vIGlkXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzICcke2FkZHJlc3N9JywgbXVzdCBjb250YWluIGV4YWN0bHkgb25lIG1lbW9JZGApO1xuICAgIH1cblxuICAgIGNvbnN0IFttZW1vSWRdID0gXy5jYXN0QXJyYXkocXVlcnlEZXRhaWxzLm1lbW9JZCkgfHwgdW5kZWZpbmVkO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkTWVtb0lkKG1lbW9JZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVtb0lkRXJyb3IoYGludmFsaWQgYWRkcmVzczogJyR7YWRkcmVzc30nLCBtZW1vSWQgaXMgbm90IHZhbGlkYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VBZGRyZXNzOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICBhZGRyZXNzOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgbWVtb0lkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYW5kIHJldHVybiBhZGRyZXNzIHdpdGggYXBwZW5kZWQgbWVtbyBpZCBvciBtdXhlZCBhZGRyZXNzXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIGFkZHJlc3NcbiAgICogQHBhcmFtIG1lbW9JZCBtZW1vIGlkXG4gICAqIEByZXR1cm5zIGFkZHJlc3Mgd2l0aCBtZW1vIGlkXG4gICAqL1xuICBub3JtYWxpemVBZGRyZXNzKHsgYWRkcmVzcywgbWVtb0lkIH06IEFkZHJlc3NEZXRhaWxzKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkTXV4ZWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG4gICAgaWYgKCFzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFkZHJlc3MgZGV0YWlsczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICBpZiAobWVtb0lkICYmIHRoaXMuaXNWYWxpZE1lbW9JZChtZW1vSWQpKSB7XG4gICAgICByZXR1cm4gYCR7YWRkcmVzc30/bWVtb0lkPSR7bWVtb0lkfWA7XG4gICAgfVxuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIGFkZHJlc3MgPT09IHRoaXMubm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzRGV0YWlscyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBTdGVsbGFyIEFzc2V0IGluIGNvaW46dG9rZW4gZm9ybSAoaS5lLiAodCl4bG06PGNvZGU+LTxpc3N1ZXI+KVxuICAgKiBJZiB0aGUgYXNzZXQgaXMgWExNLCByZXR1cm4gdGhlIGNoYWluXG4gICAqIEBwYXJhbSB7c3RlbGxhci5Bc3NldH0gYXNzZXQgLSBpbnN0YW5jZSBvZiBTdGVsbGFyIEFzc2V0XG4gICAqL1xuICBnZXRUb2tlbk5hbWVGcm9tU3RlbGxhckFzc2V0KGFzc2V0OiBzdGVsbGFyLkFzc2V0KTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2RlID0gYXNzZXQuZ2V0Q29kZSgpO1xuICAgIGNvbnN0IGlzc3VlciA9IGFzc2V0LmdldElzc3VlcigpO1xuICAgIGlmIChhc3NldC5pc05hdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDaGFpbigpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy5nZXRDaGFpbigpfSR7QmFzZUNvaW4uY29pblRva2VuUGF0dGVyblNlcGFyYXRvcn0ke2NvZGV9JHtYbG0udG9rZW5QYXR0ZXJuU2VwYXJhdG9yfSR7aXNzdWVyfWA7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGUgd2hldGhlciBhIHN0ZWxsYXIgdXNlcm5hbWUgaGFzIHZhbGlkIGZvcm1hdFxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGJ5IHRoZSBjbGllbnQgd2hlbiBhIHN0ZWxsYXIgYWRkcmVzcyBpcyBiZWluZyBhZGRlZCB0byBhIHdhbGxldFxuICAgKiBFeGFtcGxlIG9mIGEgY29tbW9uIHN0ZWxsYXIgdXNlcm5hbWU6IGZvb0BiYXIuYmF6XG4gICAqIFRoZSBhYm92ZSBleGFtcGxlIHdvdWxkIHJlc3VsdCBpbiB0aGUgU3RlbGxhciBhZGRyZXNzOiBmb29AYmFyLmJheipiaXRnby5jb21cbiAgICpcbiAgICogQHBhcmFtIHVzZXJuYW1lIC0gc3RlbGxhciB1c2VybmFtZVxuICAgKiBAcmV0dXJuIHRydWUgaWYgc3RlbGxhciB1c2VybmFtZSBpcyB2YWxpZFxuICAgKi9cbiAgaXNWYWxpZFN0ZWxsYXJVc2VybmFtZSh1c2VybmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIC9eW2EtejAtOVxcLV8uK0BdKyQvLnRlc3QodXNlcm5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBGZWRlcmF0aW9uU2VydmVyIGZvciBCaXRHbyBsb29rdXBzXG4gICAqXG4gICAqIEByZXR1cm5zIGluc3RhbmNlIG9mIEJpdEdvIEZlZGVyYXRpb24gU2VydmVyXG4gICAqL1xuICBnZXRCaXRHb0ZlZGVyYXRpb25TZXJ2ZXIoKTogc3RlbGxhci5GZWRlcmF0aW9uU2VydmVyIHtcbiAgICAvLyBJZGVudGlmeSB0aGUgVVJJIHNjaGVtZSBpbiBjYXNlIHdlIG5lZWQgdG8gYWxsb3cgY29ubmVjdGluZyB0byBIVFRQIHNlcnZlci5cbiAgICBjb25zdCBpc05vblNlY3VyZUVudiA9ICFfLnN0YXJ0c1dpdGgoY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmJpdGdvLmVudl0udXJpLCAnaHR0cHMnKTtcbiAgICBjb25zdCBmZWRlcmF0aW9uU2VydmVyT3B0aW9ucyA9IHsgYWxsb3dIdHRwOiBpc05vblNlY3VyZUVudiB9O1xuICAgIHJldHVybiBuZXcgc3RlbGxhci5GZWRlcmF0aW9uU2VydmVyKHRoaXMuZ2V0RmVkZXJhdGlvblNlcnZlclVybCgpLCAnYml0Z28uY29tJywgZmVkZXJhdGlvblNlcnZlck9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gZmVkZXJhdGlvbiBsb29rdXBzXG4gICAqIE91ciBmZWRlcmF0aW9uIHNlcnZlciBoYW5kbGVzIGxvb2t1cHMgZm9yIGJpdGdvIGFzIHdlbGwgYXMgZm9yIG90aGVyIGZlZGVyYXRpb24gZG9tYWluc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FkZHJlc3NdIC0gYWRkcmVzcyB0byBsb29rIHVwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYWNjb3VudElkXSAtIGFjY291bnQgaWQgdG8gbG9vayB1cFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBmZWRlcmF0aW9uTG9va3VwKHtcbiAgICBhZGRyZXNzLFxuICAgIGFjY291bnRJZCxcbiAgfToge1xuICAgIGFkZHJlc3M/OiBzdHJpbmc7XG4gICAgYWNjb3VudElkPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIuUmVjb3JkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZlZGVyYXRpb25TZXJ2ZXIgPSB0aGlzLmdldEJpdEdvRmVkZXJhdGlvblNlcnZlcigpO1xuICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZlZGVyYXRpb25TZXJ2ZXIucmVzb2x2ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICB9IGVsc2UgaWYgKGFjY291bnRJZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZmVkZXJhdGlvblNlcnZlci5yZXNvbHZlQWNjb3VudElkKGFjY291bnRJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgLSBtdXN0IHByb3ZpZGUgU3RlbGxhciBhZGRyZXNzIG9yIGFjY291bnQgaWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnJvciA9IF8uZ2V0KGUsICdyZXNwb25zZS5kYXRhLmRldGFpbCcpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBTdGVsbGFyRmVkZXJhdGlvblVzZXJOb3RGb3VuZEVycm9yKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gcmVzb2x2ZSBhIHN0ZWxsYXIgYWRkcmVzcyBpbnRvIGEgc3RlbGxhciBhY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gc3RlbGxhciBhZGRyZXNzIHRvIGxvb2sgZm9yXG4gICAqL1xuICBhc3luYyBmZWRlcmF0aW9uTG9va3VwQnlOYW1lKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RlbGxhci5GZWRlcmF0aW9uU2VydmVyLlJlY29yZD4ge1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFN0ZWxsYXIgYWRkcmVzcycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZlZGVyYXRpb25Mb29rdXAoeyBhZGRyZXNzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gcmVzb2x2ZSBhbiBhY2NvdW50IGlkIGludG8gYSBzdGVsbGFyIGFjY291bnRcbiAgICogT25seSB3b3JrcyBmb3IgYWNjb3VudHMgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgYnkgb3VyIGZlZGVyYXRpb24gc2VydmVyXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgLSBzdGVsbGFyIGFjY291bnQgaWRcbiAgICovXG4gIGFzeW5jIGZlZGVyYXRpb25Mb29rdXBCeUFjY291bnRJZChhY2NvdW50SWQ6IHN0cmluZyk6IFByb21pc2U8c3RlbGxhci5GZWRlcmF0aW9uU2VydmVyLlJlY29yZD4ge1xuICAgIGlmICghYWNjb3VudElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU3RlbGxhciBhY2NvdW50Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZlZGVyYXRpb25Mb29rdXAoeyBhY2NvdW50SWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYWRkcmVzcyBpcyBhIHZhbGlkIFhMTSBhZGRyZXNzLCBhbmQgdGhlbiBtYWtlIHN1cmUgaXQgbWF0Y2hlcyB0aGUgcm9vdCBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyB7U3RyaW5nfSB0aGUgYWRkcmVzcyB0byB2ZXJpZnlcbiAgICogQHBhcmFtIHJvb3RBZGRyZXNzIHtTdHJpbmd9IHRoZSB3YWxsZXQncyByb290IGFkZHJlc3NcbiAgICovXG4gIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyh7IGFkZHJlc3MsIHJvb3RBZGRyZXNzIH06IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgIGNvbnN0IHJvb3RBZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMocm9vdEFkZHJlc3MpO1xuICAgIGlmIChhZGRyZXNzRGV0YWlscy5iYXNlQWRkcmVzcyAhPT0gcm9vdEFkZHJlc3NEZXRhaWxzLmFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yKFxuICAgICAgICBgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6ICR7YWRkcmVzc0RldGFpbHMuYmFzZUFkZHJlc3N9IHZzICR7cm9vdEFkZHJlc3NEZXRhaWxzLmFkZHJlc3N9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZXh0cmEgcGFyYW1ldGVycyBmb3IgcHJlYnVpbGRpbmcgYSB0eFxuICAgKiBTZXQgZW1wdHkgcmVjaXBpZW50cyBhcnJheSBpbiB0cnVzdGxpbmUgdHhzXG4gICAqL1xuICBhc3luYyBnZXRFeHRyYVByZWJ1aWxkUGFyYW1zKGJ1aWxkUGFyYW1zOiBFeHRyYVByZWJ1aWxkUGFyYW1zT3B0aW9ucyk6IFByb21pc2U8QnVpbGRPcHRpb25zPiB7XG4gICAgY29uc3QgcGFyYW1zOiB7IHJlY2lwaWVudHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+W10gfSA9IHt9O1xuICAgIGlmIChidWlsZFBhcmFtcy50eXBlID09PSAndHJ1c3RsaW5lJykge1xuICAgICAgcGFyYW1zLnJlY2lwaWVudHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgaW5pdGlhdGVSZWNvdmVyeShwYXJhbXM6IFJlY292ZXJ5T3B0aW9ucyk6IG5ldmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlcHJlY2F0ZWQgbWV0aG9kJyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdXNlcktleTogW2VuY3J5cHRlZF0gU3RlbGxhciBwcml2YXRlIGtleVxuICAgKiAtIGJhY2t1cEtleTogW2VuY3J5cHRlZF0gU3RlbGxhciBwcml2YXRlIGtleSwgb3IgcHVibGljIGtleSBpZiB0aGUgcHJpdmF0ZSBrZXkgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICAgKiAtIHdhbGxldFBhc3NwaHJhc2U6IG5lY2Vzc2FyeSBpZiBvbmUgb2YgdGhlIHByaXZhdGUga2V5cyBpcyBlbmNyeXB0ZWRcbiAgICogLSByb290QWRkcmVzczogYmFzZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgdG8gcmVjb3ZlciBmdW5kcyBmcm9tXG4gICAqIC0ga3JzUHJvdmlkZXI6IG5lY2Vzc2FyeSBpZiBiYWNrdXAga2V5IGlzIGhlbGQgYnkgS1JTXG4gICAqIC0gcmVjb3ZlcnlEZXN0aW5hdGlvbjogdGFyZ2V0IGFkZHJlc3MgdG8gc2VuZCByZWNvdmVyZWQgZnVuZHMgdG9cbiAgICovXG4gIGFzeW5jIHJlY292ZXIocGFyYW1zOiBSZWNvdmVyeU9wdGlvbnMpOiBQcm9taXNlPFJlY292ZXJ5VHJhbnNhY3Rpb24+IHtcbiAgICAvLyBDaGVjayBpZiB1bmVuY3J5cHRlZCByb290IGtleXMgd2VyZSBwcm92aWRlZCwgY29udmVydCB0byBTdGVsbGFyIGZvcm1hdCBpZiBuZWNlc3NhcnlcbiAgICBpZiAoVXRpbHMuaXNWYWxpZFJvb3RQcml2YXRlS2V5KHBhcmFtcy51c2VyS2V5KSkge1xuICAgICAgcGFyYW1zLnVzZXJLZXkgPSBVdGlscy5lbmNvZGVQcml2YXRlS2V5KEJ1ZmZlci5mcm9tKHBhcmFtcy51c2VyS2V5LnNsaWNlKDAsIDY0KSwgJ2hleCcpKTtcbiAgICB9IGVsc2UgaWYgKFV0aWxzLmlzVmFsaWRSb290UHVibGljS2V5KHBhcmFtcy51c2VyS2V5KSkge1xuICAgICAgcGFyYW1zLnVzZXJLZXkgPSBVdGlscy5lbmNvZGVQdWJsaWNLZXkoQnVmZmVyLmZyb20ocGFyYW1zLnVzZXJLZXksICdoZXgnKSk7XG4gICAgfVxuXG4gICAgaWYgKFV0aWxzLmlzVmFsaWRSb290UHJpdmF0ZUtleShwYXJhbXMuYmFja3VwS2V5KSkge1xuICAgICAgcGFyYW1zLmJhY2t1cEtleSA9IFV0aWxzLmVuY29kZVByaXZhdGVLZXkoQnVmZmVyLmZyb20ocGFyYW1zLmJhY2t1cEtleS5zbGljZSgwLCA2NCksICdoZXgnKSk7XG4gICAgfSBlbHNlIGlmIChVdGlscy5pc1ZhbGlkUm9vdFB1YmxpY0tleShwYXJhbXMuYmFja3VwS2V5KSkge1xuICAgICAgcGFyYW1zLmJhY2t1cEtleSA9IFV0aWxzLmVuY29kZVB1YmxpY0tleShCdWZmZXIuZnJvbShwYXJhbXMuYmFja3VwS2V5LCAnaGV4JykpO1xuICAgIH1cblxuICAgIC8vIFN0ZWxsYXIncyBFZDI1NTE5IHB1YmxpYyBrZXlzIHN0YXJ0IHdpdGggYSBHLCB3aGlsZSBwcml2YXRlIGtleXMgc3RhcnQgd2l0aCBhbiBTXG4gICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgnRycpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCdHJyk7XG4gICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCdHJykgJiYgcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgnRycpO1xuXG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIGNoZWNrS3JzUHJvdmlkZXIodGhpcywgcGFyYW1zLmtyc1Byb3ZpZGVyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignSW52YWxpZCBkZXN0aW5hdGlvbiBhZGRyZXNzIScpO1xuICAgIH1cblxuICAgIGNvbnN0IFt1c2VyS2V5LCBiYWNrdXBLZXldID0gZ2V0U3RlbGxhcktleXModGhpcy5iaXRnbywgcGFyYW1zKTtcblxuICAgIGlmICghcGFyYW1zLnJvb3RBZGRyZXNzIHx8ICFzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShwYXJhbXMucm9vdEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgd2FsbGV0IGFkZHJlc3M6ICR7cGFyYW1zLnJvb3RBZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY291bnREYXRhVXJsID0gYCR7dGhpcy5nZXRIb3Jpem9uVXJsKCl9L2FjY291bnRzLyR7cGFyYW1zLnJvb3RBZGRyZXNzfWA7XG4gICAgY29uc3QgZGVzdGluYXRpb25VcmwgPSBgJHt0aGlzLmdldEhvcml6b25VcmwoKX0vYWNjb3VudHMvJHtwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbn1gO1xuXG4gICAgbGV0IGFjY291bnREYXRhO1xuICAgIHRyeSB7XG4gICAgICBhY2NvdW50RGF0YSA9IGF3YWl0IHRvQml0Z29SZXF1ZXN0KHJlcXVlc3QuZ2V0KGFjY291bnREYXRhVXJsKSkucmVzdWx0KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVhY2ggdGhlIFN0ZWxsYXIgbmV0d29yayB2aWEgSG9yaXpvbi4nKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgY2hlY2sgaWYgdGhlIGRlc3RpbmF0aW9uIGFjY291bnQgaXMgZW1wdHkgb3Igbm90XG4gICAgbGV0IHVuZnVuZGVkRGVzdGluYXRpb24gPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmVxdWVzdC5nZXQoZGVzdGluYXRpb25VcmwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIC8vIElmIHRoZSBkZXN0aW5hdGlvbiBhY2NvdW50IGRvZXMgbm90IHlldCBleGlzdCwgaG9yaXpvbiByZXNwb25kcyB3aXRoIDQwNFxuICAgICAgICB1bmZ1bmRlZERlc3RpbmF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFjY291bnREYXRhLnNlcXVlbmNlIHx8ICFhY2NvdW50RGF0YS5iYWxhbmNlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb3Jpem9uIHNlcnZlciBlcnJvciAtIHVuYWJsZSB0byByZXRyaWV2ZSBzZXF1ZW5jZSBJRCBvciBhY2NvdW50IGJhbGFuY2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY2NvdW50ID0gbmV3IHN0ZWxsYXIuQWNjb3VudChwYXJhbXMucm9vdEFkZHJlc3MsIGFjY291bnREYXRhLnNlcXVlbmNlKTtcblxuICAgIC8vIFN0ZWxsYXIgc3VwcG9ydHMgbXVsdGlwbGUgYXNzZXRzIG9uIGNoYWluLCB3ZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gdGhlIGJhbGFuY2VzIGVudHJ5IHdob3NlIHR5cGUgaXMgXCJuYXRpdmVcIiAoWExNKVxuICAgIGNvbnN0IG5hdGl2ZUJhbGFuY2VJbmZvID0gYWNjb3VudERhdGEuYmFsYW5jZXMuZmluZCgoYXNzZXRCYWxhbmNlKSA9PiBhc3NldEJhbGFuY2VbJ2Fzc2V0X3R5cGUnXSA9PT0gJ25hdGl2ZScpO1xuXG4gICAgaWYgKCFuYXRpdmVCYWxhbmNlSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCB3YWxsZXQgaGFzIGEgYmFsYW5jZSBvZiAwIFhMTSwgcmVjb3ZlcnkgYWJvcnRlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHdhbGxldEJhbGFuY2UgPSBOdW1iZXIodGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKG5hdGl2ZUJhbGFuY2VJbmZvLmJhbGFuY2UpKTtcbiAgICBjb25zdCBtaW5pbXVtUmVzZXJ2ZSA9IGF3YWl0IHRoaXMuZ2V0TWluaW11bVJlc2VydmUoKTtcbiAgICBjb25zdCBiYXNlVHhGZWUgPSBhd2FpdCB0aGlzLmdldEJhc2VUcmFuc2FjdGlvbkZlZSgpO1xuICAgIGNvbnN0IHJlY292ZXJ5QW1vdW50ID0gd2FsbGV0QmFsYW5jZSAtIG1pbmltdW1SZXNlcnZlIC0gYmFzZVR4RmVlO1xuICAgIGNvbnN0IGZvcm1hdHRlZFJlY292ZXJ5QW1vdW50ID0gdGhpcy5iYXNlVW5pdHNUb0JpZ1VuaXRzKHJlY292ZXJ5QW1vdW50KS50b1N0cmluZygpO1xuXG4gICAgY29uc3QgdHhCdWlsZGVyID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb25CdWlsZGVyKGFjY291bnQsIHtcbiAgICAgIGZlZTogYmFzZVR4RmVlLnRvRml4ZWQoMCksXG4gICAgICBuZXR3b3JrUGFzc3BocmFzZTogdGhpcy5nZXRTdGVsbGFyTmV0d29yaygpLFxuICAgIH0pO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHVuZnVuZGVkRGVzdGluYXRpb25cbiAgICAgID8gLy8gSW4gdGhpcyBjYXNlLCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgYWNjb3VudFxuICAgICAgICBzdGVsbGFyLk9wZXJhdGlvbi5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICBkZXN0aW5hdGlvbjogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sXG4gICAgICAgICAgc3RhcnRpbmdCYWxhbmNlOiBmb3JtYXR0ZWRSZWNvdmVyeUFtb3VudCxcbiAgICAgICAgfSlcbiAgICAgIDogLy8gT3RoZXJ3aXNlIGlmIHRoZSBhY2NvdW50IGFscmVhZHkgZXhpc3RzLCB3ZSBkbyBhIG5vcm1hbCBzZW5kXG4gICAgICAgIHN0ZWxsYXIuT3BlcmF0aW9uLnBheW1lbnQoe1xuICAgICAgICAgIGRlc3RpbmF0aW9uOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbixcbiAgICAgICAgICBhc3NldDogc3RlbGxhci5Bc3NldC5uYXRpdmUoKSxcbiAgICAgICAgICBhbW91bnQ6IGZvcm1hdHRlZFJlY292ZXJ5QW1vdW50LFxuICAgICAgICB9KTtcbiAgICBjb25zdCB0eCA9IHR4QnVpbGRlci5hZGRPcGVyYXRpb24ob3BlcmF0aW9uKS5zZXRUaW1lb3V0KHN0ZWxsYXIuVGltZW91dEluZmluaXRlKS5idWlsZCgpO1xuXG4gICAgY29uc3QgZmVlSW5mbyA9IHtcbiAgICAgIGZlZTogbmV3IEJpZ051bWJlcih0eC5mZWUpLnRvTnVtYmVyKCksXG4gICAgICBmZWVTdHJpbmc6IHR4LmZlZSxcbiAgICB9O1xuXG4gICAgaWYgKCFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIHR4LnNpZ24odXNlcktleSk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0tyc1JlY292ZXJ5ICYmICFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIHR4LnNpZ24oYmFja3VwS2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbjogUmVjb3ZlcnlUcmFuc2FjdGlvbiA9IHtcbiAgICAgIHR4QmFzZTY0OiBYbG0udHhUb1N0cmluZyh0eCksXG4gICAgICByZWNvdmVyeUFtb3VudCxcbiAgICB9O1xuXG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXk7XG4gICAgfVxuXG4gICAgdHJhbnNhY3Rpb24uY29pbiA9IHRoaXMuZ2V0Q2hhaW4oKTtcbiAgICB0cmFuc2FjdGlvbi5mZWVJbmZvID0gZmVlSW5mbztcblxuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtPYmplY3R9IHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB7U3RyaW5nfSB1c2VyIHBydlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+fVxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8SGFsZlNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgeyB0eFByZWJ1aWxkLCBwcnYgfSA9IHBhcmFtcztcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4UHJlYnVpbGR9YCk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgcHJ2fWApO1xuICAgIH1cblxuICAgIGNvbnN0IGtleVBhaXIgPSBVdGlscy5jcmVhdGVTdGVsbGFyS2V5cGFpckZyb21QcnYocHJ2KTtcbiAgICBjb25zdCB0eCA9IG5ldyBzdGVsbGFyLlRyYW5zYWN0aW9uKHR4UHJlYnVpbGQudHhCYXNlNjQsIHRoaXMuZ2V0U3RlbGxhck5ldHdvcmsoKSk7XG4gICAgdHguc2lnbihrZXlQYWlyKTtcbiAgICBjb25zdCB0eEJhc2U2NCA9IFhsbS50eFRvU3RyaW5nKHR4KTtcblxuICAgIGNvbnN0IHR5cGUgPSB0eFByZWJ1aWxkPy5idWlsZFBhcmFtcz8udHlwZTtcbiAgICBjb25zdCByZWNpcGllbnRzID0gdHhQcmVidWlsZD8uYnVpbGRQYXJhbXM/LnJlY2lwaWVudHM7XG4gICAgaWYgKHR5cGUgPT09ICdlbmFibGV0b2tlbicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhbGZTaWduZWQ6IHsgdHhCYXNlNjQgfSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVjaXBpZW50cyxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IGhhbGZTaWduZWQ6IHsgdHhCYXNlNjQgfSB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgd2FsbGV0UGFyYW1zIHdpdGggZXh0cmEgcGFyYW1zIHJlcXVpcmVkIGZvciBnZW5lcmF0aW5nIGFuIFhMTSB3YWxsZXRcbiAgICpcbiAgICogU3RlbGxhciB3YWxsZXRzIGhhdmUgdGhyZWUga2V5Y2hhaW5zIG9uIHRoZW0uIFR3byBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBwbGF0Zm9ybSwgYW5kIHRoZSBsYXN0IGlzIGdlbmVyYXRlZCBieSB0aGUgdXNlci5cbiAgICogSW5pdGlhbGx5LCB3ZSBuZWVkIGEgcm9vdCBwcnYgdG8gZ2VuZXJhdGUgdGhlIGFjY291bnQsIHdoaWNoIG11c3QgYmUgZGlzdGluY3QgZnJvbSBhbGwgdGhyZWUga2V5Y2hhaW5zIG9uIHRoZSB3YWxsZXQuXG4gICAqIElmIGEgcm9vdCBwcnYgaXMgbm90IHByb3ZpZGVkLCBhIHJhbmRvbSBvbmUgaXMgZ2VuZXJhdGVkLlxuICAgKi9cbiAgYXN5bmMgc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KFxuICAgIHdhbGxldFBhcmFtczogU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9uc1xuICApOiBQcm9taXNlPFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnM+IHtcbiAgICBsZXQgc2VlZDtcbiAgICBjb25zdCByb290UHJ2ID0gd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5O1xuICAgIGlmIChyb290UHJ2KSB7XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZFBydihyb290UHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3RQcml2YXRlS2V5IG5lZWRzIHRvIGJlIHZhbGlkIGVkMjU1MTkgc2VjcmV0IHNlZWQnKTtcbiAgICAgIH1cbiAgICAgIHNlZWQgPSBzdGVsbGFyLlN0cktleS5kZWNvZGVFZDI1NTE5U2VjcmV0U2VlZChyb290UHJ2KTtcbiAgICB9XG4gICAgY29uc3Qga2V5UGFpciA9IHRoaXMuZ2VuZXJhdGVLZXlQYWlyKHNlZWQpO1xuICAgIC8vIGV4dGVuZCB0aGUgd2FsbGV0IGluaXRpYWxpemF0aW9uIHBhcmFtc1xuICAgIHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSA9IGtleVBhaXIucHJ2O1xuICAgIHJldHVybiB3YWxsZXRQYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkUHJ2KGtleS5wcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHJ2OiAke2tleS5wcnZ9YCk7XG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cGFpciA9IFV0aWxzLmNyZWF0ZVN0ZWxsYXJLZXlwYWlyRnJvbVBydihrZXkucHJ2KTtcbiAgICByZXR1cm4ga2V5cGFpci5zaWduKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGlmIHNpZ25hdHVyZSBmb3IgbWVzc2FnZSBpcyB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHB1YiBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlIHNpZ25lZCBtZXNzYWdlXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgc2lnbmF0dXJlIHRvIHZlcmlmeVxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZShwdWI6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyLCBzaWduYXR1cmU6IEJ1ZmZlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkUHViKHB1YikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwdWI6ICR7cHVifWApO1xuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGtleVBhaXIgPSBVdGlscy5jcmVhdGVTdGVsbGFyS2V5cGFpckZyb21QdWIocHViKTtcbiAgICByZXR1cm4ga2V5UGFpci52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICBjb25zdCB7IHR4SGV4LCB0eEJhc2U2NCB9ID0gcGFyYW1zO1xuICAgIGxldCB0eDogc3RlbGxhci5UcmFuc2FjdGlvbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICghdHhIZXggJiYgIXR4QmFzZTY0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGxhaW5UcmFuc2FjdGlvbiBtaXNzaW5nIHR4SGV4IG9yIHR4QmFzZTY0IHBhcmFtZXRlciwgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZScpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAodHhIZXgpIHtcbiAgICAgICAgdHggPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbihCdWZmZXIuZnJvbSh0eEhleCwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKSwgdGhpcy5nZXRTdGVsbGFyTmV0d29yaygpKTtcbiAgICAgIH0gZWxzZSBpZiAodHhCYXNlNjQpIHtcbiAgICAgICAgdHggPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbih0eEJhc2U2NCwgdGhpcy5nZXRTdGVsbGFyTmV0d29yaygpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4QmFzZTY0IG5lZWRzIHRvIGJlIGEgdmFsaWQgdHggZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0eCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eCBuZWVkcyB0byBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIGV4cGxhaW4gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSB0eC5oYXNoKCkudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgLy8gSW4gYSBTdGVsbGFyIHR4LCB0aGUgX21lbW8gcHJvcGVydHkgaXMgYW4gb2JqZWN0IHdpdGggdGhlIG1ldGhvZHM6XG4gICAgLy8gdmFsdWUoKSBhbmQgYXJtKCkgdGhhdCBwcm92aWRlIG1lbW8gdmFsdWUgYW5kIHR5cGUsIHJlc3BlY3RpdmVseS5cbiAgICBjb25zdCBtZW1vOiBUcmFuc2FjdGlvbk1lbW8gPVxuICAgICAgXy5yZXN1bHQodHgsICdfbWVtby52YWx1ZScpICYmIF8ucmVzdWx0KHR4LCAnX21lbW8uYXJtJylcbiAgICAgICAgPyB7XG4gICAgICAgICAgICB2YWx1ZTogKF8ucmVzdWx0KHR4LCAnX21lbW8udmFsdWUnKSBhcyBhbnkpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0eXBlOiBfLnJlc3VsdCh0eCwgJ19tZW1vLmFybScpLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7fTtcblxuICAgIGxldCBzcGVuZEFtb3VudCA9IG5ldyBCaWdOdW1iZXIoMCk7IC8vIGFtb3VudCBvZiBYTE0gdXNlZCBpbiBYTE0tb25seSB0eHNcbiAgICBjb25zdCBzcGVuZEFtb3VudHMgPSB7fTsgLy8gdHJhY2sgYm90aCB4bG0gYW5kIHRva2VuIGFtb3VudHNcbiAgICBpZiAoXy5pc0VtcHR5KHR4Lm9wZXJhdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3BlcmF0aW9ucycpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dHM6IFRyYW5zYWN0aW9uT3V0cHV0W10gPSBbXTtcbiAgICBjb25zdCBvcGVyYXRpb25zOiBUcmFuc2FjdGlvbk9wZXJhdGlvbltdID0gW107IC8vIG5vbi1wYXltZW50IG9wZXJhdGlvbnNcblxuICAgIF8uZm9yRWFjaCh0eC5vcGVyYXRpb25zLCAob3A6IHN0ZWxsYXIuT3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAob3AudHlwZSA9PT0gJ2NyZWF0ZUFjY291bnQnIHx8IG9wLnR5cGUgPT09ICdwYXltZW50Jykge1xuICAgICAgICAvLyBUT0RPIFJlbW92ZSBtZW1vSWQgZnJvbSBhZGRyZXNzXG4gICAgICAgIC8vIEdldCBtZW1vIHRvIGF0dGFjaCB0byBhZGRyZXNzLCBpZiB0eXBlIGlzICdpZCdcbiAgICAgICAgY29uc3QgbWVtb0lkID0gXy5nZXQobWVtbywgJ3R5cGUnKSA9PT0gJ2lkJyAmJiAhXy5nZXQobWVtbywgJ3ZhbHVlJykgPyBgP21lbW9JZD0ke21lbW8udmFsdWV9YCA6ICcnO1xuICAgICAgICBsZXQgYXNzZXQ7XG4gICAgICAgIGlmIChvcC50eXBlID09PSAncGF5bWVudCcpIHtcbiAgICAgICAgICBpZiAob3AuYXNzZXQuZ2V0QXNzZXRUeXBlKCkgPT09ICdsaXF1aWRpdHlfcG9vbF9zaGFyZXMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXNzZXQgdHlwZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NldCA9IG9wLmFzc2V0IGFzIHN0ZWxsYXIuQXNzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXQgPSBzdGVsbGFyLkFzc2V0Lm5hdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvaW4gPSB0aGlzLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQoYXNzZXQpOyAvLyBjb2luIG9yIHRva2VuIGlkXG4gICAgICAgIGNvbnN0IG91dHB1dDogVHJhbnNhY3Rpb25PdXRwdXQgPSB7XG4gICAgICAgICAgYW1vdW50OiB0aGlzLmJpZ1VuaXRzVG9CYXNlVW5pdHMoXG4gICAgICAgICAgICAob3AgYXMgc3RlbGxhci5PcGVyYXRpb24uQ3JlYXRlQWNjb3VudCkuc3RhcnRpbmdCYWxhbmNlIHx8IChvcCBhcyBzdGVsbGFyLk9wZXJhdGlvbi5QYXltZW50KS5hbW91bnRcbiAgICAgICAgICApLFxuICAgICAgICAgIGFkZHJlc3M6IG9wLmRlc3RpbmF0aW9uICsgbWVtb0lkLFxuICAgICAgICAgIGNvaW4sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHNwZW5kQW1vdW50c1tjb2luXSkpIHtcbiAgICAgICAgICBzcGVuZEFtb3VudHNbY29pbl0gPSBzcGVuZEFtb3VudHNbY29pbl0ucGx1cyhvdXRwdXQuYW1vdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGVuZEFtb3VudHNbY29pbl0gPSBuZXcgQmlnTnVtYmVyKG91dHB1dC5hbW91bnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3NldC5pc05hdGl2ZSgpKSB7XG4gICAgICAgICAgc3BlbmRBbW91bnQgPSBzcGVuZEFtb3VudC5wbHVzKG91dHB1dC5hbW91bnQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dHMucHVzaChvdXRwdXQpO1xuICAgICAgfSBlbHNlIGlmIChvcC50eXBlID09PSAnY2hhbmdlVHJ1c3QnKSB7XG4gICAgICAgIGlmIChvcC5saW5lLmdldEFzc2V0VHlwZSgpID09PSAnbGlxdWlkaXR5X3Bvb2xfc2hhcmVzJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhc3NldCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXNzZXQgPSBvcC5saW5lIGFzIHN0ZWxsYXIuQXNzZXQ7XG5cbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBvcC50eXBlLFxuICAgICAgICAgIGNvaW46IHRoaXMuZ2V0VG9rZW5OYW1lRnJvbVN0ZWxsYXJBc3NldChhc3NldCksXG4gICAgICAgICAgYXNzZXQsXG4gICAgICAgICAgbGltaXQ6IHRoaXMuYmlnVW5pdHNUb0Jhc2VVbml0cyhvcC5saW1pdCksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gc3BlbmRBbW91bnQudG9GaXhlZCgwKTtcbiAgICBjb25zdCBvdXRwdXRBbW91bnRzID0gXy5tYXBWYWx1ZXMoc3BlbmRBbW91bnRzLCAoYW1vdW50OiBCaWdOdW1iZXIpID0+IGFtb3VudC50b0ZpeGVkKDApKTtcbiAgICBjb25zdCBmZWUgPSB7XG4gICAgICBmZWU6IG5ldyBCaWdOdW1iZXIodHguZmVlKS50b0ZpeGVkKDApLFxuICAgICAgZmVlUmF0ZTogbnVsbCxcbiAgICAgIHNpemU6IG51bGwsXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5T3JkZXI6IFtcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ291dHB1dEFtb3VudCcsXG4gICAgICAgICdvdXRwdXRBbW91bnRzJyxcbiAgICAgICAgJ2NoYW5nZUFtb3VudCcsXG4gICAgICAgICdvdXRwdXRzJyxcbiAgICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgICAnZmVlJyxcbiAgICAgICAgJ21lbW8nLFxuICAgICAgICAnb3BlcmF0aW9ucycsXG4gICAgICBdLFxuICAgICAgaWQsXG4gICAgICBvdXRwdXRzLFxuICAgICAgb3V0cHV0QW1vdW50LFxuICAgICAgb3V0cHV0QW1vdW50cyxcbiAgICAgIGNoYW5nZU91dHB1dHM6IFtdLFxuICAgICAgY2hhbmdlQW1vdW50OiAnMCcsXG4gICAgICBtZW1vLFxuICAgICAgZmVlLFxuICAgICAgb3BlcmF0aW9ucyxcbiAgICB9IGFzIGFueTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHR4IHByZWJ1aWxkJ3Mgb3BlcmF0aW9ucyBjb21wbHkgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqIEBwYXJhbSB7c3RlbGxhci5PcGVyYXRpb259IG9wZXJhdGlvbnMgLSB0eCBvcGVyYXRpb25zXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25QYXJhbXN9IHR4UGFyYW1zIC0gcGFyYW1zIHVzZWQgdG8gYnVpbGQgdGhlIHR4XG4gICAqL1xuICB2ZXJpZnlFbmFibGVUb2tlblR4T3BlcmF0aW9ucyhvcGVyYXRpb25zOiBzdGVsbGFyLk9wZXJhdGlvbltdLCB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXMpOiB2b2lkIHtcbiAgICBjb25zdCB0cnVzdGxpbmVPcGVyYXRpb25zID0gXy5maWx0ZXIob3BlcmF0aW9ucywgWyd0eXBlJywgJ2NoYW5nZVRydXN0J10pIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLkNoYW5nZVRydXN0W107XG4gICAgaWYgKHRydXN0bGluZU9wZXJhdGlvbnMubGVuZ3RoICE9PSBfLmdldCh0eFBhcmFtcywgJ3JlY2lwaWVudHMnLCBbXSkubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHRydXN0bGluZSBvcGVyYXRpb25zJyk7XG4gICAgfVxuICAgIF8uZm9yRWFjaCh0cnVzdGxpbmVPcGVyYXRpb25zLCAob3A6IHN0ZWxsYXIuT3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gJ2NoYW5nZVRydXN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXNzZXQgdHlwZScpO1xuICAgICAgfVxuICAgICAgaWYgKG9wLmxpbmUuZ2V0QXNzZXRUeXBlKCkgPT09ICdsaXF1aWRpdHlfcG9vbF9zaGFyZXMnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhc3NldCB0eXBlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBhc3NldCA9IG9wLmxpbmUgYXMgc3RlbGxhci5Bc3NldDtcbiAgICAgIGNvbnN0IG9wVG9rZW4gPSB0aGlzLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQoYXNzZXQpO1xuICAgICAgY29uc3QgdG9rZW5UcnVzdGxpbmUgPSBfLmZpbmQodHhQYXJhbXMucmVjaXBpZW50cywgKHJlY2lwaWVudCkgPT4ge1xuICAgICAgICAvLyB0cnVzdGxpbmUgcGFyYW1zIHVzZSBsaW1pdHMgaW4gYmFzZSB1bml0c1xuICAgICAgICBjb25zdCBvcExpbWl0QmFzZVVuaXRzID0gdGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKG9wLmxpbWl0KTtcbiAgICAgICAgLy8gRW5hYmxlIHRva2VuIGxpbWl0IGlzIHNldCB0byBYbG0ubWF4VHJ1c3RsaW5lTGltaXQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gcmVjaXBpZW50LnRva2VuTmFtZSA9PT0gb3BUb2tlbiAmJiBvcExpbWl0QmFzZVVuaXRzID09PSBYbG0ubWF4VHJ1c3RsaW5lTGltaXQ7XG4gICAgICB9KTtcbiAgICAgIGlmICghdG9rZW5UcnVzdGxpbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCB0cnVzdGxpbmUgdG9rZW5zJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0eCBwcmVidWlsZCdzIG9wZXJhdGlvbnMgY29tcGx5IHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKiBAcGFyYW0ge3N0ZWxsYXIuT3BlcmF0aW9ufSBvcGVyYXRpb25zIC0gdHggb3BlcmF0aW9uc1xuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUGFyYW1zfSB0eFBhcmFtcyAtIHBhcmFtcyB1c2VkIHRvIGJ1aWxkIHRoZSB0eFxuICAgKi9cbiAgdmVyaWZ5VHJ1c3RsaW5lVHhPcGVyYXRpb25zKG9wZXJhdGlvbnM6IHN0ZWxsYXIuT3BlcmF0aW9uW10sIHR4UGFyYW1zOiBUcmFuc2FjdGlvblBhcmFtcyk6IHZvaWQge1xuICAgIGNvbnN0IHRydXN0bGluZU9wZXJhdGlvbnMgPSBfLmZpbHRlcihvcGVyYXRpb25zLCBbJ3R5cGUnLCAnY2hhbmdlVHJ1c3QnXSkgYXMgc3RlbGxhci5PcGVyYXRpb24uQ2hhbmdlVHJ1c3RbXTtcbiAgICBpZiAodHJ1c3RsaW5lT3BlcmF0aW9ucy5sZW5ndGggIT09IF8uZ2V0KHR4UGFyYW1zLCAndHJ1c3RsaW5lcycsIFtdKS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgdHJ1c3RsaW5lIG9wZXJhdGlvbnMnKTtcbiAgICB9XG4gICAgXy5mb3JFYWNoKHRydXN0bGluZU9wZXJhdGlvbnMsIChvcDogc3RlbGxhci5PcGVyYXRpb24pID0+IHtcbiAgICAgIGlmIChvcC50eXBlICE9PSAnY2hhbmdlVHJ1c3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhc3NldCB0eXBlJyk7XG4gICAgICB9XG4gICAgICBpZiAob3AubGluZS5nZXRBc3NldFR5cGUoKSA9PT0gJ2xpcXVpZGl0eV9wb29sX3NoYXJlcycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFzc2V0IHR5cGUnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFzc2V0ID0gb3AubGluZSBhcyBzdGVsbGFyLkFzc2V0O1xuICAgICAgY29uc3Qgb3BUb2tlbiA9IHRoaXMuZ2V0VG9rZW5OYW1lRnJvbVN0ZWxsYXJBc3NldChhc3NldCk7XG4gICAgICBjb25zdCB0b2tlblRydXN0bGluZSA9IF8uZmluZCh0eFBhcmFtcy50cnVzdGxpbmVzLCAodHJ1c3RsaW5lKSA9PiB7XG4gICAgICAgIC8vIHRydXN0bGluZSBwYXJhbXMgdXNlIGxpbWl0cyBpbiBiYXNlIHVuaXRzXG4gICAgICAgIGNvbnN0IG9wTGltaXRCYXNlVW5pdHMgPSB0aGlzLmJpZ1VuaXRzVG9CYXNlVW5pdHMob3AubGltaXQpO1xuICAgICAgICAvLyBQcmVwYXJlIHRoZSBjb25kaXRpb25zIHRvIGNoZWNrIGZvclxuICAgICAgICAvLyBMaW1pdCB3aWxsIGFsd2F5cyBiZSBzZXQgaW4gdGhlIG9wZXJhdGlvbiwgZXZlbiBpZiBpdCB3YXMgb21pdHRlZCBmcm9tIHR4UGFyYW1zIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgIC8vIDEuIEFjdGlvbiBpcyAnYWRkJyAtIGxpbWl0IGlzIHNldCB0byBYbG0ubWF4VHJ1c3RsaW5lTGltaXQgYnkgZGVmYXVsdFxuICAgICAgICAvLyAyLiBBY3Rpb24gaXMgJ3JlbW92ZScgLSBsaW1pdCBpcyBzZXQgdG8gJzAnXG4gICAgICAgIGNvbnN0IG5vTGltaXQgPSBfLmlzVW5kZWZpbmVkKHRydXN0bGluZS5saW1pdCk7XG4gICAgICAgIGNvbnN0IGFkZFRydXN0bGluZVdpdGhEZWZhdWx0TGltaXQgPSB0cnVzdGxpbmUuYWN0aW9uID09PSAnYWRkJyAmJiBvcExpbWl0QmFzZVVuaXRzID09PSBYbG0ubWF4VHJ1c3RsaW5lTGltaXQ7XG4gICAgICAgIGNvbnN0IHJlbW92ZVRydXN0bGluZSA9IHRydXN0bGluZS5hY3Rpb24gPT09ICdyZW1vdmUnICYmIG9wTGltaXRCYXNlVW5pdHMgPT09ICcwJztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0cnVzdGxpbmUudG9rZW4gPT09IG9wVG9rZW4gJiZcbiAgICAgICAgICAodHJ1c3RsaW5lLmxpbWl0ID09PSBvcExpbWl0QmFzZVVuaXRzIHx8IChub0xpbWl0ICYmIChhZGRUcnVzdGxpbmVXaXRoRGVmYXVsdExpbWl0IHx8IHJlbW92ZVRydXN0bGluZSkpKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRva2VuVHJ1c3RsaW5lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgdHJ1c3RsaW5lIHRva2VucycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgY29tcGxpZXMgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLnR4UHJlYnVpbGQgcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHBsYXRmb3JtXG4gICAqIEBwYXJhbSBvcHRpb25zLnR4UHJlYnVpbGQudHhCYXNlNjQgcHJlYnVpbHQgdHJhbnNhY3Rpb24gZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5nXG4gICAqIEBwYXJhbSBvcHRpb25zLndhbGxldCB3YWxsZXQgb2JqZWN0IHRvIG9idGFpbiBrZXlzIHRvIHZlcmlmeSBhZ2FpbnN0XG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbiBzcGVjaWZ5aW5nIHNvbWUgdmVyaWZpY2F0aW9uIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMudmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nIERpc2FsbG93IGZldGNoaW5nIGFueSBkYXRhIGZyb20gdGhlIGludGVybmV0IGZvciB2ZXJpZmljYXRpb24gcHVycG9zZXNcbiAgICogQHBhcmFtIG9wdGlvbnMudmVyaWZpY2F0aW9uLmtleWNoYWlucyBQYXNzIGtleWNoYWlucyBtYW51YWxseSByYXRoZXIgdGhhbiBmZXRjaGluZyB0aGVtIGJ5IGlkXG4gICAqL1xuICBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbihvcHRpb25zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAvLyBUT0RPIEJHLTU2MDAgQWRkIHBhcnNlVHJhbnNhY3Rpb24gLyBpbXByb3ZlIHZlcmlmaWNhdGlvblxuICAgIGNvbnN0IHsgdHhQYXJhbXMsIHR4UHJlYnVpbGQsIHdhbGxldCwgdmVyaWZpY2F0aW9uID0ge30gfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZGlzYWJsZU5ldHdvcmtpbmcgPSAhIXZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZztcblxuICAgIGlmICghdHhQcmVidWlsZC50eEJhc2U2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4IHByZWJ1aWxkIHByb3BlcnR5IHR4QmFzZTY0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgdHggPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbih0eFByZWJ1aWxkLnR4QmFzZTY0LCB0aGlzLmdldFN0ZWxsYXJOZXR3b3JrKCkpO1xuXG4gICAgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMgJiYgdHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IG1vcmUgdGhhbiAxIHJlY2lwaWVudCcpO1xuICAgIH1cblxuICAgIC8vIFN0ZWxsYXIgdHhzIGFyZSBtYWRlIHVwIG9mIG9wZXJhdGlvbnMuIFdlIG9ubHkgY2FyZSBhYm91dCBDcmVhdGUgQWNjb3VudCBhbmQgUGF5bWVudCBmb3Igc2VuZGluZyBmdW5kcy5cbiAgICBjb25zdCBvdXRwdXRPcGVyYXRpb25zID0gXy5maWx0ZXIoXG4gICAgICB0eC5vcGVyYXRpb25zLFxuICAgICAgKG9wZXJhdGlvbikgPT4gb3BlcmF0aW9uLnR5cGUgPT09ICdjcmVhdGVBY2NvdW50JyB8fCBvcGVyYXRpb24udHlwZSA9PT0gJ3BheW1lbnQnXG4gICAgKTtcblxuICAgIGlmICh0eFBhcmFtcy50eXBlID09PSAnZW5hYmxldG9rZW4nKSB7XG4gICAgICB0aGlzLnZlcmlmeUVuYWJsZVRva2VuVHhPcGVyYXRpb25zKHR4Lm9wZXJhdGlvbnMsIHR4UGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKHR4UGFyYW1zLnR5cGUgPT09ICd0cnVzdGxpbmUnKSB7XG4gICAgICB0aGlzLnZlcmlmeVRydXN0bGluZVR4T3BlcmF0aW9ucyh0eC5vcGVyYXRpb25zLCB0eFBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfLmlzRW1wdHkob3V0cHV0T3BlcmF0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBoYXZlIGFueSBvcGVyYXRpb25zJyk7XG4gICAgICB9XG5cbiAgICAgIF8uZm9yRWFjaCh0eFBhcmFtcy5yZWNpcGllbnRzLCAoZXhwZWN0ZWRPdXRwdXQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0QWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGV4cGVjdGVkT3V0cHV0LmFkZHJlc3MpO1xuICAgICAgICBjb25zdCBleHBlY3RlZE91dHB1dEFkZHJlc3MgPSBleHBlY3RlZE91dHB1dEFkZHJlc3NEZXRhaWxzLmFkZHJlc3M7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dE9wZXJhdGlvbnNbaW5kZXhdIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLlBheW1lbnQgfCBzdGVsbGFyLk9wZXJhdGlvbi5DcmVhdGVBY2NvdW50O1xuICAgICAgICBpZiAob3V0cHV0LmRlc3RpbmF0aW9uICE9PSBleHBlY3RlZE91dHB1dEFkZHJlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHJlY2lwaWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXRBbW91bnQgPSBuZXcgQmlnTnVtYmVyKGV4cGVjdGVkT3V0cHV0LmFtb3VudCk7XG4gICAgICAgIC8vIFRoZSBvdXRwdXQgYW1vdW50IGlzIGV4cHJlc3NlZCBhcyBzdGFydGluZ0JhbGFuY2UgaW4gY3JlYXRlQWNjb3VudCBvcGVyYXRpb25zIGFuZCBhcyBhbW91bnQgaW4gcGF5bWVudCBvcGVyYXRpb25zLlxuICAgICAgICBjb25zdCBvdXRwdXRBbW91bnRTdHJpbmcgPSBvdXRwdXQudHlwZSA9PT0gJ2NyZWF0ZUFjY291bnQnID8gb3V0cHV0LnN0YXJ0aW5nQmFsYW5jZSA6IG91dHB1dC5hbW91bnQ7XG4gICAgICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IG5ldyBCaWdOdW1iZXIodGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKG91dHB1dEFtb3VudFN0cmluZykpO1xuXG4gICAgICAgIGlmICghb3V0cHV0QW1vdW50LmVxKGV4cGVjdGVkT3V0cHV0QW1vdW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgYW1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSB0aGUgdXNlciBzaWduYXR1cmUsIGlmIHRoZSB0eCBpcyBoYWxmLXNpZ25lZFxuICAgIGlmICghXy5pc0VtcHR5KHR4LnNpZ25hdHVyZXMpKSB7XG4gICAgICBjb25zdCB1c2VyU2lnbmF0dXJlID0gdHguc2lnbmF0dXJlc1swXS5zaWduYXR1cmUoKTtcblxuICAgICAgLy8gb2J0YWluIHRoZSBrZXljaGFpbnMgYW5kIGtleSBzaWduYXR1cmVzXG4gICAgICBsZXQga2V5Y2hhaW5zID0gdmVyaWZpY2F0aW9uLmtleWNoYWlucztcbiAgICAgIGlmICgha2V5Y2hhaW5zICYmIGRpc2FibGVOZXR3b3JraW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGZldGNoIGtleWNoYWlucyB3aXRob3V0IG5ldHdvcmtpbmcnKTtcbiAgICAgIH0gZWxzZSBpZiAoIWtleWNoYWlucykge1xuICAgICAgICBrZXljaGFpbnMgPSBhd2FpdCBwcm9taXNlUHJvcHMoe1xuICAgICAgICAgIHVzZXI6IHRoaXMua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVtLZXlJbmRpY2VzLlVTRVJdIH0pLFxuICAgICAgICAgIGJhY2t1cDogdGhpcy5rZXljaGFpbnMoKS5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpW0tleUluZGljZXMuQkFDS1VQXSB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgha2V5Y2hhaW5zIHx8ICFrZXljaGFpbnMuYmFja3VwIHx8ICFrZXljaGFpbnMudXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleWNoYWlucyBhcmUgcmVxdWlyZWQsIGJ1dCBjb3VsZCBub3QgYmUgZmV0Y2hlZCcpO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQoa2V5Y2hhaW5zLmJhY2t1cC5wdWIpO1xuICAgICAgaWYgKHRoaXMudmVyaWZ5U2lnbmF0dXJlKGtleWNoYWlucy5iYWNrdXAucHViLCB0eC5oYXNoKCksIHVzZXJTaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gc2lnbmVkIHdpdGggd3Jvbmcga2V5Jyk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoa2V5Y2hhaW5zLnVzZXIucHViKTtcbiAgICAgIGlmICghdGhpcy52ZXJpZnlTaWduYXR1cmUoa2V5Y2hhaW5zLnVzZXIucHViLCB0eC5oYXNoKCksIHVzZXJTaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gc2lnbmF0dXJlIGludmFsaWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBpbmhlcml0ZG9jICovXG4gIGRlcml2ZUtleVdpdGhTZWVkKCk6IHsgZGVyaXZhdGlvblBhdGg6IHN0cmluZzsga2V5OiBzdHJpbmcgfSB7XG4gICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCgnbWV0aG9kIGRlcml2ZUtleVdpdGhTZWVkIG5vdCBzdXBwb3J0ZWQgZm9yIGVkZHNhIGN1cnZlJyk7XG4gIH1cblxuICAvKipcbiAgICogc3RlbGxhci1zZGsgaGFzIHR3byBvdmVybG9hZHMgZm9yIHRvWERSLCBhbmQgdHlwZXNjcmlwdCBjYW4ndCBzZWVtIHRvIGZpZ3VyZSBvdXQgdGhlXG4gICAqIGNvcnJlY3Qgb25lIHRvIHVzZSwgc28gd2UgaGF2ZSB0byBiZSB2ZXJ5IGV4cGxpY2l0IGFzIHRvIHdoaWNoIG9uZSB3ZSB3YW50LlxuICAgKiBAcGFyYW0gdHggdHJhbnNhY3Rpb24gdG8gY29udmVydFxuICAgKi9cbiAgcHJvdGVjdGVkIHN0YXRpYyB0eFRvU3RyaW5nID0gKHR4OiBzdGVsbGFyLlRyYW5zYWN0aW9uKTogc3RyaW5nID0+XG4gICAgKHR4LnRvRW52ZWxvcGUoKS50b1hEUiBhcyAoXzogc3RyaW5nKSA9PiBzdHJpbmcpKCdiYXNlNjQnKTtcblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY29uZmlnIGZvciBob3cgdG9rZW4gZW5hYmxlbWVudHMgd29yayBmb3IgdGhpcyBjb2luXG4gICAqIEByZXR1cm5zXG4gICAqICAgIHJlcXVpcmVzVG9rZW5FbmFibGVtZW50OiBUcnVlIGlmIHRva2VucyBuZWVkIHRvIGJlIGVuYWJsZWQgZm9yIHRoaXMgY29pblxuICAgKiAgICBzdXBwb3J0c011bHRpcGxlVG9rZW5FbmFibGVtZW50czogVHJ1ZSBpZiBtdWx0aXBsZSB0b2tlbnMgY2FuIGJlIGVuYWJsZWQgaW4gb25lIHRyYW5zYWN0aW9uXG4gICAqL1xuICBnZXRUb2tlbkVuYWJsZW1lbnRDb25maWcoKTogVG9rZW5FbmFibGVtZW50Q29uZmlnIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWlyZXNUb2tlbkVuYWJsZW1lbnQ6IHRydWUsXG4gICAgICBzdXBwb3J0c011bHRpcGxlVG9rZW5FbmFibGVtZW50czogZmFsc2UsXG4gICAgfTtcbiAgfVxufVxuIl19