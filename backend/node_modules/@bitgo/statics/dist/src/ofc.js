"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tofcPolygonErc20 = exports.ofcPolygonErc20 = exports.tofcAvaxErc20 = exports.ofcAvaxErc20 = exports.tofcArbethErc20 = exports.ofcArbethErc20 = exports.tofcHederaToken = exports.ofcHederaToken = exports.tofcAlgoToken = exports.ofcAlgoToken = exports.tofcStellarToken = exports.ofcStellarToken = exports.tofcsolToken = exports.ofcsolToken = exports.tofcerc20 = exports.ofcerc20 = exports.tofc = exports.ofc = exports.OfcCoin = void 0;
const base_1 = require("./base");
const networks_1 = require("./networks");
/**
 * OFC (off chain) coins. These are virtual coins used to represent off chain assets on the BitGo platform.
 */
class OfcCoin extends base_1.BaseCoin {
    constructor(options) {
        const { addressCoin, ...baseOptions } = options;
        super(baseOptions);
        this.addressCoin = addressCoin;
    }
    requiredFeatures() {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL, base_1.CoinFeature.REQUIRES_BIG_NUMBER]);
    }
    disallowedFeatures() {
        return new Set([
            base_1.CoinFeature.UNSPENT_MODEL,
            base_1.CoinFeature.CHILD_PAYS_FOR_PARENT,
            base_1.CoinFeature.PAYGO,
            base_1.CoinFeature.SUPPORTS_TOKENS,
        ]);
    }
}
exports.OfcCoin = OfcCoin;
OfcCoin.DEFAULT_FEATURES = [
    base_1.CoinFeature.ACCOUNT_MODEL,
    base_1.CoinFeature.REQUIRES_BIG_NUMBER,
    base_1.CoinFeature.CUSTODY,
    base_1.CoinFeature.CUSTODY_BITGO_TRUST,
];
/**
 * Factory function for ofc coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofc(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, 
/** OFC tokens use SECP256K1 under the hood even if the chain doesn't **/
primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.OFC,
    }));
}
exports.ofc = ofc;
/**
 * Factory function for testnet ofc coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofc(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.OFC,
    }));
}
exports.tofc = tofc;
/**
 * Factory function for ofc erc20 coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcerc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'eth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.ofcerc20 = ofcerc20;
/**
 * Factory function for testnet ofc erc20 coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcerc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'teth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.tofcerc20 = tofcerc20;
/**
 * Factory function for ofc solana token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param features
 * @param prefix
 * @param suffix
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param isToken
 * @param addressCoin
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcsolToken(id, name, fullName, decimalPlaces, asset, features = [...OfcCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], kind = base_1.CoinKind.CRYPTO, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'sol', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.SOL,
    }));
}
exports.ofcsolToken = ofcsolToken;
/**
 * Factory function for testnet ofc solana token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param features
 * @param prefix
 * @param suffix
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param isToken
 * @param addressCoin
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcsolToken(id, name, fullName, decimalPlaces, asset, features = [...OfcCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], kind = base_1.CoinKind.CRYPTO, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'tsol', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.SOL,
    }));
}
exports.tofcsolToken = tofcsolToken;
/**
 * Factory function for ofc stellar token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcStellarToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'xlm', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.XLM,
    }));
}
exports.ofcStellarToken = ofcStellarToken;
/**
 * Factory function for testnet ofc stellar token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcStellarToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'txlm', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.XLM,
    }));
}
exports.tofcStellarToken = tofcStellarToken;
/**
 * Factory function for ofc algo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcAlgoToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'algo', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ALGO,
    }));
}
exports.ofcAlgoToken = ofcAlgoToken;
/**
 * Factory function for testnet ofc algo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcAlgoToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'talgo', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ALGO,
    }));
}
exports.tofcAlgoToken = tofcAlgoToken;
/**
 * Factory function for ofc hedera token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcHederaToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'hbar', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.HBAR,
    }));
}
exports.ofcHederaToken = ofcHederaToken;
/**
 * Factory function for testnet ofc hedera token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcHederaToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'thbar', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.HBAR,
    }));
}
exports.tofcHederaToken = tofcHederaToken;
/**
 * Factory function for ofc arbethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcArbethErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'arbeth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.ofcArbethErc20 = ofcArbethErc20;
/**
 * Factory function for testnet ofc arbethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcArbethErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'tarbeth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.tofcArbethErc20 = tofcArbethErc20;
/**
 * Factory function for ofc avaxErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcAvaxErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'avaxc', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.ofcAvaxErc20 = ofcAvaxErc20;
/**
 * Factory function for testnet ofc avaxErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcAvaxErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'tavaxc', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.tofcAvaxErc20 = tofcAvaxErc20;
/**
 * Factory function for ofc polygonErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcPolygonErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'polygon', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.ofcPolygonErc20 = ofcPolygonErc20;
/**
 * Factory function for testnet ofc polygonErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcPolygonErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'tpolygon', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.tofcPolygonErc20 = tofcPolygonErc20;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2ZjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL29mYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxpQ0FBOEY7QUFDOUYseUNBQStEO0FBbUIvRDs7R0FFRztBQUNILE1BQWEsT0FBUSxTQUFRLGVBQVE7SUFXbkMsWUFBWSxPQUE4QjtRQUN4QyxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsV0FBVyxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQ2hELEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNqQyxDQUFDO0lBRVMsZ0JBQWdCO1FBQ3hCLE9BQU8sSUFBSSxHQUFHLENBQWMsQ0FBQyxrQkFBVyxDQUFDLGFBQWEsRUFBRSxrQkFBVyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRVMsa0JBQWtCO1FBQzFCLE9BQU8sSUFBSSxHQUFHLENBQWM7WUFDMUIsa0JBQVcsQ0FBQyxhQUFhO1lBQ3pCLGtCQUFXLENBQUMscUJBQXFCO1lBQ2pDLGtCQUFXLENBQUMsS0FBSztZQUNqQixrQkFBVyxDQUFDLGVBQWU7U0FDNUIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7QUE1QkgsMEJBNkJDO0FBNUJ3Qix3QkFBZ0IsR0FBRztJQUN4QyxrQkFBVyxDQUFDLGFBQWE7SUFDekIsa0JBQVcsQ0FBQyxtQkFBbUI7SUFDL0Isa0JBQVcsQ0FBQyxPQUFPO0lBQ25CLGtCQUFXLENBQUMsbUJBQW1CO0NBQ2hDLENBQUM7QUF5Qko7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsU0FBZ0IsR0FBRyxDQUNqQixFQUFVLEVBQ1YsSUFBWSxFQUNaLFFBQWdCLEVBQ2hCLGFBQXFCLEVBQ3JCLEtBQXNCLEVBQ3RCLE9BQWlCLGVBQVEsQ0FBQyxNQUFNLEVBQ2hDLFdBQTBCLE9BQU8sQ0FBQyxnQkFBZ0IsRUFDbEQsTUFBTSxHQUFHLEVBQUUsRUFDWCxTQUFpQixJ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QUM5QixFQUFVLEVBQ1YsSUFBWSxFQUNaLFFBQWdCLEVBQ2hCLGFBQXFCLEVBQ3JCLEtBQXNCLEVBQ3RCLE9BQWlCLGVBQVEsQ0FBQyxNQUFNLEVBQ2hDLFdBQTBCLE9BQU8sQ0FBQyxnQkFBZ0IsRUFDbEQsTUFBTSxHQUFHLEVBQUUsRUFDWCxTQUFpQixJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFDdkQsVUFBc0IsbUJBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUN2QyxPQUFPLEdBQUcsSUFBSSxFQUNkLFdBQVcsR0FBRyxVQUFVLEVBQ3hCLGtCQUE0QixlQUFRLENBQUMsU0FBUztJQUU5QyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQ2xCLElBQUksT0FBTyxDQUFDO1FBQ1YsRUFBRTtRQUNGLElBQUk7UUFDSixRQUFRO1FBQ1IsT0FBTztRQUNQLE1BQU07UUFDTixNQUFNO1FBQ04sUUFBUTtRQUNSLGFBQWE7UUFDYixPQUFPO1FBQ1AsS0FBSztRQUNMLElBQUk7UUFDSixXQUFXO1FBQ1gsZUFBZTtRQUNmLFFBQVEsRUFBRSxlQUFRLENBQUMsR0FBRztLQUN2QixDQUFDLENBQ0gsQ0FBQztBQUNKLENBQUM7QUFqQ0QsNENBaUNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4sIEJhc2VVbml0LCBDb2luRmVhdHVyZSwgQ29pbktpbmQsIEtleUN1cnZlLCBVbmRlcmx5aW5nQXNzZXQgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgQmFzZU5ldHdvcmssIE5ldHdvcmtzLCBPZmNOZXR3b3JrIH0gZnJvbSAnLi9uZXR3b3Jrcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2ZjQ29uc3RydWN0b3JPcHRpb25zIHtcbiAgaWQ6IHN0cmluZztcbiAgZnVsbE5hbWU6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBuZXR3b3JrOiBCYXNlTmV0d29yaztcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldDtcbiAgYmFzZVVuaXQ6IEJhc2VVbml0O1xuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXTtcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyO1xuICBpc1Rva2VuOiBib29sZWFuO1xuICBraW5kOiBDb2luS2luZDtcbiAgcHJlZml4Pzogc3RyaW5nO1xuICBzdWZmaXg/OiBzdHJpbmc7XG4gIGFkZHJlc3NDb2luPzogc3RyaW5nO1xuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlO1xufVxuXG4vKipcbiAqIE9GQyAob2ZmIGNoYWluKSBjb2lucy4gVGhlc2UgYXJlIHZpcnR1YWwgY29pbnMgdXNlZCB0byByZXByZXNlbnQgb2ZmIGNoYWluIGFzc2V0cyBvbiB0aGUgQml0R28gcGxhdGZvcm0uXG4gKi9cbmV4cG9ydCBjbGFzcyBPZmNDb2luIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfRkVBVFVSRVMgPSBbXG4gICAgQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTCxcbiAgICBDb2luRmVhdHVyZS5SRVFVSVJFU19CSUdfTlVNQkVSLFxuICAgIENvaW5GZWF0dXJlLkNVU1RPRFksXG4gICAgQ29pbkZlYXR1cmUuQ1VTVE9EWV9CSVRHT19UUlVTVCxcbiAgXTtcblxuICAvLyBJZiBzZXQsIHRoaXMgY29pbiBpcyB0aGUgbmF0aXZlIGFkZHJlc3MgZm9ybWF0IGZvciB0aGlzIHRva2VuLlxuICBwdWJsaWMgcmVhZG9ubHkgYWRkcmVzc0NvaW4/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogT2ZjQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzQ29pbiwgLi4uYmFzZU9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoYmFzZU9wdGlvbnMpO1xuICAgIHRoaXMuYWRkcmVzc0NvaW4gPSBhZGRyZXNzQ29pbjtcbiAgfVxuXG4gIHByb3RlY3RlZCByZXF1aXJlZEZlYXR1cmVzKCk6IFNldDxDb2luRmVhdHVyZT4ge1xuICAgIHJldHVybiBuZXcgU2V0PENvaW5GZWF0dXJlPihbQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTCwgQ29pbkZlYXR1cmUuUkVRVUlSRVNfQklHX05VTUJFUl0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRpc2FsbG93ZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW1xuICAgICAgQ29pbkZlYXR1cmUuVU5TUEVOVF9NT0RFTCxcbiAgICAgIENvaW5GZWF0dXJlLkNISUxEX1BBWVNfRk9SX1BBUkVOVCxcbiAgICAgIENvaW5GZWF0dXJlLlBBWUdPLFxuICAgICAgQ29pbkZlYXR1cmUuU1VQUE9SVFNfVE9LRU5TLFxuICAgIF0pO1xuICB9XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3Igb2ZjIGNvaW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmMoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICAvKiogT0ZDIHRva2VucyB1c2UgU0VDUDI1NksxIHVuZGVyIHRoZSBob29kIGV2ZW4gaWYgdGhlIGNoYWluIGRvZXNuJ3QgKiovXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0Lk9GQyxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgb2ZjIGNvaW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2ZjKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuT0ZDLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3Igb2ZjIGVyYzIwIGNvaW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmNlcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luID0gJ2V0aCcsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgb2ZjIGVyYzIwIGNvaW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2ZjZXJjMjAoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MudGVzdC5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICd0ZXRoJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgc29sYW5hIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXNcbiAqIEBwYXJhbSBwcmVmaXhcbiAqIEBwYXJhbSBzdWZmaXhcbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gaXNUb2tlblxuICogQHBhcmFtIGFkZHJlc3NDb2luXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBvZmNzb2xUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gWy4uLk9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUywgQ29pbkZlYXR1cmUuUkVRVUlSRVNfUkVTRVJWRV0sXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAnc29sJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5TT0wsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBzb2xhbmEgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlc1xuICogQHBhcmFtIHByZWZpeFxuICogQHBhcmFtIHN1ZmZpeFxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBpc1Rva2VuXG4gKiBAcGFyYW0gYWRkcmVzc0NvaW5cbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZmNzb2xUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gWy4uLk9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUywgQ29pbkZlYXR1cmUuUkVRVUlSRVNfUkVTRVJWRV0sXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAndHNvbCcsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuU09MLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3Igb2ZjIHN0ZWxsYXIgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmNTdGVsbGFyVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICd4bG0nLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LlhMTSxcbiAgICB9KVxuICApO1xufVxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBzdGVsbGFyIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9mY1N0ZWxsYXJUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0Lm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luID0gJ3R4bG0nLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LlhMTSxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG9mYyBhbGdvIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZjQWxnb1Rva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luID0gJ2FsZ28nLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkFMR08sXG4gICAgfSlcbiAgKTtcbn1cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBvZmMgYWxnbyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZmNBbGdvVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAndGFsZ28nLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkFMR08sXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgaGVkZXJhIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZjSGVkZXJhVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAnaGJhcicsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuSEJBUixcbiAgICB9KVxuICApO1xufVxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBoZWRlcmEgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2ZjSGVkZXJhVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAndGhiYXInLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkhCQVIsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgYXJiZXRoRXJjMjAgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmNBcmJldGhFcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luID0gJ2FyYmV0aCcsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBvZmMgYXJiZXRoRXJjMjAgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2ZjQXJiZXRoRXJjMjAoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MudGVzdC5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICd0YXJiZXRoJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgYXZheEVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZjQXZheEVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAnYXZheGMnLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgb2ZjIGF2YXhFcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZmNBdmF4RXJjMjAoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MudGVzdC5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICd0YXZheGMnLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG9mYyBwb2x5Z29uRXJjMjAgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmNQb2x5Z29uRXJjMjAoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICdwb2x5Z29uJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBwb2x5Z29uRXJjMjAgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2ZjUG9seWdvbkVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAndHBvbHlnb24nLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuIl19