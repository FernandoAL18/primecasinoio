"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sui = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const statics_1 = require("@bitgo/statics");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const lib_1 = require("./lib");
const utils_1 = __importDefault(require("./lib/utils"));
const _ = __importStar(require("lodash"));
const iface_1 = require("./lib/iface");
const constants_1 = require("./lib/constants");
class Sui extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Sui(bitgo, staticsCoin);
    }
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    getBaseFactor() {
        return 1e9;
    }
    getChain() {
        return 'sui';
    }
    getFamily() {
        return 'sui';
    }
    getFullName() {
        return 'Sui';
    }
    /** @inheritDoc */
    supportsTss() {
        return true;
    }
    getMPCAlgorithm() {
        return 'eddsa';
    }
    allowsAccountConsolidations() {
        return true;
    }
    async verifyTransaction(params) {
        var _a;
        let totalAmount = new bignumber_js_1.default(0);
        const coinConfig = statics_1.coins.get(this.getChain());
        const { txPrebuild: txPrebuild, txParams: txParams } = params;
        const transaction = new lib_1.TransferTransaction(coinConfig);
        const rawTx = txPrebuild.txHex;
        if (!rawTx) {
            throw new Error('missing required tx prebuild property txHex');
        }
        transaction.fromRawTransaction(Buffer.from(rawTx, 'hex').toString('base64'));
        const explainedTx = transaction.explainTransaction();
        if (txParams.recipients && txParams.recipients.length > 0) {
            const filteredRecipients = (_a = txParams.recipients) === null || _a === void 0 ? void 0 : _a.map((recipient) => {
                const filteredRecipient = _.pick(recipient, ['address', 'amount']);
                filteredRecipient.amount = new bignumber_js_1.default(filteredRecipient.amount).toFixed();
                return filteredRecipient;
            });
            const filteredOutputs = explainedTx.outputs.map((output) => {
                const filteredOutput = _.pick(output, ['address', 'amount']);
                filteredOutput.amount = new bignumber_js_1.default(filteredOutput.amount).toFixed();
                return filteredOutput;
            });
            if (!_.isEqual(filteredOutputs, filteredRecipients)) {
                throw new Error('Tx outputs does not match with expected txParams recipients');
            }
            for (const recipients of txParams.recipients) {
                totalAmount = totalAmount.plus(recipients.amount);
            }
            if (!totalAmount.isEqualTo(explainedTx.outputAmount)) {
                throw new Error('Tx total amount does not match with expected total amount field');
            }
        }
        return true;
    }
    async isWalletAddress(params) {
        const { keychains, address: newAddress, index } = params;
        if (!this.isValidAddress(newAddress)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${newAddress}`);
        }
        if (!keychains) {
            throw new Error('missing required param keychains');
        }
        for (const keychain of keychains) {
            const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
            const commonKeychain = keychain.commonKeychain;
            const derivationPath = 'm/' + index;
            const derivedPublicKey = MPC.deriveUnhardened(commonKeychain, derivationPath).slice(0, 64);
            const expectedAddress = this.getAddressFromPublicKey(derivedPublicKey);
            if (newAddress !== expectedAddress) {
                return false;
            }
        }
        return true;
    }
    async parseTransaction(params) {
        const transactionExplanation = await this.explainTransaction({ txHex: params.txHex });
        if (!transactionExplanation) {
            throw new Error('Invalid transaction');
        }
        let fee = new bignumber_js_1.default(0);
        const suiTransaction = transactionExplanation;
        if (suiTransaction.outputs.length <= 0) {
            return {
                inputs: [],
                outputs: [],
                fee,
            };
        }
        const senderAddress = suiTransaction.outputs[0].address;
        if (suiTransaction.fee.fee !== '') {
            fee = new bignumber_js_1.default(suiTransaction.fee.fee);
        }
        // assume 1 sender, who is also the fee payer
        const inputs = [
            {
                address: senderAddress,
                amount: new bignumber_js_1.default(suiTransaction.outputAmount).plus(fee).toFixed(),
            },
        ];
        const outputs = suiTransaction.outputs.map((output) => {
            return {
                address: output.address,
                amount: new bignumber_js_1.default(output.amount).toFixed(),
            };
        });
        return {
            inputs,
            outputs,
            fee,
        };
    }
    generateKeyPair(seed) {
        const keyPair = seed ? new lib_1.KeyPair({ seed }) : new lib_1.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return {
            pub: keys.pub,
            prv: keys.prv,
        };
    }
    isValidPub(_) {
        throw new Error('Method not implemented.');
    }
    isValidPrv(_) {
        throw new Error('Method not implemented.');
    }
    isValidAddress(address) {
        return utils_1.default.isValidAddress(address);
    }
    signTransaction(_) {
        throw new Error('Method not implemented.');
    }
    /**
     * Explain a Sui transaction
     * @param params
     */
    async explainTransaction(params) {
        const factory = this.getBuilder();
        let rebuiltTransaction;
        try {
            const transactionBuilder = factory.from(Buffer.from(params.txHex, 'hex').toString('base64'));
            rebuiltTransaction = await transactionBuilder.build();
        }
        catch {
            throw new Error('Invalid transaction');
        }
        return rebuiltTransaction.explainTransaction();
    }
    getBuilder() {
        return new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
    }
    getAddressFromPublicKey(derivedPublicKey) {
        // TODO(BG-59016) replace with account lib implementation
        return utils_1.default.getAddressFromPublicKey(derivedPublicKey);
    }
    /** @inheritDoc */
    async getSignablePayload(serializedTx) {
        const factory = this.getBuilder();
        const rebuiltTransaction = await factory.from(serializedTx).build();
        return rebuiltTransaction.signablePayload;
    }
    getPublicNodeUrl() {
        return sdk_core_1.Environments[this.bitgo.getEnv()].suiNodeUrl;
    }
    async getBalance(owner, coinType) {
        const url = this.getPublicNodeUrl();
        return await utils_1.default.getBalance(url, owner, coinType);
    }
    async getInputCoins(owner, coinType) {
        const url = this.getPublicNodeUrl();
        return await utils_1.default.getInputCoins(url, owner, coinType);
    }
    async getFeeEstimate(txHex) {
        const url = this.getPublicNodeUrl();
        return await utils_1.default.getFeeEstimate(url, txHex);
    }
    /**
     * Builds funds recovery transaction(s) without BitGo
     *
     * @param {MPCRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {MPCTx | MPCSweepTxs} array of the serialized transaction hex strings and indices
     * of the addresses being swept
     */
    async recover(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        const startIdx = utils_1.default.validateNonNegativeNumber(0, 'Invalid starting index to scan for addresses', params.startingScanIndex);
        const numIterations = utils_1.default.validateNonNegativeNumber(20, 'Invalid scanning factor', params.scan);
        const endIdx = startIdx + numIterations;
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        for (let idx = startIdx; idx < endIdx; idx++) {
            const derivationPath = `m/${idx}`;
            const derivedPublicKey = MPC.deriveUnhardened(bitgoKey, derivationPath).slice(0, 64);
            const senderAddress = this.getAddressFromPublicKey(derivedPublicKey);
            let availableBalance = new bignumber_js_1.default(0);
            try {
                availableBalance = new bignumber_js_1.default(await this.getBalance(senderAddress));
            }
            catch (e) {
                continue;
            }
            if (availableBalance.minus(constants_1.MAX_GAS_BUDGET).toNumber() <= 0) {
                continue;
            }
            let inputCoins = await this.getInputCoins(senderAddress);
            inputCoins = inputCoins.sort((a, b) => {
                return b.balance.minus(a.balance).toNumber();
            });
            if (inputCoins.length > constants_1.MAX_OBJECT_LIMIT) {
                inputCoins = inputCoins.slice(0, constants_1.MAX_OBJECT_LIMIT);
            }
            let netAmount = inputCoins.reduce((acc, obj) => acc.plus(obj.balance), new bignumber_js_1.default(0));
            netAmount = netAmount.minus(constants_1.MAX_GAS_BUDGET);
            const recipients = [
                {
                    address: params.recoveryDestination,
                    amount: netAmount.toString(),
                },
            ];
            // first build the unsigned txn
            const factory = new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
            const txBuilder = factory
                .getTransferBuilder()
                .type(iface_1.SuiTransactionType.Transfer)
                .sender(senderAddress)
                .send(recipients)
                .gasData({
                owner: senderAddress,
                price: constants_1.DEFAULT_GAS_PRICE,
                budget: constants_1.MAX_GAS_BUDGET,
                payment: inputCoins,
            });
            const tempTx = (await txBuilder.build());
            const feeEstimate = await this.getFeeEstimate(tempTx.toBroadcastFormat());
            const gasBudget = Math.trunc(feeEstimate.toNumber() * constants_1.DEFAULT_GAS_OVERHEAD);
            netAmount = netAmount.plus(constants_1.MAX_GAS_BUDGET).minus(gasBudget);
            recipients[0].amount = netAmount.toString();
            txBuilder.send(recipients);
            txBuilder.gasData({
                owner: senderAddress,
                price: constants_1.DEFAULT_GAS_PRICE,
                budget: gasBudget,
                payment: inputCoins,
            });
            if (isUnsignedSweep) {
                return this.buildUnsignedSweepTransaction(txBuilder, senderAddress, bitgoKey, idx, derivationPath);
            }
            await this.signRecoveryTransaction(txBuilder, params, derivationPath, derivedPublicKey);
            const tx = (await txBuilder.build());
            return {
                transactions: [
                    {
                        scanIndex: idx,
                        recoveryAmount: netAmount.toString(),
                        serializedTx: tx.toBroadcastFormat(),
                        signature: Buffer.from(tx.serializedSig).toString('base64'),
                    },
                ],
                lastScanIndex: idx,
            };
        }
        throw new Error(`Did not find an address with sufficient funds to recover. Please start the next scan at address index ${endIdx}.`);
    }
    async buildUnsignedSweepTransaction(txBuilder, senderAddress, bitgoKey, index, derivationPath) {
        const unsignedTransaction = (await txBuilder.build());
        const serializedTx = unsignedTransaction.toBroadcastFormat();
        const serializedTxHex = Buffer.from(serializedTx, 'base64').toString('hex');
        const parsedTx = await this.parseTransaction({ txHex: serializedTxHex });
        const walletCoin = this.getChain();
        const output = parsedTx.outputs[0];
        const inputs = [
            {
                address: senderAddress,
                valueString: output.amount,
                value: new bignumber_js_1.default(output.amount),
            },
        ];
        const outputs = [
            {
                address: output.address,
                valueString: output.amount,
                coinName: walletCoin,
            },
        ];
        const spendAmount = output.amount;
        const completedParsedTx = {
            inputs: inputs,
            outputs: outputs,
            spendAmount: spendAmount,
            type: iface_1.SuiTransactionType.Transfer,
        };
        const fee = parsedTx.fee;
        const feeInfo = { fee: fee.toNumber(), feeString: fee.toString() };
        const coinSpecific = { commonKeychain: bitgoKey };
        const transaction = {
            serializedTx: serializedTxHex,
            scanIndex: index,
            coin: walletCoin,
            signableHex: unsignedTransaction.signablePayload.toString('hex'),
            derivationPath,
            parsedTx: completedParsedTx,
            feeInfo: feeInfo,
            coinSpecific: coinSpecific,
        };
        const unsignedTx = { unsignedTx: transaction, signatureShares: [] };
        const transactions = [unsignedTx];
        const txRequest = {
            transactions: transactions,
            walletCoin: walletCoin,
        };
        return { txRequests: [txRequest] };
    }
    async signRecoveryTransaction(txBuilder, params, derivationPath, derivedPublicKey) {
        // TODO(BG-51092): This looks like a common part which can be extracted out too
        const unsignedTx = (await txBuilder.build());
        if (!params.userKey) {
            throw new Error('missing userKey');
        }
        if (!params.backupKey) {
            throw new Error('missing backupKey');
        }
        if (!params.walletPassphrase) {
            throw new Error('missing wallet passphrase');
        }
        // Clean up whitespace from entered values
        const userKey = params.userKey.replace(/\s/g, '');
        const backupKey = params.backupKey.replace(/\s/g, '');
        // Decrypt private keys from KeyCard values
        let userPrv;
        try {
            userPrv = this.bitgo.decrypt({
                input: userKey,
                password: params.walletPassphrase,
            });
        }
        catch (e) {
            throw new Error(`Error decrypting user keychain: ${e.message}`);
        }
        /** TODO BG-52419 Implement Codec for parsing */
        const userSigningMaterial = JSON.parse(userPrv);
        let backupPrv;
        try {
            backupPrv = this.bitgo.decrypt({
                input: backupKey,
                password: params.walletPassphrase,
            });
        }
        catch (e) {
            throw new Error(`Error decrypting backup keychain: ${e.message}`);
        }
        const backupSigningMaterial = JSON.parse(backupPrv);
        /* ********************** END ***********************************/
        // add signature
        const signatureHex = await sdk_core_1.EDDSAMethods.getTSSSignature(userSigningMaterial, backupSigningMaterial, derivationPath, unsignedTx);
        txBuilder.addSignature({ pub: derivedPublicKey }, signatureHex);
    }
    async broadcastTransaction({ transactions, }) {
        const txIds = [];
        const url = this.getPublicNodeUrl();
        let digest = '';
        if (!!transactions) {
            for (const txn of transactions) {
                try {
                    digest = await utils_1.default.executeTransactionBlock(url, txn.serializedTx, [txn.signature]);
                }
                catch (e) {
                    throw new Error(`Failed to broadcast transaction, error: ${e.message}`);
                }
                txIds.push(digest);
            }
        }
        return { txIds };
    }
    /** inherited doc */
    async createBroadcastableSweepTransaction(params) {
        var _a;
        const req = params.signatureShares;
        const broadcastableTransactions = [];
        let lastScanIndex = 0;
        for (let i = 0; i < req.length; i++) {
            const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
            const transaction = req[i].txRequest.transactions[0].unsignedTx;
            if (!req[i].ovc || !req[i].ovc[0].eddsaSignature) {
                throw new Error('Missing signature(s)');
            }
            const signature = req[i].ovc[0].eddsaSignature;
            if (!transaction.signableHex) {
                throw new Error('Missing signable hex');
            }
            const messageBuffer = Buffer.from(transaction.signableHex, 'hex');
            const result = MPC.verify(messageBuffer, signature);
            if (!result) {
                throw new Error('Invalid signature');
            }
            const signatureHex = Buffer.concat([Buffer.from(signature.R, 'hex'), Buffer.from(signature.sigma, 'hex')]);
            const serializedTxBase64 = Buffer.from(transaction.serializedTx, 'hex').toString('base64');
            const txBuilder = this.getBuilder().from(serializedTxBase64);
            if (!((_a = transaction.coinSpecific) === null || _a === void 0 ? void 0 : _a.commonKeychain)) {
                throw new Error('Missing common keychain');
            }
            const commonKeychain = transaction.coinSpecific.commonKeychain;
            if (!transaction.derivationPath) {
                throw new Error('Missing derivation path');
            }
            const derivationPath = transaction.derivationPath;
            const derivedPublicKey = MPC.deriveUnhardened(commonKeychain, derivationPath).slice(0, 64);
            // add combined signature from ovc
            txBuilder.addSignature({ pub: derivedPublicKey }, signatureHex);
            const signedTransaction = (await txBuilder.build());
            const serializedTx = signedTransaction.toBroadcastFormat();
            const outputAmount = signedTransaction.explainTransaction().outputAmount;
            broadcastableTransactions.push({
                serializedTx: serializedTx,
                scanIndex: transaction.scanIndex,
                signature: Buffer.from(signedTransaction.serializedSig).toString('base64'),
                recoveryAmount: outputAmount.toString(),
            });
            if (i === req.length - 1 && transaction.coinSpecific.lastScanIndex) {
                lastScanIndex = transaction.coinSpecific.lastScanIndex;
            }
        }
        return { transactions: broadcastableTransactions, lastScanIndex };
    }
    /**
     * Builds native SUI recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     *
     * @param {MPCConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    async recoverConsolidations(params) {
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        const startIdx = utils_1.default.validateNonNegativeNumber(1, 'Invalid starting index to scan for addresses', params.startingScanIndex);
        const endIdx = utils_1.default.validateNonNegativeNumber(startIdx + constants_1.DEFAULT_SCAN_FACTOR, 'Invalid ending index to scan for addresses', params.endingScanIndex);
        if (startIdx < 1 || endIdx <= startIdx || endIdx - startIdx > 10 * constants_1.DEFAULT_SCAN_FACTOR) {
            throw new Error(`Invalid starting or ending index to scan for addresses. startingScanIndex: ${startIdx}, endingScanIndex: ${endIdx}.`);
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        const derivationPath = `m/0`;
        const derivedPublicKey = MPC.deriveUnhardened(bitgoKey, derivationPath).slice(0, 64);
        const baseAddress = this.getAddressFromPublicKey(derivedPublicKey);
        const consolidationTransactions = [];
        let lastScanIndex = startIdx;
        for (let idx = startIdx; idx < endIdx; idx++) {
            const recoverParams = {
                userKey: params.userKey,
                backupKey: params.backupKey,
                bitgoKey: params.bitgoKey,
                walletPassphrase: params.walletPassphrase,
                recoveryDestination: baseAddress,
                startingScanIndex: idx,
                scan: 1,
            };
            let recoveryTransaction;
            try {
                recoveryTransaction = await this.recover(recoverParams);
            }
            catch (e) {
                if (e.message.startsWith('Did not find an address with sufficient funds to recover.')) {
                    lastScanIndex = idx;
                    continue;
                }
                throw e;
            }
            if (isUnsignedSweep) {
                consolidationTransactions.push(recoveryTransaction.txRequests[0]);
            }
            else {
                consolidationTransactions.push(recoveryTransaction.transactions[0]);
            }
            lastScanIndex = idx;
        }
        if (consolidationTransactions.length === 0) {
            throw new Error(`Did not find an address with sufficient funds to recover. Please start the next scan at address index ${lastScanIndex + 1}.`);
        }
        if (isUnsignedSweep) {
            // lastScanIndex will be used to inform user the last address index scanned for available funds (so they can
            // appropriately adjust the scan range on the next iteration of consolidation recoveries). In the case of unsigned
            // sweep consolidations, this lastScanIndex will be provided in the coinSpecific of the last txn made.
            consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific.lastScanIndex = lastScanIndex;
            return { txRequests: consolidationTransactions };
        }
        return { transactions: consolidationTransactions, lastScanIndex };
    }
}
exports.Sui = Sui;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3VpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3N1aS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDhDQTJCeUI7QUFDekIsNENBQW9FO0FBQ3BFLGdFQUFxQztBQUNyQywrQkFBK0c7QUFDL0csd0RBQWdDO0FBQ2hDLDBDQUE0QjtBQUM1Qix1Q0FBZ0U7QUFDaEUsK0NBTXlCO0FBNkJ6QixNQUFhLEdBQUksU0FBUSxtQkFBUTtJQUUvQixZQUFzQixLQUFnQixFQUFFLFdBQXVDO1FBQzdFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUViLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO1NBQ3ZFO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7SUFDbEMsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBZ0IsRUFBRSxXQUF1QztRQUM3RSxPQUFPLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxhQUFhO1FBQ2xCLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVNLFFBQVE7UUFDYixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFTSxTQUFTO1FBQ2QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRU0sV0FBVztRQUNoQixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELGVBQWU7UUFDYixPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRUQsMkJBQTJCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxNQUFnQzs7UUFDdEQsSUFBSSxX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QXlCLENBQUMsSUFBSSxDQUFFLG1CQUE4QixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2pGO1lBQ0QsYUFBYSxHQUFHLEdBQUcsQ0FBQztTQUNyQjtRQUVELElBQUkseUJBQXlCLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMxQyxNQUFNLElBQUksS0FBSyxDQUNiLHlHQUNFLGFBQWEsR0FBRyxDQUNsQixHQUFHLENBQ0osQ0FBQztTQUNIO1FBRUQsSUFBSSxlQUFlLEVBQUU7WUFDbkIsNEdBQTRHO1lBQzVHLGtIQUFrSDtZQUNsSCxzR0FBc0c7WUFDdEcseUJBQXlCLENBQ3ZCLHlCQUF5QixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQ3JDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQztZQUN4RSxPQUFPLEVBQUUsVUFBVSxFQUFFLHlCQUF5QixFQUFFLENBQUM7U0FDbEQ7UUFFRCxPQUFPLEVBQUUsWUFBWSxFQUFFLHlCQUF5QixFQUFFLGFBQWEsRUFBRSxDQUFDO0lBQ3BFLENBQUM7Q0FDRjtBQTltQkQsa0JBOG1CQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvblJlc3VsdCxcbiAgQmFzZUNvaW4sXG4gIEJhc2VUcmFuc2FjdGlvbixcbiAgQml0R29CYXNlLFxuICBFRERTQU1ldGhvZHMsXG4gIEVERFNBTWV0aG9kVHlwZXMsXG4gIEVudmlyb25tZW50cyxcbiAgSW52YWxpZEFkZHJlc3NFcnJvcixcbiAgS2V5UGFpcixcbiAgTVBDQWxnb3JpdGhtLFxuICBNUENSZWNvdmVyeU9wdGlvbnMsXG4gIE1QQ0NvbnNvbGlkYXRpb25SZWNvdmVyeU9wdGlvbnMsXG4gIE1QQ1N3ZWVwUmVjb3ZlcnlPcHRpb25zLFxuICBNUENTd2VlcFR4cyxcbiAgTVBDVHgsXG4gIE1QQ1R4cyxcbiAgTVBDVW5zaWduZWRUeCxcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUmVjb3ZlcnlUeFJlcXVlc3QsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBUc3NWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgU3RhdGljc0Jhc2VDb2luLCBjb2lucyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEtleVBhaXIgYXMgU3VpS2V5UGFpciwgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSwgVHJhbnNmZXJCdWlsZGVyLCBUcmFuc2ZlclRyYW5zYWN0aW9uIH0gZnJvbSAnLi9saWInO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vbGliL3V0aWxzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFN1aU9iamVjdEluZm8sIFN1aVRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4vbGliL2lmYWNlJztcbmltcG9ydCB7XG4gIERFRkFVTFRfR0FTX09WRVJIRUFELFxuICBERUZBVUxUX0dBU19QUklDRSxcbiAgREVGQVVMVF9TQ0FOX0ZBQ1RPUixcbiAgTUFYX0dBU19CVURHRVQsXG4gIE1BWF9PQkpFQ1RfTElNSVQsXG59IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4SGV4OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VpUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25PdXRwdXQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogc3RyaW5nO1xufVxuXG50eXBlIFRyYW5zYWN0aW9uSW5wdXQgPSBUcmFuc2FjdGlvbk91dHB1dDtcblxuZXhwb3J0IGludGVyZmFjZSBTdWlQYXJzZWRUcmFuc2FjdGlvbiBleHRlbmRzIFBhcnNlZFRyYW5zYWN0aW9uIHtcbiAgLy8gdG90YWwgYXNzZXRzIGJlaW5nIG1vdmVkLCBpbmNsdWRpbmcgZmVlc1xuICBpbnB1dHM6IFRyYW5zYWN0aW9uSW5wdXRbXTtcblxuICAvLyB3aGVyZSBhc3NldHMgYXJlIG1vdmVkIHRvXG4gIG91dHB1dHM6IFRyYW5zYWN0aW9uT3V0cHV0W107XG5cbiAgZmVlOiBCaWdOdW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFN1aVRyYW5zYWN0aW9uRXhwbGFuYXRpb24gPSBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uO1xuXG5leHBvcnQgY2xhc3MgU3VpIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuXG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgU3VpKGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yIGJldHdlZW4gdGhlIGNvaW4ncyBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqL1xuICBwdWJsaWMgZ2V0QmFzZUZhY3RvcigpOiBudW1iZXIge1xuICAgIHJldHVybiAxZTk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3N1aSc7XG4gIH1cblxuICBwdWJsaWMgZ2V0RmFtaWx5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdzdWknO1xuICB9XG5cbiAgcHVibGljIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdTdWknO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHN1cHBvcnRzVHNzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0TVBDQWxnb3JpdGhtKCk6IE1QQ0FsZ29yaXRobSB7XG4gICAgcmV0dXJuICdlZGRzYSc7XG4gIH1cblxuICBhbGxvd3NBY2NvdW50Q29uc29saWRhdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxldCB0b3RhbEFtb3VudCA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgY29uc3QgY29pbkNvbmZpZyA9IGNvaW5zLmdldCh0aGlzLmdldENoYWluKCkpO1xuICAgIGNvbnN0IHsgdHhQcmVidWlsZDogdHhQcmVidWlsZCwgdHhQYXJhbXM6IHR4UGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNmZXJUcmFuc2FjdGlvbihjb2luQ29uZmlnKTtcbiAgICBjb25zdCByYXdUeCA9IHR4UHJlYnVpbGQudHhIZXg7XG4gICAgaWYgKCFyYXdUeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4IHByZWJ1aWxkIHByb3BlcnR5IHR4SGV4Jyk7XG4gICAgfVxuXG4gICAgdHJhbnNhY3Rpb24uZnJvbVJhd1RyYW5zYWN0aW9uKEJ1ZmZlci5mcm9tKHJhd1R4LCAnaGV4JykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICBjb25zdCBleHBsYWluZWRUeCA9IHRyYW5zYWN0aW9uLmV4cGxhaW5UcmFuc2FjdGlvbigpO1xuXG4gICAgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMgJiYgdHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZFJlY2lwaWVudHMgPSB0eFBhcmFtcy5yZWNpcGllbnRzPy5tYXAoKHJlY2lwaWVudCkgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFJlY2lwaWVudCA9IF8ucGljayhyZWNpcGllbnQsIFsnYWRkcmVzcycsICdhbW91bnQnXSk7XG4gICAgICAgIGZpbHRlcmVkUmVjaXBpZW50LmFtb3VudCA9IG5ldyBCaWdOdW1iZXIoZmlsdGVyZWRSZWNpcGllbnQuYW1vdW50KS50b0ZpeGVkKCk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZFJlY2lwaWVudDtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZmlsdGVyZWRPdXRwdXRzID0gZXhwbGFpbmVkVHgub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZE91dHB1dCA9IF8ucGljayhvdXRwdXQsIFsnYWRkcmVzcycsICdhbW91bnQnXSk7XG4gICAgICAgIGZpbHRlcmVkT3V0cHV0LmFtb3VudCA9IG5ldyBCaWdOdW1iZXIoZmlsdGVyZWRPdXRwdXQuYW1vdW50KS50b0ZpeGVkKCk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZE91dHB1dDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIV8uaXNFcXVhbChmaWx0ZXJlZE91dHB1dHMsIGZpbHRlcmVkUmVjaXBpZW50cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCBvdXRwdXRzIGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdHhQYXJhbXMgcmVjaXBpZW50cycpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCByZWNpcGllbnRzIG9mIHR4UGFyYW1zLnJlY2lwaWVudHMpIHtcbiAgICAgICAgdG90YWxBbW91bnQgPSB0b3RhbEFtb3VudC5wbHVzKHJlY2lwaWVudHMuYW1vdW50KTtcbiAgICAgIH1cbiAgICAgIGlmICghdG90YWxBbW91bnQuaXNFcXVhbFRvKGV4cGxhaW5lZFR4Lm91dHB1dEFtb3VudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCB0b3RhbCBhbW91bnQgZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0b3RhbCBhbW91bnQgZmllbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBUc3NWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHsga2V5Y2hhaW5zLCBhZGRyZXNzOiBuZXdBZGRyZXNzLCBpbmRleCB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKG5ld0FkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke25ld0FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXljaGFpbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSBrZXljaGFpbnMnKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleWNoYWluIG9mIGtleWNoYWlucykge1xuICAgICAgY29uc3QgTVBDID0gYXdhaXQgRUREU0FNZXRob2RzLmdldEluaXRpYWxpemVkTXBjSW5zdGFuY2UoKTtcbiAgICAgIGNvbnN0IGNvbW1vbktleWNoYWluID0ga2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4gYXMgc3RyaW5nO1xuXG4gICAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9ICdtLycgKyBpbmRleDtcbiAgICAgIGNvbnN0IGRlcml2ZWRQdWJsaWNLZXkgPSBNUEMuZGVyaXZlVW5oYXJkZW5lZChjb21tb25LZXljaGFpbiwgZGVyaXZhdGlvblBhdGgpLnNsaWNlKDAsIDY0KTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkQWRkcmVzcyA9IHRoaXMuZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkoZGVyaXZlZFB1YmxpY0tleSk7XG5cbiAgICAgIGlmIChuZXdBZGRyZXNzICE9PSBleHBlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFN1aVBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxTdWlQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24gPSBhd2FpdCB0aGlzLmV4cGxhaW5UcmFuc2FjdGlvbih7IHR4SGV4OiBwYXJhbXMudHhIZXggfSk7XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uRXhwbGFuYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGxldCBmZWUgPSBuZXcgQmlnTnVtYmVyKDApO1xuXG4gICAgY29uc3Qgc3VpVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbkV4cGxhbmF0aW9uIGFzIFN1aVRyYW5zYWN0aW9uRXhwbGFuYXRpb247XG4gICAgaWYgKHN1aVRyYW5zYWN0aW9uLm91dHB1dHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBmZWUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHNlbmRlckFkZHJlc3MgPSBzdWlUcmFuc2FjdGlvbi5vdXRwdXRzWzBdLmFkZHJlc3M7XG4gICAgaWYgKHN1aVRyYW5zYWN0aW9uLmZlZS5mZWUgIT09ICcnKSB7XG4gICAgICBmZWUgPSBuZXcgQmlnTnVtYmVyKHN1aVRyYW5zYWN0aW9uLmZlZS5mZWUpO1xuICAgIH1cblxuICAgIC8vIGFzc3VtZSAxIHNlbmRlciwgd2hvIGlzIGFsc28gdGhlIGZlZSBwYXllclxuICAgIGNvbnN0IGlucHV0cyA9IFtcbiAgICAgIHtcbiAgICAgICAgYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKHN1aVRyYW5zYWN0aW9uLm91dHB1dEFtb3VudCkucGx1cyhmZWUpLnRvRml4ZWQoKSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGNvbnN0IG91dHB1dHM6IFRyYW5zYWN0aW9uT3V0cHV0W10gPSBzdWlUcmFuc2FjdGlvbi5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBvdXRwdXQuYWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKG91dHB1dC5hbW91bnQpLnRvRml4ZWQoKSxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRzLFxuICAgICAgb3V0cHV0cyxcbiAgICAgIGZlZSxcbiAgICB9O1xuICB9XG5cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBrZXlQYWlyID0gc2VlZCA/IG5ldyBTdWlLZXlQYWlyKHsgc2VlZCB9KSA6IG5ldyBTdWlLZXlQYWlyKCk7XG4gICAgY29uc3Qga2V5cyA9IGtleVBhaXIuZ2V0S2V5cygpO1xuICAgIGlmICgha2V5cy5wcnYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcnYgaW4ga2V5IGdlbmVyYXRpb24uJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwdWI6IGtleXMucHViLFxuICAgICAgcHJ2OiBrZXlzLnBydixcbiAgICB9O1xuICB9XG5cbiAgaXNWYWxpZFB1YihfOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBpc1ZhbGlkUHJ2KF86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB1dGlscy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKTtcbiAgfVxuXG4gIHNpZ25UcmFuc2FjdGlvbihfOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgU3VpIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFN1aVRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5nZXRCdWlsZGVyKCk7XG4gICAgbGV0IHJlYnVpbHRUcmFuc2FjdGlvbjogQmFzZVRyYW5zYWN0aW9uO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uQnVpbGRlciA9IGZhY3RvcnkuZnJvbShCdWZmZXIuZnJvbShwYXJhbXMudHhIZXgsICdoZXgnKS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgICAgcmVidWlsdFRyYW5zYWN0aW9uID0gYXdhaXQgdHJhbnNhY3Rpb25CdWlsZGVyLmJ1aWxkKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVidWlsdFRyYW5zYWN0aW9uLmV4cGxhaW5UcmFuc2FjdGlvbigpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRCdWlsZGVyKCk6IFRyYW5zYWN0aW9uQnVpbGRlckZhY3Rvcnkge1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2lucy5nZXQodGhpcy5nZXRDaGFpbigpKSk7XG4gIH1cblxuICBwcml2YXRlIGdldEFkZHJlc3NGcm9tUHVibGljS2V5KGRlcml2ZWRQdWJsaWNLZXk6IHN0cmluZykge1xuICAgIC8vIFRPRE8oQkctNTkwMTYpIHJlcGxhY2Ugd2l0aCBhY2NvdW50IGxpYiBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybiB1dGlscy5nZXRBZGRyZXNzRnJvbVB1YmxpY0tleShkZXJpdmVkUHVibGljS2V5KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBhc3luYyBnZXRTaWduYWJsZVBheWxvYWQoc2VyaWFsaXplZFR4OiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcbiAgICBjb25zdCByZWJ1aWx0VHJhbnNhY3Rpb24gPSBhd2FpdCBmYWN0b3J5LmZyb20oc2VyaWFsaXplZFR4KS5idWlsZCgpO1xuICAgIHJldHVybiByZWJ1aWx0VHJhbnNhY3Rpb24uc2lnbmFibGVQYXlsb2FkO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldFB1YmxpY05vZGVVcmwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLnN1aU5vZGVVcmw7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0QmFsYW5jZShvd25lcjogc3RyaW5nLCBjb2luVHlwZT86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5nZXRQdWJsaWNOb2RlVXJsKCk7XG4gICAgcmV0dXJuIGF3YWl0IHV0aWxzLmdldEJhbGFuY2UodXJsLCBvd25lciwgY29pblR5cGUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldElucHV0Q29pbnMob3duZXI6IHN0cmluZywgY29pblR5cGU/OiBzdHJpbmcpOiBQcm9taXNlPFN1aU9iamVjdEluZm9bXT4ge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0UHVibGljTm9kZVVybCgpO1xuICAgIHJldHVybiBhd2FpdCB1dGlscy5nZXRJbnB1dENvaW5zKHVybCwgb3duZXIsIGNvaW5UeXBlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRGZWVFc3RpbWF0ZSh0eEhleDogc3RyaW5nKTogUHJvbWlzZTxCaWdOdW1iZXI+IHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmdldFB1YmxpY05vZGVVcmwoKTtcbiAgICByZXR1cm4gYXdhaXQgdXRpbHMuZ2V0RmVlRXN0aW1hdGUodXJsLCB0eEhleCk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uKHMpIHdpdGhvdXQgQml0R29cbiAgICpcbiAgICogQHBhcmFtIHtNUENSZWNvdmVyeU9wdGlvbnN9IHBhcmFtcyBwYXJhbWV0ZXJzIG5lZWRlZCB0byBjb25zdHJ1Y3QgYW5kXG4gICAqIChtYXliZSkgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge01QQ1R4IHwgTVBDU3dlZXBUeHN9IGFycmF5IG9mIHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGhleCBzdHJpbmdzIGFuZCBpbmRpY2VzXG4gICAqIG9mIHRoZSBhZGRyZXNzZXMgYmVpbmcgc3dlcHRcbiAgICovXG4gIGFzeW5jIHJlY292ZXIocGFyYW1zOiBNUENSZWNvdmVyeU9wdGlvbnMpOiBQcm9taXNlPE1QQ1R4cyB8IE1QQ1N3ZWVwVHhzPiB7XG4gICAgaWYgKCFwYXJhbXMuYml0Z29LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiaXRnb0tleScpO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydElkeCA9IHV0aWxzLnZhbGlkYXRlTm9uTmVnYXRpdmVOdW1iZXIoXG4gICAgICAwLFxuICAgICAgJ0ludmFsaWQgc3RhcnRpbmcgaW5kZXggdG8gc2NhbiBmb3IgYWRkcmVzc2VzJyxcbiAgICAgIHBhcmFtcy5zdGFydGluZ1NjYW5JbmRleFxuICAgICk7XG4gICAgY29uc3QgbnVtSXRlcmF0aW9ucyA9IHV0aWxzLnZhbGlkYXRlTm9uTmVnYXRpdmVOdW1iZXIoMjAsICdJbnZhbGlkIHNjYW5uaW5nIGZhY3RvcicsIHBhcmFtcy5zY2FuKTtcbiAgICBjb25zdCBlbmRJZHggPSBzdGFydElkeCArIG51bUl0ZXJhdGlvbnM7XG4gICAgY29uc3QgYml0Z29LZXkgPSBwYXJhbXMuYml0Z29LZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSAhcGFyYW1zLnVzZXJLZXkgJiYgIXBhcmFtcy5iYWNrdXBLZXkgJiYgIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlO1xuICAgIGNvbnN0IE1QQyA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRJbml0aWFsaXplZE1wY0luc3RhbmNlKCk7XG5cbiAgICBmb3IgKGxldCBpZHggPSBzdGFydElkeDsgaWR4IDwgZW5kSWR4OyBpZHgrKykge1xuICAgICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBgbS8ke2lkeH1gO1xuICAgICAgY29uc3QgZGVyaXZlZFB1YmxpY0tleSA9IE1QQy5kZXJpdmVVbmhhcmRlbmVkKGJpdGdvS2V5LCBkZXJpdmF0aW9uUGF0aCkuc2xpY2UoMCwgNjQpO1xuICAgICAgY29uc3Qgc2VuZGVyQWRkcmVzcyA9IHRoaXMuZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkoZGVyaXZlZFB1YmxpY0tleSk7XG4gICAgICBsZXQgYXZhaWxhYmxlQmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgICB0cnkge1xuICAgICAgICBhdmFpbGFibGVCYWxhbmNlID0gbmV3IEJpZ051bWJlcihhd2FpdCB0aGlzLmdldEJhbGFuY2Uoc2VuZGVyQWRkcmVzcykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhdmFpbGFibGVCYWxhbmNlLm1pbnVzKE1BWF9HQVNfQlVER0VUKS50b051bWJlcigpIDw9IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBpbnB1dENvaW5zID0gYXdhaXQgdGhpcy5nZXRJbnB1dENvaW5zKHNlbmRlckFkZHJlc3MpO1xuICAgICAgaW5wdXRDb2lucyA9IGlucHV0Q29pbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gYi5iYWxhbmNlLm1pbnVzKGEuYmFsYW5jZSkudG9OdW1iZXIoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGlucHV0Q29pbnMubGVuZ3RoID4gTUFYX09CSkVDVF9MSU1JVCkge1xuICAgICAgICBpbnB1dENvaW5zID0gaW5wdXRDb2lucy5zbGljZSgwLCBNQVhfT0JKRUNUX0xJTUlUKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXRBbW91bnQgPSBpbnB1dENvaW5zLnJlZHVjZSgoYWNjLCBvYmopID0+IGFjYy5wbHVzKG9iai5iYWxhbmNlKSwgbmV3IEJpZ051bWJlcigwKSk7XG4gICAgICBuZXRBbW91bnQgPSBuZXRBbW91bnQubWludXMoTUFYX0dBU19CVURHRVQpO1xuXG4gICAgICBjb25zdCByZWNpcGllbnRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgYWRkcmVzczogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sXG4gICAgICAgICAgYW1vdW50OiBuZXRBbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIC8vIGZpcnN0IGJ1aWxkIHRoZSB1bnNpZ25lZCB0eG5cbiAgICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2lucy5nZXQodGhpcy5nZXRDaGFpbigpKSk7XG4gICAgICBjb25zdCB0eEJ1aWxkZXIgPSBmYWN0b3J5XG4gICAgICAgIC5nZXRUcmFuc2ZlckJ1aWxkZXIoKVxuICAgICAgICAudHlwZShTdWlUcmFuc2FjdGlvblR5cGUuVHJhbnNmZXIpXG4gICAgICAgIC5zZW5kZXIoc2VuZGVyQWRkcmVzcylcbiAgICAgICAgLnNlbmQocmVjaXBpZW50cylcbiAgICAgICAgLmdhc0RhdGEoe1xuICAgICAgICAgIG93bmVyOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIHByaWNlOiBERUZBVUxUX0dBU19QUklDRSxcbiAgICAgICAgICBidWRnZXQ6IE1BWF9HQVNfQlVER0VULFxuICAgICAgICAgIHBheW1lbnQ6IGlucHV0Q29pbnMsXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0ZW1wVHggPSAoYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCkpIGFzIFRyYW5zZmVyVHJhbnNhY3Rpb247XG4gICAgICBjb25zdCBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZ2V0RmVlRXN0aW1hdGUodGVtcFR4LnRvQnJvYWRjYXN0Rm9ybWF0KCkpO1xuICAgICAgY29uc3QgZ2FzQnVkZ2V0ID0gTWF0aC50cnVuYyhmZWVFc3RpbWF0ZS50b051bWJlcigpICogREVGQVVMVF9HQVNfT1ZFUkhFQUQpO1xuXG4gICAgICBuZXRBbW91bnQgPSBuZXRBbW91bnQucGx1cyhNQVhfR0FTX0JVREdFVCkubWludXMoZ2FzQnVkZ2V0KTtcbiAgICAgIHJlY2lwaWVudHNbMF0uYW1vdW50ID0gbmV0QW1vdW50LnRvU3RyaW5nKCk7XG4gICAgICB0eEJ1aWxkZXIuc2VuZChyZWNpcGllbnRzKTtcbiAgICAgIHR4QnVpbGRlci5nYXNEYXRhKHtcbiAgICAgICAgb3duZXI6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgIHByaWNlOiBERUZBVUxUX0dBU19QUklDRSxcbiAgICAgICAgYnVkZ2V0OiBnYXNCdWRnZXQsXG4gICAgICAgIHBheW1lbnQ6IGlucHV0Q29pbnMsXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFVuc2lnbmVkU3dlZXBUcmFuc2FjdGlvbih0eEJ1aWxkZXIsIHNlbmRlckFkZHJlc3MsIGJpdGdvS2V5LCBpZHgsIGRlcml2YXRpb25QYXRoKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5zaWduUmVjb3ZlcnlUcmFuc2FjdGlvbih0eEJ1aWxkZXIsIHBhcmFtcywgZGVyaXZhdGlvblBhdGgsIGRlcml2ZWRQdWJsaWNLZXkpO1xuICAgICAgY29uc3QgdHggPSAoYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCkpIGFzIFRyYW5zZmVyVHJhbnNhY3Rpb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc2FjdGlvbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzY2FuSW5kZXg6IGlkeCxcbiAgICAgICAgICAgIHJlY292ZXJ5QW1vdW50OiBuZXRBbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRUeDogdHgudG9Ccm9hZGNhc3RGb3JtYXQoKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20odHguc2VyaWFsaXplZFNpZykudG9TdHJpbmcoJ2Jhc2U2NCcpLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGxhc3RTY2FuSW5kZXg6IGlkeCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYERpZCBub3QgZmluZCBhbiBhZGRyZXNzIHdpdGggc3VmZmljaWVudCBmdW5kcyB0byByZWNvdmVyLiBQbGVhc2Ugc3RhcnQgdGhlIG5leHQgc2NhbiBhdCBhZGRyZXNzIGluZGV4ICR7ZW5kSWR4fS5gXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgYnVpbGRVbnNpZ25lZFN3ZWVwVHJhbnNhY3Rpb24oXG4gICAgdHhCdWlsZGVyOiBUcmFuc2ZlckJ1aWxkZXIsXG4gICAgc2VuZGVyQWRkcmVzczogc3RyaW5nLFxuICAgIGJpdGdvS2V5OiBzdHJpbmcsXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICBkZXJpdmF0aW9uUGF0aDogc3RyaW5nXG4gICk6IFByb21pc2U8TVBDU3dlZXBUeHM+IHtcbiAgICBjb25zdCB1bnNpZ25lZFRyYW5zYWN0aW9uID0gKGF3YWl0IHR4QnVpbGRlci5idWlsZCgpKSBhcyBUcmFuc2ZlclRyYW5zYWN0aW9uO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9IHVuc2lnbmVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkVHhIZXggPSBCdWZmZXIuZnJvbShzZXJpYWxpemVkVHgsICdiYXNlNjQnKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgcGFyc2VkVHggPSBhd2FpdCB0aGlzLnBhcnNlVHJhbnNhY3Rpb24oeyB0eEhleDogc2VyaWFsaXplZFR4SGV4IH0pO1xuICAgIGNvbnN0IHdhbGxldENvaW4gPSB0aGlzLmdldENoYWluKCk7XG4gICAgY29uc3Qgb3V0cHV0ID0gcGFyc2VkVHgub3V0cHV0c1swXTtcbiAgICBjb25zdCBpbnB1dHMgPSBbXG4gICAgICB7XG4gICAgICAgIGFkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZhbHVlU3RyaW5nOiBvdXRwdXQuYW1vdW50LFxuICAgICAgICB2YWx1ZTogbmV3IEJpZ051bWJlcihvdXRwdXQuYW1vdW50KSxcbiAgICAgIH0sXG4gICAgXTtcbiAgICBjb25zdCBvdXRwdXRzID0gW1xuICAgICAge1xuICAgICAgICBhZGRyZXNzOiBvdXRwdXQuYWRkcmVzcyxcbiAgICAgICAgdmFsdWVTdHJpbmc6IG91dHB1dC5hbW91bnQsXG4gICAgICAgIGNvaW5OYW1lOiB3YWxsZXRDb2luLFxuICAgICAgfSxcbiAgICBdO1xuICAgIGNvbnN0IHNwZW5kQW1vdW50ID0gb3V0cHV0LmFtb3VudDtcbiAgICBjb25zdCBjb21wbGV0ZWRQYXJzZWRUeCA9IHtcbiAgICAgIGlucHV0czogaW5wdXRzLFxuICAgICAgb3V0cHV0czogb3V0cHV0cyxcbiAgICAgIHNwZW5kQW1vdW50OiBzcGVuZEFtb3VudCxcbiAgICAgIHR5cGU6IFN1aVRyYW5zYWN0aW9uVHlwZS5UcmFuc2ZlcixcbiAgICB9O1xuICAgIGNvbnN0IGZlZSA9IHBhcnNlZFR4LmZlZTtcbiAgICBjb25zdCBmZWVJbmZvID0geyBmZWU6IGZlZS50b051bWJlcigpLCBmZWVTdHJpbmc6IGZlZS50b1N0cmluZygpIH07XG4gICAgY29uc3QgY29pblNwZWNpZmljID0geyBjb21tb25LZXljaGFpbjogYml0Z29LZXkgfTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbjogTVBDVHggPSB7XG4gICAgICBzZXJpYWxpemVkVHg6IHNlcmlhbGl6ZWRUeEhleCxcbiAgICAgIHNjYW5JbmRleDogaW5kZXgsXG4gICAgICBjb2luOiB3YWxsZXRDb2luLFxuICAgICAgc2lnbmFibGVIZXg6IHVuc2lnbmVkVHJhbnNhY3Rpb24uc2lnbmFibGVQYXlsb2FkLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIGRlcml2YXRpb25QYXRoLFxuICAgICAgcGFyc2VkVHg6IGNvbXBsZXRlZFBhcnNlZFR4LFxuICAgICAgZmVlSW5mbzogZmVlSW5mbyxcbiAgICAgIGNvaW5TcGVjaWZpYzogY29pblNwZWNpZmljLFxuICAgIH07XG4gICAgY29uc3QgdW5zaWduZWRUeDogTVBDVW5zaWduZWRUeCA9IHsgdW5zaWduZWRUeDogdHJhbnNhY3Rpb24sIHNpZ25hdHVyZVNoYXJlczogW10gfTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbnM6IE1QQ1Vuc2lnbmVkVHhbXSA9IFt1bnNpZ25lZFR4XTtcbiAgICBjb25zdCB0eFJlcXVlc3Q6IFJlY292ZXJ5VHhSZXF1ZXN0ID0ge1xuICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMsXG4gICAgICB3YWxsZXRDb2luOiB3YWxsZXRDb2luLFxuICAgIH07XG4gICAgcmV0dXJuIHsgdHhSZXF1ZXN0czogW3R4UmVxdWVzdF0gfTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2lnblJlY292ZXJ5VHJhbnNhY3Rpb24oXG4gICAgdHhCdWlsZGVyOiBUcmFuc2ZlckJ1aWxkZXIsXG4gICAgcGFyYW1zOiBNUENSZWNvdmVyeU9wdGlvbnMsXG4gICAgZGVyaXZhdGlvblBhdGg6IHN0cmluZyxcbiAgICBkZXJpdmVkUHVibGljS2V5OiBzdHJpbmdcbiAgKSB7XG4gICAgLy8gVE9ETyhCRy01MTA5Mik6IFRoaXMgbG9va3MgbGlrZSBhIGNvbW1vbiBwYXJ0IHdoaWNoIGNhbiBiZSBleHRyYWN0ZWQgb3V0IHRvb1xuICAgIGNvbnN0IHVuc2lnbmVkVHggPSAoYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCkpIGFzIFRyYW5zZmVyVHJhbnNhY3Rpb247XG4gICAgaWYgKCFwYXJhbXMudXNlcktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHVzZXJLZXknKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMuYmFja3VwS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYmFja3VwS2V5Jyk7XG4gICAgfVxuICAgIGlmICghcGFyYW1zLndhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB3YWxsZXQgcGFzc3BocmFzZScpO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIHdoaXRlc3BhY2UgZnJvbSBlbnRlcmVkIHZhbHVlc1xuICAgIGNvbnN0IHVzZXJLZXkgPSBwYXJhbXMudXNlcktleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGNvbnN0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICAgIC8vIERlY3J5cHQgcHJpdmF0ZSBrZXlzIGZyb20gS2V5Q2FyZCB2YWx1ZXNcbiAgICBsZXQgdXNlclBydjogc3RyaW5nO1xuICAgIHRyeSB7XG4gICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyB1c2VyIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgLyoqIFRPRE8gQkctNTI0MTkgSW1wbGVtZW50IENvZGVjIGZvciBwYXJzaW5nICovXG4gICAgY29uc3QgdXNlclNpZ25pbmdNYXRlcmlhbCA9IEpTT04ucGFyc2UodXNlclBydikgYXMgRUREU0FNZXRob2RUeXBlcy5Vc2VyU2lnbmluZ01hdGVyaWFsO1xuXG4gICAgbGV0IGJhY2t1cFBydjogc3RyaW5nO1xuICAgIHRyeSB7XG4gICAgICBiYWNrdXBQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBpbnB1dDogYmFja3VwS2V5LFxuICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgYmFja3VwIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYmFja3VwU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZShiYWNrdXBQcnYpIGFzIEVERFNBTWV0aG9kVHlwZXMuQmFja3VwU2lnbmluZ01hdGVyaWFsO1xuICAgIC8qICoqKioqKioqKioqKioqKioqKioqKiogRU5EICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gYWRkIHNpZ25hdHVyZVxuICAgIGNvbnN0IHNpZ25hdHVyZUhleCA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRUU1NTaWduYXR1cmUoXG4gICAgICB1c2VyU2lnbmluZ01hdGVyaWFsLFxuICAgICAgYmFja3VwU2lnbmluZ01hdGVyaWFsLFxuICAgICAgZGVyaXZhdGlvblBhdGgsXG4gICAgICB1bnNpZ25lZFR4XG4gICAgKTtcbiAgICB0eEJ1aWxkZXIuYWRkU2lnbmF0dXJlKHsgcHViOiBkZXJpdmVkUHVibGljS2V5IH0sIHNpZ25hdHVyZUhleCk7XG4gIH1cblxuICBhc3luYyBicm9hZGNhc3RUcmFuc2FjdGlvbih7XG4gICAgdHJhbnNhY3Rpb25zLFxuICB9OiBCYXNlQnJvYWRjYXN0VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxCYXNlQnJvYWRjYXN0VHJhbnNhY3Rpb25SZXN1bHQ+IHtcbiAgICBjb25zdCB0eElkczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmdldFB1YmxpY05vZGVVcmwoKTtcbiAgICBsZXQgZGlnZXN0ID0gJyc7XG4gICAgaWYgKCEhdHJhbnNhY3Rpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IHR4biBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkaWdlc3QgPSBhd2FpdCB1dGlscy5leGVjdXRlVHJhbnNhY3Rpb25CbG9jayh1cmwsIHR4bi5zZXJpYWxpemVkVHgsIFt0eG4uc2lnbmF0dXJlIV0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gYnJvYWRjYXN0IHRyYW5zYWN0aW9uLCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdHhJZHMucHVzaChkaWdlc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB0eElkcyB9O1xuICB9XG5cbiAgLyoqIGluaGVyaXRlZCBkb2MgKi9cbiAgYXN5bmMgY3JlYXRlQnJvYWRjYXN0YWJsZVN3ZWVwVHJhbnNhY3Rpb24ocGFyYW1zOiBNUENTd2VlcFJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8TVBDVHhzPiB7XG4gICAgY29uc3QgcmVxID0gcGFyYW1zLnNpZ25hdHVyZVNoYXJlcztcbiAgICBjb25zdCBicm9hZGNhc3RhYmxlVHJhbnNhY3Rpb25zOiBNUENUeFtdID0gW107XG4gICAgbGV0IGxhc3RTY2FuSW5kZXggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IE1QQyA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRJbml0aWFsaXplZE1wY0luc3RhbmNlKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHJlcVtpXS50eFJlcXVlc3QudHJhbnNhY3Rpb25zWzBdLnVuc2lnbmVkVHg7XG4gICAgICBpZiAoIXJlcVtpXS5vdmMgfHwgIXJlcVtpXS5vdmNbMF0uZWRkc2FTaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hdHVyZShzKScpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcmVxW2ldLm92Y1swXS5lZGRzYVNpZ25hdHVyZTtcbiAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmFibGVIZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hYmxlIGhleCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnNpZ25hYmxlSGV4ISwgJ2hleCcpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gTVBDLnZlcmlmeShtZXNzYWdlQnVmZmVyLCBzaWduYXR1cmUpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlSGV4ID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oc2lnbmF0dXJlLlIsICdoZXgnKSwgQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNpZ21hLCAnaGV4JyldKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUeEJhc2U2NCA9IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnNlcmlhbGl6ZWRUeCwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIGNvbnN0IHR4QnVpbGRlciA9IHRoaXMuZ2V0QnVpbGRlcigpLmZyb20oc2VyaWFsaXplZFR4QmFzZTY0KTtcbiAgICAgIGlmICghdHJhbnNhY3Rpb24uY29pblNwZWNpZmljPy5jb21tb25LZXljaGFpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY29tbW9uIGtleWNoYWluJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21tb25LZXljaGFpbiA9IHRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYyEuY29tbW9uS2V5Y2hhaW4hIGFzIHN0cmluZztcbiAgICAgIGlmICghdHJhbnNhY3Rpb24uZGVyaXZhdGlvblBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRlcml2YXRpb24gcGF0aCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSB0cmFuc2FjdGlvbi5kZXJpdmF0aW9uUGF0aCBhcyBzdHJpbmc7XG4gICAgICBjb25zdCBkZXJpdmVkUHVibGljS2V5ID0gTVBDLmRlcml2ZVVuaGFyZGVuZWQoY29tbW9uS2V5Y2hhaW4sIGRlcml2YXRpb25QYXRoKS5zbGljZSgwLCA2NCk7XG5cbiAgICAgIC8vIGFkZCBjb21iaW5lZCBzaWduYXR1cmUgZnJvbSBvdmNcbiAgICAgIHR4QnVpbGRlci5hZGRTaWduYXR1cmUoeyBwdWI6IGRlcml2ZWRQdWJsaWNLZXkgfSwgc2lnbmF0dXJlSGV4KTtcbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gKGF3YWl0IHR4QnVpbGRlci5idWlsZCgpKSBhcyBUcmFuc2ZlclRyYW5zYWN0aW9uO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZFR4ID0gc2lnbmVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcbiAgICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IHNpZ25lZFRyYW5zYWN0aW9uLmV4cGxhaW5UcmFuc2FjdGlvbigpLm91dHB1dEFtb3VudDtcblxuICAgICAgYnJvYWRjYXN0YWJsZVRyYW5zYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgc2VyaWFsaXplZFR4OiBzZXJpYWxpemVkVHgsXG4gICAgICAgIHNjYW5JbmRleDogdHJhbnNhY3Rpb24uc2NhbkluZGV4LFxuICAgICAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKHNpZ25lZFRyYW5zYWN0aW9uLnNlcmlhbGl6ZWRTaWcpLnRvU3RyaW5nKCdiYXNlNjQnKSxcbiAgICAgICAgcmVjb3ZlcnlBbW91bnQ6IG91dHB1dEFtb3VudC50b1N0cmluZygpLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpID09PSByZXEubGVuZ3RoIC0gMSAmJiB0cmFuc2FjdGlvbi5jb2luU3BlY2lmaWMhLmxhc3RTY2FuSW5kZXgpIHtcbiAgICAgICAgbGFzdFNjYW5JbmRleCA9IHRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYyEubGFzdFNjYW5JbmRleCBhcyBudW1iZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJhbnNhY3Rpb25zOiBicm9hZGNhc3RhYmxlVHJhbnNhY3Rpb25zLCBsYXN0U2NhbkluZGV4IH07XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIG5hdGl2ZSBTVUkgcmVjb3ZlcmllcyBvZiByZWNlaXZlIGFkZHJlc3NlcyBpbiBiYXRjaCB3aXRob3V0IEJpdEdvLlxuICAgKiBGdW5kcyB3aWxsIGJlIHJlY292ZXJlZCB0byBiYXNlIGFkZHJlc3MgZmlyc3QuIFlvdSBuZWVkIHRvIGluaXRpYXRlIGFub3RoZXIgc3dlZXAgdHhuIGFmdGVyIHRoYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7TVBDQ29uc29saWRhdGlvblJlY292ZXJ5T3B0aW9uc30gcGFyYW1zIC0gb3B0aW9ucyBmb3IgY29uc29saWRhdGlvbiByZWNvdmVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuc3RhcnRpbmdTY2FuSW5kZXhdIC0gcmVjZWl2ZSBhZGRyZXNzIGluZGV4IHRvIHN0YXJ0IHNjYW5uaW5nIGZyb20uIGRlZmF1bHQgdG8gMSAoaW5jbHVzaXZlKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuZW5kaW5nU2NhbkluZGV4XSAtIHJlY2VpdmUgYWRkcmVzcyBpbmRleCB0byBlbmQgc2Nhbm5pbmcgYXQuIGRlZmF1bHQgdG8gc3RhcnRpbmdTY2FuSW5kZXggKyAyMCAoZXhjbHVzaXZlKS5cbiAgICovXG4gIGFzeW5jIHJlY292ZXJDb25zb2xpZGF0aW9ucyhwYXJhbXM6IE1QQ0NvbnNvbGlkYXRpb25SZWNvdmVyeU9wdGlvbnMpOiBQcm9taXNlPE1QQ1R4cyB8IE1QQ1N3ZWVwVHhzPiB7XG4gICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gIXBhcmFtcy51c2VyS2V5ICYmICFwYXJhbXMuYmFja3VwS2V5ICYmICFwYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcbiAgICBjb25zdCBzdGFydElkeCA9IHV0aWxzLnZhbGlkYXRlTm9uTmVnYXRpdmVOdW1iZXIoXG4gICAgICAxLFxuICAgICAgJ0ludmFsaWQgc3RhcnRpbmcgaW5kZXggdG8gc2NhbiBmb3IgYWRkcmVzc2VzJyxcbiAgICAgIHBhcmFtcy5zdGFydGluZ1NjYW5JbmRleFxuICAgICk7XG4gICAgY29uc3QgZW5kSWR4ID0gdXRpbHMudmFsaWRhdGVOb25OZWdhdGl2ZU51bWJlcihcbiAgICAgIHN0YXJ0SWR4ICsgREVGQVVMVF9TQ0FOX0ZBQ1RPUixcbiAgICAgICdJbnZhbGlkIGVuZGluZyBpbmRleCB0byBzY2FuIGZvciBhZGRyZXNzZXMnLFxuICAgICAgcGFyYW1zLmVuZGluZ1NjYW5JbmRleFxuICAgICk7XG5cbiAgICBpZiAoc3RhcnRJZHggPCAxIHx8IGVuZElkeCA8PSBzdGFydElkeCB8fCBlbmRJZHggLSBzdGFydElkeCA+IDEwICogREVGQVVMVF9TQ0FOX0ZBQ1RPUikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBzdGFydGluZyBvciBlbmRpbmcgaW5kZXggdG8gc2NhbiBmb3IgYWRkcmVzc2VzLiBzdGFydGluZ1NjYW5JbmRleDogJHtzdGFydElkeH0sIGVuZGluZ1NjYW5JbmRleDogJHtlbmRJZHh9LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgYml0Z29LZXkgPSBwYXJhbXMuYml0Z29LZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBjb25zdCBNUEMgPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0SW5pdGlhbGl6ZWRNcGNJbnN0YW5jZSgpO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gYG0vMGA7XG4gICAgY29uc3QgZGVyaXZlZFB1YmxpY0tleSA9IE1QQy5kZXJpdmVVbmhhcmRlbmVkKGJpdGdvS2V5LCBkZXJpdmF0aW9uUGF0aCkuc2xpY2UoMCwgNjQpO1xuICAgIGNvbnN0IGJhc2VBZGRyZXNzID0gdGhpcy5nZXRBZGRyZXNzRnJvbVB1YmxpY0tleShkZXJpdmVkUHVibGljS2V5KTtcblxuICAgIGNvbnN0IGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnM6IGFueVtdID0gW107XG4gICAgbGV0IGxhc3RTY2FuSW5kZXggPSBzdGFydElkeDtcbiAgICBmb3IgKGxldCBpZHggPSBzdGFydElkeDsgaWR4IDwgZW5kSWR4OyBpZHgrKykge1xuICAgICAgY29uc3QgcmVjb3ZlclBhcmFtcyA9IHtcbiAgICAgICAgdXNlcktleTogcGFyYW1zLnVzZXJLZXksXG4gICAgICAgIGJhY2t1cEtleTogcGFyYW1zLmJhY2t1cEtleSxcbiAgICAgICAgYml0Z29LZXk6IHBhcmFtcy5iaXRnb0tleSxcbiAgICAgICAgd2FsbGV0UGFzc3BocmFzZTogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIHJlY292ZXJ5RGVzdGluYXRpb246IGJhc2VBZGRyZXNzLFxuICAgICAgICBzdGFydGluZ1NjYW5JbmRleDogaWR4LFxuICAgICAgICBzY2FuOiAxLFxuICAgICAgfTtcblxuICAgICAgbGV0IHJlY292ZXJ5VHJhbnNhY3Rpb246IE1QQ1R4cyB8IE1QQ1N3ZWVwVHhzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVjb3ZlcnlUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMucmVjb3ZlcihyZWNvdmVyUGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUubWVzc2FnZS5zdGFydHNXaXRoKCdEaWQgbm90IGZpbmQgYW4gYWRkcmVzcyB3aXRoIHN1ZmZpY2llbnQgZnVuZHMgdG8gcmVjb3Zlci4nKSkge1xuICAgICAgICAgIGxhc3RTY2FuSW5kZXggPSBpZHg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLnB1c2goKHJlY292ZXJ5VHJhbnNhY3Rpb24gYXMgTVBDU3dlZXBUeHMpLnR4UmVxdWVzdHNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29saWRhdGlvblRyYW5zYWN0aW9ucy5wdXNoKChyZWNvdmVyeVRyYW5zYWN0aW9uIGFzIE1QQ1R4cykudHJhbnNhY3Rpb25zWzBdKTtcbiAgICAgIH1cbiAgICAgIGxhc3RTY2FuSW5kZXggPSBpZHg7XG4gICAgfVxuXG4gICAgaWYgKGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBEaWQgbm90IGZpbmQgYW4gYWRkcmVzcyB3aXRoIHN1ZmZpY2llbnQgZnVuZHMgdG8gcmVjb3Zlci4gUGxlYXNlIHN0YXJ0IHRoZSBuZXh0IHNjYW4gYXQgYWRkcmVzcyBpbmRleCAke1xuICAgICAgICAgIGxhc3RTY2FuSW5kZXggKyAxXG4gICAgICAgIH0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAvLyBsYXN0U2NhbkluZGV4IHdpbGwgYmUgdXNlZCB0byBpbmZvcm0gdXNlciB0aGUgbGFzdCBhZGRyZXNzIGluZGV4IHNjYW5uZWQgZm9yIGF2YWlsYWJsZSBmdW5kcyAoc28gdGhleSBjYW5cbiAgICAgIC8vIGFwcHJvcHJpYXRlbHkgYWRqdXN0IHRoZSBzY2FuIHJhbmdlIG9uIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiBjb25zb2xpZGF0aW9uIHJlY292ZXJpZXMpLiBJbiB0aGUgY2FzZSBvZiB1bnNpZ25lZFxuICAgICAgLy8gc3dlZXAgY29uc29saWRhdGlvbnMsIHRoaXMgbGFzdFNjYW5JbmRleCB3aWxsIGJlIHByb3ZpZGVkIGluIHRoZSBjb2luU3BlY2lmaWMgb2YgdGhlIGxhc3QgdHhuIG1hZGUuXG4gICAgICBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zW1xuICAgICAgICBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFcbiAgICAgIF0udHJhbnNhY3Rpb25zWzBdLnVuc2lnbmVkVHguY29pblNwZWNpZmljLmxhc3RTY2FuSW5kZXggPSBsYXN0U2NhbkluZGV4O1xuICAgICAgcmV0dXJuIHsgdHhSZXF1ZXN0czogY29uc29saWRhdGlvblRyYW5zYWN0aW9ucyB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IHRyYW5zYWN0aW9uczogY29uc29saWRhdGlvblRyYW5zYWN0aW9ucywgbGFzdFNjYW5JbmRleCB9O1xuICB9XG59XG4iXX0=