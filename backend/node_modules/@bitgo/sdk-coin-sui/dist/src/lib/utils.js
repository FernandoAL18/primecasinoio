"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntentScope = exports.IntentVersion = exports.AppId = exports.Utils = exports.isImmOrOwnedObj = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const constants_1 = require("./constants");
const sui_bcs_1 = require("./mystenlab/types/sui-bcs");
const bcs_1 = require("@mysten/bcs");
const iface_1 = require("./iface");
const buffer_1 = require("buffer");
const types_1 = require("./mystenlab/types");
const builder_1 = require("./mystenlab/builder");
const keyPair_1 = require("./keyPair");
const blake2b_1 = __importDefault(require("@bitgo/blake2b"));
const TransactionDataBlock_1 = require("./mystenlab/builder/TransactionDataBlock");
const rpcClient_1 = require("./rpcClient");
const assert_1 = __importDefault(require("assert"));
function isImmOrOwnedObj(obj) {
    return 'ImmOrOwned' in obj;
}
exports.isImmOrOwnedObj = isImmOrOwnedObj;
class Utils {
    /** @inheritdoc */
    isValidBlockId(hash) {
        throw new Error('Method not implemented.');
    }
    /** @inheritdoc */
    isValidPrivateKey(key) {
        throw new Error('Method not implemented.');
    }
    /** @inheritdoc */
    isValidPublicKey(key) {
        return (0, sdk_core_1.isValidEd25519PublicKey)(key);
    }
    /** @inheritdoc */
    isValidSignature(signature) {
        throw new Error('Method not implemented.');
    }
    /** @inheritdoc */
    isValidTransactionId(txId) {
        throw new Error('Method not implemented.');
    }
    /**
     * Checks if raw transaction can be deserialized
     *
     * @param {string} rawTransaction - transaction in base64 string format
     * @returns {boolean} - the validation result
     */
    isValidRawTransaction(rawTransaction) {
        try {
            const data = (0, bcs_1.fromB64)(rawTransaction);
            const deserialized = builder_1.builder.de('TransactionData', data);
            builder_1.builder.ser('TransactionData', deserialized, { maxSize: TransactionDataBlock_1.TRANSACTION_DATA_MAX_SIZE });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
     *
     * @param {string} rawTransaction - Transaction in base64 string  format
     */
    validateRawTransaction(rawTransaction) {
        if (!rawTransaction) {
            throw new sdk_core_1.ParseTransactionError('Invalid raw transaction: Undefined');
        }
        if (!this.isValidRawTransaction(rawTransaction)) {
            throw new sdk_core_1.ParseTransactionError('Invalid raw transaction');
        }
    }
    /**
     * Validates addresses to check if all exist and are valid Sui public keys
     *
     * @param {string} addresses The address to be validated
     * @param {string} fieldName Name of the field to validate, its needed to return which field is failing on case of error.
     */
    validateAddresses(addresses, fieldName) {
        for (const address of addresses) {
            this.validateAddress(address, fieldName);
        }
    }
    /**
     * Validates address to check if it exists and is a valid Sui public key
     *
     * @param {string} address The address to be validated
     * @param {string} fieldName Name of the field to validate, its needed to return which field is failing on case of error.
     */
    validateAddress(address, fieldName) {
        if (!address || !(0, types_1.isValidSuiAddress)((0, types_1.normalizeSuiAddress)(address))) {
            throw new sdk_core_1.BuildTransactionError(`Invalid or missing ${fieldName}, got: ${address}`);
        }
    }
    /** @inheritdoc */
    isValidAddress(address) {
        return this.isHex(address) && this.getHexByteLength(address) === constants_1.SUI_ADDRESS_LENGTH;
    }
    isHex(value) {
        return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
    }
    getHexByteLength(value) {
        // return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
        return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
    }
    /**
     * Returns whether or not the string is a valid amount
     *
     * @param {number[]} amounts - the amounts to validate
     * @returns {boolean} - the validation result
     */
    isValidAmounts(amounts) {
        for (const amount of amounts) {
            if (!this.isValidAmount(amount)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns whether or not the string is a valid amount
     *
     * @param {number} amounts - the amount to validate
     * @returns {boolean} - the validation result
     */
    isValidAmount(amount) {
        const bigNumberAmount = new bignumber_js_1.default(Number(amount));
        if (!bigNumberAmount.isInteger() || bigNumberAmount.isLessThanOrEqualTo(0)) {
            return false;
        }
        return true;
    }
    /**
     * Normalizes hex ids (addresses, object ids) to always contain the '0x' prefix.
     *
     * @param {string} id
     * @return {string}
     **/
    normalizeHexId(id) {
        return id.startsWith('0x') ? id : '0x'.concat(id);
    }
    /**
     * Get transaction type by function name
     *
     * @param {MethodNames} fctName
     * @return {TransactionType}
     */
    getTransactionType(suiTransactionType) {
        switch (suiTransactionType) {
            case iface_1.SuiTransactionType.Transfer:
            case iface_1.SuiTransactionType.TokenTransfer:
                return sdk_core_1.TransactionType.Send;
            case iface_1.SuiTransactionType.AddStake:
                return sdk_core_1.TransactionType.StakingAdd;
            case iface_1.SuiTransactionType.WithdrawStake:
                return sdk_core_1.TransactionType.StakingWithdraw;
            case iface_1.SuiTransactionType.CustomTx:
                return sdk_core_1.TransactionType.CustomTx;
        }
    }
    /**
     * Get SUI transaction type
     *
     * @param {MethodNames} fctName
     * @return {TransactionType}
     */
    getSuiTransactionType(command) {
        switch (command.kind) {
            case 'SplitCoins':
                if (command.coin.kind === 'GasCoin') {
                    return iface_1.SuiTransactionType.Transfer;
                }
                return iface_1.SuiTransactionType.TokenTransfer;
            case 'TransferObjects':
                return iface_1.SuiTransactionType.Transfer;
            case 'MergeCoins':
                if (command.destination.kind === 'GasCoin') {
                    return iface_1.SuiTransactionType.Transfer;
                }
                return iface_1.SuiTransactionType.TokenTransfer;
            case 'MoveCall':
                if (command.target.endsWith(iface_1.MethodNames.RequestAddStake)) {
                    return iface_1.SuiTransactionType.AddStake;
                }
                else if (command.target.endsWith(iface_1.MethodNames.RequestWithdrawStake)) {
                    return iface_1.SuiTransactionType.WithdrawStake;
                }
                else if (command.target.endsWith(iface_1.MethodNames.StakingPoolSplit) ||
                    command.target.endsWith(iface_1.MethodNames.PublicTransfer)) {
                    return iface_1.SuiTransactionType.CustomTx;
                }
                else {
                    throw new sdk_core_1.InvalidTransactionError(`unsupported target method ${command.target}`);
                }
            default:
                throw new sdk_core_1.InvalidTransactionError(`unsupported transaction kind ${command.kind}`);
        }
    }
    getRecipients(tx) {
        const receipts = [];
        const splitResults = [];
        tx.tx.transactions.forEach((transaction) => {
            if (transaction.kind === 'SplitCoins') {
                const index = transaction.amounts[0].index;
                const input = tx.tx.inputs[index];
                splitResults.push(this.getAmount(input));
            }
            if (transaction.kind === 'MoveCall' && transaction.target.endsWith(iface_1.MethodNames.StakingPoolSplit)) {
                const index = transaction.arguments[1].index;
                const input = tx.tx.inputs[index];
                splitResults.push(this.getAmount(input));
            }
        });
        const destinations = [];
        tx.tx.transactions.forEach((transaction) => {
            if (transaction.kind === 'TransferObjects') {
                const index = transaction.address.index;
                const input = tx.tx.inputs[index];
                destinations.push(this.getAddress(input));
            }
        });
        destinations.map((address, i) => {
            receipts.push({
                address: address,
                amount: splitResults[i].toString(),
            });
        });
        tx.tx.transactions.forEach((transaction) => {
            if (transaction.kind === 'MoveCall' && transaction.target.endsWith(iface_1.MethodNames.PublicTransfer)) {
                const destinationArg = transaction.arguments[1];
                const destinationInput = tx.tx.inputs[destinationArg.index];
                const destination = this.getAddress(destinationInput);
                const movingObject = transaction.arguments[0];
                if (movingObject.kind === 'Input') {
                    receipts.push({
                        address: destination,
                        amount: '0',
                        data: 'unknown amount',
                    });
                }
                else if (movingObject.kind === 'Result') {
                    receipts.push({
                        address: destination,
                        amount: splitResults[movingObject.index].toString(),
                    });
                }
            }
        });
        return receipts;
    }
    /**
     * Get add staking requests
     *
     * @param {StakingProgrammableTransaction} tx: staking transaction object
     * @return {RequestAddStake[]}  add staking requests
     */
    getStakeRequests(tx) {
        const amounts = [];
        const addresses = [];
        tx.transactions.forEach((transaction, i) => {
            if (transaction.kind === 'SplitCoins') {
                const amountInputIdx = transaction.amounts[0].index;
                amounts.push(utils.getAmount(tx.inputs[amountInputIdx]));
            }
            if (transaction.kind === 'MoveCall') {
                const validatorAddressInputIdx = transaction.arguments[2]
                    .index;
                const validatorAddress = utils.getAddress(tx.inputs[validatorAddressInputIdx]);
                addresses.push(validatorAddress);
            }
        });
        return addresses.map((address, index) => {
            return {
                validatorAddress: address,
                amount: amounts[index],
            };
        });
    }
    getAmount(input) {
        return (0, sui_bcs_1.isPureArg)(input)
            ? builder_1.builder.de(bcs_1.BCS.U64, buffer_1.Buffer.from(new Uint16Array(input.Pure)).toString('base64'), 'base64')
            : input.value;
    }
    getAddress(input) {
        var _a;
        if (input.hasOwnProperty('value')) {
            return (0, sui_bcs_1.isPureArg)(input.value)
                ? (0, types_1.normalizeSuiAddress)(builder_1.builder.de(bcs_1.BCS.ADDRESS, buffer_1.Buffer.from(new Uint16Array((_a = input.value) === null || _a === void 0 ? void 0 : _a.Pure)).toString('base64'), 'base64'))
                : input.value;
        }
        else {
            return (0, sui_bcs_1.isPureArg)(input)
                ? (0, types_1.normalizeSuiAddress)(builder_1.builder.de(bcs_1.BCS.ADDRESS, buffer_1.Buffer.from(new Uint16Array(input.Pure)).toString('base64'), 'base64'))
                : input.value;
        }
    }
    normalizeCoins(coins) {
        return coins.map((coin) => {
            return utils.normalizeSuiObjectRef(coin);
        });
    }
    normalizeSuiObjectRef(obj) {
        return {
            objectId: (0, types_1.normalizeSuiObjectId)(obj.objectId),
            version: Number(obj.version),
            digest: obj.digest,
        };
    }
    transactionInput(type, index = 0, value) {
        return {
            kind: 'Input',
            value: typeof value === 'bigint' ? String(value) : value,
            index,
            type,
        };
    }
    getAddressFromPublicKey(publicKey) {
        const PUBLIC_KEY_SIZE = 32;
        const tmp = new Uint8Array(PUBLIC_KEY_SIZE + 1);
        const pubBuf = buffer_1.Buffer.from(publicKey, 'hex');
        tmp.set([keyPair_1.SIGNATURE_SCHEME_TO_FLAG['ED25519']]); // ED25519: 0x00,
        tmp.set(pubBuf, 1);
        return (0, types_1.normalizeSuiAddress)((0, blake2b_1.default)(PUBLIC_KEY_SIZE)
            .update(tmp)
            .digest('hex')
            .slice(0, constants_1.SUI_ADDRESS_LENGTH * 2));
    }
    async getFeeEstimate(url, txHex) {
        const result = await (0, rpcClient_1.makeRPC)(url, 'sui_dryRunTransactionBlock', [txHex]);
        (0, assert_1.default)(result.effects);
        (0, assert_1.default)(result.effects.gasUsed);
        if (result.effects.status.status !== 'success') {
            console.error(`Dry run failed, could not automatically determine a budget for txHex ${txHex}`);
            throw new Error(`Failed to get fee estimate`);
        }
        const gasObject = result.effects.gasUsed;
        const storageCost = new bignumber_js_1.default(gasObject.storageCost);
        const computationCost = new bignumber_js_1.default(gasObject.computationCost);
        const storageRebate = new bignumber_js_1.default(gasObject.storageRebate);
        const netCost = computationCost.plus(storageCost).minus(storageRebate);
        return netCost.comparedTo(computationCost) > 0 ? netCost : computationCost;
    }
    async getBalance(url, owner, coinType) {
        if (coinType === undefined) {
            coinType = types_1.SUI_TYPE_ARG;
        }
        const result = await (0, rpcClient_1.makeRPC)(url, 'suix_getBalance', [owner, coinType]);
        return result.totalBalance;
    }
    async getInputCoins(url, owner, coinType) {
        if (coinType === undefined) {
            coinType = types_1.SUI_TYPE_ARG;
        }
        let hasNextPage = true;
        let cursor = undefined;
        let params = [owner, coinType];
        let data = [];
        while (hasNextPage) {
            if (cursor !== undefined) {
                params = [owner, coinType, cursor];
            }
            try {
                const result = await (0, rpcClient_1.makeRPC)(url, 'suix_getCoins', params);
                data = data.concat(result.data);
                hasNextPage = result.hasNextPage;
                cursor = result.nextCursor;
            }
            catch (e) {
                console.error(`Failed to get input coins from the node ${e}`);
                throw new Error(`Failed to get input coins from the node.`);
            }
        }
        return data
            .filter((object) => object.balance !== undefined)
            .map((object) => {
            return {
                coinType: object.coinType,
                objectId: object.coinObjectId,
                version: object.version,
                digest: object.digest,
                balance: new bignumber_js_1.default(object.balance),
            };
        });
    }
    async executeTransactionBlock(url, serializedTx, signatures) {
        const reqType = 'WaitForEffectsCert';
        const options = { showEffects: true };
        const params = [serializedTx, signatures, options, reqType];
        let result;
        try {
            result = await (0, rpcClient_1.makeRPC)(url, 'sui_executeTransactionBlock', params);
        }
        catch (e) {
            throw new Error(`${e.message}`);
        }
        return result.digest;
    }
    validateNonNegativeNumber(defaultVal, errorMsg, inputVal) {
        if (inputVal === undefined) {
            return defaultVal;
        }
        let nonNegativeNum;
        try {
            nonNegativeNum = Number(inputVal);
        }
        catch (e) {
            throw new Error(errorMsg);
        }
        if (isNaN(nonNegativeNum.valueOf()) || nonNegativeNum < 0) {
            throw new Error(errorMsg);
        }
        return nonNegativeNum;
    }
}
exports.Utils = Utils;
const utils = new Utils();
exports.default = utils;
var AppId;
(function (AppId) {
    AppId[AppId["Sui"] = 0] = "Sui";
})(AppId = exports.AppId || (exports.AppId = {}));
var IntentVersion;
(function (IntentVersion) {
    IntentVersion[IntentVersion["V0"] = 0] = "V0";
})(IntentVersion = exports.IntentVersion || (exports.IntentVersion = {}));
var IntentScope;
(function (IntentScope) {
    IntentScope[IntentScope["TransactionData"] = 0] = "TransactionData";
    IntentScope[IntentScope["TransactionEffects"] = 1] = "TransactionEffects";
    IntentScope[IntentScope["CheckpointSummary"] = 2] = "CheckpointSummary";
    IntentScope[IntentScope["PersonalMessage"] = 3] = "PersonalMessage";
})(IntentScope = exports.IntentScope || (exports.IntentScope = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDhDQVF5QjtBQUN6QixnRUFBcUM7QUFDckMsMkNBQWlEO0FBQ2pELHVEQUFzRDtBQUN0RCxxQ0FBMkM7QUFDM0MsbUNBUWlCO0FBQ2pCLG1DQUFnQztBQUNoQyw2Q0FPMkI7QUFDM0IsaURBUTZCO0FBQzdCLHVDQUFxRDtBQUNyRCw2REFBcUM7QUFDckMsbUZBQXFGO0FBQ3JGLDJDQUFzQztBQUN0QyxvREFBNEI7QUFFNUIsU0FBZ0IsZUFBZSxDQUFDLEdBQTRCO0lBQzFELE9BQU8sWUFBWSxJQUFJLEdBQUcsQ0FBQztBQUM3QixDQUFDO0FBRkQsMENBRUM7QUFFRCxNQUFhLEtBQUs7SUFDaEIsa0JBQWtCO0lBQ2xCLGNBQWMsQ0FBQyxJQUFZO1FBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLGlCQUFpQixDQUFDLEdBQVc7UUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsZ0JBQWdCLENBQUMsR0FBVztRQUMxQixPQUFPLElBQUEsa0NBQXVCLEVBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixnQkFBZ0IsQ0FBQyxTQUFpQjtRQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixvQkFBb0IsQ0FBQyxJQUFZO1FBQy9CLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxxQkFBcUIsQ0FBQyxjQUFzQjtRQUMxQyxJQUFJO1lBQ0YsTUFBTSxJQUFJ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O1NBQ25DO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixNQUFNLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzNCO1FBQ0QsSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksY0FBYyxHQUFHLENBQUMsRUFBRTtZQUN6RCxNQUFNLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzNCO1FBQ0QsT0FBTyxjQUFjLENBQUM7SUFDeEIsQ0FBQztDQUNGO0FBNWFELHNCQTRhQztBQUVELE1BQU0sS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7QUFDMUIsa0JBQWUsS0FBSyxDQUFDO0FBRXJCLElBQVksS0FFWDtBQUZELFdBQVksS0FBSztJQUNmLCtCQUFPLENBQUE7QUFDVCxDQUFDLEVBRlcsS0FBSyxHQUFMLGFBQUssS0FBTCxhQUFLLFFBRWhCO0FBRUQsSUFBWSxhQUVYO0FBRkQsV0FBWSxhQUFhO0lBQ3ZCLDZDQUFNLENBQUE7QUFDUixDQUFDLEVBRlcsYUFBYSxHQUFiLHFCQUFhLEtBQWIscUJBQWEsUUFFeEI7QUFFRCxJQUFZLFdBS1g7QUFMRCxXQUFZLFdBQVc7SUFDckIsbUVBQW1CLENBQUE7SUFDbkIseUVBQXNCLENBQUE7SUFDdEIsdUVBQXFCLENBQUE7SUFDckIsbUVBQW1CLENBQUE7QUFDckIsQ0FBQyxFQUxXLFdBQVcsR0FBWCxtQkFBVyxLQUFYLG1CQUFXLFFBS3RCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmFzZVV0aWxzLFxuICBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsXG4gIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLFxuICBpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleSxcbiAgUGFyc2VUcmFuc2FjdGlvbkVycm9yLFxuICBSZWNpcGllbnQsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IFNVSV9BRERSRVNTX0xFTkdUSCB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGlzUHVyZUFyZyB9IGZyb20gJy4vbXlzdGVubGFiL3R5cGVzL3N1aS1iY3MnO1xuaW1wb3J0IHsgQkNTLCBmcm9tQjY0IH0gZnJvbSAnQG15c3Rlbi9iY3MnO1xuaW1wb3J0IHtcbiAgTWV0aG9kTmFtZXMsXG4gIFJlcXVlc3RBZGRTdGFrZSxcbiAgU3Rha2luZ1Byb2dyYW1tYWJsZVRyYW5zYWN0aW9uLFxuICBTdWlPYmplY3RJbmZvLFxuICBTdWlQcm9ncmFtbWFibGVUcmFuc2FjdGlvbixcbiAgU3VpVHJhbnNhY3Rpb24sXG4gIFN1aVRyYW5zYWN0aW9uVHlwZSxcbn0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHtcbiAgaXNWYWxpZFN1aUFkZHJlc3MsXG4gIG5vcm1hbGl6ZVN1aUFkZHJlc3MsXG4gIG5vcm1hbGl6ZVN1aU9iamVjdElkLFxuICBTVUlfVFlQRV9BUkcsXG4gIFN1aUpzb25WYWx1ZSxcbiAgU3VpT2JqZWN0UmVmLFxufSBmcm9tICcuL215c3RlbmxhYi90eXBlcyc7XG5pbXBvcnQge1xuICBidWlsZGVyLFxuICBNZXJnZUNvaW5zVHJhbnNhY3Rpb24sXG4gIE1vdmVDYWxsVHJhbnNhY3Rpb24sXG4gIE9iamVjdENhbGxBcmcsXG4gIFNwbGl0Q29pbnNUcmFuc2FjdGlvbixcbiAgVHJhbnNhY3Rpb25CbG9ja0lucHV0LFxuICBUcmFuc2FjdGlvblR5cGUgYXMgVHJhbnNhY3Rpb25Db21tYW5kVHlwZSxcbn0gZnJvbSAnLi9teXN0ZW5sYWIvYnVpbGRlcic7XG5pbXBvcnQgeyBTSUdOQVRVUkVfU0NIRU1FX1RPX0ZMQUcgfSBmcm9tICcuL2tleVBhaXInO1xuaW1wb3J0IGJsYWtlMmIgZnJvbSAnQGJpdGdvL2JsYWtlMmInO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fREFUQV9NQVhfU0laRSB9IGZyb20gJy4vbXlzdGVubGFiL2J1aWxkZXIvVHJhbnNhY3Rpb25EYXRhQmxvY2snO1xuaW1wb3J0IHsgbWFrZVJQQyB9IGZyb20gJy4vcnBjQ2xpZW50JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW1tT3JPd25lZE9iaihvYmo6IE9iamVjdENhbGxBcmdbJ09iamVjdCddKTogb2JqIGlzIHsgSW1tT3JPd25lZDogU3VpT2JqZWN0UmVmIH0ge1xuICByZXR1cm4gJ0ltbU9yT3duZWQnIGluIG9iajtcbn1cblxuZXhwb3J0IGNsYXNzIFV0aWxzIGltcGxlbWVudHMgQmFzZVV0aWxzIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRCbG9ja0lkKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkUHJpdmF0ZUtleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkUHVibGljS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzVmFsaWRFZDI1NTE5UHVibGljS2V5KGtleSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFNpZ25hdHVyZShzaWduYXR1cmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkVHJhbnNhY3Rpb25JZCh0eElkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHJhdyB0cmFuc2FjdGlvbiBjYW4gYmUgZGVzZXJpYWxpemVkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByYXdUcmFuc2FjdGlvbiAtIHRyYW5zYWN0aW9uIGluIGJhc2U2NCBzdHJpbmcgZm9ybWF0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgaXNWYWxpZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGZyb21CNjQocmF3VHJhbnNhY3Rpb24pO1xuICAgICAgY29uc3QgZGVzZXJpYWxpemVkID0gYnVpbGRlci5kZSgnVHJhbnNhY3Rpb25EYXRhJywgZGF0YSk7XG4gICAgICBidWlsZGVyLnNlcignVHJhbnNhY3Rpb25EYXRhJywgZGVzZXJpYWxpemVkLCB7IG1heFNpemU6IFRSQU5TQUNUSU9OX0RBVEFfTUFYX1NJWkUgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSByYXcgdHJhbnNhY3Rpb24gaGFzIGEgdmFsaWQgZm9ybWF0IGluIHRoZSBibG9ja2NoYWluIGNvbnRleHQsIHRocm93IG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJhd1RyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gaW4gYmFzZTY0IHN0cmluZyAgZm9ybWF0XG4gICAqL1xuICB2YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIXJhd1RyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHJhdyB0cmFuc2FjdGlvbjogVW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1ZhbGlkUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHJhdyB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYWRkcmVzc2VzIHRvIGNoZWNrIGlmIGFsbCBleGlzdCBhbmQgYXJlIHZhbGlkIFN1aSBwdWJsaWMga2V5c1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc2VzIFRoZSBhZGRyZXNzIHRvIGJlIHZhbGlkYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lIE5hbWUgb2YgdGhlIGZpZWxkIHRvIHZhbGlkYXRlLCBpdHMgbmVlZGVkIHRvIHJldHVybiB3aGljaCBmaWVsZCBpcyBmYWlsaW5nIG9uIGNhc2Ugb2YgZXJyb3IuXG4gICAqL1xuICB2YWxpZGF0ZUFkZHJlc3NlcyhhZGRyZXNzZXM6IHN0cmluZ1tdLCBmaWVsZE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBhZGRyZXNzZXMpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVBZGRyZXNzKGFkZHJlc3MsIGZpZWxkTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhZGRyZXNzIHRvIGNoZWNrIGlmIGl0IGV4aXN0cyBhbmQgaXMgYSB2YWxpZCBTdWkgcHVibGljIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBiZSB2YWxpZGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0byB2YWxpZGF0ZSwgaXRzIG5lZWRlZCB0byByZXR1cm4gd2hpY2ggZmllbGQgaXMgZmFpbGluZyBvbiBjYXNlIG9mIGVycm9yLlxuICAgKi9cbiAgdmFsaWRhdGVBZGRyZXNzKGFkZHJlc3M6IHN0cmluZywgZmllbGROYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIWFkZHJlc3MgfHwgIWlzVmFsaWRTdWlBZGRyZXNzKG5vcm1hbGl6ZVN1aUFkZHJlc3MoYWRkcmVzcykpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIG9yIG1pc3NpbmcgJHtmaWVsZE5hbWV9LCBnb3Q6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNIZXgoYWRkcmVzcykgJiYgdGhpcy5nZXRIZXhCeXRlTGVuZ3RoKGFkZHJlc3MpID09PSBTVUlfQUREUkVTU19MRU5HVEg7XG4gIH1cblxuICBpc0hleCh2YWx1ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIC9eKDB4fDBYKT9bYS1mQS1GMC05XSskLy50ZXN0KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggJSAyID09PSAwO1xuICB9XG5cbiAgZ2V0SGV4Qnl0ZUxlbmd0aCh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAvLyByZXR1cm4gL14oMHh8MFgpLy50ZXN0KHZhbHVlKSA/ICh2YWx1ZS5sZW5ndGggLSAyKSAvIDIgOiB2YWx1ZS5sZW5ndGggLyAyO1xuICAgIHJldHVybiAvXigweHwwWCkvLnRlc3QodmFsdWUpID8gKHZhbHVlLmxlbmd0aCAtIDIpIC8gMiA6IHZhbHVlLmxlbmd0aCAvIDI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgYW1vdW50XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGFtb3VudHMgLSB0aGUgYW1vdW50cyB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAgICovXG4gIGlzVmFsaWRBbW91bnRzKGFtb3VudHM6IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgZm9yIChjb25zdCBhbW91bnQgb2YgYW1vdW50cykge1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRBbW91bnQoYW1vdW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIGFtb3VudFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50cyAtIHRoZSBhbW91bnQgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAqL1xuICBpc1ZhbGlkQW1vdW50KGFtb3VudDogc3RyaW5nIHwgbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYmlnTnVtYmVyQW1vdW50ID0gbmV3IEJpZ051bWJlcihOdW1iZXIoYW1vdW50KSk7XG4gICAgaWYgKCFiaWdOdW1iZXJBbW91bnQuaXNJbnRlZ2VyKCkgfHwgYmlnTnVtYmVyQW1vdW50LmlzTGVzc1RoYW5PckVxdWFsVG8oMCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplcyBoZXggaWRzIChhZGRyZXNzZXMsIG9iamVjdCBpZHMpIHRvIGFsd2F5cyBjb250YWluIHRoZSAnMHgnIHByZWZpeC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICoqL1xuICBub3JtYWxpemVIZXhJZChpZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaWQuc3RhcnRzV2l0aCgnMHgnKSA/IGlkIDogJzB4Jy5jb25jYXQoaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2FjdGlvbiB0eXBlIGJ5IGZ1bmN0aW9uIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtNZXRob2ROYW1lc30gZmN0TmFtZVxuICAgKiBAcmV0dXJuIHtUcmFuc2FjdGlvblR5cGV9XG4gICAqL1xuICBnZXRUcmFuc2FjdGlvblR5cGUoc3VpVHJhbnNhY3Rpb25UeXBlOiBTdWlUcmFuc2FjdGlvblR5cGUpOiBUcmFuc2FjdGlvblR5cGUge1xuICAgIHN3aXRjaCAoc3VpVHJhbnNhY3Rpb25UeXBlKSB7XG4gICAgICBjYXNlIFN1aVRyYW5zYWN0aW9uVHlwZS5UcmFuc2ZlcjpcbiAgICAgIGNhc2UgU3VpVHJhbnNhY3Rpb25UeXBlLlRva2VuVHJhbnNmZXI6XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU2VuZDtcbiAgICAgIGNhc2UgU3VpVHJhbnNhY3Rpb25UeXBlLkFkZFN0YWtlOlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdBZGQ7XG4gICAgICBjYXNlIFN1aVRyYW5zYWN0aW9uVHlwZS5XaXRoZHJhd1N0YWtlOlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdztcbiAgICAgIGNhc2UgU3VpVHJhbnNhY3Rpb25UeXBlLkN1c3RvbVR4OlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLkN1c3RvbVR4O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgU1VJIHRyYW5zYWN0aW9uIHR5cGVcbiAgICpcbiAgICogQHBhcmFtIHtNZXRob2ROYW1lc30gZmN0TmFtZVxuICAgKiBAcmV0dXJuIHtUcmFuc2FjdGlvblR5cGV9XG4gICAqL1xuICBnZXRTdWlUcmFuc2FjdGlvblR5cGUoY29tbWFuZDogVHJhbnNhY3Rpb25Db21tYW5kVHlwZSk6IFN1aVRyYW5zYWN0aW9uVHlwZSB7XG4gICAgc3dpdGNoIChjb21tYW5kLmtpbmQpIHtcbiAgICAgIGNhc2UgJ1NwbGl0Q29pbnMnOlxuICAgICAgICBpZiAoKGNvbW1hbmQgYXMgU3BsaXRDb2luc1RyYW5zYWN0aW9uKS5jb2luLmtpbmQgPT09ICdHYXNDb2luJykge1xuICAgICAgICAgIHJldHVybiBTdWlUcmFuc2FjdGlvblR5cGUuVHJhbnNmZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN1aVRyYW5zYWN0aW9uVHlwZS5Ub2tlblRyYW5zZmVyO1xuICAgICAgY2FzZSAnVHJhbnNmZXJPYmplY3RzJzpcbiAgICAgICAgcmV0dXJuIFN1aVRyYW5zYWN0aW9uVHlwZS5UcmFuc2ZlcjtcbiAgICAgIGNhc2UgJ01lcmdlQ29pbnMnOlxuICAgICAgICBpZiAoKGNvbW1hbmQgYXMgTWVyZ2VDb2luc1RyYW5zYWN0aW9uKS5kZXN0aW5hdGlvbi5raW5kID09PSAnR2FzQ29pbicpIHtcbiAgICAgICAgICByZXR1cm4gU3VpVHJhbnNhY3Rpb25UeXBlLlRyYW5zZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdWlUcmFuc2FjdGlvblR5cGUuVG9rZW5UcmFuc2ZlcjtcbiAgICAgIGNhc2UgJ01vdmVDYWxsJzpcbiAgICAgICAgaWYgKGNvbW1hbmQudGFyZ2V0LmVuZHNXaXRoKE1ldGhvZE5hbWVzLlJlcXVlc3RBZGRTdGFrZSkpIHtcbiAgICAgICAgICByZXR1cm4gU3VpVHJhbnNhY3Rpb25UeXBlLkFkZFN0YWtlO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQudGFyZ2V0LmVuZHNXaXRoKE1ldGhvZE5hbWVzLlJlcXVlc3RXaXRoZHJhd1N0YWtlKSkge1xuICAgICAgICAgIHJldHVybiBTdWlUcmFuc2FjdGlvblR5cGUuV2l0aGRyYXdTdGFrZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBjb21tYW5kLnRhcmdldC5lbmRzV2l0aChNZXRob2ROYW1lcy5TdGFraW5nUG9vbFNwbGl0KSB8fFxuICAgICAgICAgIGNvbW1hbmQudGFyZ2V0LmVuZHNXaXRoKE1ldGhvZE5hbWVzLlB1YmxpY1RyYW5zZmVyKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gU3VpVHJhbnNhY3Rpb25UeXBlLkN1c3RvbVR4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgdW5zdXBwb3J0ZWQgdGFyZ2V0IG1ldGhvZCAke2NvbW1hbmQudGFyZ2V0fWApO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoYHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIGtpbmQgJHtjb21tYW5kLmtpbmR9YCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UmVjaXBpZW50cyh0eDogU3VpVHJhbnNhY3Rpb248U3VpUHJvZ3JhbW1hYmxlVHJhbnNhY3Rpb24+KTogUmVjaXBpZW50W10ge1xuICAgIGNvbnN0IHJlY2VpcHRzOiBSZWNpcGllbnRbXSA9IFtdO1xuICAgIGNvbnN0IHNwbGl0UmVzdWx0czogbnVtYmVyW10gPSBbXTtcbiAgICB0eC50eC50cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIGlmICh0cmFuc2FjdGlvbi5raW5kID09PSAnU3BsaXRDb2lucycpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0cmFuc2FjdGlvbi5hbW91bnRzWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBpbnB1dCA9IHR4LnR4LmlucHV0c1tpbmRleF0gYXMgYW55O1xuICAgICAgICBzcGxpdFJlc3VsdHMucHVzaCh0aGlzLmdldEFtb3VudChpbnB1dCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb24ua2luZCA9PT0gJ01vdmVDYWxsJyAmJiB0cmFuc2FjdGlvbi50YXJnZXQuZW5kc1dpdGgoTWV0aG9kTmFtZXMuU3Rha2luZ1Bvb2xTcGxpdCkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0cmFuc2FjdGlvbi5hcmd1bWVudHNbMV0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdHgudHguaW5wdXRzW2luZGV4XSBhcyBhbnk7XG4gICAgICAgIHNwbGl0UmVzdWx0cy5wdXNoKHRoaXMuZ2V0QW1vdW50KGlucHV0KSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBkZXN0aW5hdGlvbnM6IHN0cmluZ1tdID0gW107XG4gICAgdHgudHgudHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICBpZiAodHJhbnNhY3Rpb24ua2luZCA9PT0gJ1RyYW5zZmVyT2JqZWN0cycpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0cmFuc2FjdGlvbi5hZGRyZXNzLmluZGV4O1xuICAgICAgICBjb25zdCBpbnB1dCA9IHR4LnR4LmlucHV0c1tpbmRleF0gYXMgYW55O1xuICAgICAgICBkZXN0aW5hdGlvbnMucHVzaCh0aGlzLmdldEFkZHJlc3MoaW5wdXQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZXN0aW5hdGlvbnMubWFwKChhZGRyZXNzLCBpKSA9PiB7XG4gICAgICByZWNlaXB0cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBzcGxpdFJlc3VsdHNbaV0udG9TdHJpbmcoKSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdHgudHgudHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICBpZiAodHJhbnNhY3Rpb24ua2luZCA9PT0gJ01vdmVDYWxsJyAmJiB0cmFuc2FjdGlvbi50YXJnZXQuZW5kc1dpdGgoTWV0aG9kTmFtZXMuUHVibGljVHJhbnNmZXIpKSB7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uQXJnID0gdHJhbnNhY3Rpb24uYXJndW1lbnRzWzFdO1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbklucHV0ID0gdHgudHguaW5wdXRzW2Rlc3RpbmF0aW9uQXJnLmluZGV4XSBhcyBhbnk7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gdGhpcy5nZXRBZGRyZXNzKGRlc3RpbmF0aW9uSW5wdXQpO1xuXG4gICAgICAgIGNvbnN0IG1vdmluZ09iamVjdCA9IHRyYW5zYWN0aW9uLmFyZ3VtZW50c1swXTtcbiAgICAgICAgaWYgKG1vdmluZ09iamVjdC5raW5kID09PSAnSW5wdXQnKSB7XG4gICAgICAgICAgcmVjZWlwdHMucHVzaCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIGFtb3VudDogJzAnLCAvLyBzZXQgMCwgbm90IGFibGUgdG8gZ2V0IGFtb3VudCBtZXJlbHkgZnJvbSBwYXJzaW5nXG4gICAgICAgICAgICBkYXRhOiAndW5rbm93biBhbW91bnQnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKG1vdmluZ09iamVjdC5raW5kID09PSAnUmVzdWx0Jykge1xuICAgICAgICAgIHJlY2VpcHRzLnB1c2goe1xuICAgICAgICAgICAgYWRkcmVzczogZGVzdGluYXRpb24sXG4gICAgICAgICAgICBhbW91bnQ6IHNwbGl0UmVzdWx0c1ttb3ZpbmdPYmplY3QuaW5kZXhdLnRvU3RyaW5nKCksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZWNlaXB0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWRkIHN0YWtpbmcgcmVxdWVzdHNcbiAgICpcbiAgICogQHBhcmFtIHtTdGFraW5nUHJvZ3JhbW1hYmxlVHJhbnNhY3Rpb259IHR4OiBzdGFraW5nIHRyYW5zYWN0aW9uIG9iamVjdFxuICAgKiBAcmV0dXJuIHtSZXF1ZXN0QWRkU3Rha2VbXX0gIGFkZCBzdGFraW5nIHJlcXVlc3RzXG4gICAqL1xuICBnZXRTdGFrZVJlcXVlc3RzKHR4OiBTdGFraW5nUHJvZ3JhbW1hYmxlVHJhbnNhY3Rpb24pOiBSZXF1ZXN0QWRkU3Rha2VbXSB7XG4gICAgY29uc3QgYW1vdW50czogbnVtYmVyW10gPSBbXTtcbiAgICBjb25zdCBhZGRyZXNzZXM6IHN0cmluZ1tdID0gW107XG4gICAgdHgudHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uLCBpKSA9PiB7XG4gICAgICBpZiAodHJhbnNhY3Rpb24ua2luZCA9PT0gJ1NwbGl0Q29pbnMnKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudElucHV0SWR4ID0gKCh0cmFuc2FjdGlvbiBhcyBTcGxpdENvaW5zVHJhbnNhY3Rpb24pLmFtb3VudHNbMF0gYXMgVHJhbnNhY3Rpb25CbG9ja0lucHV0KS5pbmRleDtcbiAgICAgICAgYW1vdW50cy5wdXNoKHV0aWxzLmdldEFtb3VudCh0eC5pbnB1dHNbYW1vdW50SW5wdXRJZHhdIGFzIFRyYW5zYWN0aW9uQmxvY2tJbnB1dCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zYWN0aW9uLmtpbmQgPT09ICdNb3ZlQ2FsbCcpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yQWRkcmVzc0lucHV0SWR4ID0gKCh0cmFuc2FjdGlvbiBhcyBNb3ZlQ2FsbFRyYW5zYWN0aW9uKS5hcmd1bWVudHNbMl0gYXMgVHJhbnNhY3Rpb25CbG9ja0lucHV0KVxuICAgICAgICAgIC5pbmRleDtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yQWRkcmVzcyA9IHV0aWxzLmdldEFkZHJlc3ModHguaW5wdXRzW3ZhbGlkYXRvckFkZHJlc3NJbnB1dElkeF0gYXMgVHJhbnNhY3Rpb25CbG9ja0lucHV0KTtcbiAgICAgICAgYWRkcmVzc2VzLnB1c2godmFsaWRhdG9yQWRkcmVzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IGFtb3VudHNbaW5kZXhdLFxuICAgICAgfSBhcyBSZXF1ZXN0QWRkU3Rha2U7XG4gICAgfSk7XG4gIH1cblxuICBnZXRBbW91bnQoaW5wdXQ6IFN1aUpzb25WYWx1ZSB8IFRyYW5zYWN0aW9uQmxvY2tJbnB1dCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGlzUHVyZUFyZyhpbnB1dClcbiAgICAgID8gYnVpbGRlci5kZShCQ1MuVTY0LCBCdWZmZXIuZnJvbShuZXcgVWludDE2QXJyYXkoaW5wdXQuUHVyZSkpLnRvU3RyaW5nKCdiYXNlNjQnKSwgJ2Jhc2U2NCcpXG4gICAgICA6IChpbnB1dCBhcyBUcmFuc2FjdGlvbkJsb2NrSW5wdXQpLnZhbHVlO1xuICB9XG5cbiAgZ2V0QWRkcmVzcyhpbnB1dDogVHJhbnNhY3Rpb25CbG9ja0lucHV0KTogc3RyaW5nIHtcbiAgICBpZiAoaW5wdXQuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcbiAgICAgIHJldHVybiBpc1B1cmVBcmcoaW5wdXQudmFsdWUpXG4gICAgICAgID8gbm9ybWFsaXplU3VpQWRkcmVzcyhcbiAgICAgICAgICAgIGJ1aWxkZXIuZGUoQkNTLkFERFJFU1MsIEJ1ZmZlci5mcm9tKG5ldyBVaW50MTZBcnJheShpbnB1dC52YWx1ZT8uUHVyZSkpLnRvU3RyaW5nKCdiYXNlNjQnKSwgJ2Jhc2U2NCcpXG4gICAgICAgICAgKVxuICAgICAgICA6IChpbnB1dCBhcyBUcmFuc2FjdGlvbkJsb2NrSW5wdXQpLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXNQdXJlQXJnKGlucHV0KVxuICAgICAgICA/IG5vcm1hbGl6ZVN1aUFkZHJlc3MoXG4gICAgICAgICAgICBidWlsZGVyLmRlKEJDUy5BRERSRVNTLCBCdWZmZXIuZnJvbShuZXcgVWludDE2QXJyYXkoaW5wdXQuUHVyZSkpLnRvU3RyaW5nKCdiYXNlNjQnKSwgJ2Jhc2U2NCcpXG4gICAgICAgICAgKVxuICAgICAgICA6IChpbnB1dCBhcyBUcmFuc2FjdGlvbkJsb2NrSW5wdXQpLnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIG5vcm1hbGl6ZUNvaW5zKGNvaW5zOiBhbnlbXSk6IFN1aU9iamVjdFJlZltdIHtcbiAgICByZXR1cm4gY29pbnMubWFwKChjb2luKSA9PiB7XG4gICAgICByZXR1cm4gdXRpbHMubm9ybWFsaXplU3VpT2JqZWN0UmVmKGNvaW4pO1xuICAgIH0pO1xuICB9XG5cbiAgbm9ybWFsaXplU3VpT2JqZWN0UmVmKG9iajogU3VpT2JqZWN0UmVmKTogU3VpT2JqZWN0UmVmIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2JqZWN0SWQ6IG5vcm1hbGl6ZVN1aU9iamVjdElkKG9iai5vYmplY3RJZCksXG4gICAgICB2ZXJzaW9uOiBOdW1iZXIob2JqLnZlcnNpb24pLFxuICAgICAgZGlnZXN0OiBvYmouZGlnZXN0LFxuICAgIH07XG4gIH1cblxuICB0cmFuc2FjdGlvbklucHV0KHR5cGU6ICdvYmplY3QnIHwgJ3B1cmUnLCBpbmRleCA9IDAsIHZhbHVlPzogdW5rbm93bik6IFRyYW5zYWN0aW9uQmxvY2tJbnB1dCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6ICdJbnB1dCcsXG4gICAgICB2YWx1ZTogdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/IFN0cmluZyh2YWx1ZSkgOiB2YWx1ZSxcbiAgICAgIGluZGV4LFxuICAgICAgdHlwZSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkocHVibGljS2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IFBVQkxJQ19LRVlfU0laRSA9IDMyO1xuICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KFBVQkxJQ19LRVlfU0laRSArIDEpO1xuICAgIGNvbnN0IHB1YkJ1ZiA9IEJ1ZmZlci5mcm9tKHB1YmxpY0tleSwgJ2hleCcpO1xuICAgIHRtcC5zZXQoW1NJR05BVFVSRV9TQ0hFTUVfVE9fRkxBR1snRUQyNTUxOSddXSk7IC8vIEVEMjU1MTk6IDB4MDAsXG4gICAgdG1wLnNldChwdWJCdWYsIDEpO1xuICAgIHJldHVybiBub3JtYWxpemVTdWlBZGRyZXNzKFxuICAgICAgYmxha2UyYihQVUJMSUNfS0VZX1NJWkUpXG4gICAgICAgIC51cGRhdGUodG1wKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKVxuICAgICAgICAuc2xpY2UoMCwgU1VJX0FERFJFU1NfTEVOR1RIICogMilcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZ2V0RmVlRXN0aW1hdGUodXJsOiBzdHJpbmcsIHR4SGV4OiBzdHJpbmcpOiBQcm9taXNlPEJpZ051bWJlcj4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1ha2VSUEModXJsLCAnc3VpX2RyeVJ1blRyYW5zYWN0aW9uQmxvY2snLCBbdHhIZXhdKTtcbiAgICBhc3NlcnQocmVzdWx0LmVmZmVjdHMpO1xuICAgIGFzc2VydChyZXN1bHQuZWZmZWN0cy5nYXNVc2VkKTtcblxuICAgIGlmIChyZXN1bHQuZWZmZWN0cy5zdGF0dXMuc3RhdHVzICE9PSAnc3VjY2VzcycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYERyeSBydW4gZmFpbGVkLCBjb3VsZCBub3QgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgYSBidWRnZXQgZm9yIHR4SGV4ICR7dHhIZXh9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZmVlIGVzdGltYXRlYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2FzT2JqZWN0ID0gcmVzdWx0LmVmZmVjdHMuZ2FzVXNlZDtcblxuICAgIGNvbnN0IHN0b3JhZ2VDb3N0ID0gbmV3IEJpZ051bWJlcihnYXNPYmplY3Quc3RvcmFnZUNvc3QpO1xuICAgIGNvbnN0IGNvbXB1dGF0aW9uQ29zdCA9IG5ldyBCaWdOdW1iZXIoZ2FzT2JqZWN0LmNvbXB1dGF0aW9uQ29zdCk7XG4gICAgY29uc3Qgc3RvcmFnZVJlYmF0ZSA9IG5ldyBCaWdOdW1iZXIoZ2FzT2JqZWN0LnN0b3JhZ2VSZWJhdGUpO1xuICAgIGNvbnN0IG5ldENvc3QgPSBjb21wdXRhdGlvbkNvc3QucGx1cyhzdG9yYWdlQ29zdCkubWludXMoc3RvcmFnZVJlYmF0ZSk7XG5cbiAgICByZXR1cm4gbmV0Q29zdC5jb21wYXJlZFRvKGNvbXB1dGF0aW9uQ29zdCkgPiAwID8gbmV0Q29zdCA6IGNvbXB1dGF0aW9uQ29zdDtcbiAgfVxuXG4gIGFzeW5jIGdldEJhbGFuY2UodXJsOiBzdHJpbmcsIG93bmVyOiBzdHJpbmcsIGNvaW5UeXBlPzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoY29pblR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29pblR5cGUgPSBTVUlfVFlQRV9BUkc7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1ha2VSUEModXJsLCAnc3VpeF9nZXRCYWxhbmNlJywgW293bmVyLCBjb2luVHlwZV0pO1xuICAgIHJldHVybiByZXN1bHQudG90YWxCYWxhbmNlO1xuICB9XG5cbiAgYXN5bmMgZ2V0SW5wdXRDb2lucyh1cmw6IHN0cmluZywgb3duZXI6IHN0cmluZywgY29pblR5cGU/OiBzdHJpbmcpOiBQcm9taXNlPFN1aU9iamVjdEluZm9bXT4ge1xuICAgIGlmIChjb2luVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2luVHlwZSA9IFNVSV9UWVBFX0FSRztcbiAgICB9XG4gICAgbGV0IGhhc05leHRQYWdlID0gdHJ1ZTtcbiAgICBsZXQgY3Vyc29yID0gdW5kZWZpbmVkO1xuICAgIGxldCBwYXJhbXMgPSBbb3duZXIsIGNvaW5UeXBlXTtcbiAgICBsZXQgZGF0YSA9IFtdO1xuICAgIHdoaWxlIChoYXNOZXh0UGFnZSkge1xuICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcyA9IFtvd25lciwgY29pblR5cGUsIGN1cnNvcl07XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtYWtlUlBDKHVybCwgJ3N1aXhfZ2V0Q29pbnMnLCBwYXJhbXMpO1xuICAgICAgICBkYXRhID0gZGF0YS5jb25jYXQocmVzdWx0LmRhdGEpO1xuICAgICAgICBoYXNOZXh0UGFnZSA9IHJlc3VsdC5oYXNOZXh0UGFnZTtcbiAgICAgICAgY3Vyc29yID0gcmVzdWx0Lm5leHRDdXJzb3I7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgaW5wdXQgY29pbnMgZnJvbSB0aGUgbm9kZSAke2V9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBpbnB1dCBjb2lucyBmcm9tIHRoZSBub2RlLmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICAgICAgLmZpbHRlcigob2JqZWN0OiBhbnkpID0+IG9iamVjdC5iYWxhbmNlICE9PSB1bmRlZmluZWQpXG4gICAgICAubWFwKChvYmplY3Q6IGFueSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvaW5UeXBlOiBvYmplY3QuY29pblR5cGUsXG4gICAgICAgICAgb2JqZWN0SWQ6IG9iamVjdC5jb2luT2JqZWN0SWQsXG4gICAgICAgICAgdmVyc2lvbjogb2JqZWN0LnZlcnNpb24sXG4gICAgICAgICAgZGlnZXN0OiBvYmplY3QuZGlnZXN0LFxuICAgICAgICAgIGJhbGFuY2U6IG5ldyBCaWdOdW1iZXIob2JqZWN0LmJhbGFuY2UpLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gIH1cblxuICBhc3luYyBleGVjdXRlVHJhbnNhY3Rpb25CbG9jayh1cmw6IHN0cmluZywgc2VyaWFsaXplZFR4OiBzdHJpbmcsIHNpZ25hdHVyZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCByZXFUeXBlID0gJ1dhaXRGb3JFZmZlY3RzQ2VydCc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgc2hvd0VmZmVjdHM6IHRydWUgfTtcbiAgICBjb25zdCBwYXJhbXMgPSBbc2VyaWFsaXplZFR4LCBzaWduYXR1cmVzLCBvcHRpb25zLCByZXFUeXBlXTtcbiAgICBsZXQgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBtYWtlUlBDKHVybCwgJ3N1aV9leGVjdXRlVHJhbnNhY3Rpb25CbG9jaycsIHBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5kaWdlc3Q7XG4gIH1cblxuICB2YWxpZGF0ZU5vbk5lZ2F0aXZlTnVtYmVyKGRlZmF1bHRWYWw6IG51bWJlciwgZXJyb3JNc2c6IHN0cmluZywgaW5wdXRWYWw/OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChpbnB1dFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbDtcbiAgICB9XG4gICAgbGV0IG5vbk5lZ2F0aXZlTnVtOiBudW1iZXI7XG4gICAgdHJ5IHtcbiAgICAgIG5vbk5lZ2F0aXZlTnVtID0gTnVtYmVyKGlucHV0VmFsKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgIH1cbiAgICBpZiAoaXNOYU4obm9uTmVnYXRpdmVOdW0udmFsdWVPZigpKSB8fCBub25OZWdhdGl2ZU51bSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgfVxuICAgIHJldHVybiBub25OZWdhdGl2ZU51bTtcbiAgfVxufVxuXG5jb25zdCB1dGlscyA9IG5ldyBVdGlscygpO1xuZXhwb3J0IGRlZmF1bHQgdXRpbHM7XG5cbmV4cG9ydCBlbnVtIEFwcElkIHtcbiAgU3VpID0gMCxcbn1cblxuZXhwb3J0IGVudW0gSW50ZW50VmVyc2lvbiB7XG4gIFYwID0gMCxcbn1cblxuZXhwb3J0IGVudW0gSW50ZW50U2NvcGUge1xuICBUcmFuc2FjdGlvbkRhdGEgPSAwLFxuICBUcmFuc2FjdGlvbkVmZmVjdHMgPSAxLFxuICBDaGVja3BvaW50U3VtbWFyeSA9IDIsXG4gIFBlcnNvbmFsTWVzc2FnZSA9IDMsXG59XG5cbmV4cG9ydCB0eXBlIEludGVudCA9IFtJbnRlbnRTY29wZSwgSW50ZW50VmVyc2lvbiwgQXBwSWRdO1xuIl19