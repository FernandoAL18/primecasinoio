/// <reference types="node" />
import { BaseBroadcastTransactionOptions, BaseBroadcastTransactionResult, BaseCoin, BitGoBase, KeyPair, MPCAlgorithm, MPCRecoveryOptions, MPCConsolidationRecoveryOptions, MPCSweepRecoveryOptions, MPCSweepTxs, MPCTxs, ParsedTransaction, ParseTransactionOptions as BaseParseTransactionOptions, SignedTransaction, SignTransactionOptions, TransactionExplanation, TssVerifyAddressOptions, VerifyTransactionOptions } from '@bitgo/sdk-core';
import { BaseCoin as StaticsBaseCoin } from '@bitgo/statics';
import BigNumber from 'bignumber.js';
import { SuiObjectInfo } from './lib/iface';
export interface ExplainTransactionOptions {
    txHex: string;
}
export interface SuiParseTransactionOptions extends BaseParseTransactionOptions {
    txHex: string;
}
interface TransactionOutput {
    address: string;
    amount: string;
}
declare type TransactionInput = TransactionOutput;
export interface SuiParsedTransaction extends ParsedTransaction {
    inputs: TransactionInput[];
    outputs: TransactionOutput[];
    fee: BigNumber;
}
export declare type SuiTransactionExplanation = TransactionExplanation;
export declare class Sui extends BaseCoin {
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    protected constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    getBaseFactor(): number;
    getChain(): string;
    getFamily(): string;
    getFullName(): string;
    /** @inheritDoc */
    supportsTss(): boolean;
    getMPCAlgorithm(): MPCAlgorithm;
    allowsAccountConsolidations(): boolean;
    verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    isWalletAddress(params: TssVerifyAddressOptions): Promise<boolean>;
    parseTransaction(params: SuiParseTransactionOptions): Promise<SuiParsedTransaction>;
    generateKeyPair(seed?: Buffer): KeyPair;
    isValidPub(_: string): boolean;
    isValidPrv(_: string): boolean;
    isValidAddress(address: string): boolean;
    signTransaction(_: SignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Explain a Sui transaction
     * @param params
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<SuiTransactionExplanation>;
    private getBuilder;
    private getAddressFromPublicKey;
    /** @inheritDoc */
    getSignablePayload(serializedTx: string): Promise<Buffer>;
    protected getPublicNodeUrl(): string;
    protected getBalance(owner: string, coinType?: string): Promise<string>;
    protected getInputCoins(owner: string, coinType?: string): Promise<SuiObjectInfo[]>;
    protected getFeeEstimate(txHex: string): Promise<BigNumber>;
    /**
     * Builds funds recovery transaction(s) without BitGo
     *
     * @param {MPCRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {MPCTx | MPCSweepTxs} array of the serialized transaction hex strings and indices
     * of the addresses being swept
     */
    recover(params: MPCRecoveryOptions): Promise<MPCTxs | MPCSweepTxs>;
    private buildUnsignedSweepTransaction;
    private signRecoveryTransaction;
    broadcastTransaction({ transactions, }: BaseBroadcastTransactionOptions): Promise<BaseBroadcastTransactionResult>;
    /** inherited doc */
    createBroadcastableSweepTransaction(params: MPCSweepRecoveryOptions): Promise<MPCTxs>;
    /**
     * Builds native SUI recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     *
     * @param {MPCConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    recoverConsolidations(params: MPCConsolidationRecoveryOptions): Promise<MPCTxs | MPCSweepTxs>;
}
export {};
//# sourceMappingURL=sui.d.ts.map