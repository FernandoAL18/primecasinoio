"use strict";
/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
//
// TransactionBuilder
// A utility for building and signing transactions
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
const utxo_lib_1 = require("@bitgo/utxo-lib");
const Bluebird = require("bluebird");
const utxolib = require("@bitgo/utxo-lib");
const _ = require("lodash");
const unspents_1 = require("@bitgo/unspents");
const debugLib = require("debug");
const debug = debugLib('bitgo:v1:txb');
const sdk_core_1 = require("@bitgo/sdk-core");
const verifyAddress_1 = require("./verifyAddress");
//
// TransactionBuilder
// @params:
//   wallet:  a wallet object to send from
//   recipients: array of recipient objects and the amount to send to each e.g. [{address: '38BKDNZbPcLogvVbcx2ekJ9E6Vv94DqDqw', amount: 1500}, {address: '36eL8yQqCn1HMRmVFFo49t2PJ3pai8wQam', amount: 2000}]
//   fee: the fee to use with this transaction.  if not provided, a default, minimum fee will be used.
//   feeRate: the amount of fee per kilobyte - optional - specify either fee, feeRate, or feeTxConfirmTarget but not more than one
//   feeTxConfirmTarget: calculate the fees per kilobyte such that the transaction will be confirmed in this number of blocks
//   maxFeeRate: The maximum fee per kb to use in satoshis, for safety purposes when using dynamic fees
//   minConfirms: the minimum confirmations an output must have before spending
//   forceChangeAtEnd: force the change address to be the last output
//   changeAddress: specify the change address rather than generate a new one
//   noSplitChange: set to true to disable automatic change splitting for purposes of unspent management
//   targetWalletUnspents: specify a number of target unspents to maintain in the wallet (currently defaulted to 8 by the server)
//   validate: extra verification of the change addresses, which is always done server-side and is redundant client-side (defaults true)
//   minUnspentSize: The minimum size in satoshis of unspent to use (to prevent spending unspents worth less than fee added). Defaults to 0.
//   feeSingleKeySourceAddress: Use this single key address to pay fees
//   feeSingleKeyWIF: Use the address based on this private key to pay fees
//   unspentsFetchParams: Extra parameters to use for fetching unspents for this transaction
//   unspents: array of unspent objects to use while constructing the transaction instead of fetching from the API
exports.createTransaction = function (params) {
    const minConfirms = params.minConfirms || 0;
    const validate = params.validate === undefined ? true : params.validate;
    let recipients = [];
    let opReturns = [];
    let extraChangeAmounts = [];
    let estTxSize;
    let travelInfos;
    // Sanity check the arguments passed in
    if (!_.isObject(params.wallet) ||
        (params.fee && !_.isNumber(params.fee)) ||
        (params.feeRate && !_.isNumber(params.feeRate)) ||
        !_.isInteger(minConfirms) ||
        (params.forceChangeAtEnd && !_.isBoolean(params.forceChangeAtEnd)) ||
        (params.changeAddress && !_.isString(params.changeAddress)) ||
        (params.noSplitChange && !_.isBoolean(params.noSplitChange)) ||
        (params.targetWalletUnspents && !_.isInteger(params.targetWalletUnspents)) ||
        (validate && !_.isBoolean(validate)) ||
        (params.enforceMinConfirmsForChange && !_.isBoolean(params.enforceMinConfirmsForChange)) ||
        (params.minUnspentSize && !_.isNumber(params.minUnspentSize)) ||
        (params.maxFeeRate && !_.isNumber(params.maxFeeRate)) ||
        // this should be an array and its length must be at least 1
        (params.unspents && (!Array.isArray(params.unspents) || params.unspents.length < 1)) ||
        (params.feeTxConfirmTarget && !_.isInteger(params.feeTxConfirmTarget)) ||
        (params.instant && !_.isBoolean(params.instant)) ||
        (params.bitgoFee && !_.isObject(params.bitgoFee)) ||
        (params.unspentsFetchParams && !_.isObject(params.unspentsFetchParams))) {
        throw new Error('invalid argument');
    }
    const bitgo = params.wallet.bitgo;
    const constants = bitgo.getConstants();
    const network = (0, sdk_core_1.getNetwork)(sdk_core_1.common.Environments[bitgo.getEnv()].network);
    // The user can specify a seperate, single-key wallet for the purposes of paying miner's fees
    // When creating a transaction this can be specified as an input address or the private key in WIF
    let feeSingleKeySourceAddress;
    let feeSingleKeyInputAmount = 0;
    if (params.feeSingleKeySourceAddress) {
        try {
            utxolib.address.fromBase58Check(params.feeSingleKeySourceAddress, network);
            feeSingleKeySourceAddress = params.feeSingleKeySourceAddress;
        }
        catch (e) {
            throw new Error('invalid bitcoin address: ' + params.feeSingleKeySourceAddress);
        }
    }
    if (params.feeSingleKeyWIF) {
        const feeSingleKey = utxolib.ECPair.fromWIF(params.feeSingleKeyWIF, network);
        feeSingleKeySourceAddress = (0, sdk_core_1.getAddressP2PKH)(feeSingleKey);
        // If the user specifies both, check to make sure the feeSingleKeySourceAddress corresponds to the address of feeSingleKeyWIF
        if (params.feeSingleKeySourceAddress && params.feeSingleKeySourceAddress !== feeSingleKeySourceAddress) {
            throw new Error('feeSingleKeySourceAddress: ' +
                params.feeSingleKeySourceAddress +
                ' did not correspond to address of feeSingleKeyWIF: ' +
                feeSingleKeySourceAddress);
        }
    }
    if (!_.isObject(params.recipients)) {
        throw new Error('recipients must be array of { address: abc, amount: 100000 } objects');
    }
    let feeParamsDefined = 0;
    if (!_.isUndefined(params.fee)) {
        feeParamsDefined++;
    }
    if (!_.isUndefined(params.feeRate)) {
        feeParamsDefined++;
    }
    if (!_.isUndefined(params.feeTxConfirmTarget)) {
        feeParamsDefined++;
    }
    if (feeParamsDefined > 1) {
        throw new Error('cannot specify more than one of fee, feeRate and feeTxConfirmTarget');
    }
    if (_.isUndefined(params.maxFeeRate)) {
        params.maxFeeRate = constants.maxFeeRate;
    }
    // Convert the old format of params.recipients (dictionary of address:amount) to new format: { destinationAddress, amount }
    if (!(params.recipients instanceof Array)) {
        recipients = [];
        Object.keys(params.recipients).forEach(function (destinationAddress) {
            const amount = params.recipients[destinationAddress];
            recipients.push({ address: destinationAddress, amount: amount });
        });
    }
    else {
        recipients = params.recipients;
    }
    if (params.opReturns) {
        if (!(params.opReturns instanceof Array)) {
            opReturns = [];
            Object.keys(params.opReturns).forEach(function (message) {
                const amount = params.opReturns[message];
                opReturns.push({ message, amount });
            });
        }
        else {
            opReturns = params.opReturns;
        }
    }
    if (recipients.length === 0 && opReturns.length === 0) {
        throw new Error('must have at least one recipient');
    }
    let fee = params.fee;
    let feeRate = params.feeRate;
    // Flag indicating whether this class will compute the fee
    const shouldComputeBestFee = _.isUndefined(fee);
    let totalOutputAmount = 0;
    recipients.forEach(function (recipient) {
        if (_.isString(recipient.address)) {
            if (!(0, verifyAddress_1.verifyAddress)(recipient.address, network)) {
                throw new Error('invalid bitcoin address: ' + recipient.address);
            }
            if (!!recipient.script) {
                // A script was provided as well - validate that the address corresponds to that
                if (utxolib.address.toOutputScript(recipient.address, network).toString('hex') !== recipient.script) {
                    throw new Error('both script and address provided but they did not match: ' + recipient.address + ' ' + recipient.script);
                }
            }
        }
        if (!_.isInteger(recipient.amount) || recipient.amount < 0) {
            throw new Error('invalid amount for ' + recipient.address + ': ' + recipient.amount);
        }
        totalOutputAmount += recipient.amount;
    });
    opReturns.forEach(function (opReturn) {
        totalOutputAmount += opReturn.amount;
    });
    let bitgoFeeInfo = params.bitgoFee;
    if (bitgoFeeInfo && (!_.isInteger(bitgoFeeInfo.amount) || !_.isString(bitgoFeeInfo.address))) {
        throw new Error('invalid bitgoFeeInfo');
    }
    // The total amount needed for this transaction.
    let totalAmount = totalOutputAmount + (fee || 0);
    // The list of unspent transactions being used in this transaction.
    let unspents;
    // the total number of unspents on this wallet
    let totalUnspentsCount;
    // the number of unspents we fetched from the server, before filtering
    let fetchedUnspentsCount;
    // The list of unspent transactions being used with zero-confirmations
    let zeroConfUnspentTxIds;
    // The sum of the input values for this transaction.
    let inputAmount;
    let changeOutputs = [];
    let containsUncompressedPublicKeys = false;
    // The transaction.
    let transaction = utxolib.bitgo.createTransactionBuilderForNetwork(network);
    const getBitGoFee = function () {
        return Bluebird.try(function () {
            if (bitgoFeeInfo) {
                return;
            }
            return params.wallet.getBitGoFee({ amount: totalOutputAmount, instant: params.instant }).then(function (result) {
                if (result && result.fee > 0) {
                    bitgoFeeInfo = {
                        amount: result.fee,
                    };
                }
            });
        }).then(function () {
            if (bitgoFeeInfo && bitgoFeeInfo.amount > 0) {
                totalAmount += bitgoFeeInfo.amount;
            }
        });
    };
    const getBitGoFeeAddress = function () {
        return Bluebird.try(function () {
            // If we don't have bitgoFeeInfo, or address is already set, don't get a new one
            if (!bitgoFeeInfo || bitgoFeeInfo.address) {
                return;
            }
            return bitgo.getBitGoFeeAddress().then(function (result) {
                bitgoFeeInfo.address = result.address;
            });
        });
    };
    // Get a dynamic fee estimate from the BitGo server if feeTxConfirmTarget
    // is specified or if no fee-related params are specified
    const getDynamicFeeRateEstimate = function () {
        if (params.feeTxConfirmTarget || !feeParamsDefined) {
            return bitgo
                .estimateFee({
                numBlocks: params.feeTxConfirmTarget,
                maxFee: params.maxFeeRate,
                inputs: zeroConfUnspentTxIds,
                txSize: estTxSize,
                cpfpAware: true,
            })
                .then(function (result) {
                const estimatedFeeRate = result.cpfpFeePerKb;
                const minimum = params.instant
                    ? Math.max(constants.minFeeRate, constants.minInstantFeeRate)
                    : constants.minFeeRate;
                // 5 satoshis per byte
                // it is worth noting that the padding only applies when the threshold is crossed, but not when the delta is less than the padding
                const padding = 5000;
                if (estimatedFeeRate < minimum) {
                    console.log(new Date() +
                        ': Error when estimating fee for send from ' +
                        params.wallet.id() +
                        ', it was too low - ' +
                        estimatedFeeRate);
                    feeRate = minimum + padding;
                }
                else if (estimatedFeeRate > params.maxFeeRate) {
                    feeRate = params.maxFeeRate - padding;
                }
                else {
                    feeRate = estimatedFeeRate;
                }
                return feeRate;
            })
                .catch(function (e) {
                // sanity check failed on tx size
                if (_.includes(e.message, 'invalid txSize')) {
                    return Bluebird.reject(e);
                }
                else {
                    // couldn't estimate the fee, proceed using the default
                    feeRate = constants.fallbackFeeRate;
                    console.log('Error estimating fee for send from ' + params.wallet.id() + ': ' + e.message);
                    return Bluebird.resolve();
                }
            });
        }
    };
    // Get the unspents for the sending wallet.
    const getUnspents = function () {
        if (params.unspents) {
            // we just wanna use custom unspents
            unspents = params.unspents;
            return;
        }
        // Get enough unspents for the requested amount
        const options = _.merge({}, params.unspentsFetchParams || {}, {
            target: totalAmount,
            minSize: params.minUnspentSize || 0,
            instant: params.instant,
            targetWalletUnspents: params.targetWalletUnspents,
        });
        if (params.instant) {
            options.instant = params.instant; // insist on instant unspents only
        }
        return params.wallet.unspentsPaged(options).then(function (results) {
            console.log(`Unspents fetched\n:  ${JSON.stringify(results, null, 2)}`);
            totalUnspentsCount = results.total;
            fetchedUnspentsCount = results.count;
            unspents = results.unspents.filter(function (u) {
                const confirms = u.confirmations || 0;
                if (!params.enforceMinConfirmsForChange && u.isChange) {
                    return true;
                }
                return confirms >= minConfirms;
            });
            // abort early if there's no viable unspents, because it won't be possible to create the txn later
            if (unspents.length === 0) {
                throw Error('0 unspents available for transaction creation');
            }
            // create array of unconfirmed unspent ID strings of the form "txHash:outputIndex"
            zeroConfUnspentTxIds = _(results.unspents)
                .filter(function (u) {
                return !u.confirmations;
            })
                .map(function (u) {
                return u.tx_hash + ':' + u.tx_output_n;
            })
                .value();
            if (_.isEmpty(zeroConfUnspentTxIds)) {
                // we don't want to pass an empty array of inputs to the server, because it assumes if the
                // inputs arguments exists, it contains values
                zeroConfUnspentTxIds = undefined;
            }
            // For backwards compatibility, respect the old splitChangeSize=0 parameter
            if (!params.noSplitChange && params.splitChangeSize !== 0) {
                extraChangeAmounts = results.extraChangeAmounts || [];
            }
        });
    };
    // Get the unspents for the single key fee address
    let feeSingleKeyUnspents = [];
    const getUnspentsForSingleKey = function () {
        if (feeSingleKeySourceAddress) {
            let feeTarget = 0.01e8;
            if (params.instant) {
                feeTarget += totalAmount * 0.001;
            }
            return bitgo
                .get(bitgo.url('/address/' + feeSingleKeySourceAddress + '/unspents?target=' + feeTarget))
                .then(function (response) {
                if (response.body.total <= 0) {
                    throw new Error('No unspents available in single key fee source');
                }
                feeSingleKeyUnspents = response.body.unspents;
            });
        }
    };
    let minerFeeInfo = {};
    let txInfo = {};
    // Iterate unspents, sum the inputs, and save _inputs with the total
    // input amount and final list of inputs to use with the transaction.
    let feeSingleKeyUnspentsUsed = [];
    const collectInputs = function () {
        if (!unspents.length) {
            throw new Error('no unspents available on wallet');
        }
        inputAmount = 0;
        // Calculate the cost of spending a single input, i.e. the smallest economical unspent value
        return Bluebird.try(function () {
            if (_.isNumber(params.feeRate) || _.isNumber(params.originalFeeRate)) {
                return !_.isUndefined(params.feeRate) ? params.feeRate : params.originalFeeRate;
            }
            else {
                return bitgo
                    .estimateFee({
                    numBlocks: params.feeTxConfirmTarget,
                    maxFee: params.maxFeeRate,
                })
                    .then(function (feeRateEstimate) {
                    return feeRateEstimate.feePerKb;
                });
            }
        })
            .then(function (feeRate) {
            // Don't spend inputs that cannot pay for their own cost.
            let minInputValue = 0;
            if (_.isInteger(params.minUnspentSize)) {
                minInputValue = params.minUnspentSize;
            }
            let prunedUnspentCount = 0;
            const originalUnspentCount = unspents.length;
            unspents = _.filter(unspents, function (unspent) {
                const isSegwitInput = !!unspent.witnessScript;
                const currentInputSize = isSegwitInput ? unspents_1.VirtualSizes.txP2shP2wshInputSize : unspents_1.VirtualSizes.txP2shInputSize;
                const feeBasedMinInputValue = (feeRate * currentInputSize) / 1000;
                const currentMinInputValue = Math.max(minInputValue, feeBasedMinInputValue);
                if (currentMinInputValue > unspent.value) {
                    // pruning unspent
                    const pruneDetails = {
                        generalMinInputValue: minInputValue,
                        feeBasedMinInputValue,
                        currentMinInputValue,
                        feeRate,
                        inputSize: currentInputSize,
                        unspent: unspent,
                    };
                    debug(`pruning unspent: ${JSON.stringify(pruneDetails, null, 4)}`);
                    prunedUnspentCount++;
                    return false;
                }
                return true;
            });
            if (prunedUnspentCount > 0) {
                debug(`pruned ${prunedUnspentCount} out of ${originalUnspentCount} unspents`);
            }
            if (unspents.length === 0) {
                throw new Error('insufficient funds');
            }
            let segwitInputCount = 0;
            unspents.every(function (unspent) {
                if (unspent.witnessScript) {
                    segwitInputCount++;
                }
                inputAmount += unspent.value;
                transaction.addInput(unspent.tx_hash, unspent.tx_output_n, 0xffffffff);
                return inputAmount < (feeSingleKeySourceAddress ? totalOutputAmount : totalAmount);
            });
            // if paying fees from an external single key wallet, add the inputs
            if (feeSingleKeySourceAddress) {
                // collect the amount used in the fee inputs so we can get change later
                feeSingleKeyInputAmount = 0;
                feeSingleKeyUnspentsUsed = [];
                feeSingleKeyUnspents.every(function (unspent) {
                    feeSingleKeyInputAmount += unspent.value;
                    inputAmount += unspent.value;
                    transaction.addInput(unspent.tx_hash, unspent.tx_output_n);
                    feeSingleKeyUnspentsUsed.push(unspent);
                    // use the fee wallet to pay miner fees and potentially instant fees
                    return feeSingleKeyInputAmount < fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0);
                });
            }
            txInfo = {
                nP2shInputs: transaction.tx.ins.length - (feeSingleKeySourceAddress ? 1 : 0) - segwitInputCount,
                nP2shP2wshInputs: segwitInputCount,
                nP2pkhInputs: feeSingleKeySourceAddress ? 1 : 0,
                // add single key source address change
                nOutputs: recipients.length +
                    1 + // recipients and change
                    extraChangeAmounts.length + // extra change splitting
                    (bitgoFeeInfo && bitgoFeeInfo.amount > 0 ? 1 : 0) + // add output for bitgo fee
                    (feeSingleKeySourceAddress ? 1 : 0),
            };
            // As per the response of get unspents API, for v1 safe wallets redeemScript is returned
            // in the response in hex format
            containsUncompressedPublicKeys = unspents.some((u) => u.redeemScript.length === 201 * 2 /* hex length is twice the length in bytes */);
            estTxSize = estimateTransactionSize({
                containsUncompressedPublicKeys,
                nP2shInputs: txInfo.nP2shInputs,
                nP2shP2wshInputs: txInfo.nP2shP2wshInputs,
                nP2pkhInputs: txInfo.nP2pkhInputs,
                nOutputs: txInfo.nOutputs,
            });
        })
            .then(getDynamicFeeRateEstimate)
            .then(function () {
            minerFeeInfo = exports.calculateMinerFeeInfo({
                bitgo: params.wallet.bitgo,
                containsUncompressedPublicKeys,
                feeRate: feeRate,
                nP2shInputs: txInfo.nP2shInputs,
                nP2shP2wshInputs: txInfo.nP2shP2wshInputs,
                nP2pkhInputs: txInfo.nP2pkhInputs,
                nOutputs: txInfo.nOutputs,
            });
            if (shouldComputeBestFee) {
                const approximateFee = minerFeeInfo.fee;
                const shouldRecurse = _.isUndefined(fee) || approximateFee > fee;
                fee = approximateFee;
                // Recompute totalAmount from scratch
                totalAmount = fee + totalOutputAmount;
                if (bitgoFeeInfo) {
                    totalAmount += bitgoFeeInfo.amount;
                }
                if (shouldRecurse) {
                    // if fee changed, re-collect inputs
                    inputAmount = 0;
                    transaction = utxolib.bitgo.createTransactionBuilderForNetwork(network);
                    return collectInputs();
                }
            }
            const totalFee = fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0);
            if (feeSingleKeySourceAddress) {
                const summedSingleKeyUnspents = _.sumBy(feeSingleKeyUnspents, 'value');
                if (totalFee > summedSingleKeyUnspents) {
                    const err = new Error('Insufficient fee amount available in single key fee source: ' + summedSingleKeyUnspents);
                    err.result = {
                        fee: fee,
                        feeRate: feeRate,
                        estimatedSize: minerFeeInfo.size,
                        available: inputAmount,
                        bitgoFee: bitgoFeeInfo,
                        txInfo: txInfo,
                    };
                    return Bluebird.reject(err);
                }
            }
            if (inputAmount < (feeSingleKeySourceAddress ? totalOutputAmount : totalAmount)) {
                // The unspents we're using for inputs do not have sufficient value on them to
                // satisfy the user's requested spend amount. That may be because the wallet's balance
                // is simply too low, or it might be that the wallet's balance is sufficient but
                // we didn't fetch enough unspents. Too few unspents could result from the wallet
                // having many small unspents and we hit our limit on the number of inputs we can use
                // in a txn, or it might have been that the filters the user passed in (like minConfirms)
                // disqualified too many of the unspents
                let err;
                if (totalUnspentsCount === fetchedUnspentsCount) {
                    // we fetched every unspent the wallet had, but it still wasn't enough
                    err = new Error('Insufficient funds');
                }
                else {
                    // we weren't able to fetch all the unspents on the wallet
                    err = new Error(`Transaction size too large due to too many unspents. Can send only ${inputAmount} satoshis in this transaction`);
                }
                err.result = {
                    fee: fee,
                    feeRate: feeRate,
                    estimatedSize: minerFeeInfo.size,
                    available: inputAmount,
                    bitgoFee: bitgoFeeInfo,
                    txInfo: txInfo,
                };
                return Bluebird.reject(err);
            }
        });
    };
    // Add the outputs for this transaction.
    const collectOutputs = function () {
        if (minerFeeInfo.size >= 90000) {
            throw new Error('transaction too large: estimated size ' + minerFeeInfo.size + ' bytes');
        }
        const outputs = [];
        recipients.forEach(function (recipient) {
            let script;
            if (_.isString(recipient.address)) {
                script = utxolib.address.toOutputScript(recipient.address, network);
            }
            else if (_.isObject(recipient.script)) {
                script = recipient.script;
            }
            else {
                throw new Error('neither recipient address nor script was provided');
            }
            // validate travelInfo if it exists
            let travelInfo;
            if (!_.isEmpty(recipient.travelInfo)) {
                travelInfo = recipient.travelInfo;
                // Better to avoid trouble now, before tx is created
                bitgo.travelRule().validateTravelInfo(travelInfo);
            }
            outputs.push({
                script: script,
                amount: recipient.amount,
                travelInfo: travelInfo,
            });
        });
        opReturns.forEach(function ({ message, amount }) {
            const script = utxolib.script.fromASM('OP_RETURN ' + Buffer.from(message).toString('hex'));
            outputs.push({ script, amount });
        });
        const getChangeOutputs = function (changeAmount) {
            if (changeAmount < 0) {
                throw new Error('negative change amount: ' + changeAmount);
            }
            const result = [];
            // if we paid fees from a single key wallet, return the fee change first
            if (feeSingleKeySourceAddress) {
                const feeSingleKeyWalletChangeAmount = feeSingleKeyInputAmount - (fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0));
                if (feeSingleKeyWalletChangeAmount >= constants.minOutputSize) {
                    result.push({ address: feeSingleKeySourceAddress, amount: feeSingleKeyWalletChangeAmount });
                    changeAmount = changeAmount - feeSingleKeyWalletChangeAmount;
                }
            }
            if (changeAmount < constants.minOutputSize) {
                // Give it to the miners
                return result;
            }
            if (params.wallet.type() === 'safe') {
                return params.wallet.addresses().then(function (response) {
                    result.push({ address: response.addresses[0].address, amount: changeAmount });
                    return result;
                });
            }
            let extraChangeTotal = _.sum(extraChangeAmounts);
            // Sanity check
            if (extraChangeTotal > changeAmount) {
                extraChangeAmounts = [];
                extraChangeTotal = 0;
            }
            // copy and add remaining change amount
            const allChangeAmounts = extraChangeAmounts.slice(0);
            allChangeAmounts.push(changeAmount - extraChangeTotal);
            // Recursive async func to add all change outputs
            const addChangeOutputs = function () {
                const thisAmount = allChangeAmounts.shift();
                if (!thisAmount) {
                    return result;
                }
                return Bluebird.try(function () {
                    if (params.changeAddress) {
                        // If user passed a change address, use it for all outputs
                        return params.changeAddress;
                    }
                    else {
                        // Otherwise create a new address per output, for privacy
                        // determine if segwit or not
                        const changeChain = params.wallet.getChangeChain(params);
                        return params.wallet.createAddress({ chain: changeChain, validate: validate }).then(function (result) {
                            return result.address;
                        });
                    }
                }).then(function (address) {
                    result.push({ address: address, amount: thisAmount });
                    return addChangeOutputs();
                });
            };
            return addChangeOutputs();
        };
        // Add change output(s) and instant fee output if applicable
        return Bluebird.try(function () {
            return getChangeOutputs(inputAmount - totalAmount);
        }).then(function (result) {
            changeOutputs = result;
            const extraOutputs = changeOutputs.concat([]); // copy the array
            if (bitgoFeeInfo && bitgoFeeInfo.amount > 0) {
                extraOutputs.push(bitgoFeeInfo);
            }
            extraOutputs.forEach(function (output) {
                if (output.address) {
                    output.script = utxolib.address.toOutputScript(output.address, network);
                }
                // decide where to put the outputs - default is to randomize unless forced to end
                const outputIndex = params.forceChangeAtEnd ? outputs.length : _.random(0, outputs.length);
                outputs.splice(outputIndex, 0, output);
            });
            // Add all outputs to the transaction
            outputs.forEach(function (output) {
                transaction.addOutput(output.script, output.amount);
            });
            travelInfos = _(outputs)
                .map(function (output, index) {
                const result = output.travelInfo;
                if (!result) {
                    return undefined;
                }
                result.outputIndex = index;
                return result;
            })
                .filter()
                .value();
        });
    };
    // Serialize the transaction, returning what is needed to sign it
    const serialize = function () {
        // only need to return the unspents that were used and just the chainPath, redeemScript, and instant flag
        const pickedUnspents = _.map(unspents, function (unspent) {
            return _.pick(unspent, ['chainPath', 'redeemScript', 'instant', 'witnessScript', 'script', 'value']);
        });
        const prunedUnspents = _.slice(pickedUnspents, 0, transaction.tx.ins.length - feeSingleKeyUnspentsUsed.length);
        _.each(feeSingleKeyUnspentsUsed, function (feeUnspent) {
            prunedUnspents.push({ redeemScript: false, chainPath: false }); // mark as false to signify a non-multisig address
        });
        const result = {
            transactionHex: transaction.buildIncomplete().toHex(),
            unspents: prunedUnspents,
            fee: fee,
            changeAddresses: changeOutputs.map(function (co) {
                return _.pick(co, ['address', 'path', 'amount']);
            }),
            walletId: params.wallet.id(),
            walletKeychains: params.wallet.keychains,
            feeRate: feeRate,
            instant: params.instant,
            bitgoFee: bitgoFeeInfo,
            estimatedSize: minerFeeInfo.size,
            txInfo: txInfo,
            travelInfos: travelInfos,
        };
        // Add for backwards compatibility
        if (result.instant && bitgoFeeInfo) {
            result.instantFee = _.pick(bitgoFeeInfo, ['amount', 'address']);
        }
        return result;
    };
    return Bluebird.try(function () {
        return getBitGoFee();
    })
        .then(function () {
        return Bluebird.all([getBitGoFeeAddress(), getUnspents(), getUnspentsForSingleKey()]);
    })
        .then(collectInputs)
        .then(collectOutputs)
        .then(serialize);
};
/**
 * Estimate the size of a transaction in bytes based on the number of
 * inputs and outputs present.
 * @params params {
 *   nP2shInputs: number of P2SH (multisig) inputs
 *   nP2pkhInputs: number of P2PKH (single sig) inputs
 *   nOutputs: number of outputs
 * }
 *
 * @returns size: estimated size of the transaction in bytes
 */
const estimateTransactionSize = function (params) {
    if (!_.isInteger(params.nP2shInputs) || params.nP2shInputs < 0) {
        throw new Error('expecting positive nP2shInputs');
    }
    if (!_.isInteger(params.nP2pkhInputs) || params.nP2pkhInputs < 0) {
        throw new Error('expecting positive nP2pkhInputs to be numeric');
    }
    if (!_.isInteger(params.nP2shP2wshInputs) || params.nP2shP2wshInputs < 0) {
        throw new Error('expecting positive nP2shP2wshInputs to be numeric');
    }
    if (params.nP2shInputs + params.nP2shP2wshInputs < 1) {
        throw new Error('expecting at least one nP2shInputs or nP2shP2wshInputs');
    }
    if (!_.isInteger(params.nOutputs) || params.nOutputs < 1) {
        throw new Error('expecting positive nOutputs');
    }
    // The size of an uncompressed public key is 32 bytes more than the compressed key,
    // and hence, needs to be accounted for in the transaction size estimation.
    const uncompressedPublicKeysTripleCorrectionFactor = 32 * 3;
    return (
    // This is not quite accurate - if there is a mix of inputs scripts where some used
    // compressed keys and some used uncompressed keys, we would overestimate the size.
    // Since we don't have mixed input sets, this should not be an issue in practice.
    (unspents_1.VirtualSizes.txP2shInputSize +
        (params.containsUncompressedPublicKeys ? uncompressedPublicKeysTripleCorrectionFactor : 0)) *
        params.nP2shInputs +
        unspents_1.VirtualSizes.txP2shP2wshInputSize * (params.nP2shP2wshInputs || 0) +
        unspents_1.VirtualSizes.txP2pkhInputSizeUncompressedKey * (params.nP2pkhInputs || 0) +
        unspents_1.VirtualSizes.txP2pkhOutputSize * params.nOutputs +
        // if the tx contains at least one segwit input, the tx overhead is increased by 1
        unspents_1.VirtualSizes.txOverheadSize +
        (params.nP2shP2wshInputs > 0 ? 1 : 0));
};
/**
 * Calculate the fee and estimated size in bytes for a transaction.
 * @params params {
 *   bitgo: bitgo object
 *   feeRate: satoshis per kilobyte
 *   nP2shInputs: number of P2SH (multisig) inputs
 *   nP2pkhInputs: number of P2PKH (single sig) inputs
 *   nOutputs: number of outputs
 * }
 *
 * @returns {
 *   size: estimated size of the transaction in bytes
 *   fee: estimated fee in satoshis for the transaction
 *   feeRate: fee rate that was used to estimate the fee for the transaction
 * }
 */
exports.calculateMinerFeeInfo = function (params) {
    const feeRateToUse = params.feeRate || params.bitgo.getConstants().fallbackFeeRate;
    const estimatedSize = estimateTransactionSize(params);
    return {
        size: estimatedSize,
        fee: Math.ceil((estimatedSize * feeRateToUse) / 1000),
        feeRate: feeRateToUse,
    };
};
/*
 * Given a transaction hex, unspent information (chain path and redeem scripts), and the keychain xprv,
 * perform key derivation and sign the inputs in the transaction based on the unspent information provided
 *
 * @params:
 *  transactionHex serialized form of the transaction in hex
 *  unspents array of unspent information, where each unspent is a chainPath and redeemScript with the same
 *  index as the inputs in the transactionHex
 *  keychain Keychain containing the xprv to sign with. For legacy support of safe wallets, keychain can
 also be a WIF private key.
 *  signingKey private key in WIF for safe wallets, when keychain is unavailable
 *  validate client-side signature verification - can be disabled for improved performance (signatures
 *           are still validated server-side).
 *  feeSingleKeyWIF Use the address based on this private key to pay fees
 * @returns {*}
 */
exports.signTransaction = function (params) {
    let keychain = params.keychain; // duplicate so as to not mutate below
    const validate = params.validate === undefined ? true : params.validate;
    let privKey;
    if (!_.isString(params.transactionHex)) {
        throw new Error('expecting the transaction hex as a string');
    }
    if (!Array.isArray(params.unspents)) {
        throw new Error('expecting the unspents array');
    }
    if (!_.isBoolean(validate)) {
        throw new Error('expecting validate to be a boolean');
    }
    let network = (0, sdk_core_1.getNetwork)();
    const enableBCH = _.isBoolean(params.forceBCH) && params.forceBCH === true;
    if (!_.isObject(keychain) || !_.isString(keychain.xprv)) {
        if (_.isString(params.signingKey)) {
            privKey = utxolib.ECPair.fromWIF(params.signingKey, network);
            keychain = undefined;
        }
        else {
            throw new Error('expecting the keychain object with xprv');
        }
    }
    let feeSingleKey;
    if (params.feeSingleKeyWIF) {
        feeSingleKey = utxolib.ECPair.fromWIF(params.feeSingleKeyWIF, network);
    }
    debug('Network: %O', network);
    if (enableBCH) {
        debug('Enabling BCH…');
        network = utxolib.networks.bitcoincash;
        debug('New network: %O', network);
    }
    const transaction = utxolib.bitgo.createTransactionFromHex(params.transactionHex, network);
    if (transaction.ins.length !== params.unspents.length) {
        throw new Error('length of unspents array should equal to the number of transaction inputs');
    }
    // decorate transaction with input values for TransactionBuilder instantiation
    const isUtxoTx = _.isObject(transaction) && Array.isArray(transaction.ins);
    const areValidUnspents = _.isObject(params) && Array.isArray(params.unspents);
    if (isUtxoTx && areValidUnspents) {
        // extend the transaction inputs with the values
        const inputValues = _.map(params.unspents, (u) => _.pick(u, 'value'));
        transaction.ins.map((currentItem, index) => _.extend(currentItem, inputValues[index]));
    }
    let rootExtKey;
    if (keychain) {
        rootExtKey = utxo_lib_1.bip32.fromBase58(keychain.xprv);
    }
    const txb = utxolib.bitgo.createTransactionBuilderFromTransaction(transaction);
    for (let index = 0; index < txb.tx.ins.length; ++index) {
        const currentUnspent = params.unspents[index];
        if (currentUnspent.redeemScript === false) {
            // this is the input from a single key fee address
            if (!feeSingleKey) {
                throw new Error('single key address used in input but feeSingleKeyWIF not provided');
            }
            if (enableBCH) {
                feeSingleKey.network = network;
            }
            txb.sign(index, feeSingleKey);
            continue;
        }
        if (currentUnspent.witnessScript && enableBCH) {
            throw new Error('BCH does not support segwit inputs');
        }
        const chainPath = currentUnspent.chainPath;
        if (rootExtKey) {
            const { walletSubPath = '/0/0' } = keychain;
            const path = (0, sdk_core_1.sanitizeLegacyPath)(keychain.path + walletSubPath + chainPath);
            debug('derived user key path "%s" using keychain path "%s", walletSubPath "%s", keychain walletSubPath "%s" and chainPath "%s"', path, keychain.path, walletSubPath, keychain.walletSubPath, chainPath);
            privKey = rootExtKey.derivePath(path);
        }
        privKey.network = network;
        // subscript is the part of the output script after the OP_CODESEPARATOR.
        // Since we are only ever signing p2sh outputs, which do not have
        // OP_CODESEPARATORS, it is always the output script.
        const subscript = Buffer.from(currentUnspent.redeemScript, 'hex');
        currentUnspent.validationScript = subscript;
        // In order to sign with bitcoinjs-lib, we must use its transaction
        // builder, confusingly named the same exact thing as our transaction
        // builder, but with inequivalent behavior.
        try {
            const witnessScript = currentUnspent.witnessScript ? Buffer.from(currentUnspent.witnessScript, 'hex') : undefined;
            const sigHash = utxolib.bitgo.getDefaultSigHash(network);
            txb.sign(index, privKey, subscript, sigHash, currentUnspent.value, witnessScript);
            debug(`Signed transaction input ${index}`);
        }
        catch (e) {
            // try fallback derivation path (see BG-46497)
            let fallbackSigningSuccessful = false;
            try {
                const fallbackPath = (0, sdk_core_1.sanitizeLegacyPath)(keychain.path + chainPath);
                debug('derived fallback user key path "%s" using keychain path "%s" and chainPath "%s"', fallbackPath, keychain.path, chainPath);
                privKey = rootExtKey.derivePath(fallbackPath);
                const witnessScript = currentUnspent.witnessScript
                    ? Buffer.from(currentUnspent.witnessScript, 'hex')
                    : undefined;
                const sigHash = utxolib.bitgo.getDefaultSigHash(network);
                txb.sign(index, privKey, subscript, sigHash, currentUnspent.value, witnessScript);
                fallbackSigningSuccessful = true;
            }
            catch (fallbackError) {
                debug('input sign failed for fallback path: %s', fallbackError.message);
            }
            // we need to know what's causing this
            if (!fallbackSigningSuccessful) {
                e.result = {
                    unspent: currentUnspent,
                };
                e.message = `Failed to sign input #${index} - ${e.message} - ${JSON.stringify(e.result, null, 4)} - \n${e.stack}`;
                debug('input sign failed: %s', e.message);
                return Bluebird.reject(e);
            }
        }
    }
    const partialTransaction = txb.buildIncomplete();
    if (validate) {
        partialTransaction.ins.forEach((input, index) => {
            const signatureCount = utxolib.bitgo
                .getSignatureVerifications(partialTransaction, index, params.unspents[index].value)
                .filter((v) => v.signedBy !== undefined).length;
            debug(`Signature count for input ${index}: ${signatureCount}`);
            if (signatureCount < 1) {
                throw new Error('expected at least one valid signature');
            }
            if (params.fullLocalSigning && signatureCount < 2) {
                throw new Error('fullLocalSigning set: expected at least two valid signatures');
            }
        });
    }
    return Bluebird.resolve({
        transactionHex: partialTransaction.toHex(),
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YxL3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBRUg7R0FDRztBQUNILEVBQUU7QUFDRixxQkFBcUI7QUFDckIsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvREFBb0Q7QUFDcEQsRUFBRTtBQUVGLDhDQUF3QztBQUN4QyxxQ0FBcUM7QUFDckMsMkNBQTJDO0FBQzNDLDRCQUE0QjtBQUM1Qiw4Q0FBK0M7QUFDL0Msa0NBQW1DO0FBQ25DLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN2Qyw4Q0FBMEY7QUFDMUYsbURBQWdEO0FBdUJoRCxFQUFFO0FBQ0YscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWCwwQ0FBMEM7QUFDMUMsOE1BQThNO0FBQzlNLHNHQUFzRztBQUN0RyxrSUFBa0k7QUFDbEksNkhBQTZIO0FBQzdILHVHQUF1RztBQUN2RywrRUFBK0U7QUFDL0UscUVBQXFFO0FBQ3JFLDZFQUE2RTtBQUM3RSx3R0FBd0c7QUFDeEcsaUlBQWlJO0FBQ2pJLHdJQUF3STtBQUN4SSw0SUFBNEk7QUFDNUksdUVBQXVFO0FBQ3ZFLDJFQUEyRTtBQUMzRSw0RkFBNEY7QUFDNUYsa0hBQWtIO0FBQ2xILE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxVQUFVLE1BQU07SUFDMUMsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUM7SUFDNUMsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztJQUN4RSxJQUFJLFVBQVUsR0FBNkUsRUFBRSxDQUFDO0lBQzlGLElBQUksU0FBUyxHQUEwQyxFQUFFLENBQUM7SUFDMUQsSUFBSSxrQkFB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LGNBQWMsRUFBRSxDQUFDLENBQUM7WUFDL0QsSUFBSSxjQUFjLEdBQUcsQ0FBQyxFQUFFO2dCQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7YUFDMUQ7WUFDRCxJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsSUFBSSxjQUFjLEdBQUcsQ0FBQyxFQUFFO2dCQUNqRCxNQUFNLElBQUksS0FBSyxDQUFDLDhEQUE4RCxDQUFDLENBQUM7YUFDakY7UUFDSCxDQUFDLENBQUMsQ0FBQztLQUNKO0lBRUQsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDO1FBQ3RCLGNBQWMsRUFBRSxrQkFBa0IsQ0FBQyxLQUFLLEVBQUU7S0FDM0MsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuLyoqXG4gKi9cbi8vXG4vLyBUcmFuc2FjdGlvbkJ1aWxkZXJcbi8vIEEgdXRpbGl0eSBmb3IgYnVpbGRpbmcgYW5kIHNpZ25pbmcgdHJhbnNhY3Rpb25zXG4vL1xuLy8gQ29weXJpZ2h0IDIwMTQsIEJpdEdvLCBJbmMuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cblxuaW1wb3J0IHsgYmlwMzIgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVmlydHVhbFNpemVzIH0gZnJvbSAnQGJpdGdvL3Vuc3BlbnRzJztcbmltcG9ydCBkZWJ1Z0xpYiA9IHJlcXVpcmUoJ2RlYnVnJyk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzp2MTp0eGInKTtcbmltcG9ydCB7IGNvbW1vbiwgZ2V0QWRkcmVzc1AyUEtILCBnZXROZXR3b3JrLCBzYW5pdGl6ZUxlZ2FjeVBhdGggfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgdmVyaWZ5QWRkcmVzcyB9IGZyb20gJy4vdmVyaWZ5QWRkcmVzcyc7XG5cbmludGVyZmFjZSBCYXNlT3V0cHV0IHtcbiAgYW1vdW50OiBudW1iZXI7XG4gIHRyYXZlbEluZm8/OiBhbnk7XG59XG5cbmludGVyZmFjZSBBZGRyZXNzT3V0cHV0IGV4dGVuZHMgQmFzZU91dHB1dCB7XG4gIGFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNjcmlwdE91dHB1dCBleHRlbmRzIEJhc2VPdXRwdXQge1xuICBzY3JpcHQ6IEJ1ZmZlcjtcbn1cblxudHlwZSBPdXRwdXQgPSBBZGRyZXNzT3V0cHV0IHwgU2NyaXB0T3V0cHV0O1xuXG5pbnRlcmZhY2UgQml0R29VbnNwZW50IHtcbiAgdmFsdWU6IG51bWJlcjtcbiAgdHhfaGFzaDogQnVmZmVyO1xuICB0eF9vdXRwdXRfbjogbnVtYmVyO1xufVxuXG4vL1xuLy8gVHJhbnNhY3Rpb25CdWlsZGVyXG4vLyBAcGFyYW1zOlxuLy8gICB3YWxsZXQ6ICBhIHdhbGxldCBvYmplY3QgdG8gc2VuZCBmcm9tXG4vLyAgIHJlY2lwaWVudHM6IGFycmF5IG9mIHJlY2lwaWVudCBvYmplY3RzIGFuZCB0aGUgYW1vdW50IHRvIHNlbmQgdG8gZWFjaCBlLmcuIFt7YWRkcmVzczogJzM4QktETlpiUGNMb2d2VmJjeDJla0o5RTZWdjk0RHFEcXcnLCBhbW91bnQ6IDE1MDB9LCB7YWRkcmVzczogJzM2ZUw4eVFxQ24xSE1SbVZGRm80OXQyUEozcGFpOHdRYW0nLCBhbW91bnQ6IDIwMDB9XVxuLy8gICBmZWU6IHRoZSBmZWUgdG8gdXNlIHdpdGggdGhpcyB0cmFuc2FjdGlvbi4gIGlmIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0LCBtaW5pbXVtIGZlZSB3aWxsIGJlIHVzZWQuXG4vLyAgIGZlZVJhdGU6IHRoZSBhbW91bnQgb2YgZmVlIHBlciBraWxvYnl0ZSAtIG9wdGlvbmFsIC0gc3BlY2lmeSBlaXRoZXIgZmVlLCBmZWVSYXRlLCBvciBmZWVUeENvbmZpcm1UYXJnZXQgYnV0IG5vdCBtb3JlIHRoYW4gb25lXG4vLyAgIGZlZVR4Q29uZmlybVRhcmdldDogY2FsY3VsYXRlIHRoZSBmZWVzIHBlciBraWxvYnl0ZSBzdWNoIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgY29uZmlybWVkIGluIHRoaXMgbnVtYmVyIG9mIGJsb2Nrc1xuLy8gICBtYXhGZWVSYXRlOiBUaGUgbWF4aW11bSBmZWUgcGVyIGtiIHRvIHVzZSBpbiBzYXRvc2hpcywgZm9yIHNhZmV0eSBwdXJwb3NlcyB3aGVuIHVzaW5nIGR5bmFtaWMgZmVlc1xuLy8gICBtaW5Db25maXJtczogdGhlIG1pbmltdW0gY29uZmlybWF0aW9ucyBhbiBvdXRwdXQgbXVzdCBoYXZlIGJlZm9yZSBzcGVuZGluZ1xuLy8gICBmb3JjZUNoYW5nZUF0RW5kOiBmb3JjZSB0aGUgY2hhbmdlIGFkZHJlc3MgdG8gYmUgdGhlIGxhc3Qgb3V0cHV0XG4vLyAgIGNoYW5nZUFkZHJlc3M6IHNwZWNpZnkgdGhlIGNoYW5nZSBhZGRyZXNzIHJhdGhlciB0aGFuIGdlbmVyYXRlIGEgbmV3IG9uZVxuLy8gICBub1NwbGl0Q2hhbmdlOiBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIGF1dG9tYXRpYyBjaGFuZ2Ugc3BsaXR0aW5nIGZvciBwdXJwb3NlcyBvZiB1bnNwZW50IG1hbmFnZW1lbnRcbi8vICAgdGFyZ2V0V2FsbGV0VW5zcGVudHM6IHNwZWNpZnkgYSBudW1iZXIgb2YgdGFyZ2V0IHVuc3BlbnRzIHRvIG1haW50YWluIGluIHRoZSB3YWxsZXQgKGN1cnJlbnRseSBkZWZhdWx0ZWQgdG8gOCBieSB0aGUgc2VydmVyKVxuLy8gICB2YWxpZGF0ZTogZXh0cmEgdmVyaWZpY2F0aW9uIG9mIHRoZSBjaGFuZ2UgYWRkcmVzc2VzLCB3aGljaCBpcyBhbHdheXMgZG9uZSBzZXJ2ZXItc2lkZSBhbmQgaXMgcmVkdW5kYW50IGNsaWVudC1zaWRlIChkZWZhdWx0cyB0cnVlKVxuLy8gICBtaW5VbnNwZW50U2l6ZTogVGhlIG1pbmltdW0gc2l6ZSBpbiBzYXRvc2hpcyBvZiB1bnNwZW50IHRvIHVzZSAodG8gcHJldmVudCBzcGVuZGluZyB1bnNwZW50cyB3b3J0aCBsZXNzIHRoYW4gZmVlIGFkZGVkKS4gRGVmYXVsdHMgdG8gMC5cbi8vICAgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzczogVXNlIHRoaXMgc2luZ2xlIGtleSBhZGRyZXNzIHRvIHBheSBmZWVzXG4vLyAgIGZlZVNpbmdsZUtleVdJRjogVXNlIHRoZSBhZGRyZXNzIGJhc2VkIG9uIHRoaXMgcHJpdmF0ZSBrZXkgdG8gcGF5IGZlZXNcbi8vICAgdW5zcGVudHNGZXRjaFBhcmFtczogRXh0cmEgcGFyYW1ldGVycyB0byB1c2UgZm9yIGZldGNoaW5nIHVuc3BlbnRzIGZvciB0aGlzIHRyYW5zYWN0aW9uXG4vLyAgIHVuc3BlbnRzOiBhcnJheSBvZiB1bnNwZW50IG9iamVjdHMgdG8gdXNlIHdoaWxlIGNvbnN0cnVjdGluZyB0aGUgdHJhbnNhY3Rpb24gaW5zdGVhZCBvZiBmZXRjaGluZyBmcm9tIHRoZSBBUElcbmV4cG9ydHMuY3JlYXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIGNvbnN0IG1pbkNvbmZpcm1zID0gcGFyYW1zLm1pbkNvbmZpcm1zIHx8IDA7XG4gIGNvbnN0IHZhbGlkYXRlID0gcGFyYW1zLnZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLnZhbGlkYXRlO1xuICBsZXQgcmVjaXBpZW50czogeyBhZGRyZXNzOiBzdHJpbmc7IGFtb3VudDogbnVtYmVyOyBzY3JpcHQ/OiBzdHJpbmc7IHRyYXZlbEluZm8/OiBhbnkgfVtdID0gW107XG4gIGxldCBvcFJldHVybnM6IHsgbWVzc2FnZTogc3RyaW5nOyBhbW91bnQ6IG51bWJlciB9W10gPSBbXTtcbiAgbGV0IGV4dHJhQ2hhbmdlQW1vdW50czogbnVtYmVyW10gPSBbXTtcbiAgbGV0IGVzdFR4U2l6ZTogbnVtYmVyO1xuICBsZXQgdHJhdmVsSW5mb3M7XG5cbiAgLy8gU2FuaXR5IGNoZWNrIHRoZSBhcmd1bWVudHMgcGFzc2VkIGluXG4gIGlmIChcbiAgICAhXy5pc09iamVjdChwYXJhbXMud2FsbGV0KSB8fFxuICAgIChwYXJhbXMuZmVlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5mZWUpKSB8fFxuICAgIChwYXJhbXMuZmVlUmF0ZSAmJiAhXy5pc051bWJlcihwYXJhbXMuZmVlUmF0ZSkpIHx8XG4gICAgIV8uaXNJbnRlZ2VyKG1pbkNvbmZpcm1zKSB8fFxuICAgIChwYXJhbXMuZm9yY2VDaGFuZ2VBdEVuZCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmZvcmNlQ2hhbmdlQXRFbmQpKSB8fFxuICAgIChwYXJhbXMuY2hhbmdlQWRkcmVzcyAmJiAhXy5pc1N0cmluZyhwYXJhbXMuY2hhbmdlQWRkcmVzcykpIHx8XG4gICAgKHBhcmFtcy5ub1NwbGl0Q2hhbmdlICYmICFfLmlzQm9vbGVhbihwYXJhbXMubm9TcGxpdENoYW5nZSkpIHx8XG4gICAgKHBhcmFtcy50YXJnZXRXYWxsZXRVbnNwZW50cyAmJiAhXy5pc0ludGVnZXIocGFyYW1zLnRhcmdldFdhbGxldFVuc3BlbnRzKSkgfHxcbiAgICAodmFsaWRhdGUgJiYgIV8uaXNCb29sZWFuKHZhbGlkYXRlKSkgfHxcbiAgICAocGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSkpIHx8XG4gICAgKHBhcmFtcy5taW5VbnNwZW50U2l6ZSAmJiAhXy5pc051bWJlcihwYXJhbXMubWluVW5zcGVudFNpemUpKSB8fFxuICAgIChwYXJhbXMubWF4RmVlUmF0ZSAmJiAhXy5pc051bWJlcihwYXJhbXMubWF4RmVlUmF0ZSkpIHx8XG4gICAgLy8gdGhpcyBzaG91bGQgYmUgYW4gYXJyYXkgYW5kIGl0cyBsZW5ndGggbXVzdCBiZSBhdCBsZWFzdCAxXG4gICAgKHBhcmFtcy51bnNwZW50cyAmJiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLnVuc3BlbnRzKSB8fCBwYXJhbXMudW5zcGVudHMubGVuZ3RoIDwgMSkpIHx8XG4gICAgKHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQgJiYgIV8uaXNJbnRlZ2VyKHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQpKSB8fFxuICAgIChwYXJhbXMuaW5zdGFudCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmluc3RhbnQpKSB8fFxuICAgIChwYXJhbXMuYml0Z29GZWUgJiYgIV8uaXNPYmplY3QocGFyYW1zLmJpdGdvRmVlKSkgfHxcbiAgICAocGFyYW1zLnVuc3BlbnRzRmV0Y2hQYXJhbXMgJiYgIV8uaXNPYmplY3QocGFyYW1zLnVuc3BlbnRzRmV0Y2hQYXJhbXMpKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGNvbnN0IGJpdGdvID0gcGFyYW1zLndhbGxldC5iaXRnbztcbiAgY29uc3QgY29uc3RhbnRzID0gYml0Z28uZ2V0Q29uc3RhbnRzKCk7XG4gIGNvbnN0IG5ldHdvcmsgPSBnZXROZXR3b3JrKGNvbW1vbi5FbnZpcm9ubWVudHNbYml0Z28uZ2V0RW52KCldLm5ldHdvcmspO1xuXG4gIC8vIFRoZSB1c2VyIGNhbiBzcGVjaWZ5IGEgc2VwZXJhdGUsIHNpbmdsZS1rZXkgd2FsbGV0IGZvciB0aGUgcHVycG9zZXMgb2YgcGF5aW5nIG1pbmVyJ3MgZmVlc1xuICAvLyBXaGVuIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb24gdGhpcyBjYW4gYmUgc3BlY2lmaWVkIGFzIGFuIGlucHV0IGFkZHJlc3Mgb3IgdGhlIHByaXZhdGUga2V5IGluIFdJRlxuICBsZXQgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcztcbiAgbGV0IGZlZVNpbmdsZUtleUlucHV0QW1vdW50ID0gMDtcbiAgaWYgKHBhcmFtcy5mZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHV0eG9saWIuYWRkcmVzcy5mcm9tQmFzZTU4Q2hlY2socGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA9IHBhcmFtcy5mZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaXRjb2luIGFkZHJlc3M6ICcgKyBwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcmFtcy5mZWVTaW5nbGVLZXlXSUYpIHtcbiAgICBjb25zdCBmZWVTaW5nbGVLZXkgPSB1dHhvbGliLkVDUGFpci5mcm9tV0lGKHBhcmFtcy5mZWVTaW5nbGVLZXlXSUYsIG5ldHdvcmsgYXMgdXR4b2xpYi5CaXRjb2luSlNOZXR3b3JrKTtcbiAgICBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID0gZ2V0QWRkcmVzc1AyUEtIKGZlZVNpbmdsZUtleSk7XG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVzIGJvdGgsIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyBjb3JyZXNwb25kcyB0byB0aGUgYWRkcmVzcyBvZiBmZWVTaW5nbGVLZXlXSUZcbiAgICBpZiAocGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgJiYgcGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgIT09IGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2ZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3M6ICcgK1xuICAgICAgICAgIHBhcmFtcy5mZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzICtcbiAgICAgICAgICAnIGRpZCBub3QgY29ycmVzcG9uZCB0byBhZGRyZXNzIG9mIGZlZVNpbmdsZUtleVdJRjogJyArXG4gICAgICAgICAgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLnJlY2lwaWVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWNpcGllbnRzIG11c3QgYmUgYXJyYXkgb2YgeyBhZGRyZXNzOiBhYmMsIGFtb3VudDogMTAwMDAwIH0gb2JqZWN0cycpO1xuICB9XG5cbiAgbGV0IGZlZVBhcmFtc0RlZmluZWQgPSAwO1xuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmZlZSkpIHtcbiAgICBmZWVQYXJhbXNEZWZpbmVkKys7XG4gIH1cblxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmZlZVJhdGUpKSB7XG4gICAgZmVlUGFyYW1zRGVmaW5lZCsrO1xuICB9XG5cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQpKSB7XG4gICAgZmVlUGFyYW1zRGVmaW5lZCsrO1xuICB9XG5cbiAgaWYgKGZlZVBhcmFtc0RlZmluZWQgPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3BlY2lmeSBtb3JlIHRoYW4gb25lIG9mIGZlZSwgZmVlUmF0ZSBhbmQgZmVlVHhDb25maXJtVGFyZ2V0Jyk7XG4gIH1cblxuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMubWF4RmVlUmF0ZSkpIHtcbiAgICBwYXJhbXMubWF4RmVlUmF0ZSA9IGNvbnN0YW50cy5tYXhGZWVSYXRlO1xuICB9XG5cbiAgLy8gQ29udmVydCB0aGUgb2xkIGZvcm1hdCBvZiBwYXJhbXMucmVjaXBpZW50cyAoZGljdGlvbmFyeSBvZiBhZGRyZXNzOmFtb3VudCkgdG8gbmV3IGZvcm1hdDogeyBkZXN0aW5hdGlvbkFkZHJlc3MsIGFtb3VudCB9XG4gIGlmICghKHBhcmFtcy5yZWNpcGllbnRzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgcmVjaXBpZW50cyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHBhcmFtcy5yZWNpcGllbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChkZXN0aW5hdGlvbkFkZHJlc3MpIHtcbiAgICAgIGNvbnN0IGFtb3VudCA9IHBhcmFtcy5yZWNpcGllbnRzW2Rlc3RpbmF0aW9uQWRkcmVzc107XG4gICAgICByZWNpcGllbnRzLnB1c2goeyBhZGRyZXNzOiBkZXN0aW5hdGlvbkFkZHJlc3MsIGFtb3VudDogYW1vdW50IH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlY2lwaWVudHMgPSBwYXJhbXMucmVjaXBpZW50cztcbiAgfVxuXG4gIGlmIChwYXJhbXMub3BSZXR1cm5zKSB7XG4gICAgaWYgKCEocGFyYW1zLm9wUmV0dXJucyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgb3BSZXR1cm5zID0gW107XG4gICAgICBPYmplY3Qua2V5cyhwYXJhbXMub3BSZXR1cm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcmFtcy5vcFJldHVybnNbbWVzc2FnZV07XG4gICAgICAgIG9wUmV0dXJucy5wdXNoKHsgbWVzc2FnZSwgYW1vdW50IH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wUmV0dXJucyA9IHBhcmFtcy5vcFJldHVybnM7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlY2lwaWVudHMubGVuZ3RoID09PSAwICYmIG9wUmV0dXJucy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgaGF2ZSBhdCBsZWFzdCBvbmUgcmVjaXBpZW50Jyk7XG4gIH1cblxuICBsZXQgZmVlID0gcGFyYW1zLmZlZTtcbiAgbGV0IGZlZVJhdGUgPSBwYXJhbXMuZmVlUmF0ZTtcblxuICAvLyBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGNsYXNzIHdpbGwgY29tcHV0ZSB0aGUgZmVlXG4gIGNvbnN0IHNob3VsZENvbXB1dGVCZXN0RmVlID0gXy5pc1VuZGVmaW5lZChmZWUpO1xuXG4gIGxldCB0b3RhbE91dHB1dEFtb3VudCA9IDA7XG5cbiAgcmVjaXBpZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNpcGllbnQpIHtcbiAgICBpZiAoXy5pc1N0cmluZyhyZWNpcGllbnQuYWRkcmVzcykpIHtcbiAgICAgIGlmICghdmVyaWZ5QWRkcmVzcyhyZWNpcGllbnQuYWRkcmVzcywgbmV0d29yaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpdGNvaW4gYWRkcmVzczogJyArIHJlY2lwaWVudC5hZGRyZXNzKTtcbiAgICAgIH1cbiAgICAgIGlmICghIXJlY2lwaWVudC5zY3JpcHQpIHtcbiAgICAgICAgLy8gQSBzY3JpcHQgd2FzIHByb3ZpZGVkIGFzIHdlbGwgLSB2YWxpZGF0ZSB0aGF0IHRoZSBhZGRyZXNzIGNvcnJlc3BvbmRzIHRvIHRoYXRcbiAgICAgICAgaWYgKHV0eG9saWIuYWRkcmVzcy50b091dHB1dFNjcmlwdChyZWNpcGllbnQuYWRkcmVzcywgbmV0d29yaykudG9TdHJpbmcoJ2hleCcpICE9PSByZWNpcGllbnQuc2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ2JvdGggc2NyaXB0IGFuZCBhZGRyZXNzIHByb3ZpZGVkIGJ1dCB0aGV5IGRpZCBub3QgbWF0Y2g6ICcgKyByZWNpcGllbnQuYWRkcmVzcyArICcgJyArIHJlY2lwaWVudC5zY3JpcHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghXy5pc0ludGVnZXIocmVjaXBpZW50LmFtb3VudCkgfHwgcmVjaXBpZW50LmFtb3VudCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhbW91bnQgZm9yICcgKyByZWNpcGllbnQuYWRkcmVzcyArICc6ICcgKyByZWNpcGllbnQuYW1vdW50KTtcbiAgICB9XG4gICAgdG90YWxPdXRwdXRBbW91bnQgKz0gcmVjaXBpZW50LmFtb3VudDtcbiAgfSk7XG5cbiAgb3BSZXR1cm5zLmZvckVhY2goZnVuY3Rpb24gKG9wUmV0dXJuKSB7XG4gICAgdG90YWxPdXRwdXRBbW91bnQgKz0gb3BSZXR1cm4uYW1vdW50O1xuICB9KTtcblxuICBsZXQgYml0Z29GZWVJbmZvID0gcGFyYW1zLmJpdGdvRmVlO1xuICBpZiAoYml0Z29GZWVJbmZvICYmICghXy5pc0ludGVnZXIoYml0Z29GZWVJbmZvLmFtb3VudCkgfHwgIV8uaXNTdHJpbmcoYml0Z29GZWVJbmZvLmFkZHJlc3MpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaXRnb0ZlZUluZm8nKTtcbiAgfVxuXG4gIC8vIFRoZSB0b3RhbCBhbW91bnQgbmVlZGVkIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICBsZXQgdG90YWxBbW91bnQgPSB0b3RhbE91dHB1dEFtb3VudCArIChmZWUgfHwgMCk7XG5cbiAgLy8gVGhlIGxpc3Qgb2YgdW5zcGVudCB0cmFuc2FjdGlvbnMgYmVpbmcgdXNlZCBpbiB0aGlzIHRyYW5zYWN0aW9uLlxuICBsZXQgdW5zcGVudHM7XG5cbiAgLy8gdGhlIHRvdGFsIG51bWJlciBvZiB1bnNwZW50cyBvbiB0aGlzIHdhbGxldFxuICBsZXQgdG90YWxVbnNwZW50c0NvdW50O1xuXG4gIC8vIHRoZSBudW1iZXIgb2YgdW5zcGVudHMgd2UgZmV0Y2hlZCBmcm9tIHRoZSBzZXJ2ZXIsIGJlZm9yZSBmaWx0ZXJpbmdcbiAgbGV0IGZldGNoZWRVbnNwZW50c0NvdW50O1xuXG4gIC8vIFRoZSBsaXN0IG9mIHVuc3BlbnQgdHJhbnNhY3Rpb25zIGJlaW5nIHVzZWQgd2l0aCB6ZXJvLWNvbmZpcm1hdGlvbnNcbiAgbGV0IHplcm9Db25mVW5zcGVudFR4SWRzO1xuXG4gIC8vIFRoZSBzdW0gb2YgdGhlIGlucHV0IHZhbHVlcyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgbGV0IGlucHV0QW1vdW50O1xuXG4gIGxldCBjaGFuZ2VPdXRwdXRzOiBPdXRwdXRbXSA9IFtdO1xuXG4gIGxldCBjb250YWluc1VuY29tcHJlc3NlZFB1YmxpY0tleXMgPSBmYWxzZTtcblxuICAvLyBUaGUgdHJhbnNhY3Rpb24uXG4gIGxldCB0cmFuc2FjdGlvbiA9IHV0eG9saWIuYml0Z28uY3JlYXRlVHJhbnNhY3Rpb25CdWlsZGVyRm9yTmV0d29yayhuZXR3b3JrKTtcblxuICBjb25zdCBnZXRCaXRHb0ZlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChiaXRnb0ZlZUluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcy53YWxsZXQuZ2V0Qml0R29GZWUoeyBhbW91bnQ6IHRvdGFsT3V0cHV0QW1vdW50LCBpbnN0YW50OiBwYXJhbXMuaW5zdGFudCB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZmVlID4gMCkge1xuICAgICAgICAgIGJpdGdvRmVlSW5mbyA9IHtcbiAgICAgICAgICAgIGFtb3VudDogcmVzdWx0LmZlZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChiaXRnb0ZlZUluZm8gJiYgYml0Z29GZWVJbmZvLmFtb3VudCA+IDApIHtcbiAgICAgICAgdG90YWxBbW91bnQgKz0gYml0Z29GZWVJbmZvLmFtb3VudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBnZXRCaXRHb0ZlZUFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGJpdGdvRmVlSW5mbywgb3IgYWRkcmVzcyBpcyBhbHJlYWR5IHNldCwgZG9uJ3QgZ2V0IGEgbmV3IG9uZVxuICAgICAgaWYgKCFiaXRnb0ZlZUluZm8gfHwgYml0Z29GZWVJbmZvLmFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpdGdvLmdldEJpdEdvRmVlQWRkcmVzcygpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBiaXRnb0ZlZUluZm8uYWRkcmVzcyA9IHJlc3VsdC5hZGRyZXNzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gR2V0IGEgZHluYW1pYyBmZWUgZXN0aW1hdGUgZnJvbSB0aGUgQml0R28gc2VydmVyIGlmIGZlZVR4Q29uZmlybVRhcmdldFxuICAvLyBpcyBzcGVjaWZpZWQgb3IgaWYgbm8gZmVlLXJlbGF0ZWQgcGFyYW1zIGFyZSBzcGVjaWZpZWRcbiAgY29uc3QgZ2V0RHluYW1pY0ZlZVJhdGVFc3RpbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCB8fCAhZmVlUGFyYW1zRGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGJpdGdvXG4gICAgICAgIC5lc3RpbWF0ZUZlZSh7XG4gICAgICAgICAgbnVtQmxvY2tzOiBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0LFxuICAgICAgICAgIG1heEZlZTogcGFyYW1zLm1heEZlZVJhdGUsXG4gICAgICAgICAgaW5wdXRzOiB6ZXJvQ29uZlVuc3BlbnRUeElkcyxcbiAgICAgICAgICB0eFNpemU6IGVzdFR4U2l6ZSxcbiAgICAgICAgICBjcGZwQXdhcmU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBjb25zdCBlc3RpbWF0ZWRGZWVSYXRlID0gcmVzdWx0LmNwZnBGZWVQZXJLYjtcbiAgICAgICAgICBjb25zdCBtaW5pbXVtID0gcGFyYW1zLmluc3RhbnRcbiAgICAgICAgICAgID8gTWF0aC5tYXgoY29uc3RhbnRzLm1pbkZlZVJhdGUsIGNvbnN0YW50cy5taW5JbnN0YW50RmVlUmF0ZSlcbiAgICAgICAgICAgIDogY29uc3RhbnRzLm1pbkZlZVJhdGU7XG4gICAgICAgICAgLy8gNSBzYXRvc2hpcyBwZXIgYnl0ZVxuICAgICAgICAgIC8vIGl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHRoZSBwYWRkaW5nIG9ubHkgYXBwbGllcyB3aGVuIHRoZSB0aHJlc2hvbGQgaXMgY3Jvc3NlZCwgYnV0IG5vdCB3aGVuIHRoZSBkZWx0YSBpcyBsZXNzIHRoYW4gdGhlIHBhZGRpbmdcbiAgICAgICAgICBjb25zdCBwYWRkaW5nID0gNTAwMDtcbiAgICAgICAgICBpZiAoZXN0aW1hdGVkRmVlUmF0ZSA8IG1pbmltdW0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBuZXcgRGF0ZSgpICtcbiAgICAgICAgICAgICAgICAnOiBFcnJvciB3aGVuIGVzdGltYXRpbmcgZmVlIGZvciBzZW5kIGZyb20gJyArXG4gICAgICAgICAgICAgICAgcGFyYW1zLndhbGxldC5pZCgpICtcbiAgICAgICAgICAgICAgICAnLCBpdCB3YXMgdG9vIGxvdyAtICcgK1xuICAgICAgICAgICAgICAgIGVzdGltYXRlZEZlZVJhdGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmZWVSYXRlID0gbWluaW11bSArIHBhZGRpbmc7XG4gICAgICAgICAgfSBlbHNlIGlmIChlc3RpbWF0ZWRGZWVSYXRlID4gcGFyYW1zLm1heEZlZVJhdGUpIHtcbiAgICAgICAgICAgIGZlZVJhdGUgPSBwYXJhbXMubWF4RmVlUmF0ZSAtIHBhZGRpbmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZlZVJhdGUgPSBlc3RpbWF0ZWRGZWVSYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmVlUmF0ZTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8gc2FuaXR5IGNoZWNrIGZhaWxlZCBvbiB0eCBzaXplXG4gICAgICAgICAgaWYgKF8uaW5jbHVkZXMoZS5tZXNzYWdlLCAnaW52YWxpZCB0eFNpemUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY291bGRuJ3QgZXN0aW1hdGUgdGhlIGZlZSwgcHJvY2VlZCB1c2luZyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgZmVlUmF0ZSA9IGNvbnN0YW50cy5mYWxsYmFja0ZlZVJhdGU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgZXN0aW1hdGluZyBmZWUgZm9yIHNlbmQgZnJvbSAnICsgcGFyYW1zLndhbGxldC5pZCgpICsgJzogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEdldCB0aGUgdW5zcGVudHMgZm9yIHRoZSBzZW5kaW5nIHdhbGxldC5cbiAgY29uc3QgZ2V0VW5zcGVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHBhcmFtcy51bnNwZW50cykge1xuICAgICAgLy8gd2UganVzdCB3YW5uYSB1c2UgY3VzdG9tIHVuc3BlbnRzXG4gICAgICB1bnNwZW50cyA9IHBhcmFtcy51bnNwZW50cztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgZW5vdWdoIHVuc3BlbnRzIGZvciB0aGUgcmVxdWVzdGVkIGFtb3VudFxuICAgIGNvbnN0IG9wdGlvbnMgPSBfLm1lcmdlKHt9LCBwYXJhbXMudW5zcGVudHNGZXRjaFBhcmFtcyB8fCB7fSwge1xuICAgICAgdGFyZ2V0OiB0b3RhbEFtb3VudCxcbiAgICAgIG1pblNpemU6IHBhcmFtcy5taW5VbnNwZW50U2l6ZSB8fCAwLFxuICAgICAgaW5zdGFudDogcGFyYW1zLmluc3RhbnQsIC8vIGluc2lzdCBvbiBpbnN0YW50IHVuc3BlbnRzIG9ubHlcbiAgICAgIHRhcmdldFdhbGxldFVuc3BlbnRzOiBwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHMsXG4gICAgfSk7XG4gICAgaWYgKHBhcmFtcy5pbnN0YW50KSB7XG4gICAgICBvcHRpb25zLmluc3RhbnQgPSBwYXJhbXMuaW5zdGFudDsgLy8gaW5zaXN0IG9uIGluc3RhbnQgdW5zcGVudHMgb25seVxuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXMud2FsbGV0LnVuc3BlbnRzUGFnZWQob3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgY29uc29sZS5sb2coYFVuc3BlbnRzIGZldGNoZWRcXG46ICAke0pTT04uc3RyaW5naWZ5KHJlc3VsdHMsIG51bGwsIDIpfWApO1xuICAgICAgdG90YWxVbnNwZW50c0NvdW50ID0gcmVzdWx0cy50b3RhbDtcbiAgICAgIGZldGNoZWRVbnNwZW50c0NvdW50ID0gcmVzdWx0cy5jb3VudDtcbiAgICAgIHVuc3BlbnRzID0gcmVzdWx0cy51bnNwZW50cy5maWx0ZXIoZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSB1LmNvbmZpcm1hdGlvbnMgfHwgMDtcbiAgICAgICAgaWYgKCFwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlICYmIHUuaXNDaGFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlybXMgPj0gbWluQ29uZmlybXM7XG4gICAgICB9KTtcblxuICAgICAgLy8gYWJvcnQgZWFybHkgaWYgdGhlcmUncyBubyB2aWFibGUgdW5zcGVudHMsIGJlY2F1c2UgaXQgd29uJ3QgYmUgcG9zc2libGUgdG8gY3JlYXRlIHRoZSB0eG4gbGF0ZXJcbiAgICAgIGlmICh1bnNwZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJzAgdW5zcGVudHMgYXZhaWxhYmxlIGZvciB0cmFuc2FjdGlvbiBjcmVhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgYXJyYXkgb2YgdW5jb25maXJtZWQgdW5zcGVudCBJRCBzdHJpbmdzIG9mIHRoZSBmb3JtIFwidHhIYXNoOm91dHB1dEluZGV4XCJcbiAgICAgIHplcm9Db25mVW5zcGVudFR4SWRzID0gXyhyZXN1bHRzLnVuc3BlbnRzKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgcmV0dXJuICF1LmNvbmZpcm1hdGlvbnM7XG4gICAgICAgIH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICByZXR1cm4gdS50eF9oYXNoICsgJzonICsgdS50eF9vdXRwdXRfbjtcbiAgICAgICAgfSlcbiAgICAgICAgLnZhbHVlKCk7XG4gICAgICBpZiAoXy5pc0VtcHR5KHplcm9Db25mVW5zcGVudFR4SWRzKSkge1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHBhc3MgYW4gZW1wdHkgYXJyYXkgb2YgaW5wdXRzIHRvIHRoZSBzZXJ2ZXIsIGJlY2F1c2UgaXQgYXNzdW1lcyBpZiB0aGVcbiAgICAgICAgLy8gaW5wdXRzIGFyZ3VtZW50cyBleGlzdHMsIGl0IGNvbnRhaW5zIHZhbHVlc1xuICAgICAgICB6ZXJvQ29uZlVuc3BlbnRUeElkcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCByZXNwZWN0IHRoZSBvbGQgc3BsaXRDaGFuZ2VTaXplPTAgcGFyYW1ldGVyXG4gICAgICBpZiAoIXBhcmFtcy5ub1NwbGl0Q2hhbmdlICYmIHBhcmFtcy5zcGxpdENoYW5nZVNpemUgIT09IDApIHtcbiAgICAgICAgZXh0cmFDaGFuZ2VBbW91bnRzID0gcmVzdWx0cy5leHRyYUNoYW5nZUFtb3VudHMgfHwgW107XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSB1bnNwZW50cyBmb3IgdGhlIHNpbmdsZSBrZXkgZmVlIGFkZHJlc3NcbiAgbGV0IGZlZVNpbmdsZUtleVVuc3BlbnRzOiBCaXRHb1Vuc3BlbnRbXSA9IFtdO1xuICBjb25zdCBnZXRVbnNwZW50c0ZvclNpbmdsZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgICAgbGV0IGZlZVRhcmdldCA9IDAuMDFlODtcbiAgICAgIGlmIChwYXJhbXMuaW5zdGFudCkge1xuICAgICAgICBmZWVUYXJnZXQgKz0gdG90YWxBbW91bnQgKiAwLjAwMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaXRnb1xuICAgICAgICAuZ2V0KGJpdGdvLnVybCgnL2FkZHJlc3MvJyArIGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgKyAnL3Vuc3BlbnRzP3RhcmdldD0nICsgZmVlVGFyZ2V0KSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmJvZHkudG90YWwgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB1bnNwZW50cyBhdmFpbGFibGUgaW4gc2luZ2xlIGtleSBmZWUgc291cmNlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZlZVNpbmdsZUtleVVuc3BlbnRzID0gcmVzcG9uc2UuYm9keS51bnNwZW50cztcbiAgICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGxldCBtaW5lckZlZUluZm86IGFueSA9IHt9O1xuICBsZXQgdHhJbmZvOiBhbnkgPSB7fTtcblxuICAvLyBJdGVyYXRlIHVuc3BlbnRzLCBzdW0gdGhlIGlucHV0cywgYW5kIHNhdmUgX2lucHV0cyB3aXRoIHRoZSB0b3RhbFxuICAvLyBpbnB1dCBhbW91bnQgYW5kIGZpbmFsIGxpc3Qgb2YgaW5wdXRzIHRvIHVzZSB3aXRoIHRoZSB0cmFuc2FjdGlvbi5cbiAgbGV0IGZlZVNpbmdsZUtleVVuc3BlbnRzVXNlZDogQml0R29VbnNwZW50W10gPSBbXTtcblxuICBjb25zdCBjb2xsZWN0SW5wdXRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdW5zcGVudHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHVuc3BlbnRzIGF2YWlsYWJsZSBvbiB3YWxsZXQnKTtcbiAgICB9XG4gICAgaW5wdXRBbW91bnQgPSAwO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBjb3N0IG9mIHNwZW5kaW5nIGEgc2luZ2xlIGlucHV0LCBpLmUuIHRoZSBzbWFsbGVzdCBlY29ub21pY2FsIHVuc3BlbnQgdmFsdWVcbiAgICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfLmlzTnVtYmVyKHBhcmFtcy5mZWVSYXRlKSB8fCBfLmlzTnVtYmVyKHBhcmFtcy5vcmlnaW5hbEZlZVJhdGUpKSB7XG4gICAgICAgIHJldHVybiAhXy5pc1VuZGVmaW5lZChwYXJhbXMuZmVlUmF0ZSkgPyBwYXJhbXMuZmVlUmF0ZSA6IHBhcmFtcy5vcmlnaW5hbEZlZVJhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYml0Z29cbiAgICAgICAgICAuZXN0aW1hdGVGZWUoe1xuICAgICAgICAgICAgbnVtQmxvY2tzOiBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0LFxuICAgICAgICAgICAgbWF4RmVlOiBwYXJhbXMubWF4RmVlUmF0ZSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmZWVSYXRlRXN0aW1hdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmZWVSYXRlRXN0aW1hdGUuZmVlUGVyS2I7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChmZWVSYXRlKSB7XG4gICAgICAgIC8vIERvbid0IHNwZW5kIGlucHV0cyB0aGF0IGNhbm5vdCBwYXkgZm9yIHRoZWlyIG93biBjb3N0LlxuICAgICAgICBsZXQgbWluSW5wdXRWYWx1ZSA9IDA7XG4gICAgICAgIGlmIChfLmlzSW50ZWdlcihwYXJhbXMubWluVW5zcGVudFNpemUpKSB7XG4gICAgICAgICAgbWluSW5wdXRWYWx1ZSA9IHBhcmFtcy5taW5VbnNwZW50U2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcnVuZWRVbnNwZW50Q291bnQgPSAwO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFVuc3BlbnRDb3VudCA9IHVuc3BlbnRzLmxlbmd0aDtcbiAgICAgICAgdW5zcGVudHMgPSBfLmZpbHRlcih1bnNwZW50cywgZnVuY3Rpb24gKHVuc3BlbnQpIHtcbiAgICAgICAgICBjb25zdCBpc1NlZ3dpdElucHV0ID0gISF1bnNwZW50LndpdG5lc3NTY3JpcHQ7XG4gICAgICAgICAgY29uc3QgY3VycmVudElucHV0U2l6ZSA9IGlzU2Vnd2l0SW5wdXQgPyBWaXJ0dWFsU2l6ZXMudHhQMnNoUDJ3c2hJbnB1dFNpemUgOiBWaXJ0dWFsU2l6ZXMudHhQMnNoSW5wdXRTaXplO1xuICAgICAgICAgIGNvbnN0IGZlZUJhc2VkTWluSW5wdXRWYWx1ZSA9IChmZWVSYXRlICogY3VycmVudElucHV0U2l6ZSkgLyAxMDAwO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRNaW5JbnB1dFZhbHVlID0gTWF0aC5tYXgobWluSW5wdXRWYWx1ZSwgZmVlQmFzZWRNaW5JbnB1dFZhbHVlKTtcbiAgICAgICAgICBpZiAoY3VycmVudE1pbklucHV0VmFsdWUgPiB1bnNwZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAvLyBwcnVuaW5nIHVuc3BlbnRcbiAgICAgICAgICAgIGNvbnN0IHBydW5lRGV0YWlscyA9IHtcbiAgICAgICAgICAgICAgZ2VuZXJhbE1pbklucHV0VmFsdWU6IG1pbklucHV0VmFsdWUsXG4gICAgICAgICAgICAgIGZlZUJhc2VkTWluSW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgY3VycmVudE1pbklucHV0VmFsdWUsXG4gICAgICAgICAgICAgIGZlZVJhdGUsXG4gICAgICAgICAgICAgIGlucHV0U2l6ZTogY3VycmVudElucHV0U2l6ZSxcbiAgICAgICAgICAgICAgdW5zcGVudDogdW5zcGVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJ1ZyhgcHJ1bmluZyB1bnNwZW50OiAke0pTT04uc3RyaW5naWZ5KHBydW5lRGV0YWlscywgbnVsbCwgNCl9YCk7XG4gICAgICAgICAgICBwcnVuZWRVbnNwZW50Q291bnQrKztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwcnVuZWRVbnNwZW50Q291bnQgPiAwKSB7XG4gICAgICAgICAgZGVidWcoYHBydW5lZCAke3BydW5lZFVuc3BlbnRDb3VudH0gb3V0IG9mICR7b3JpZ2luYWxVbnNwZW50Q291bnR9IHVuc3BlbnRzYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5zcGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnN1ZmZpY2llbnQgZnVuZHMnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Vnd2l0SW5wdXRDb3VudCA9IDA7XG4gICAgICAgIHVuc3BlbnRzLmV2ZXJ5KGZ1bmN0aW9uICh1bnNwZW50KSB7XG4gICAgICAgICAgaWYgKHVuc3BlbnQud2l0bmVzc1NjcmlwdCkge1xuICAgICAgICAgICAgc2Vnd2l0SW5wdXRDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dEFtb3VudCArPSB1bnNwZW50LnZhbHVlO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZElucHV0KHVuc3BlbnQudHhfaGFzaCwgdW5zcGVudC50eF9vdXRwdXRfbiwgMHhmZmZmZmZmZik7XG5cbiAgICAgICAgICByZXR1cm4gaW5wdXRBbW91bnQgPCAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA/IHRvdGFsT3V0cHV0QW1vdW50IDogdG90YWxBbW91bnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiBwYXlpbmcgZmVlcyBmcm9tIGFuIGV4dGVybmFsIHNpbmdsZSBrZXkgd2FsbGV0LCBhZGQgdGhlIGlucHV0c1xuICAgICAgICBpZiAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIGFtb3VudCB1c2VkIGluIHRoZSBmZWUgaW5wdXRzIHNvIHdlIGNhbiBnZXQgY2hhbmdlIGxhdGVyXG4gICAgICAgICAgZmVlU2luZ2xlS2V5SW5wdXRBbW91bnQgPSAwO1xuICAgICAgICAgIGZlZVNpbmdsZUtleVVuc3BlbnRzVXNlZCA9IFtdO1xuICAgICAgICAgIGZlZVNpbmdsZUtleVVuc3BlbnRzLmV2ZXJ5KGZ1bmN0aW9uICh1bnNwZW50KSB7XG4gICAgICAgICAgICBmZWVTaW5nbGVLZXlJbnB1dEFtb3VudCArPSB1bnNwZW50LnZhbHVlO1xuICAgICAgICAgICAgaW5wdXRBbW91bnQgKz0gdW5zcGVudC52YWx1ZTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZElucHV0KHVuc3BlbnQudHhfaGFzaCwgdW5zcGVudC50eF9vdXRwdXRfbik7XG4gICAgICAgICAgICBmZWVTaW5nbGVLZXlVbnNwZW50c1VzZWQucHVzaCh1bnNwZW50KTtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgZmVlIHdhbGxldCB0byBwYXkgbWluZXIgZmVlcyBhbmQgcG90ZW50aWFsbHkgaW5zdGFudCBmZWVzXG4gICAgICAgICAgICByZXR1cm4gZmVlU2luZ2xlS2V5SW5wdXRBbW91bnQgPCBmZWUgKyAoYml0Z29GZWVJbmZvID8gYml0Z29GZWVJbmZvLmFtb3VudCA6IDApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHhJbmZvID0ge1xuICAgICAgICAgIG5QMnNoSW5wdXRzOiB0cmFuc2FjdGlvbi50eC5pbnMubGVuZ3RoIC0gKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPyAxIDogMCkgLSBzZWd3aXRJbnB1dENvdW50LFxuICAgICAgICAgIG5QMnNoUDJ3c2hJbnB1dHM6IHNlZ3dpdElucHV0Q291bnQsXG4gICAgICAgICAgblAycGtoSW5wdXRzOiBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID8gMSA6IDAsXG4gICAgICAgICAgLy8gYWRkIHNpbmdsZSBrZXkgc291cmNlIGFkZHJlc3MgY2hhbmdlXG4gICAgICAgICAgbk91dHB1dHM6XG4gICAgICAgICAgICByZWNpcGllbnRzLmxlbmd0aCArXG4gICAgICAgICAgICAxICsgLy8gcmVjaXBpZW50cyBhbmQgY2hhbmdlXG4gICAgICAgICAgICBleHRyYUNoYW5nZUFtb3VudHMubGVuZ3RoICsgLy8gZXh0cmEgY2hhbmdlIHNwbGl0dGluZ1xuICAgICAgICAgICAgKGJpdGdvRmVlSW5mbyAmJiBiaXRnb0ZlZUluZm8uYW1vdW50ID4gMCA/IDEgOiAwKSArIC8vIGFkZCBvdXRwdXQgZm9yIGJpdGdvIGZlZVxuICAgICAgICAgICAgKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPyAxIDogMCksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQXMgcGVyIHRoZSByZXNwb25zZSBvZiBnZXQgdW5zcGVudHMgQVBJLCBmb3IgdjEgc2FmZSB3YWxsZXRzIHJlZGVlbVNjcmlwdCBpcyByZXR1cm5lZFxuICAgICAgICAvLyBpbiB0aGUgcmVzcG9uc2UgaW4gaGV4IGZvcm1hdFxuICAgICAgICBjb250YWluc1VuY29tcHJlc3NlZFB1YmxpY0tleXMgPSB1bnNwZW50cy5zb21lKFxuICAgICAgICAgICh1KSA9PiB1LnJlZGVlbVNjcmlwdC5sZW5ndGggPT09IDIwMSAqIDIgLyogaGV4IGxlbmd0aCBpcyB0d2ljZSB0aGUgbGVuZ3RoIGluIGJ5dGVzICovXG4gICAgICAgICk7XG5cbiAgICAgICAgZXN0VHhTaXplID0gZXN0aW1hdGVUcmFuc2FjdGlvblNpemUoe1xuICAgICAgICAgIGNvbnRhaW5zVW5jb21wcmVzc2VkUHVibGljS2V5cyxcbiAgICAgICAgICBuUDJzaElucHV0czogdHhJbmZvLm5QMnNoSW5wdXRzLFxuICAgICAgICAgIG5QMnNoUDJ3c2hJbnB1dHM6IHR4SW5mby5uUDJzaFAyd3NoSW5wdXRzLFxuICAgICAgICAgIG5QMnBraElucHV0czogdHhJbmZvLm5QMnBraElucHV0cyxcbiAgICAgICAgICBuT3V0cHV0czogdHhJbmZvLm5PdXRwdXRzLFxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAudGhlbihnZXREeW5hbWljRmVlUmF0ZUVzdGltYXRlKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBtaW5lckZlZUluZm8gPSBleHBvcnRzLmNhbGN1bGF0ZU1pbmVyRmVlSW5mbyh7XG4gICAgICAgICAgYml0Z286IHBhcmFtcy53YWxsZXQuYml0Z28sXG4gICAgICAgICAgY29udGFpbnNVbmNvbXByZXNzZWRQdWJsaWNLZXlzLFxuICAgICAgICAgIGZlZVJhdGU6IGZlZVJhdGUsXG4gICAgICAgICAgblAyc2hJbnB1dHM6IHR4SW5mby5uUDJzaElucHV0cyxcbiAgICAgICAgICBuUDJzaFAyd3NoSW5wdXRzOiB0eEluZm8ublAyc2hQMndzaElucHV0cyxcbiAgICAgICAgICBuUDJwa2hJbnB1dHM6IHR4SW5mby5uUDJwa2hJbnB1dHMsXG4gICAgICAgICAgbk91dHB1dHM6IHR4SW5mby5uT3V0cHV0cyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNob3VsZENvbXB1dGVCZXN0RmVlKSB7XG4gICAgICAgICAgY29uc3QgYXBwcm94aW1hdGVGZWUgPSBtaW5lckZlZUluZm8uZmVlO1xuICAgICAgICAgIGNvbnN0IHNob3VsZFJlY3Vyc2UgPSBfLmlzVW5kZWZpbmVkKGZlZSkgfHwgYXBwcm94aW1hdGVGZWUgPiBmZWU7XG4gICAgICAgICAgZmVlID0gYXBwcm94aW1hdGVGZWU7XG4gICAgICAgICAgLy8gUmVjb21wdXRlIHRvdGFsQW1vdW50IGZyb20gc2NyYXRjaFxuICAgICAgICAgIHRvdGFsQW1vdW50ID0gZmVlICsgdG90YWxPdXRwdXRBbW91bnQ7XG4gICAgICAgICAgaWYgKGJpdGdvRmVlSW5mbykge1xuICAgICAgICAgICAgdG90YWxBbW91bnQgKz0gYml0Z29GZWVJbmZvLmFtb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZFJlY3Vyc2UpIHtcbiAgICAgICAgICAgIC8vIGlmIGZlZSBjaGFuZ2VkLCByZS1jb2xsZWN0IGlucHV0c1xuICAgICAgICAgICAgaW5wdXRBbW91bnQgPSAwO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB1dHhvbGliLmJpdGdvLmNyZWF0ZVRyYW5zYWN0aW9uQnVpbGRlckZvck5ldHdvcmsobmV0d29yayk7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdElucHV0cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvdGFsRmVlID0gZmVlICsgKGJpdGdvRmVlSW5mbyA/IGJpdGdvRmVlSW5mby5hbW91bnQgOiAwKTtcblxuICAgICAgICBpZiAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgICAgICAgIGNvbnN0IHN1bW1lZFNpbmdsZUtleVVuc3BlbnRzID0gXy5zdW1CeShmZWVTaW5nbGVLZXlVbnNwZW50cywgJ3ZhbHVlJyk7XG4gICAgICAgICAgaWYgKHRvdGFsRmVlID4gc3VtbWVkU2luZ2xlS2V5VW5zcGVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnSW5zdWZmaWNpZW50IGZlZSBhbW91bnQgYXZhaWxhYmxlIGluIHNpbmdsZSBrZXkgZmVlIHNvdXJjZTogJyArIHN1bW1lZFNpbmdsZUtleVVuc3BlbnRzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLnJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgZmVlOiBmZWUsXG4gICAgICAgICAgICAgIGZlZVJhdGU6IGZlZVJhdGUsXG4gICAgICAgICAgICAgIGVzdGltYXRlZFNpemU6IG1pbmVyRmVlSW5mby5zaXplLFxuICAgICAgICAgICAgICBhdmFpbGFibGU6IGlucHV0QW1vdW50LFxuICAgICAgICAgICAgICBiaXRnb0ZlZTogYml0Z29GZWVJbmZvLFxuICAgICAgICAgICAgICB0eEluZm86IHR4SW5mbyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gQmx1ZWJpcmQucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0QW1vdW50IDwgKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPyB0b3RhbE91dHB1dEFtb3VudCA6IHRvdGFsQW1vdW50KSkge1xuICAgICAgICAgIC8vIFRoZSB1bnNwZW50cyB3ZSdyZSB1c2luZyBmb3IgaW5wdXRzIGRvIG5vdCBoYXZlIHN1ZmZpY2llbnQgdmFsdWUgb24gdGhlbSB0b1xuICAgICAgICAgIC8vIHNhdGlzZnkgdGhlIHVzZXIncyByZXF1ZXN0ZWQgc3BlbmQgYW1vdW50LiBUaGF0IG1heSBiZSBiZWNhdXNlIHRoZSB3YWxsZXQncyBiYWxhbmNlXG4gICAgICAgICAgLy8gaXMgc2ltcGx5IHRvbyBsb3csIG9yIGl0IG1pZ2h0IGJlIHRoYXQgdGhlIHdhbGxldCdzIGJhbGFuY2UgaXMgc3VmZmljaWVudCBidXRcbiAgICAgICAgICAvLyB3ZSBkaWRuJ3QgZmV0Y2ggZW5vdWdoIHVuc3BlbnRzLiBUb28gZmV3IHVuc3BlbnRzIGNvdWxkIHJlc3VsdCBmcm9tIHRoZSB3YWxsZXRcbiAgICAgICAgICAvLyBoYXZpbmcgbWFueSBzbWFsbCB1bnNwZW50cyBhbmQgd2UgaGl0IG91ciBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIGlucHV0cyB3ZSBjYW4gdXNlXG4gICAgICAgICAgLy8gaW4gYSB0eG4sIG9yIGl0IG1pZ2h0IGhhdmUgYmVlbiB0aGF0IHRoZSBmaWx0ZXJzIHRoZSB1c2VyIHBhc3NlZCBpbiAobGlrZSBtaW5Db25maXJtcylcbiAgICAgICAgICAvLyBkaXNxdWFsaWZpZWQgdG9vIG1hbnkgb2YgdGhlIHVuc3BlbnRzXG4gICAgICAgICAgbGV0IGVycjtcbiAgICAgICAgICBpZiAodG90YWxVbnNwZW50c0NvdW50ID09PSBmZXRjaGVkVW5zcGVudHNDb3VudCkge1xuICAgICAgICAgICAgLy8gd2UgZmV0Y2hlZCBldmVyeSB1bnNwZW50IHRoZSB3YWxsZXQgaGFkLCBidXQgaXQgc3RpbGwgd2Fzbid0IGVub3VnaFxuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgZnVuZHMnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2Ugd2VyZW4ndCBhYmxlIHRvIGZldGNoIGFsbCB0aGUgdW5zcGVudHMgb24gdGhlIHdhbGxldFxuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVHJhbnNhY3Rpb24gc2l6ZSB0b28gbGFyZ2UgZHVlIHRvIHRvbyBtYW55IHVuc3BlbnRzLiBDYW4gc2VuZCBvbmx5ICR7aW5wdXRBbW91bnR9IHNhdG9zaGlzIGluIHRoaXMgdHJhbnNhY3Rpb25gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnIucmVzdWx0ID0ge1xuICAgICAgICAgICAgZmVlOiBmZWUsXG4gICAgICAgICAgICBmZWVSYXRlOiBmZWVSYXRlLFxuICAgICAgICAgICAgZXN0aW1hdGVkU2l6ZTogbWluZXJGZWVJbmZvLnNpemUsXG4gICAgICAgICAgICBhdmFpbGFibGU6IGlucHV0QW1vdW50LFxuICAgICAgICAgICAgYml0Z29GZWU6IGJpdGdvRmVlSW5mbyxcbiAgICAgICAgICAgIHR4SW5mbzogdHhJbmZvLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgdGhlIG91dHB1dHMgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gIGNvbnN0IGNvbGxlY3RPdXRwdXRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChtaW5lckZlZUluZm8uc2l6ZSA+PSA5MDAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiB0b28gbGFyZ2U6IGVzdGltYXRlZCBzaXplICcgKyBtaW5lckZlZUluZm8uc2l6ZSArICcgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXRzOiBPdXRwdXRbXSA9IFtdO1xuXG4gICAgcmVjaXBpZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNpcGllbnQpIHtcbiAgICAgIGxldCBzY3JpcHQ7XG4gICAgICBpZiAoXy5pc1N0cmluZyhyZWNpcGllbnQuYWRkcmVzcykpIHtcbiAgICAgICAgc2NyaXB0ID0gdXR4b2xpYi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KHJlY2lwaWVudC5hZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChyZWNpcGllbnQuc2NyaXB0KSkge1xuICAgICAgICBzY3JpcHQgPSByZWNpcGllbnQuc2NyaXB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWl0aGVyIHJlY2lwaWVudCBhZGRyZXNzIG5vciBzY3JpcHQgd2FzIHByb3ZpZGVkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkYXRlIHRyYXZlbEluZm8gaWYgaXQgZXhpc3RzXG4gICAgICBsZXQgdHJhdmVsSW5mbztcbiAgICAgIGlmICghXy5pc0VtcHR5KHJlY2lwaWVudC50cmF2ZWxJbmZvKSkge1xuICAgICAgICB0cmF2ZWxJbmZvID0gcmVjaXBpZW50LnRyYXZlbEluZm87XG4gICAgICAgIC8vIEJldHRlciB0byBhdm9pZCB0cm91YmxlIG5vdywgYmVmb3JlIHR4IGlzIGNyZWF0ZWRcbiAgICAgICAgYml0Z28udHJhdmVsUnVsZSgpLnZhbGlkYXRlVHJhdmVsSW5mbyh0cmF2ZWxJbmZvKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgc2NyaXB0OiBzY3JpcHQsXG4gICAgICAgIGFtb3VudDogcmVjaXBpZW50LmFtb3VudCxcbiAgICAgICAgdHJhdmVsSW5mbzogdHJhdmVsSW5mbyxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgb3BSZXR1cm5zLmZvckVhY2goZnVuY3Rpb24gKHsgbWVzc2FnZSwgYW1vdW50IH0pIHtcbiAgICAgIGNvbnN0IHNjcmlwdCA9IHV0eG9saWIuc2NyaXB0LmZyb21BU00oJ09QX1JFVFVSTiAnICsgQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgIG91dHB1dHMucHVzaCh7IHNjcmlwdCwgYW1vdW50IH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0Q2hhbmdlT3V0cHV0cyA9IGZ1bmN0aW9uIChjaGFuZ2VBbW91bnQ6IG51bWJlcik6IE91dHB1dFtdIHwgQmx1ZWJpcmQ8T3V0cHV0W10+IHtcbiAgICAgIGlmIChjaGFuZ2VBbW91bnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVnYXRpdmUgY2hhbmdlIGFtb3VudDogJyArIGNoYW5nZUFtb3VudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdDogT3V0cHV0W10gPSBbXTtcbiAgICAgIC8vIGlmIHdlIHBhaWQgZmVlcyBmcm9tIGEgc2luZ2xlIGtleSB3YWxsZXQsIHJldHVybiB0aGUgZmVlIGNoYW5nZSBmaXJzdFxuICAgICAgaWYgKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgZmVlU2luZ2xlS2V5V2FsbGV0Q2hhbmdlQW1vdW50ID1cbiAgICAgICAgICBmZWVTaW5nbGVLZXlJbnB1dEFtb3VudCAtIChmZWUgKyAoYml0Z29GZWVJbmZvID8gYml0Z29GZWVJbmZvLmFtb3VudCA6IDApKTtcbiAgICAgICAgaWYgKGZlZVNpbmdsZUtleVdhbGxldENoYW5nZUFtb3VudCA+PSBjb25zdGFudHMubWluT3V0cHV0U2l6ZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHsgYWRkcmVzczogZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcywgYW1vdW50OiBmZWVTaW5nbGVLZXlXYWxsZXRDaGFuZ2VBbW91bnQgfSk7XG4gICAgICAgICAgY2hhbmdlQW1vdW50ID0gY2hhbmdlQW1vdW50IC0gZmVlU2luZ2xlS2V5V2FsbGV0Q2hhbmdlQW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VBbW91bnQgPCBjb25zdGFudHMubWluT3V0cHV0U2l6ZSkge1xuICAgICAgICAvLyBHaXZlIGl0IHRvIHRoZSBtaW5lcnNcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy53YWxsZXQudHlwZSgpID09PSAnc2FmZScpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy53YWxsZXQuYWRkcmVzc2VzKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7IGFkZHJlc3M6IHJlc3BvbnNlLmFkZHJlc3Nlc1swXS5hZGRyZXNzLCBhbW91bnQ6IGNoYW5nZUFtb3VudCB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dHJhQ2hhbmdlVG90YWwgPSBfLnN1bShleHRyYUNoYW5nZUFtb3VudHMpO1xuICAgICAgLy8gU2FuaXR5IGNoZWNrXG4gICAgICBpZiAoZXh0cmFDaGFuZ2VUb3RhbCA+IGNoYW5nZUFtb3VudCkge1xuICAgICAgICBleHRyYUNoYW5nZUFtb3VudHMgPSBbXTtcbiAgICAgICAgZXh0cmFDaGFuZ2VUb3RhbCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvcHkgYW5kIGFkZCByZW1haW5pbmcgY2hhbmdlIGFtb3VudFxuICAgICAgY29uc3QgYWxsQ2hhbmdlQW1vdW50cyA9IGV4dHJhQ2hhbmdlQW1vdW50cy5zbGljZSgwKTtcbiAgICAgIGFsbENoYW5nZUFtb3VudHMucHVzaChjaGFuZ2VBbW91bnQgLSBleHRyYUNoYW5nZVRvdGFsKTtcblxuICAgICAgLy8gUmVjdXJzaXZlIGFzeW5jIGZ1bmMgdG8gYWRkIGFsbCBjaGFuZ2Ugb3V0cHV0c1xuICAgICAgY29uc3QgYWRkQ2hhbmdlT3V0cHV0cyA9IGZ1bmN0aW9uICgpOiBPdXRwdXRbXSB8IEJsdWViaXJkPE91dHB1dFtdPiB7XG4gICAgICAgIGNvbnN0IHRoaXNBbW91bnQgPSBhbGxDaGFuZ2VBbW91bnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmICghdGhpc0Ftb3VudCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJsdWViaXJkLnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy5jaGFuZ2VBZGRyZXNzKSB7XG4gICAgICAgICAgICAvLyBJZiB1c2VyIHBhc3NlZCBhIGNoYW5nZSBhZGRyZXNzLCB1c2UgaXQgZm9yIGFsbCBvdXRwdXRzXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmNoYW5nZUFkZHJlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgYWRkcmVzcyBwZXIgb3V0cHV0LCBmb3IgcHJpdmFjeVxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHNlZ3dpdCBvciBub3RcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZUNoYWluID0gcGFyYW1zLndhbGxldC5nZXRDaGFuZ2VDaGFpbihwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy53YWxsZXQuY3JlYXRlQWRkcmVzcyh7IGNoYWluOiBjaGFuZ2VDaGFpbiwgdmFsaWRhdGU6IHZhbGlkYXRlIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmFkZHJlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7IGFkZHJlc3M6IGFkZHJlc3MsIGFtb3VudDogdGhpc0Ftb3VudCB9KTtcbiAgICAgICAgICByZXR1cm4gYWRkQ2hhbmdlT3V0cHV0cygpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBhZGRDaGFuZ2VPdXRwdXRzKCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBjaGFuZ2Ugb3V0cHV0KHMpIGFuZCBpbnN0YW50IGZlZSBvdXRwdXQgaWYgYXBwbGljYWJsZVxuICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldENoYW5nZU91dHB1dHMoaW5wdXRBbW91bnQgLSB0b3RhbEFtb3VudCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBjaGFuZ2VPdXRwdXRzID0gcmVzdWx0O1xuICAgICAgY29uc3QgZXh0cmFPdXRwdXRzID0gY2hhbmdlT3V0cHV0cy5jb25jYXQoW10pOyAvLyBjb3B5IHRoZSBhcnJheVxuICAgICAgaWYgKGJpdGdvRmVlSW5mbyAmJiBiaXRnb0ZlZUluZm8uYW1vdW50ID4gMCkge1xuICAgICAgICBleHRyYU91dHB1dHMucHVzaChiaXRnb0ZlZUluZm8pO1xuICAgICAgfVxuICAgICAgZXh0cmFPdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICBpZiAoKG91dHB1dCBhcyBBZGRyZXNzT3V0cHV0KS5hZGRyZXNzKSB7XG4gICAgICAgICAgKG91dHB1dCBhcyBTY3JpcHRPdXRwdXQpLnNjcmlwdCA9IHV0eG9saWIuYWRkcmVzcy50b091dHB1dFNjcmlwdCgob3V0cHV0IGFzIEFkZHJlc3NPdXRwdXQpLmFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVjaWRlIHdoZXJlIHRvIHB1dCB0aGUgb3V0cHV0cyAtIGRlZmF1bHQgaXMgdG8gcmFuZG9taXplIHVubGVzcyBmb3JjZWQgdG8gZW5kXG4gICAgICAgIGNvbnN0IG91dHB1dEluZGV4ID0gcGFyYW1zLmZvcmNlQ2hhbmdlQXRFbmQgPyBvdXRwdXRzLmxlbmd0aCA6IF8ucmFuZG9tKDAsIG91dHB1dHMubGVuZ3RoKTtcbiAgICAgICAgb3V0cHV0cy5zcGxpY2Uob3V0cHV0SW5kZXgsIDAsIG91dHB1dCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGFsbCBvdXRwdXRzIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uYWRkT3V0cHV0KChvdXRwdXQgYXMgU2NyaXB0T3V0cHV0KS5zY3JpcHQsIG91dHB1dC5hbW91bnQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRyYXZlbEluZm9zID0gXyhvdXRwdXRzKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChvdXRwdXQsIGluZGV4KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3V0cHV0LnRyYXZlbEluZm87XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5vdXRwdXRJbmRleCA9IGluZGV4O1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKVxuICAgICAgICAudmFsdWUoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBTZXJpYWxpemUgdGhlIHRyYW5zYWN0aW9uLCByZXR1cm5pbmcgd2hhdCBpcyBuZWVkZWQgdG8gc2lnbiBpdFxuICBjb25zdCBzZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gb25seSBuZWVkIHRvIHJldHVybiB0aGUgdW5zcGVudHMgdGhhdCB3ZXJlIHVzZWQgYW5kIGp1c3QgdGhlIGNoYWluUGF0aCwgcmVkZWVtU2NyaXB0LCBhbmQgaW5zdGFudCBmbGFnXG4gICAgY29uc3QgcGlja2VkVW5zcGVudHM6IGFueSA9IF8ubWFwKHVuc3BlbnRzLCBmdW5jdGlvbiAodW5zcGVudCkge1xuICAgICAgcmV0dXJuIF8ucGljayh1bnNwZW50LCBbJ2NoYWluUGF0aCcsICdyZWRlZW1TY3JpcHQnLCAnaW5zdGFudCcsICd3aXRuZXNzU2NyaXB0JywgJ3NjcmlwdCcsICd2YWx1ZSddKTtcbiAgICB9KTtcbiAgICBjb25zdCBwcnVuZWRVbnNwZW50cyA9IF8uc2xpY2UocGlja2VkVW5zcGVudHMsIDAsIHRyYW5zYWN0aW9uLnR4Lmlucy5sZW5ndGggLSBmZWVTaW5nbGVLZXlVbnNwZW50c1VzZWQubGVuZ3RoKTtcbiAgICBfLmVhY2goZmVlU2luZ2xlS2V5VW5zcGVudHNVc2VkLCBmdW5jdGlvbiAoZmVlVW5zcGVudCkge1xuICAgICAgcHJ1bmVkVW5zcGVudHMucHVzaCh7IHJlZGVlbVNjcmlwdDogZmFsc2UsIGNoYWluUGF0aDogZmFsc2UgfSk7IC8vIG1hcmsgYXMgZmFsc2UgdG8gc2lnbmlmeSBhIG5vbi1tdWx0aXNpZyBhZGRyZXNzXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0OiBhbnkgPSB7XG4gICAgICB0cmFuc2FjdGlvbkhleDogdHJhbnNhY3Rpb24uYnVpbGRJbmNvbXBsZXRlKCkudG9IZXgoKSxcbiAgICAgIHVuc3BlbnRzOiBwcnVuZWRVbnNwZW50cyxcbiAgICAgIGZlZTogZmVlLFxuICAgICAgY2hhbmdlQWRkcmVzc2VzOiBjaGFuZ2VPdXRwdXRzLm1hcChmdW5jdGlvbiAoY28pIHtcbiAgICAgICAgcmV0dXJuIF8ucGljayhjbywgWydhZGRyZXNzJywgJ3BhdGgnLCAnYW1vdW50J10pO1xuICAgICAgfSksXG4gICAgICB3YWxsZXRJZDogcGFyYW1zLndhbGxldC5pZCgpLFxuICAgICAgd2FsbGV0S2V5Y2hhaW5zOiBwYXJhbXMud2FsbGV0LmtleWNoYWlucyxcbiAgICAgIGZlZVJhdGU6IGZlZVJhdGUsXG4gICAgICBpbnN0YW50OiBwYXJhbXMuaW5zdGFudCxcbiAgICAgIGJpdGdvRmVlOiBiaXRnb0ZlZUluZm8sXG4gICAgICBlc3RpbWF0ZWRTaXplOiBtaW5lckZlZUluZm8uc2l6ZSxcbiAgICAgIHR4SW5mbzogdHhJbmZvLFxuICAgICAgdHJhdmVsSW5mb3M6IHRyYXZlbEluZm9zLFxuICAgIH07XG5cbiAgICAvLyBBZGQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKHJlc3VsdC5pbnN0YW50ICYmIGJpdGdvRmVlSW5mbykge1xuICAgICAgcmVzdWx0Lmluc3RhbnRGZWUgPSBfLnBpY2soYml0Z29GZWVJbmZvLCBbJ2Ftb3VudCcsICdhZGRyZXNzJ10pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIEJsdWViaXJkLnRyeShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEJpdEdvRmVlKCk7XG4gIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEJsdWViaXJkLmFsbChbZ2V0Qml0R29GZWVBZGRyZXNzKCksIGdldFVuc3BlbnRzKCksIGdldFVuc3BlbnRzRm9yU2luZ2xlS2V5KCldKTtcbiAgICB9KVxuICAgIC50aGVuKGNvbGxlY3RJbnB1dHMpXG4gICAgLnRoZW4oY29sbGVjdE91dHB1dHMpXG4gICAgLnRoZW4oc2VyaWFsaXplKTtcbn07XG5cbi8qKlxuICogRXN0aW1hdGUgdGhlIHNpemUgb2YgYSB0cmFuc2FjdGlvbiBpbiBieXRlcyBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mXG4gKiBpbnB1dHMgYW5kIG91dHB1dHMgcHJlc2VudC5cbiAqIEBwYXJhbXMgcGFyYW1zIHtcbiAqICAgblAyc2hJbnB1dHM6IG51bWJlciBvZiBQMlNIIChtdWx0aXNpZykgaW5wdXRzXG4gKiAgIG5QMnBraElucHV0czogbnVtYmVyIG9mIFAyUEtIIChzaW5nbGUgc2lnKSBpbnB1dHNcbiAqICAgbk91dHB1dHM6IG51bWJlciBvZiBvdXRwdXRzXG4gKiB9XG4gKlxuICogQHJldHVybnMgc2l6ZTogZXN0aW1hdGVkIHNpemUgb2YgdGhlIHRyYW5zYWN0aW9uIGluIGJ5dGVzXG4gKi9cbmNvbnN0IGVzdGltYXRlVHJhbnNhY3Rpb25TaXplID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5uUDJzaElucHV0cykgfHwgcGFyYW1zLm5QMnNoSW5wdXRzIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHBvc2l0aXZlIG5QMnNoSW5wdXRzJyk7XG4gIH1cbiAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMublAycGtoSW5wdXRzKSB8fCBwYXJhbXMublAycGtoSW5wdXRzIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHBvc2l0aXZlIG5QMnBraElucHV0cyB0byBiZSBudW1lcmljJyk7XG4gIH1cbiAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMublAyc2hQMndzaElucHV0cykgfHwgcGFyYW1zLm5QMnNoUDJ3c2hJbnB1dHMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgcG9zaXRpdmUgblAyc2hQMndzaElucHV0cyB0byBiZSBudW1lcmljJyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5uUDJzaElucHV0cyArIHBhcmFtcy5uUDJzaFAyd3NoSW5wdXRzIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIGF0IGxlYXN0IG9uZSBuUDJzaElucHV0cyBvciBuUDJzaFAyd3NoSW5wdXRzJyk7XG4gIH1cbiAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMubk91dHB1dHMpIHx8IHBhcmFtcy5uT3V0cHV0cyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBwb3NpdGl2ZSBuT3V0cHV0cycpO1xuICB9XG5cbiAgLy8gVGhlIHNpemUgb2YgYW4gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgaXMgMzIgYnl0ZXMgbW9yZSB0aGFuIHRoZSBjb21wcmVzc2VkIGtleSxcbiAgLy8gYW5kIGhlbmNlLCBuZWVkcyB0byBiZSBhY2NvdW50ZWQgZm9yIGluIHRoZSB0cmFuc2FjdGlvbiBzaXplIGVzdGltYXRpb24uXG4gIGNvbnN0IHVuY29tcHJlc3NlZFB1YmxpY0tleXNUcmlwbGVDb3JyZWN0aW9uRmFjdG9yID0gMzIgKiAzO1xuXG4gIHJldHVybiAoXG4gICAgLy8gVGhpcyBpcyBub3QgcXVpdGUgYWNjdXJhdGUgLSBpZiB0aGVyZSBpcyBhIG1peCBvZiBpbnB1dHMgc2NyaXB0cyB3aGVyZSBzb21lIHVzZWRcbiAgICAvLyBjb21wcmVzc2VkIGtleXMgYW5kIHNvbWUgdXNlZCB1bmNvbXByZXNzZWQga2V5cywgd2Ugd291bGQgb3ZlcmVzdGltYXRlIHRoZSBzaXplLlxuICAgIC8vIFNpbmNlIHdlIGRvbid0IGhhdmUgbWl4ZWQgaW5wdXQgc2V0cywgdGhpcyBzaG91bGQgbm90IGJlIGFuIGlzc3VlIGluIHByYWN0aWNlLlxuICAgIChWaXJ0dWFsU2l6ZXMudHhQMnNoSW5wdXRTaXplICtcbiAgICAgIChwYXJhbXMuY29udGFpbnNVbmNvbXByZXNzZWRQdWJsaWNLZXlzID8gdW5jb21wcmVzc2VkUHVibGljS2V5c1RyaXBsZUNvcnJlY3Rpb25GYWN0b3IgOiAwKSkgKlxuICAgICAgcGFyYW1zLm5QMnNoSW5wdXRzICtcbiAgICBWaXJ0dWFsU2l6ZXMudHhQMnNoUDJ3c2hJbnB1dFNpemUgKiAocGFyYW1zLm5QMnNoUDJ3c2hJbnB1dHMgfHwgMCkgK1xuICAgIFZpcnR1YWxTaXplcy50eFAycGtoSW5wdXRTaXplVW5jb21wcmVzc2VkS2V5ICogKHBhcmFtcy5uUDJwa2hJbnB1dHMgfHwgMCkgK1xuICAgIFZpcnR1YWxTaXplcy50eFAycGtoT3V0cHV0U2l6ZSAqIHBhcmFtcy5uT3V0cHV0cyArXG4gICAgLy8gaWYgdGhlIHR4IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBzZWd3aXQgaW5wdXQsIHRoZSB0eCBvdmVyaGVhZCBpcyBpbmNyZWFzZWQgYnkgMVxuICAgIFZpcnR1YWxTaXplcy50eE92ZXJoZWFkU2l6ZSArXG4gICAgKHBhcmFtcy5uUDJzaFAyd3NoSW5wdXRzID4gMCA/IDEgOiAwKVxuICApO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGZlZSBhbmQgZXN0aW1hdGVkIHNpemUgaW4gYnl0ZXMgZm9yIGEgdHJhbnNhY3Rpb24uXG4gKiBAcGFyYW1zIHBhcmFtcyB7XG4gKiAgIGJpdGdvOiBiaXRnbyBvYmplY3RcbiAqICAgZmVlUmF0ZTogc2F0b3NoaXMgcGVyIGtpbG9ieXRlXG4gKiAgIG5QMnNoSW5wdXRzOiBudW1iZXIgb2YgUDJTSCAobXVsdGlzaWcpIGlucHV0c1xuICogICBuUDJwa2hJbnB1dHM6IG51bWJlciBvZiBQMlBLSCAoc2luZ2xlIHNpZykgaW5wdXRzXG4gKiAgIG5PdXRwdXRzOiBudW1iZXIgb2Ygb3V0cHV0c1xuICogfVxuICpcbiAqIEByZXR1cm5zIHtcbiAqICAgc2l6ZTogZXN0aW1hdGVkIHNpemUgb2YgdGhlIHRyYW5zYWN0aW9uIGluIGJ5dGVzXG4gKiAgIGZlZTogZXN0aW1hdGVkIGZlZSBpbiBzYXRvc2hpcyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gKiAgIGZlZVJhdGU6IGZlZSByYXRlIHRoYXQgd2FzIHVzZWQgdG8gZXN0aW1hdGUgdGhlIGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gKiB9XG4gKi9cbmV4cG9ydHMuY2FsY3VsYXRlTWluZXJGZWVJbmZvID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICBjb25zdCBmZWVSYXRlVG9Vc2UgPSBwYXJhbXMuZmVlUmF0ZSB8fCBwYXJhbXMuYml0Z28uZ2V0Q29uc3RhbnRzKCkuZmFsbGJhY2tGZWVSYXRlO1xuICBjb25zdCBlc3RpbWF0ZWRTaXplID0gZXN0aW1hdGVUcmFuc2FjdGlvblNpemUocGFyYW1zKTtcblxuICByZXR1cm4ge1xuICAgIHNpemU6IGVzdGltYXRlZFNpemUsXG4gICAgZmVlOiBNYXRoLmNlaWwoKGVzdGltYXRlZFNpemUgKiBmZWVSYXRlVG9Vc2UpIC8gMTAwMCksXG4gICAgZmVlUmF0ZTogZmVlUmF0ZVRvVXNlLFxuICB9O1xufTtcblxuLypcbiAqIEdpdmVuIGEgdHJhbnNhY3Rpb24gaGV4LCB1bnNwZW50IGluZm9ybWF0aW9uIChjaGFpbiBwYXRoIGFuZCByZWRlZW0gc2NyaXB0cyksIGFuZCB0aGUga2V5Y2hhaW4geHBydixcbiAqIHBlcmZvcm0ga2V5IGRlcml2YXRpb24gYW5kIHNpZ24gdGhlIGlucHV0cyBpbiB0aGUgdHJhbnNhY3Rpb24gYmFzZWQgb24gdGhlIHVuc3BlbnQgaW5mb3JtYXRpb24gcHJvdmlkZWRcbiAqXG4gKiBAcGFyYW1zOlxuICogIHRyYW5zYWN0aW9uSGV4IHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgdHJhbnNhY3Rpb24gaW4gaGV4XG4gKiAgdW5zcGVudHMgYXJyYXkgb2YgdW5zcGVudCBpbmZvcm1hdGlvbiwgd2hlcmUgZWFjaCB1bnNwZW50IGlzIGEgY2hhaW5QYXRoIGFuZCByZWRlZW1TY3JpcHQgd2l0aCB0aGUgc2FtZVxuICogIGluZGV4IGFzIHRoZSBpbnB1dHMgaW4gdGhlIHRyYW5zYWN0aW9uSGV4XG4gKiAga2V5Y2hhaW4gS2V5Y2hhaW4gY29udGFpbmluZyB0aGUgeHBydiB0byBzaWduIHdpdGguIEZvciBsZWdhY3kgc3VwcG9ydCBvZiBzYWZlIHdhbGxldHMsIGtleWNoYWluIGNhblxuIGFsc28gYmUgYSBXSUYgcHJpdmF0ZSBrZXkuXG4gKiAgc2lnbmluZ0tleSBwcml2YXRlIGtleSBpbiBXSUYgZm9yIHNhZmUgd2FsbGV0cywgd2hlbiBrZXljaGFpbiBpcyB1bmF2YWlsYWJsZVxuICogIHZhbGlkYXRlIGNsaWVudC1zaWRlIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gLSBjYW4gYmUgZGlzYWJsZWQgZm9yIGltcHJvdmVkIHBlcmZvcm1hbmNlIChzaWduYXR1cmVzXG4gKiAgICAgICAgICAgYXJlIHN0aWxsIHZhbGlkYXRlZCBzZXJ2ZXItc2lkZSkuXG4gKiAgZmVlU2luZ2xlS2V5V0lGIFVzZSB0aGUgYWRkcmVzcyBiYXNlZCBvbiB0aGlzIHByaXZhdGUga2V5IHRvIHBheSBmZWVzXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIGxldCBrZXljaGFpbiA9IHBhcmFtcy5rZXljaGFpbjsgLy8gZHVwbGljYXRlIHNvIGFzIHRvIG5vdCBtdXRhdGUgYmVsb3dcblxuICBjb25zdCB2YWxpZGF0ZSA9IHBhcmFtcy52YWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy52YWxpZGF0ZTtcbiAgbGV0IHByaXZLZXk7XG4gIGlmICghXy5pc1N0cmluZyhwYXJhbXMudHJhbnNhY3Rpb25IZXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgdGhlIHRyYW5zYWN0aW9uIGhleCBhcyBhIHN0cmluZycpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMudW5zcGVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgdGhlIHVuc3BlbnRzIGFycmF5Jyk7XG4gIH1cbiAgaWYgKCFfLmlzQm9vbGVhbih2YWxpZGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB2YWxpZGF0ZSB0byBiZSBhIGJvb2xlYW4nKTtcbiAgfVxuICBsZXQgbmV0d29yayA9IGdldE5ldHdvcmsoKTtcbiAgY29uc3QgZW5hYmxlQkNIID0gXy5pc0Jvb2xlYW4ocGFyYW1zLmZvcmNlQkNIKSAmJiBwYXJhbXMuZm9yY2VCQ0ggPT09IHRydWU7XG5cbiAgaWYgKCFfLmlzT2JqZWN0KGtleWNoYWluKSB8fCAhXy5pc1N0cmluZygoa2V5Y2hhaW4gYXMgYW55KS54cHJ2KSkge1xuICAgIGlmIChfLmlzU3RyaW5nKHBhcmFtcy5zaWduaW5nS2V5KSkge1xuICAgICAgcHJpdktleSA9IHV0eG9saWIuRUNQYWlyLmZyb21XSUYocGFyYW1zLnNpZ25pbmdLZXksIG5ldHdvcmsgYXMgdXR4b2xpYi5CaXRjb2luSlNOZXR3b3JrKTtcbiAgICAgIGtleWNoYWluID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB0aGUga2V5Y2hhaW4gb2JqZWN0IHdpdGggeHBydicpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBmZWVTaW5nbGVLZXk7XG4gIGlmIChwYXJhbXMuZmVlU2luZ2xlS2V5V0lGKSB7XG4gICAgZmVlU2luZ2xlS2V5ID0gdXR4b2xpYi5FQ1BhaXIuZnJvbVdJRihwYXJhbXMuZmVlU2luZ2xlS2V5V0lGLCBuZXR3b3JrIGFzIHV0eG9saWIuQml0Y29pbkpTTmV0d29yayk7XG4gIH1cblxuICBkZWJ1ZygnTmV0d29yazogJU8nLCBuZXR3b3JrKTtcblxuICBpZiAoZW5hYmxlQkNIKSB7XG4gICAgZGVidWcoJ0VuYWJsaW5nIEJDSOKApicpO1xuICAgIG5ldHdvcmsgPSB1dHhvbGliLm5ldHdvcmtzLmJpdGNvaW5jYXNoO1xuICAgIGRlYnVnKCdOZXcgbmV0d29yazogJU8nLCBuZXR3b3JrKTtcbiAgfVxuXG4gIGNvbnN0IHRyYW5zYWN0aW9uID0gdXR4b2xpYi5iaXRnby5jcmVhdGVUcmFuc2FjdGlvbkZyb21IZXgocGFyYW1zLnRyYW5zYWN0aW9uSGV4LCBuZXR3b3JrKTtcbiAgaWYgKHRyYW5zYWN0aW9uLmlucy5sZW5ndGggIT09IHBhcmFtcy51bnNwZW50cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiB1bnNwZW50cyBhcnJheSBzaG91bGQgZXF1YWwgdG8gdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbiBpbnB1dHMnKTtcbiAgfVxuXG4gIC8vIGRlY29yYXRlIHRyYW5zYWN0aW9uIHdpdGggaW5wdXQgdmFsdWVzIGZvciBUcmFuc2FjdGlvbkJ1aWxkZXIgaW5zdGFudGlhdGlvblxuICBjb25zdCBpc1V0eG9UeCA9IF8uaXNPYmplY3QodHJhbnNhY3Rpb24pICYmIEFycmF5LmlzQXJyYXkoKHRyYW5zYWN0aW9uIGFzIGFueSkuaW5zKTtcbiAgY29uc3QgYXJlVmFsaWRVbnNwZW50cyA9IF8uaXNPYmplY3QocGFyYW1zKSAmJiBBcnJheS5pc0FycmF5KChwYXJhbXMgYXMgYW55KS51bnNwZW50cyk7XG4gIGlmIChpc1V0eG9UeCAmJiBhcmVWYWxpZFVuc3BlbnRzKSB7XG4gICAgLy8gZXh0ZW5kIHRoZSB0cmFuc2FjdGlvbiBpbnB1dHMgd2l0aCB0aGUgdmFsdWVzXG4gICAgY29uc3QgaW5wdXRWYWx1ZXMgPSBfLm1hcCgocGFyYW1zIGFzIGFueSkudW5zcGVudHMsICh1KSA9PiBfLnBpY2sodSwgJ3ZhbHVlJykpO1xuICAgIHRyYW5zYWN0aW9uLmlucy5tYXAoKGN1cnJlbnRJdGVtLCBpbmRleCkgPT4gXy5leHRlbmQoY3VycmVudEl0ZW0sIGlucHV0VmFsdWVzW2luZGV4XSkpO1xuICB9XG5cbiAgbGV0IHJvb3RFeHRLZXk7XG4gIGlmIChrZXljaGFpbikge1xuICAgIHJvb3RFeHRLZXkgPSBiaXAzMi5mcm9tQmFzZTU4KGtleWNoYWluLnhwcnYpO1xuICB9XG5cbiAgY29uc3QgdHhiID0gdXR4b2xpYi5iaXRnby5jcmVhdGVUcmFuc2FjdGlvbkJ1aWxkZXJGcm9tVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0eGIudHguaW5zLmxlbmd0aDsgKytpbmRleCkge1xuICAgIGNvbnN0IGN1cnJlbnRVbnNwZW50ID0gcGFyYW1zLnVuc3BlbnRzW2luZGV4XTtcbiAgICBpZiAoY3VycmVudFVuc3BlbnQucmVkZWVtU2NyaXB0ID09PSBmYWxzZSkge1xuICAgICAgLy8gdGhpcyBpcyB0aGUgaW5wdXQgZnJvbSBhIHNpbmdsZSBrZXkgZmVlIGFkZHJlc3NcbiAgICAgIGlmICghZmVlU2luZ2xlS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2luZ2xlIGtleSBhZGRyZXNzIHVzZWQgaW4gaW5wdXQgYnV0IGZlZVNpbmdsZUtleVdJRiBub3QgcHJvdmlkZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuYWJsZUJDSCkge1xuICAgICAgICBmZWVTaW5nbGVLZXkubmV0d29yayA9IG5ldHdvcms7XG4gICAgICB9XG5cbiAgICAgIHR4Yi5zaWduKGluZGV4LCBmZWVTaW5nbGVLZXkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRVbnNwZW50LndpdG5lc3NTY3JpcHQgJiYgZW5hYmxlQkNIKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JDSCBkb2VzIG5vdCBzdXBwb3J0IHNlZ3dpdCBpbnB1dHMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFpblBhdGggPSBjdXJyZW50VW5zcGVudC5jaGFpblBhdGg7XG4gICAgaWYgKHJvb3RFeHRLZXkpIHtcbiAgICAgIGNvbnN0IHsgd2FsbGV0U3ViUGF0aCA9ICcvMC8wJyB9ID0ga2V5Y2hhaW47XG4gICAgICBjb25zdCBwYXRoID0gc2FuaXRpemVMZWdhY3lQYXRoKGtleWNoYWluLnBhdGggKyB3YWxsZXRTdWJQYXRoICsgY2hhaW5QYXRoKTtcbiAgICAgIGRlYnVnKFxuICAgICAgICAnZGVyaXZlZCB1c2VyIGtleSBwYXRoIFwiJXNcIiB1c2luZyBrZXljaGFpbiBwYXRoIFwiJXNcIiwgd2FsbGV0U3ViUGF0aCBcIiVzXCIsIGtleWNoYWluIHdhbGxldFN1YlBhdGggXCIlc1wiIGFuZCBjaGFpblBhdGggXCIlc1wiJyxcbiAgICAgICAgcGF0aCxcbiAgICAgICAga2V5Y2hhaW4ucGF0aCxcbiAgICAgICAgd2FsbGV0U3ViUGF0aCxcbiAgICAgICAga2V5Y2hhaW4ud2FsbGV0U3ViUGF0aCxcbiAgICAgICAgY2hhaW5QYXRoXG4gICAgICApO1xuICAgICAgcHJpdktleSA9IHJvb3RFeHRLZXkuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG5cbiAgICBwcml2S2V5Lm5ldHdvcmsgPSBuZXR3b3JrO1xuXG4gICAgLy8gc3Vic2NyaXB0IGlzIHRoZSBwYXJ0IG9mIHRoZSBvdXRwdXQgc2NyaXB0IGFmdGVyIHRoZSBPUF9DT0RFU0VQQVJBVE9SLlxuICAgIC8vIFNpbmNlIHdlIGFyZSBvbmx5IGV2ZXIgc2lnbmluZyBwMnNoIG91dHB1dHMsIHdoaWNoIGRvIG5vdCBoYXZlXG4gICAgLy8gT1BfQ09ERVNFUEFSQVRPUlMsIGl0IGlzIGFsd2F5cyB0aGUgb3V0cHV0IHNjcmlwdC5cbiAgICBjb25zdCBzdWJzY3JpcHQgPSBCdWZmZXIuZnJvbShjdXJyZW50VW5zcGVudC5yZWRlZW1TY3JpcHQsICdoZXgnKTtcbiAgICBjdXJyZW50VW5zcGVudC52YWxpZGF0aW9uU2NyaXB0ID0gc3Vic2NyaXB0O1xuXG4gICAgLy8gSW4gb3JkZXIgdG8gc2lnbiB3aXRoIGJpdGNvaW5qcy1saWIsIHdlIG11c3QgdXNlIGl0cyB0cmFuc2FjdGlvblxuICAgIC8vIGJ1aWxkZXIsIGNvbmZ1c2luZ2x5IG5hbWVkIHRoZSBzYW1lIGV4YWN0IHRoaW5nIGFzIG91ciB0cmFuc2FjdGlvblxuICAgIC8vIGJ1aWxkZXIsIGJ1dCB3aXRoIGluZXF1aXZhbGVudCBiZWhhdmlvci5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgd2l0bmVzc1NjcmlwdCA9IGN1cnJlbnRVbnNwZW50LndpdG5lc3NTY3JpcHQgPyBCdWZmZXIuZnJvbShjdXJyZW50VW5zcGVudC53aXRuZXNzU2NyaXB0LCAnaGV4JykgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBzaWdIYXNoID0gdXR4b2xpYi5iaXRnby5nZXREZWZhdWx0U2lnSGFzaChuZXR3b3JrKTtcbiAgICAgIHR4Yi5zaWduKGluZGV4LCBwcml2S2V5LCBzdWJzY3JpcHQsIHNpZ0hhc2gsIGN1cnJlbnRVbnNwZW50LnZhbHVlLCB3aXRuZXNzU2NyaXB0KTtcbiAgICAgIGRlYnVnKGBTaWduZWQgdHJhbnNhY3Rpb24gaW5wdXQgJHtpbmRleH1gKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyB0cnkgZmFsbGJhY2sgZGVyaXZhdGlvbiBwYXRoIChzZWUgQkctNDY0OTcpXG4gICAgICBsZXQgZmFsbGJhY2tTaWduaW5nU3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tQYXRoID0gc2FuaXRpemVMZWdhY3lQYXRoKGtleWNoYWluLnBhdGggKyBjaGFpblBhdGgpO1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAnZGVyaXZlZCBmYWxsYmFjayB1c2VyIGtleSBwYXRoIFwiJXNcIiB1c2luZyBrZXljaGFpbiBwYXRoIFwiJXNcIiBhbmQgY2hhaW5QYXRoIFwiJXNcIicsXG4gICAgICAgICAgZmFsbGJhY2tQYXRoLFxuICAgICAgICAgIGtleWNoYWluLnBhdGgsXG4gICAgICAgICAgY2hhaW5QYXRoXG4gICAgICAgICk7XG4gICAgICAgIHByaXZLZXkgPSByb290RXh0S2V5LmRlcml2ZVBhdGgoZmFsbGJhY2tQYXRoKTtcbiAgICAgICAgY29uc3Qgd2l0bmVzc1NjcmlwdCA9IGN1cnJlbnRVbnNwZW50LndpdG5lc3NTY3JpcHRcbiAgICAgICAgICA/IEJ1ZmZlci5mcm9tKGN1cnJlbnRVbnNwZW50LndpdG5lc3NTY3JpcHQsICdoZXgnKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWdIYXNoID0gdXR4b2xpYi5iaXRnby5nZXREZWZhdWx0U2lnSGFzaChuZXR3b3JrKTtcbiAgICAgICAgdHhiLnNpZ24oaW5kZXgsIHByaXZLZXksIHN1YnNjcmlwdCwgc2lnSGFzaCwgY3VycmVudFVuc3BlbnQudmFsdWUsIHdpdG5lc3NTY3JpcHQpO1xuICAgICAgICBmYWxsYmFja1NpZ25pbmdTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGZhbGxiYWNrRXJyb3IpIHtcbiAgICAgICAgZGVidWcoJ2lucHV0IHNpZ24gZmFpbGVkIGZvciBmYWxsYmFjayBwYXRoOiAlcycsIGZhbGxiYWNrRXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICAvLyB3ZSBuZWVkIHRvIGtub3cgd2hhdCdzIGNhdXNpbmcgdGhpc1xuICAgICAgaWYgKCFmYWxsYmFja1NpZ25pbmdTdWNjZXNzZnVsKSB7XG4gICAgICAgIGUucmVzdWx0ID0ge1xuICAgICAgICAgIHVuc3BlbnQ6IGN1cnJlbnRVbnNwZW50LFxuICAgICAgICB9O1xuICAgICAgICBlLm1lc3NhZ2UgPSBgRmFpbGVkIHRvIHNpZ24gaW5wdXQgIyR7aW5kZXh9IC0gJHtlLm1lc3NhZ2V9IC0gJHtKU09OLnN0cmluZ2lmeShlLnJlc3VsdCwgbnVsbCwgNCl9IC0gXFxuJHtcbiAgICAgICAgICBlLnN0YWNrXG4gICAgICAgIH1gO1xuICAgICAgICBkZWJ1ZygnaW5wdXQgc2lnbiBmYWlsZWQ6ICVzJywgZS5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBwYXJ0aWFsVHJhbnNhY3Rpb24gPSB0eGIuYnVpbGRJbmNvbXBsZXRlKCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgcGFydGlhbFRyYW5zYWN0aW9uLmlucy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gdXR4b2xpYi5iaXRnb1xuICAgICAgICAuZ2V0U2lnbmF0dXJlVmVyaWZpY2F0aW9ucyhwYXJ0aWFsVHJhbnNhY3Rpb24sIGluZGV4LCBwYXJhbXMudW5zcGVudHNbaW5kZXhdLnZhbHVlKVxuICAgICAgICAuZmlsdGVyKCh2KSA9PiB2LnNpZ25lZEJ5ICE9PSB1bmRlZmluZWQpLmxlbmd0aDtcbiAgICAgIGRlYnVnKGBTaWduYXR1cmUgY291bnQgZm9yIGlucHV0ICR7aW5kZXh9OiAke3NpZ25hdHVyZUNvdW50fWApO1xuICAgICAgaWYgKHNpZ25hdHVyZUNvdW50IDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGF0IGxlYXN0IG9uZSB2YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuZnVsbExvY2FsU2lnbmluZyAmJiBzaWduYXR1cmVDb3VudCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdWxsTG9jYWxTaWduaW5nIHNldDogZXhwZWN0ZWQgYXQgbGVhc3QgdHdvIHZhbGlkIHNpZ25hdHVyZXMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHtcbiAgICB0cmFuc2FjdGlvbkhleDogcGFydGlhbFRyYW5zYWN0aW9uLnRvSGV4KCksXG4gIH0pO1xufTtcbiJdfQ==