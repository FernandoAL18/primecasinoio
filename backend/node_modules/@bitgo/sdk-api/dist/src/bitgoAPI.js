"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitGoAPI = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const sjcl = require("@bitgo/sjcl");
const utxolib = require("@bitgo/utxo-lib");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bitcoinMessage = require("bitcoinjs-message");
const browser_or_node_1 = require("browser-or-node");
const crypto_1 = require("crypto");
const debug_1 = require("debug");
const _ = require("lodash");
const secp256k1 = require("secp256k1");
const superagent = require("superagent");
const urlLib = require("url");
const api_1 = require("./api");
const encrypt_1 = require("./encrypt");
const verifyAddress_1 = require("./v1/verifyAddress");
const shamir = require("secrets.js-grempe");
const pjson = require("../package.json");
const debug = (0, debug_1.default)('bitgo:api');
const Blockchain = require('./v1/blockchain');
const Keychains = require('./v1/keychains');
const Wallet = require("./v1/wallet");
const Wallets = require('./v1/wallets');
const Markets = require('./v1/markets');
const PendingApprovals = require('./v1/pendingapprovals');
const TravelRule = require('./v1/travelRule');
const TransactionBuilder = require('./v1/transactionBuilder');
let enableProxyAgent = false;
let proxyAgentModule;
if (!browser_or_node_1.isBrowser && !browser_or_node_1.isWebWorker) {
    debug('enabling proxy-agent');
    enableProxyAgent = true;
    proxyAgentModule = require('proxy-agent');
}
const patchedRequestMethods = ['get', 'post', 'put', 'del', 'patch', 'options'];
class BitGoAPI {
    constructor(params = {}) {
        this._authVersion = 2;
        this._hmacVerification = true;
        this._version = pjson.version;
        this.cookiesPropagationEnabled = false;
        if (!sdk_core_1.common.validateParams(params, [], [
            'accessToken',
            'userAgent',
            'customRootURI',
            'customBitcoinNetwork',
            'serverXpub',
            'stellarFederationServerUrl',
        ]) ||
            (params.useProduction && !_.isBoolean(params.useProduction))) {
            throw new Error('invalid argument');
        }
        // By default, we operate on the test server.
        // Deprecate useProduction in the future
        let env;
        if (params.useProduction) {
            if (params.env && params.env !== 'prod') {
                throw new Error('cannot use useProduction when env=' + params.env);
            }
            env = 'prod';
        }
        else if (params.customRootURI ||
            params.customBitcoinNetwork ||
            params.customSigningAddress ||
            params.serverXpub ||
            process.env.BITGO_CUSTOM_ROOT_URI ||
            process.env.BITGO_CUSTOM_BITCOIN_NETWORK) {
            // for branch deploys, we want to be able to specify custom endpoints while still
            // maintaining the name of specified the environment
            env = params.env === 'branch' ? 'branch' : 'custom';
            if (params.customRootURI) {
                sdk_core_1.common.Environments[env].uri = params.customRootURI;
            }
            if (params.customBitcoinNetwork) {
                sdk_core_1.common.Environments[env].network = params.customBitcoinNetwork;
            }
            if (params.customSigningAddress) {
                sdk_core_1.common.Environments[env].customSigningAddress = params.customSigningAddress;
            }
            if (params.serverXpub) {
                sdk_core_1.common.Environments[env].serverXpub = params.serverXpub;
            }
            if (params.stellarFederationServerUrl) {
                sdk_core_1.common.Environments[env].stellarFederationServerUrl = params.stellarFederationServerUrl;
            }
            if (params.cookiesPropagationEnabled) {
                this.cookiesPropagationEnabled = true;
            }
        }
        else {
            env = params.env || process.env.BITGO_ENV;
        }
        // if this hasn't been set to true already some conditions are not met
        if (params.cookiesPropagationEnabled && !this.cookiesPropagationEnabled) {
            throw new Error('Cookies are only allowed when custom URIs are in use');
        }
        if (params.authVersion !== undefined) {
            this._authVersion = params.authVersion;
        }
        // if this env is an alias, swap it out with the equivalent supported environment
        if (env in sdk_core_1.AliasEnvironments) {
            env = sdk_core_1.AliasEnvironments[env];
        }
        if (env === 'custom' && _.isUndefined(sdk_core_1.common.Environments[env].uri)) {
            throw new Error('must use --customrooturi or set the BITGO_CUSTOM_ROOT_URI environment variable when using the custom environment');
        }
        if (env) {
            if (sdk_core_1.common.Environments[env]) {
                this._baseUrl = sdk_core_1.common.Environments[env].uri;
            }
            else {
                throw new Error('invalid environment ' + env + '. Supported environments: prod, test, dev, latest');
            }
        }
        else {
            env = 'test';
            if (!BitGoAPI._testnetWarningMessage) {
                BitGoAPI._testnetWarningMessage = true;
                console.log('BitGo SDK env not set - defaulting to test at test.bitgo.com.');
            }
            this._baseUrl = sdk_core_1.common.Environments[env].uri;
        }
        this._env = this.env = env;
        const supportedApiTokens = [
            'etherscanApiToken',
            'polygonscanApiToken',
            'arbiscanApiToken',
            'optimisticEtherscanApiToken',
            'zksyncExplorerApiToken',
            'bscscanApiToken',
        ];
        Object.keys(params).forEach((key) => {
            if (supportedApiTokens.includes(key)) {
                sdk_core_1.common.Environments[env][key] = params[key];
            }
        });
        sdk_core_1.common.setNetwork(sdk_core_1.common.Environments[env].network);
        this._baseApiUrl = this._baseUrl + '/api/v1';
        this._baseApiUrlV2 = this._baseUrl + '/api/v2';
        this._token = params.accessToken;
        this._userAgent = params.userAgent || 'BitGoJS-api/' + this.version();
        this._reqId = undefined;
        this._refreshToken = params.refreshToken;
        this._clientId = params.clientId;
        this._clientSecret = params.clientSecret;
        this._keychains = null;
        this._wallets = null;
        // whether to perform extra client-side validation for some things, such as
        // address validation or signature validation. defaults to true, but can be
        // turned off by setting to false. can also be overridden individually in the
        // functions that use it.
        this._validate = params.validate === undefined ? true : params.validate;
        if (!params.hmacVerification && params.hmacVerification !== undefined) {
            if ((env == 'prod' || env == 'adminProd') && sdk_core_1.common.Environments[env].hmacVerificationEnforced) {
                throw new Error(`Cannot disable request HMAC verification in environment ${this.getEnv()}`);
            }
            debug('HMAC verification explicitly disabled by constructor option');
            this._hmacVerification = params.hmacVerification;
        }
        if (!params.proxy && process.env.BITGO_USE_PROXY) {
            params.proxy = process.env.BITGO_USE_PROXY;
        }
        if (process.browser && params.proxy) {
            throw new Error('cannot use https proxy params while in browser');
        }
        this._proxy = params.proxy;
        // capture outer stack so we have useful debug information if fetch constants fails
        const e = new Error();
        // Kick off first load of constants
        this.fetchConstants().catch((err) => {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch initial client constants from BitGo');
                debug(e.stack);
            }
        });
    }
    /**
     * Get a superagent request for specified http method and URL configured to the SDK configuration
     * @param method - http method for the new request
     * @param url - URL for the new request
     */
    getAgentRequest(method, url) {
        let req = superagent[method](url);
        if (this.cookiesPropagationEnabled) {
            req = req.withCredentials();
        }
        return req;
    }
    /**
     * Create a basecoin object
     * @param name
     */
    coin(name) {
        return sdk_core_1.GlobalCoinFactory.getInstance(this, name);
    }
    /**
     * Return the current BitGo environment
     */
    getEnv() {
        return this._env;
    }
    /**
     * Return the current auth version used for requests to the BitGo server
     */
    getAuthVersion() {
        return this._authVersion;
    }
    /**
     * This is a patching function which can apply our authorization
     * headers to any outbound request.
     * @param method
     */
    requestPatch(method, url) {
        const req = this.getAgentRequest(method, url);
        if (this._proxy && enableProxyAgent) {
            debug('proxying request through %s', this._proxy);
            const proxyUrl = this._proxy;
            const agent = new proxyAgentModule.ProxyAgent({
                getProxyForUrl: () => proxyUrl,
            });
            if (agent) {
                req.agent(agent);
            }
        }
        const originalThen = req.then.bind(req);
        req.then = (onfulfilled, onrejected) => {
            var _a, _b;
            // intercept a request before it's submitted to the server for v2 authentication (based on token)
            if (this._version) {
                // TODO - decide where to get version
                req.set('BitGo-SDK-Version', this._version);
            }
            if (!_.isUndefined(this._reqId)) {
                req.set('Request-ID', this._reqId.toString());
                // increment after setting the header so the sequence numbers start at 0
                this._reqId.inc();
                // request ids must be set before each request instead of being kept
                // inside the bitgo object. This is to prevent reentrancy issues where
                // multiple simultaneous requests could cause incorrect reqIds to be used
                delete this._reqId;
            }
            // prevent IE from caching requests
            req.set('If-Modified-Since', 'Mon, 26 Jul 1997 05:00:00 GMT');
            if (!process.browser && this._userAgent) {
                // If not in the browser, set the User-Agent. Browsers don't allow
                // setting of User-Agent, so we must disable this when run in the
                // browser (browserify sets process.browser).
                req.set('User-Agent', this._userAgent);
            }
            // Set the request timeout to just above 5 minutes by default
            req.timeout(process.env.BITGO_TIMEOUT * 1000 || 305 * 1000);
            // if there is no token, and we're not logged in, the request cannot be v2 authenticated
            req.isV2Authenticated = true;
            req.authenticationToken = this._token;
            // some of the older tokens appear to be only 40 characters long
            if ((this._token && this._token.length !== 67 && this._token.indexOf('v2x') !== 0) || req.forceV1Auth) {
                // use the old method
                req.isV2Authenticated = false;
                req.set('Authorization', 'Bearer ' + this._token);
                debug('sending v1 %s request to %s with token %s', method, url, (_a = this._token) === null || _a === void 0 ? void 0 : _a.substr(0, 8));
                return originalThen(onfulfilled).catch(onrejected);
            }
            req.set('BitGo-Auth-Version', this._authVersion === 3 ? '3.0' : '2.0');
            if (this._token) {
                const data = (0, api_1.serializeRequestData)(req);
                (0, api_1.setRequestQueryString)(req);
                const requestProperties = this.calculateRequestHeaders({
                    url: req.url,
                    token: this._token,
                    method,
                    text: data || '',
                });
                req.set('Auth-Timestamp', requestProperties.timestamp.toString());
                // we're not sending the actual token, but only its hash
                req.set('Authorization', 'Bearer ' + requestProperties.tokenHash);
                debug('sending v2 %s request to %s with token %s', method, url, (_b = this._token) === null || _b === void 0 ? void 0 : _b.substr(0, 8));
                // set the HMAC
                req.set('HMAC', requestProperties.hmac);
            }
            /**
             * Verify the response before calling the original onfulfilled handler,
             * and make sure onrejected is called if a verification error is encountered
             */
            const newOnFulfilled = onfulfilled
                ? (response) => {
                    // HMAC verification is only allowed to be skipped in certain environments.
                    // This is checked in the constructor, but checking it again at request time
                    // will help prevent against tampering of this property after the object is created
                    if (!this._hmacVerification && !sdk_core_1.common.Environments[this.getEnv()].hmacVerificationEnforced) {
                        return onfulfilled(response);
                    }
                    const verifiedResponse = (0, api_1.verifyResponse)(this, this._token, method, req, response);
                    return onfulfilled(verifiedResponse);
                }
                : null;
            return originalThen(newOnFulfilled).catch(onrejected);
        };
        return (0, api_1.toBitgoRequest)(req);
    }
    get(url) {
        return this.requestPatch('get', url);
    }
    post(url) {
        return this.requestPatch('post', url);
    }
    put(url) {
        return this.requestPatch('put', url);
    }
    del(url) {
        return this.requestPatch('del', url);
    }
    patch(url) {
        return this.requestPatch('patch', url);
    }
    options(url) {
        return this.requestPatch('options', url);
    }
    /**
     * Calculate the HMAC for the given key and message
     * @param key {String} - the key to use for the HMAC
     * @param message {String} - the actual message to HMAC
     * @returns {*} - the result of the HMAC operation
     */
    calculateHMAC(key, message) {
        return (0, crypto_1.createHmac)('sha256', key).update(message).digest('hex');
    }
    /**
     * Calculate the subject string that is to be HMAC'ed for a HTTP request or response
     * @param urlPath request url, including query params
     * @param text request body text
     * @param timestamp request timestamp from `Date.now()`
     * @param statusCode Only set for HTTP responses, leave blank for requests
     * @param method request method
     * @returns {string}
     */
    calculateHMACSubject({ urlPath, text, timestamp, statusCode, method }) {
        const urlDetails = urlLib.parse(urlPath);
        const queryPath = urlDetails.query && urlDetails.query.length > 0 ? urlDetails.path : urlDetails.pathname;
        if (!_.isUndefined(statusCode) && _.isInteger(statusCode) && _.isFinite(statusCode)) {
            if (this._authVersion === 3) {
                return [method.toUpperCase(), timestamp, queryPath, statusCode, text].join('|');
            }
            return [timestamp, queryPath, statusCode, text].join('|');
        }
        if (this._authVersion === 3) {
            return [method.toUpperCase(), timestamp, '3.0', queryPath, text].join('|');
        }
        return [timestamp, queryPath, text].join('|');
    }
    /**
     * Calculate the HMAC for an HTTP request
     */
    calculateRequestHMAC({ url: urlPath, text, timestamp, token, method }) {
        const signatureSubject = this.calculateHMACSubject({ urlPath, text, timestamp, method });
        // calculate the HMAC
        return this.calculateHMAC(token, signatureSubject);
    }
    /**
     * Calculate request headers with HMAC
     */
    calculateRequestHeaders({ url, text, token, method }) {
        const timestamp = Date.now();
        const hmac = this.calculateRequestHMAC({ url, text, timestamp, token, method });
        // calculate the SHA256 hash of the token
        const hashDigest = sjcl.hash.sha256.hash(token);
        const tokenHash = sjcl.codec.hex.fromBits(hashDigest);
        return {
            hmac,
            timestamp,
            tokenHash,
        };
    }
    /**
     * Verify the HMAC for an HTTP response
     */
    verifyResponse({ url: urlPath, statusCode, text, timestamp, token, hmac, method, }) {
        const signatureSubject = this.calculateHMACSubject({
            urlPath,
            text,
            timestamp,
            statusCode,
            method,
        });
        // calculate the HMAC
        const expectedHmac = this.calculateHMAC(token, signatureSubject);
        // determine if the response is still within the validity window (5 minute window)
        const now = Date.now();
        const isInResponseValidityWindow = timestamp >= now - 1000 * 60 * 5 && timestamp <= now;
        // verify the HMAC and timestamp
        return {
            isValid: expectedHmac === hmac,
            expectedHmac,
            signatureSubject,
            isInResponseValidityWindow,
            verificationTime: now,
        };
    }
    /**
     * Fetch useful constant values from the BitGo server.
     * These values do change infrequently, so they need to be fetched,
     * but are unlikely to change during the lifetime of a BitGo object,
     * so they can safely cached.
     */
    async fetchConstants() {
        var _a, _b;
        const env = this.getEnv();
        if (!BitGoAPI._constants) {
            BitGoAPI._constants = {};
        }
        if (!BitGoAPI._constantsExpire) {
            BitGoAPI._constantsExpire = {};
        }
        if (BitGoAPI._constants[env] && BitGoAPI._constantsExpire[env] && new Date() < BitGoAPI._constantsExpire[env]) {
            return BitGoAPI._constants[env];
        }
        // client constants call cannot be authenticated using the normal HMAC validation
        // scheme, so we need to use a raw superagent instance to do this request.
        // Proxy settings must still be respected however
        const resultPromise = this.getAgentRequest('get', this.url('/client/constants'));
        resultPromise.set('BitGo-SDK-Version', this._version);
        if (this._proxy && enableProxyAgent) {
            const proxyUrl = this._proxy;
            const agent = new proxyAgentModule.ProxyAgent({
                getProxyForUrl: () => proxyUrl,
            });
            if (agent) {
                resultPromise.agent(agent);
            }
        }
        const result = await resultPromise;
        BitGoAPI._constants[env] = result.body.constants;
        if (((_a = result.body) === null || _a === void 0 ? void 0 : _a.ttl) && typeof ((_b = result.body) === null || _b === void 0 ? void 0 : _b.ttl) === 'number') {
            BitGoAPI._constantsExpire[env] = new Date(new Date().getTime() + result.body.ttl * 1000);
        }
        return BitGoAPI._constants[env];
    }
    /**
     * Create a url for calling BitGo platform APIs
     * @param path
     * @param version
     */
    url(path, version = 1) {
        const baseUrl = version === 2 ? this._baseApiUrlV2 : this._baseApiUrl;
        return baseUrl + path;
    }
    /**
     * Create a url for calling BitGo microservice APIs
     */
    microservicesUrl(path) {
        return this._baseUrl + path;
    }
    /**
     * Gets the version of the BitGoJS package
     */
    version() {
        return this._version;
    }
    /**
     * Test connectivity to the server
     * @param params
     */
    ping({ reqId } = {}) {
        if (reqId) {
            this._reqId = reqId;
        }
        return this.get(this.url('/ping')).result();
    }
    /**
     * Set a request tracer to provide request IDs during multi-request workflows
     */
    setRequestTracer(reqTracer) {
        if (reqTracer) {
            this._reqId = reqTracer;
        }
    }
    /**
     * Utility function to encrypt locally.
     */
    encrypt(params) {
        sdk_core_1.common.validateParams(params, ['input', 'password'], ['adata']);
        if (!params.password) {
            throw new Error(`cannot encrypt without password`);
        }
        return (0, encrypt_1.encrypt)(params.password, params.input, { adata: params.adata });
    }
    /**
     * Decrypt an encrypted string locally.
     */
    decrypt(params) {
        params = params || {};
        sdk_core_1.common.validateParams(params, ['input', 'password'], []);
        if (!params.password) {
            throw new Error(`cannot decrypt without password`);
        }
        try {
            return (0, encrypt_1.decrypt)(params.password, params.input);
        }
        catch (error) {
            if (error.message.includes("ccm: tag doesn't match")) {
                error.message = 'password error - ' + error.message;
            }
            throw error;
        }
    }
    /**
     * Serialize this BitGo object to a JSON object.
     *
     * Caution: contains sensitive data
     */
    toJSON() {
        return {
            user: this._user,
            token: this._token,
            extensionKey: this._extensionKey ? this._extensionKey.toWIF() : undefined,
            ecdhXprv: this._ecdhXprv,
        };
    }
    /**
     * Get the current user
     */
    user() {
        return this._user;
    }
    /**
     * Deserialize a JSON serialized BitGo object.
     *
     * Overwrites the properties on the current BitGo object with
     * those of the deserialzed object.
     *
     * @param json
     */
    fromJSON(json) {
        this._user = json.user;
        this._token = json.token;
        this._ecdhXprv = json.ecdhXprv;
        if (json.extensionKey) {
            const network = sdk_core_1.common.Environments[this.getEnv()].network;
            this._extensionKey = utxolib.ECPair.fromWIF(json.extensionKey, utxolib.networks[network]);
        }
    }
    /**
     * Process the username, password and otp into an object containing the username and hashed password, ready to
     * send to bitgo for authentication.
     */
    preprocessAuthenticationParams({ username, password, otp, forceSMS, extensible, trust, forReset2FA, }) {
        if (!_.isString(username)) {
            throw new Error('expected string username');
        }
        if (!_.isString(password)) {
            throw new Error('expected string password');
        }
        const lowerName = username.toLowerCase();
        // Calculate the password HMAC so we don't send clear-text passwords
        const hmacPassword = this.calculateHMAC(lowerName, password);
        const authParams = {
            email: lowerName,
            password: hmacPassword,
            forceSMS: !!forceSMS,
        };
        if (otp) {
            authParams.otp = otp;
            if (trust) {
                authParams.trust = 1;
            }
        }
        if (extensible) {
            this._extensionKey = (0, sdk_core_1.makeRandomKey)();
            authParams.extensible = true;
            authParams.extensionAddress = (0, sdk_core_1.getAddressP2PKH)(this._extensionKey);
        }
        if (forReset2FA) {
            authParams.forReset2FA = true;
        }
        return authParams;
    }
    /**
     * Synchronous method for activating an access token.
     */
    authenticateWithAccessToken({ accessToken }) {
        debug('now authenticating with access token %s', accessToken.substring(0, 8));
        this._token = accessToken;
    }
    /**
     * Creates a new ECDH keychain for the user.
     * @param {string} loginPassword - The user's login password.
     * @returns {Promise<any>} - A promise that resolves with the new ECDH keychain data.
     * @throws {Error} - Throws an error if there is an issue creating the keychain.
     */
    async createUserEcdhKeychain(loginPassword) {
        const keyData = this.keychains().create();
        const hdNode = sdk_core_1.bitcoin.HDNode.fromBase58(keyData.xprv);
        /**
         * Add the new ECDH keychain to the user's account.
         * @type {Promise<any>} - A promise that resolves with the new ECDH keychain.
         */
        return await this.keychains().add({
            source: 'ecdh',
            xpub: hdNode.neutered().toBase58(),
            encryptedXprv: this.encrypt({
                password: loginPassword,
                input: hdNode.toBase58(),
            }),
        });
    }
    /**
     * Updates the user's settings with the provided parameters.
     * @param {Object} params - The parameters to update the user's settings with.
     * @returns {Promise<any>}
     * @throws {Error} - Throws an error if there is an issue updating the user's settings.
     */
    async updateUserSettings(params) {
        return this.put(this.url('/user/settings', 2)).send(params).result();
    }
    /**
     * Ensures that the user's ECDH keychain is created for wallet sharing and TSS wallets.
     * If the keychain does not exist, it will be created and the user's settings will be updated.
     * @param {string} loginPassword - The user's login password.
     * @returns {Promise<any>} - A promise that resolves with the user's settings ensuring we have the ecdhKeychain in there.
     * @throws {Error} - Throws an error if there is an issue creating the keychain or updating the user's settings.
     */
    async ensureUserEcdhKeychainIsCreated(loginPassword) {
        /**
         * Get the user's current settings.
         */
        const userSettings = await this.get(this.url('/user/settings')).result();
        /**
         * If the user's ECDH keychain does not exist, create a new keychain and update the user's settings.
         */
        if (!userSettings.settings.ecdhKeychain) {
            const newKeychain = await this.createUserEcdhKeychain(loginPassword);
            await this.updateUserSettings({
                settings: {
                    ecdhKeychain: newKeychain.xpub,
                },
            });
            /**
             * Update the user's settings object with the new ECDH keychain.
             */
            userSettings.settings.ecdhKeychain = newKeychain.xpub;
        }
        /**
         * Return the user's ECDH keychain settings.
         */
        return userSettings.settings;
    }
    /**
     * Login to the bitgo platform.
     */
    async authenticate(params) {
        try {
            if (!_.isObject(params)) {
                throw new Error('required object params');
            }
            if (!_.isString(params.password)) {
                throw new Error('expected string password');
            }
            const forceV1Auth = !!params.forceV1Auth;
            const authParams = this.preprocessAuthenticationParams(params);
            const password = params.password;
            if (this._token) {
                return new Error('already logged in');
            }
            const authUrl = this.microservicesUrl('/api/auth/v1/session');
            const request = this.post(authUrl);
            if (forceV1Auth) {
                request.forceV1Auth = true;
                // tell the server that the client was forced to downgrade the authentication protocol
                authParams.forceV1Auth = true;
                debug('forcing v1 auth for call to authenticate');
            }
            const response = await request.send(authParams);
            // extract body and user information
            const body = response.body;
            this._user = body.user;
            if (body.access_token) {
                this._token = body.access_token;
                // if the downgrade was forced, adding a warning message might be prudent
            }
            else {
                // check the presence of an encrypted ECDH xprv
                // if not present, legacy account
                const encryptedXprv = body.encryptedECDHXprv;
                if (!encryptedXprv) {
                    throw new Error('Keychain needs encryptedXprv property');
                }
                const responseDetails = this.handleTokenIssuance(response.body, password);
                this._token = responseDetails.token;
                this._ecdhXprv = responseDetails.ecdhXprv;
                // verify the response's authenticity
                (0, api_1.verifyResponse)(this, responseDetails.token, 'post', request, response);
                // add the remaining component for easier access
                response.body.access_token = this._token;
            }
            const userSettings = params.ensureEcdhKeychain ? await this.ensureUserEcdhKeychainIsCreated(password) : undefined;
            if (userSettings === null || userSettings === void 0 ? void 0 : userSettings.ecdhKeychain) {
                response.body.user.ecdhKeychain = userSettings.ecdhKeychain;
            }
            return (0, api_1.handleResponseResult)()(response);
        }
        catch (e) {
            (0, api_1.handleResponseError)(e);
        }
    }
    /**
     *
     * @param responseBody Response body object
     * @param password Password for the symmetric decryption
     */
    handleTokenIssuance(responseBody, password) {
        // make sure the response body contains the necessary properties
        sdk_core_1.common.validateParams(responseBody, ['derivationPath'], ['encryptedECDHXprv']);
        const environment = this._env;
        const environmentConfig = sdk_core_1.common.Environments[environment];
        const serverXpub = environmentConfig.serverXpub;
        let ecdhXprv = this._ecdhXprv;
        if (!ecdhXprv) {
            if (!password || !responseBody.encryptedECDHXprv) {
                throw new Error('ecdhXprv property must be set or password and encrypted encryptedECDHXprv must be provided');
            }
            try {
                ecdhXprv = this.decrypt({
                    input: responseBody.encryptedECDHXprv,
                    password: password,
                });
            }
            catch (e) {
                e.errorCode = 'ecdh_xprv_decryption_failure';
                console.error('Failed to decrypt encryptedECDHXprv.');
                throw e;
            }
        }
        // construct HDNode objects for client's xprv and server's xpub
        const clientHDNode = utxo_lib_1.bip32.fromBase58(ecdhXprv);
        const serverHDNode = utxo_lib_1.bip32.fromBase58(serverXpub);
        // BIP32 derivation path is applied to both client and server master keys
        const derivationPath = (0, sdk_core_1.sanitizeLegacyPath)(responseBody.derivationPath);
        const clientDerivedNode = clientHDNode.derivePath(derivationPath);
        const serverDerivedNode = serverHDNode.derivePath(derivationPath);
        const publicKey = serverDerivedNode.publicKey;
        const secretKey = clientDerivedNode.privateKey;
        if (!secretKey) {
            throw new Error('no client private Key');
        }
        const secret = Buffer.from(
        // FIXME(BG-34386): we should use `secp256k1.ecdh()` in the future
        //                  see discussion here https://github.com/bitcoin-core/secp256k1/issues/352
        secp256k1.publicKeyTweakMul(publicKey, secretKey)).toString('hex');
        // decrypt token with symmetric ECDH key
        let response;
        try {
            response = {
                token: this.decrypt({
                    input: responseBody.encryptedToken,
                    password: secret,
                }),
            };
        }
        catch (e) {
            e.errorCode = 'token_decryption_failure';
            console.error('Failed to decrypt token.');
            throw e;
        }
        if (!this._ecdhXprv) {
            response.ecdhXprv = ecdhXprv;
        }
        return response;
    }
    /**
     */
    verifyPassword(params = {}) {
        if (!_.isString(params.password)) {
            throw new Error('missing required string password');
        }
        if (!this._user || !this._user.username) {
            throw new Error('no current user');
        }
        const hmacPassword = this.calculateHMAC(this._user.username, params.password);
        return this.post(this.url('/user/verifypassword')).send({ password: hmacPassword }).result('valid');
    }
    /**
     * Clear out all state from this BitGo object, effectively logging out the current user.
     */
    clear() {
        // TODO: are there any other fields which should be cleared?
        this._user = undefined;
        this._token = undefined;
        this._refreshToken = undefined;
        this._ecdhXprv = undefined;
    }
    /**
     * Use refresh token to get new access token.
     * If the refresh token is null/defined, then we use the stored token from auth
     */
    async refreshToken(params = {}) {
        sdk_core_1.common.validateParams(params, [], ['refreshToken']);
        const refreshToken = params.refreshToken || this._refreshToken;
        if (!refreshToken) {
            throw new Error('Must provide refresh token or have authenticated with Oauth before');
        }
        if (!this._clientId || !this._clientSecret) {
            throw new Error('Need client id and secret set first to use this');
        }
        const body = await this.post(this._baseUrl + '/oauth/token')
            .send({
            grant_type: 'refresh_token',
            refresh_token: refreshToken,
            client_id: this._clientId,
            client_secret: this._clientSecret,
        })
            .result();
        this._token = body.access_token;
        this._refreshToken = body.refresh_token;
        return body;
    }
    /**
     *
     * listAccessTokens
     * Get information on all of the BitGo access tokens on the user
     * @return {
     *  id: <id of the token>
     *  label: <the user-provided label for this token>
     *  user: <id of the user on the token>
     *  enterprise <id of the enterprise this token is valid for>
     *  client: <the auth client that this token belongs to>
     *  scope: <list of allowed OAuth scope values>
     *  created: <date the token was created>
     *  expires: <date the token will expire>
     *  origin: <the origin for which this token is valid>
     *  isExtensible: <flag indicating if the token can be extended>
     *  extensionAddress: <address whose private key's signature is necessary for extensions>
     *  unlock: <info for actions that require an unlock before firing>
     * }
     */
    async listAccessTokens() {
        return this.get(this.url('/user/accesstoken')).send().result('accessTokens');
    }
    /**
     * addAccessToken
     * Add a BitGo API Access Token to the current user account
     * @param params {
     *    otp: (required) <valid otp code>
     *    label: (required) <label for the token>
     *    duration: <length of time in seconds the token will be valid for>
     *    ipRestrict: <array of IP address strings to whitelist>
     *    txValueLimit: <number of outgoing satoshis allowed on this token>
     *    scope: (required) <authorization scope of the requested token>
     * }
     * @return {
     *    id: <id of the token>
     *    token: <access token hex string to be used for BitGo API request verification>
     *    label: <user-provided label for this token>
     *    user: <id of the user on the token>
     *    enterprise <id of the enterprise this token is valid for>
     *    client: <the auth client that this token belongs to>
     *    scope: <list of allowed OAuth scope values>
     *    created: <date the token was created>
     *    expires: <date the token will expire>
     *    origin: <the origin for which this token is valid>
     *    isExtensible: <flag indicating if the token can be extended>
     *    extensionAddress: <address whose private key's signature is necessary for extensions>
     *    unlock: <info for actions that require an unlock before firing>
     * }
     */
    async addAccessToken(params) {
        var _a;
        try {
            if (!_.isString(params.label)) {
                throw new Error('required string label');
            }
            // check non-string params
            if (params.duration) {
                if (!_.isNumber(params.duration) || params.duration < 0) {
                    throw new Error('duration must be a non-negative number');
                }
            }
            if (params.ipRestrict) {
                if (!_.isArray(params.ipRestrict)) {
                    throw new Error('ipRestrict must be an array');
                }
                _.forEach(params.ipRestrict, (ipAddr) => {
                    if (!_.isString(ipAddr)) {
                        throw new Error('ipRestrict must be an array of IP address strings');
                    }
                });
            }
            if (params.txValueLimit) {
                if (!_.isNumber(params.txValueLimit)) {
                    throw new Error('txValueLimit must be a number');
                }
                if (params.txValueLimit < 0) {
                    throw new Error('txValueLimit must be a non-negative number');
                }
            }
            if (params.scope && params.scope.length > 0) {
                if (!_.isArray(params.scope)) {
                    throw new Error('scope must be an array');
                }
            }
            else {
                throw new Error('must specify scope for token');
            }
            const authUrl = this.microservicesUrl('/api/auth/v1/accesstoken');
            const request = this.post(authUrl);
            if (!this._ecdhXprv) {
                // without a private key, the user cannot decrypt the new access token the server will send
                request.forceV1Auth = true;
                debug('forcing v1 auth for adding access token using token %s', (_a = this._token) === null || _a === void 0 ? void 0 : _a.substr(0, 8));
            }
            const response = await request.send(params);
            if (request.forceV1Auth) {
                response.body.warning = 'A protocol downgrade has occurred because this is a legacy account.';
                return (0, api_1.handleResponseResult)()(response);
            }
            // verify the authenticity of the server's response before proceeding any further
            (0, api_1.verifyResponse)(this, this._token, 'post', request, response);
            const responseDetails = this.handleTokenIssuance(response.body);
            response.body.token = responseDetails.token;
            return (0, api_1.handleResponseResult)()(response);
        }
        catch (e) {
            (0, api_1.handleResponseError)(e);
        }
    }
    /**
     * Sets the expire time of an access token matching either the id or label to the current date, effectively deleting it
     *
     * Params:
     * id: <id of the access token to be deleted>
     * label: <label of the access token to be deleted>
     *
     * Returns:
     * id: <id of the token>
     * label: <user-provided label for this token>
     * user: <id of the user on the token>
     * enterprise <id of the enterprise this token is valid for>
     * client: <the auth client that this token belongs to>
     * scope: <list of allowed OAuth scope values>
     * created: <date the token was created>
     * expires: <date the token will expire>
     * origin: <the origin for which this token is valid>
     * isExtensible: <flag indicating if the token can be extended>
     * extensionAddress: <address whose private key's signature is ne*cessary for extensions>
     * unlock: <info for actions that require an unlock before firing>
     * @param params
     */
    async removeAccessToken({ id, label }) {
        if ((!id && !label) || (id && label)) {
            throw new Error('must provide exactly one of id or label');
        }
        if (id) {
            return this.del(this.url(`/user/accesstoken/${id}`))
                .send()
                .result();
        }
        const tokens = await this.listAccessTokens();
        if (!tokens) {
            throw new Error('token with this label does not exist');
        }
        const matchingTokens = _.filter(tokens, { label });
        if (matchingTokens.length > 1) {
            throw new Error('ambiguous call: multiple tokens matching this label');
        }
        if (matchingTokens.length === 0) {
            throw new Error('token with this label does not exist');
        }
        return this.del(this.url(`/user/accesstoken/${matchingTokens[0].id}`))
            .send()
            .result();
    }
    /**
     * Generate a random password
     * @param   {Number} numWords     Number of 32-bit words
     * @returns {String}          base58 random password
     */
    generateRandomPassword(numWords = 5) {
        return (0, sdk_core_1.generateRandomPassword)(numWords);
    }
    /**
     * Logout of BitGo
     */
    async logout() {
        const result = await this.get(this.url('/user/logout')).result();
        this.clear();
        return result;
    }
    /**
     * Get a user by ID (name/email only)
     * @param id
     *
     * @deprecated
     */
    async getUser({ id }) {
        if (!_.isString(id)) {
            throw new Error('expected string id');
        }
        return this.get(this.url(`/user/${id}`)).result('user');
    }
    /**
     * Get the current logged in user
     */
    async me() {
        return this.getUser({ id: 'me' });
    }
    /**
     * Unlock the session by providing OTP
     * @param {string} otp Required OTP code for the account.
     * @param {number} duration Desired duration of the unlock in seconds (default=600, max=3600).
     */
    async unlock({ otp, duration }) {
        if (otp && !_.isString(otp)) {
            throw new Error('expected string or undefined otp');
        }
        return this.post(this.url('/user/unlock')).send({ otp, duration }).result();
    }
    /**
     * Lock the session
     */
    async lock() {
        return this.post(this.url('/user/lock')).result();
    }
    /**
     * Get the current session
     */
    async session() {
        return this.get(this.url('/user/session')).result('session');
    }
    /**
     * Trigger a push/sms for the OTP code
     * @param {boolean} params.forceSMS If set to true, will use SMS to send the OTP to the user even if they have other 2FA method set up.
     * @deprecated
     */
    async sendOTP(params = {}) {
        return this.post(this.url('/user/sendotp')).send(params).result();
    }
    /**
     * Extend token, provided the current token is extendable
     * @param params
     * - duration: duration in seconds by which to extend the token, starting at the current time
     */
    async extendToken(params = {}) {
        if (!this._extensionKey) {
            throw new Error('missing required property _extensionKey');
        }
        const timestamp = Date.now();
        const duration = params.duration;
        const message = timestamp + '|' + this._token + '|' + duration;
        const privateKey = this._extensionKey.privateKey;
        if (!privateKey) {
            throw new Error('no privateKey on extensionKey');
        }
        const isCompressed = this._extensionKey.compressed;
        const prefix = utxolib.networks.bitcoin.messagePrefix;
        const signature = bitcoinMessage.sign(message, privateKey, isCompressed, prefix).toString('hex');
        return this.post(this.url('/user/extendtoken'))
            .send(params)
            .set('timestamp', timestamp.toString())
            .set('signature', signature)
            .result();
    }
    /**
     * Get a key for sharing a wallet with a user
     * @param email email of user to share wallet with
     */
    async getSharingKey({ email }) {
        if (!_.isString(email)) {
            throw new Error('required string email');
        }
        return this.post(this.url('/user/sharingkey')).send({ email }).result();
    }
    /**
     * Users that want to sign with a key will use this api to fetch the keychain and the path.
     * Users that want to verify a signature will use this api to fetch another users ecdh pubkey.
     * Note: If the user id is not provided, it will default to getting the current user's keychain.
     * @param bitgo
     * @param enterpriseId
     * @param userId
     */
    async getSigningKeyForUser(enterpriseId, userId) {
        const user = userId !== null && userId !== void 0 ? userId : 'me';
        return this.get(this.url(`/enterprise/${enterpriseId}/user/${user}/signingkey`, 2))
            .query({})
            .result();
    }
    /**
     *
     */
    getValidate() {
        return this._validate;
    }
    /**
     *
     */
    setValidate(validate) {
        if (!_.isBoolean(validate)) {
            throw new Error('invalid argument');
        }
        this._validate = validate;
    }
    /**
     * Register a new coin instance with its builder factory
     * @param {string} name coin name as it was registered in @bitgo/statics
     * @param {CoinConstructor} coin the builder factory class for that coin
     * @returns {void}
     */
    register(name, coin) {
        sdk_core_1.GlobalCoinFactory.register(name, coin);
    }
    /**
     * Get bitcoin market data
     *
     * @deprecated
     */
    markets() {
        if (!this._markets) {
            this._markets = new Markets(this);
        }
        return this._markets;
    }
    /**
     * Get the latest bitcoin prices
     * (Deprecated: Will be removed in the future) use `bitgo.markets().latest()`
     * @deprecated
     */
    // cb-compat
    async market() {
        return this.get(this.url('/market/latest')).result();
    }
    /**
     * Get market data from yesterday
     * (Deprecated: Will be removed in the future) use bitgo.markets().yesterday()
     * @deprecated
     */
    async yesterday() {
        return this.get(this.url('/market/yesterday')).result();
    }
    /**
     * Get the blockchain object.
     * @deprecated
     */
    blockchain() {
        if (!this._blockchain) {
            this._blockchain = new Blockchain(this);
        }
        return this._blockchain;
    }
    /**
     * Get the user's keychains object.
     * @deprecated
     */
    keychains() {
        if (!this._keychains) {
            this._keychains = new Keychains(this);
        }
        return this._keychains;
    }
    /**
     * Get the travel rule object
     * @deprecated
     */
    travelRule() {
        if (!this._travelRule) {
            this._travelRule = new TravelRule(this);
        }
        return this._travelRule;
    }
    /**
     * Get the user's wallets object.
     * @deprecated
     */
    wallets() {
        if (!this._wallets) {
            this._wallets = new Wallets(this);
        }
        return this._wallets;
    }
    /**
     * Get pending approvals that can be approved/ or rejected
     * @deprecated
     */
    pendingApprovals() {
        if (!this._pendingApprovals) {
            this._pendingApprovals = new PendingApprovals(this);
        }
        return this._pendingApprovals;
    }
    /**
     * A factory method to create a new Wallet object, initialized with the wallet params
     * Can be used to reconstitute a wallet from cached data
     * @param walletParams
     * @deprecated
     */
    newWalletObject(walletParams) {
        return new Wallet(this, walletParams);
    }
    /**
     * V1 method for calculating miner fee amounts, given the number and
     * type of transaction inputs, along with a fee rate in satoshis per vkB.
     *
     * This method should not be used for new code.
     *
     * @deprecated
     * @param params
     * @return {any}
     */
    async calculateMinerFeeInfo(params) {
        return TransactionBuilder.calculateMinerFeeInfo(params);
    }
    /**
     * Verify a Bitcoin address is a valid base58 address
     * @deprecated
     */
    verifyAddress(params = {}) {
        sdk_core_1.common.validateParams(params, ['address'], []);
        if (!_.isString(params.address)) {
            throw new Error('missing required string address');
        }
        const networkName = sdk_core_1.common.Environments[this.getEnv()].network;
        const network = utxolib.networks[networkName];
        return (0, verifyAddress_1.verifyAddress)(params.address, network);
    }
    /**
     * Split a secret into shards using Shamir Secret Sharing.
     * @param seed A hexadecimal secret to split
     * @param passwords An array of the passwords used to encrypt each share
     * @param m The threshold number of shards necessary to reconstitute the secret
     */
    splitSecret({ seed, passwords, m }) {
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (!_.isInteger(m) || m < 2) {
            throw new Error('m must be a positive integer greater than or equal to 2');
        }
        if (passwords.length < m) {
            throw new Error('passwords array length cannot be less than m');
        }
        const n = passwords.length;
        const secrets = shamir.share(seed, n, m);
        const shards = _.zipWith(secrets, passwords, (shard, password) => {
            return this.encrypt({ input: shard, password });
        });
        const node = utxo_lib_1.bip32.fromSeed(Buffer.from(seed, 'hex'));
        return {
            xpub: node.neutered().toBase58(),
            m,
            n,
            seedShares: shards,
        };
    }
    /**
     * Reconstitute a secret which was sharded with `splitSecret`.
     * @param shards
     * @param passwords
     */
    reconstituteSecret({ shards, passwords }) {
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        const secrets = _.zipWith(shards, passwords, (shard, password) => {
            return this.decrypt({ input: shard, password });
        });
        const seed = shamir.combine(secrets);
        const node = utxo_lib_1.bip32.fromSeed(Buffer.from(seed, 'hex'));
        return {
            xpub: node.neutered().toBase58(),
            xprv: node.toBase58(),
            seed,
        };
    }
    /**
     *
     * @param shards
     * @param passwords
     * @param m
     * @param xpub Optional xpub to verify the results against
     */
    verifyShards({ shards, passwords, m, xpub }) {
        /**
         * Generate all possible combinations of a given array's values given subset size m
         * @param array The array whose values are to be arranged in all combinations
         * @param m The size of each subset
         * @param entryIndices Recursively trailing set of currently chosen array indices for the combination subset under construction
         * @returns {Array}
         */
        const generateCombinations = (array, m, entryIndices = []) => {
            let combinations = [];
            if (entryIndices.length === m) {
                const currentCombination = _.at(array, entryIndices);
                return [currentCombination];
            }
            // The highest index
            let entryIndex = _.last(entryIndices);
            // If there are currently no indices, assume -1
            if (_.isUndefined(entryIndex)) {
                entryIndex = -1;
            }
            for (let i = entryIndex + 1; i < array.length; i++) {
                // append the current index to the trailing indices
                const currentEntryIndices = [...entryIndices, i];
                const newCombinations = generateCombinations(array, m, currentEntryIndices);
                combinations = [...combinations, ...newCombinations];
            }
            return combinations;
        };
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        const secrets = _.zipWith(shards, passwords, (shard, password) => {
            return this.decrypt({ input: shard, password });
        });
        const secretCombinations = generateCombinations(secrets, m);
        const seeds = secretCombinations.map((currentCombination) => {
            return shamir.combine(currentCombination);
        });
        const uniqueSeeds = _.uniq(seeds);
        if (uniqueSeeds.length !== 1) {
            return false;
        }
        const seed = _.first(uniqueSeeds);
        const node = utxo_lib_1.bip32.fromSeed(Buffer.from(seed, 'hex'));
        const restoredXpub = node.neutered().toBase58();
        if (!_.isUndefined(xpub)) {
            if (!_.isString(xpub)) {
                throw new Error('xpub must be a string');
            }
            if (restoredXpub !== xpub) {
                return false;
            }
        }
        return true;
    }
    /**
     * @deprecated - use `getSharedSecret()`
     */
    getECDHSecret({ otherPubKeyHex, eckey }) {
        if (!_.isString(otherPubKeyHex)) {
            throw new Error('otherPubKeyHex string required');
        }
        if (!_.isObject(eckey)) {
            throw new Error('eckey object required');
        }
        return (0, sdk_core_1.getSharedSecret)(eckey, Buffer.from(otherPubKeyHex, 'hex')).toString('hex');
    }
    /**
     * Gets the user's private ECDH keychain
     */
    async getECDHKeychain(ecdhKeychainPub) {
        if (!ecdhKeychainPub) {
            const result = await this.get(this.url('/user/settings')).result();
            if (!result.settings.ecdhKeychain) {
                return new Error('ecdh keychain not found for user');
            }
            ecdhKeychainPub = result.settings.ecdhKeychain;
        }
        return this.keychains().get({ xpub: ecdhKeychainPub });
    }
    /**
     * Returns the user derived public and private ECDH keypair
     * @param password password to decrypt the user's ECDH encrypted private key
     * @param entId? optional enterprise id to check for permissions
     */
    async getEcdhKeypairPrivate(password, entId) {
        const userSigningKey = await this.getSigningKeyForUser(entId);
        const pubkeyOfAdminEcdhKeyHex = userSigningKey.derivedPubkey;
        if (!userSigningKey.ecdhKeychain || !userSigningKey.derivationPath) {
            throw new Error('Something went wrong with the user keychain. Please contact support@bitgo.com.');
        }
        const userEcdhKeychain = await this.getECDHKeychain(userSigningKey.ecdhKeychain);
        let xprv;
        try {
            xprv = this.decrypt({
                password: password,
                input: userEcdhKeychain.encryptedXprv,
            });
        }
        catch (e) {
            throw new Error('Incorrect password. Please try again.');
        }
        return {
            derivedPubKey: pubkeyOfAdminEcdhKeyHex,
            derivationPath: userSigningKey.derivationPath,
            xprv,
        };
    }
    /**
     * @param params
     * - operatingSystem: one of ios, android
     * - pushToken: hex-formatted token for the respective native push notification service
     * @returns {*}
     * @deprecated
     */
    async registerPushToken(params) {
        params = params || {};
        sdk_core_1.common.validateParams(params, ['pushToken', 'operatingSystem'], []);
        if (!this._token) {
            // this device has to be registered to an extensible session
            throw new Error('not logged in');
        }
        const postParams = _.pick(params, ['pushToken', 'operatingSystem']);
        return this.post(this.url('/devices')).send(postParams).result();
    }
    /**
     * @param params
     * - pushVerificationToken: the token received via push notification to confirm the device's mobility
     * @deprecated
     */
    verifyPushToken(params) {
        if (!_.isObject(params)) {
            throw new Error('required object params');
        }
        if (!_.isString(params.pushVerificationToken)) {
            throw new Error('required string pushVerificationToken');
        }
        if (!this._token) {
            // this device has to be registered to an extensible session
            throw new Error('not logged in');
        }
        const postParams = _.pick(params, 'pushVerificationToken');
        return this.post(this.url('/devices/verify')).send(postParams).result();
    }
    /**
     * Login to the bitgo system using an authcode generated via Oauth
     */
    async authenticateWithAuthCode(params) {
        if (!_.isObject(params)) {
            throw new Error('required object params');
        }
        if (!_.isString(params.authCode)) {
            throw new Error('required string authCode');
        }
        if (!this._clientId || !this._clientSecret) {
            throw new Error('Need client id and secret set first to use this');
        }
        const authCode = params.authCode;
        if (this._token) {
            throw new Error('already logged in');
        }
        const request = this.post(this._baseUrl + '/oauth/token');
        request.forceV1Auth = true; // OAuth currently only supports v1 authentication
        const body = await request
            .send({
            grant_type: 'authorization_code',
            code: authCode,
            client_id: this._clientId,
            client_secret: this._clientSecret,
        })
            .result();
        this._token = body.access_token;
        this._refreshToken = body.refresh_token;
        this._user = await this.me();
        return body;
    }
    /**
     * Change the password of the currently logged in user.
     * Also change all v1 and v2 keychain passwords if they match the
     * given oldPassword. Returns nothing on success.
     * @param oldPassword {String} - the current password
     * @param newPassword {String} - the new password
     */
    async changePassword({ oldPassword, newPassword }) {
        if (!_.isString(oldPassword)) {
            throw new Error('expected string oldPassword');
        }
        if (!_.isString(newPassword)) {
            throw new Error('expected string newPassword');
        }
        const user = this.user();
        if (typeof user !== 'object' || !user.username) {
            throw new Error('missing required object user');
        }
        const validation = await this.verifyPassword({ password: oldPassword });
        if (!validation) {
            throw new Error('the provided oldPassword is incorrect');
        }
        // it doesn't matter which coin we choose because the v2 updatePassword functions updates all v2 keychains
        // we just need to choose a coin that exists in the current environment
        const coin = sdk_core_1.common.Environments[this.getEnv()].network === 'bitcoin' ? 'btc' : 'tbtc';
        const updateKeychainPasswordParams = { oldPassword, newPassword };
        const v1KeychainUpdatePWResult = await this.keychains().updatePassword(updateKeychainPasswordParams);
        const v2Keychains = await this.coin(coin).keychains().updatePassword(updateKeychainPasswordParams);
        const updatePasswordParams = {
            keychains: v1KeychainUpdatePWResult.keychains,
            v2_keychains: v2Keychains,
            version: v1KeychainUpdatePWResult.version,
            oldPassword: this.calculateHMAC(user.username, oldPassword),
            password: this.calculateHMAC(user.username, newPassword),
        };
        return this.post(this.url('/user/changepassword')).send(updatePasswordParams).result();
    }
    /**
     * Get all the address labels on all of the user's wallets
     *
     * @deprecated
     */
    async labels() {
        return this.get(this.url('/labels')).result('labels');
    }
    /**
     * Estimates approximate fee per kb needed for a tx to get into a block
     * @param {number} params.numBlocks target blocks for the transaction to be confirmed
     * @param {number} params.maxFee maximum fee willing to be paid (for safety)
     * @param {array[string]} params.inputs list of unconfirmed txIds from which this transaction uses inputs
     * @param {number} params.txSize estimated transaction size in bytes, optional parameter used for CPFP estimation.
     * @param {boolean} params.cpfpAware flag indicating fee should take into account CPFP
     * @deprecated
     */
    async estimateFee(params = {}) {
        const queryParams = { version: 12 };
        if (params.numBlocks) {
            if (!_.isNumber(params.numBlocks)) {
                throw new Error('invalid argument');
            }
            queryParams.numBlocks = params.numBlocks;
        }
        if (params.maxFee) {
            if (!_.isNumber(params.maxFee)) {
                throw new Error('invalid argument');
            }
            queryParams.maxFee = params.maxFee;
        }
        if (params.inputs) {
            if (!Array.isArray(params.inputs)) {
                throw new Error('invalid argument');
            }
            queryParams.inputs = params.inputs;
        }
        if (params.txSize) {
            if (!_.isNumber(params.txSize)) {
                throw new Error('invalid argument');
            }
            queryParams.txSize = params.txSize;
        }
        if (params.cpfpAware) {
            if (!_.isBoolean(params.cpfpAware)) {
                throw new Error('invalid argument');
            }
            queryParams.cpfpAware = params.cpfpAware;
        }
        return this.get(this.url('/tx/fee')).query(queryParams).result();
    }
    /**
     * Get BitGo's guarantee using an instant id
     * @param params
     * @deprecated
     */
    async instantGuarantee(params) {
        if (!_.isString(params.id)) {
            throw new Error('required string id');
        }
        const body = await this.get(this.url('/instant/' + params.id)).result();
        if (!body.guarantee) {
            throw new Error('no guarantee found in response body');
        }
        if (!body.signature) {
            throw new Error('no signature found in guarantee response body');
        }
        const signingAddress = sdk_core_1.common.Environments[this.getEnv()].signingAddress;
        const signatureBuffer = Buffer.from(body.signature, 'hex');
        const prefix = utxolib.networks[sdk_core_1.common.Environments[this.getEnv()].network].messagePrefix;
        const isValidSignature = bitcoinMessage.verify(body.guarantee, signingAddress, signatureBuffer, prefix);
        if (!isValidSignature) {
            throw new Error('incorrect signature');
        }
        return body;
    }
    /**
     * Get a target address for payment of a BitGo fee
     * @deprecated
     */
    async getBitGoFeeAddress() {
        return this.post(this.url('/billing/address')).send({}).result();
    }
    /**
     * Gets an address object (including the wallet id) for a given address.
     * @param {string} params.address The address to look up.
     * @deprecated
     */
    async getWalletAddress({ address }) {
        return this.get(this.url(`/walletaddress/${address}`)).result();
    }
    /**
     * Fetch list of user webhooks
     *
     * @returns {*}
     * @deprecated
     */
    async listWebhooks() {
        return this.get(this.url('/webhooks')).result();
    }
    /**
     * Add new user webhook
     *
     * @param params
     * @returns {*}
     * @deprecated
     */
    async addWebhook(params) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.post(this.url('/webhooks')).send(params).result();
    }
    /**
     * Remove user webhook
     *
     * @param params
     * @returns {*}
     * @deprecated
     */
    async removeWebhook(params) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.del(this.url('/webhooks')).send(params).result();
    }
    /**
     * Fetch list of webhook notifications for the user
     *
     * @param params
     * @returns {*}
     */
    async listWebhookNotifications(params = {}) {
        const query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.get(this.url('/webhooks/notifications')).query(query).result();
    }
    /**
     * Simulate a user webhook
     *
     * @param params
     * @returns {*}
     */
    async simulateWebhook(params) {
        sdk_core_1.common.validateParams(params, ['webhookId', 'blockId'], []);
        if (!_.isString(params.webhookId)) {
            throw new Error('required string webhookId');
        }
        if (!_.isString(params.blockId)) {
            throw new Error('required string blockId');
        }
        return this.post(this.url(`/webhooks/${params.webhookId}/simulate`))
            .send(params)
            .result();
    }
    /**
     * Synchronously get constants which are relevant to the client.
     *
     * Note: This function has a known race condition. It may return different values over time,
     * especially if called shortly after creation of the BitGo object.
     *
     * New code should call fetchConstants() directly instead.
     *
     * @deprecated
     * @return {Object} The client constants object
     */
    getConstants() {
        // kick off a fresh request for the client constants
        this.fetchConstants().catch(function (err) {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch client constants from BitGo');
                console.trace(err);
            }
        });
        // use defaultConstants as the backup for keys that are not set in this._constants
        return _.merge({}, (0, sdk_core_1.defaultConstants)(this.getEnv()), BitGoAPI._constants[this.getEnv()]);
    }
}
exports.BitGoAPI = BitGoAPI;
BitGoAPI._testnetWarningMessage = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Z29BUEkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYml0Z29BUEkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsOENBc0J5QjtBQUN6QixvQ0FBb0M7QUFDcEMsMkNBQTJDO0FBQzNDLDhDQUF5RDtBQUN6RCxvREFBb0Q7QUFDcEQscURBQXlEO0FBQ3pELG1DQUFvQztBQUNwQyxpQ0FBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLHVDQUF1QztBQUN2Qyx5Q0FBeUM7QUFDekMsOEJBQThCO0FBQzlCLCtCQU9lO0FBQ2YsdUNBQTZDO0FBQzdDLHNEQUFtRDtBQXlDbkQsNENBQTZDO0FBQzdDLHlDQUEwQztBQUMxQyxNQUFNLEtBQUssR0FBRyxJQUFBLGVBQVEsRUFBQyxXQUFXLENBQUMsQ0FBQztBQUVwQyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUM5QyxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUM1QyxzQ0FBdUM7QUFFdkMsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ3hDLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN4QyxNQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQzFELE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzlDLE1BQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFFOUQsSUFBSSxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7QUFDN0IsSUFBSSxnQkFBZ0IsQ0FBQztBQUNyQixJQUFJLENBQUMsMkJBQVMsSUFBSSxDQUFDLDZCQUFXLEVBQUU7SUFDOUIsS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDOUIsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO0lBQ3hCLGdC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QUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLE1BQU0sQ0FBQyxTQUFTLFdBQVcsQ0FBQyxDQUFDO2FBQ2pFLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsWUFBWTtRQUNWLG9EQUFvRDtRQUNwRCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRztZQUN2QyxJQUFJLEdBQUcsRUFBRTtnQkFDUCwwREFBMEQ7Z0JBQzFELE9BQU8sQ0FBQyxLQUFLLENBQUMsNkNBQTZDLENBQUMsQ0FBQztnQkFDN0QsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNwQjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsa0ZBQWtGO1FBQ2xGLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsSUFBQSwyQkFBZ0IsRUFBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDMUYsQ0FBQzs7QUE5M0RILDRCQSszREM7QUFwM0RrQiwrQkFBc0IsR0FBRyxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBbGlhc0Vudmlyb25tZW50cyxcbiAgQmFzZUNvaW4sXG4gIGJpdGNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgQml0R29SZXF1ZXN0LFxuICBDb2luQ29uc3RydWN0b3IsXG4gIGNvbW1vbixcbiAgRGVjcnlwdE9wdGlvbnMsXG4gIGRlZmF1bHRDb25zdGFudHMsXG4gIEVjZGhEZXJpdmVkS2V5cGFpcixcbiAgRW5jcnlwdE9wdGlvbnMsXG4gIEVudmlyb25tZW50TmFtZSxcbiAgZ2VuZXJhdGVSYW5kb21QYXNzd29yZCxcbiAgZ2V0QWRkcmVzc1AyUEtILFxuICBnZXRTaGFyZWRTZWNyZXQsXG4gIEdldFNoYXJpbmdLZXlPcHRpb25zLFxuICBHZXRTaWduaW5nS2V5QXBpLFxuICBHbG9iYWxDb2luRmFjdG9yeSxcbiAgSVJlcXVlc3RUcmFjZXIsXG4gIG1ha2VSYW5kb21LZXksXG4gIHNhbml0aXplTGVnYWN5UGF0aCxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCAqIGFzIHNqY2wgZnJvbSAnQGJpdGdvL3NqY2wnO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgYmlwMzIsIEVDUGFpckludGVyZmFjZSB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgKiBhcyBiaXRjb2luTWVzc2FnZSBmcm9tICdiaXRjb2luanMtbWVzc2FnZSc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIsIGlzV2ViV29ya2VyIH0gZnJvbSAnYnJvd3Nlci1vci1ub2RlJztcbmltcG9ydCB7IGNyZWF0ZUhtYWMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IGRlYnVnTGliIGZyb20gJ2RlYnVnJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIHNlY3AyNTZrMSBmcm9tICdzZWNwMjU2azEnO1xuaW1wb3J0ICogYXMgc3VwZXJhZ2VudCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIHVybExpYiBmcm9tICd1cmwnO1xuaW1wb3J0IHtcbiAgaGFuZGxlUmVzcG9uc2VFcnJvcixcbiAgaGFuZGxlUmVzcG9uc2VSZXN1bHQsXG4gIHNlcmlhbGl6ZVJlcXVlc3REYXRhLFxuICBzZXRSZXF1ZXN0UXVlcnlTdHJpbmcsXG4gIHRvQml0Z29SZXF1ZXN0LFxuICB2ZXJpZnlSZXNwb25zZSxcbn0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHsgZGVjcnlwdCwgZW5jcnlwdCB9IGZyb20gJy4vZW5jcnlwdCc7XG5pbXBvcnQgeyB2ZXJpZnlBZGRyZXNzIH0gZnJvbSAnLi92MS92ZXJpZnlBZGRyZXNzJztcbmltcG9ydCB7XG4gIEFjY2Vzc1Rva2VuT3B0aW9ucyxcbiAgQWRkQWNjZXNzVG9rZW5PcHRpb25zLFxuICBBZGRBY2Nlc3NUb2tlblJlc3BvbnNlLFxuICBBdXRoZW50aWNhdGVPcHRpb25zLFxuICBBdXRoZW50aWNhdGVXaXRoQXV0aENvZGVPcHRpb25zLFxuICBCaXRHb0FQSU9wdGlvbnMsXG4gIEJpdEdvSnNvbixcbiAgQml0R29TaW11bGF0ZVdlYmhvb2tPcHRpb25zLFxuICBDYWxjdWxhdGVIbWFjU3ViamVjdE9wdGlvbnMsXG4gIENhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzT3B0aW9ucyxcbiAgQ2FsY3VsYXRlUmVxdWVzdEhtYWNPcHRpb25zLFxuICBDaGFuZ2VQYXNzd29yZE9wdGlvbnMsXG4gIERlcHJlY2F0ZWRWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgRXN0aW1hdGVGZWVPcHRpb25zLFxuICBFeHRlbmRUb2tlbk9wdGlvbnMsXG4gIEdldEVjZGhTZWNyZXRPcHRpb25zLFxuICBHZXRVc2VyT3B0aW9ucyxcbiAgTGlzdFdlYmhvb2tOb3RpZmljYXRpb25zT3B0aW9ucyxcbiAgTG9naW5SZXNwb25zZSxcbiAgUGluZ09wdGlvbnMsXG4gIFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyxcbiAgUmVjb25zdGl0dXRlZFNlY3JldCxcbiAgUmVjb25zdGl0dXRlU2VjcmV0T3B0aW9ucyxcbiAgUmVnaXN0ZXJQdXNoVG9rZW5PcHRpb25zLFxuICBSZW1vdmVBY2Nlc3NUb2tlbk9wdGlvbnMsXG4gIFJlcXVlc3RIZWFkZXJzLFxuICBTcGxpdFNlY3JldCxcbiAgU3BsaXRTZWNyZXRPcHRpb25zLFxuICBUb2tlbklzc3VhbmNlLFxuICBUb2tlbklzc3VhbmNlUmVzcG9uc2UsXG4gIFVubG9ja09wdGlvbnMsXG4gIFVzZXIsXG4gIFZlcmlmeVBhc3N3b3JkT3B0aW9ucyxcbiAgVmVyaWZ5UHVzaFRva2VuT3B0aW9ucyxcbiAgVmVyaWZ5UmVzcG9uc2VJbmZvLFxuICBWZXJpZnlSZXNwb25zZU9wdGlvbnMsXG4gIFZlcmlmeVNoYXJkc09wdGlvbnMsXG4gIFdlYmhvb2tPcHRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBzaGFtaXIgPSByZXF1aXJlKCdzZWNyZXRzLmpzLWdyZW1wZScpO1xuaW1wb3J0IHBqc29uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzphcGknKTtcblxuY29uc3QgQmxvY2tjaGFpbiA9IHJlcXVpcmUoJy4vdjEvYmxvY2tjaGFpbicpO1xuY29uc3QgS2V5Y2hhaW5zID0gcmVxdWlyZSgnLi92MS9rZXljaGFpbnMnKTtcbmltcG9ydCBXYWxsZXQgPSByZXF1aXJlKCcuL3YxL3dhbGxldCcpO1xuXG5jb25zdCBXYWxsZXRzID0gcmVxdWlyZSgnLi92MS93YWxsZXRzJyk7XG5jb25zdCBNYXJrZXRzID0gcmVxdWlyZSgnLi92MS9tYXJrZXRzJyk7XG5jb25zdCBQZW5kaW5nQXBwcm92YWxzID0gcmVxdWlyZSgnLi92MS9wZW5kaW5nYXBwcm92YWxzJyk7XG5jb25zdCBUcmF2ZWxSdWxlID0gcmVxdWlyZSgnLi92MS90cmF2ZWxSdWxlJyk7XG5jb25zdCBUcmFuc2FjdGlvbkJ1aWxkZXIgPSByZXF1aXJlKCcuL3YxL3RyYW5zYWN0aW9uQnVpbGRlcicpO1xuXG5sZXQgZW5hYmxlUHJveHlBZ2VudCA9IGZhbHNlO1xubGV0IHByb3h5QWdlbnRNb2R1bGU7XG5pZiAoIWlzQnJvd3NlciAmJiAhaXNXZWJXb3JrZXIpIHtcbiAgZGVidWcoJ2VuYWJsaW5nIHByb3h5LWFnZW50Jyk7XG4gIGVuYWJsZVByb3h5QWdlbnQgPSB0cnVlO1xuICBwcm94eUFnZW50TW9kdWxlID0gcmVxdWlyZSgncHJveHktYWdlbnQnKTtcbn1cblxuY29uc3QgcGF0Y2hlZFJlcXVlc3RNZXRob2RzID0gWydnZXQnLCAncG9zdCcsICdwdXQnLCAnZGVsJywgJ3BhdGNoJywgJ29wdGlvbnMnXSBhcyBjb25zdDtcblxuZXhwb3J0IGNsYXNzIEJpdEdvQVBJIGltcGxlbWVudHMgQml0R29CYXNlIHtcbiAgLy8gdjEgdHlwZXNcbiAgcHJvdGVjdGVkIF9rZXljaGFpbnM6IGFueTtcbiAgcHJvdGVjdGVkIF93YWxsZXRzOiBhbnk7XG4gIHByb3RlY3RlZCBfbWFya2V0cz86IGFueTtcbiAgcHJvdGVjdGVkIF9ibG9ja2NoYWluPzogYW55O1xuICBwcm90ZWN0ZWQgX3RyYXZlbFJ1bGU/OiBhbnk7XG4gIHByb3RlY3RlZCBfcGVuZGluZ0FwcHJvdmFscz86IGFueTtcblxuICBwcm90ZWN0ZWQgc3RhdGljIF9jb25zdGFudHM6IGFueTtcbiAgcHJvdGVjdGVkIHN0YXRpYyBfY29uc3RhbnRzRXhwaXJlOiBhbnk7XG4gIHByb3RlY3RlZCBzdGF0aWMgX3Rlc3RuZXRXYXJuaW5nTWVzc2FnZSA9IGZhbHNlO1xuICBwdWJsaWMgcmVhZG9ubHkgZW52OiBFbnZpcm9ubWVudE5hbWU7XG4gIHByb3RlY3RlZCByZWFkb25seSBfYmFzZVVybDogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2Jhc2VBcGlVcmw6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9iYXNlQXBpVXJsVjI6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9lbnY6IEVudmlyb25tZW50TmFtZTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9hdXRoVmVyc2lvbjogRXhjbHVkZTxCaXRHb0FQSU9wdGlvbnNbJ2F1dGhWZXJzaW9uJ10sIHVuZGVmaW5lZD4gPSAyO1xuICBwcm90ZWN0ZWQgX2htYWNWZXJpZmljYXRpb24gPSB0cnVlO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3Byb3h5Pzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3VzZXI/OiBVc2VyO1xuICBwcm90ZWN0ZWQgX2V4dGVuc2lvbktleT86IEVDUGFpckludGVyZmFjZTtcbiAgcHJvdGVjdGVkIF9yZXFJZD86IElSZXF1ZXN0VHJhY2VyO1xuICBwcm90ZWN0ZWQgX3Rva2VuPzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3ZlcnNpb24gPSBwanNvbi52ZXJzaW9uO1xuICBwcm90ZWN0ZWQgX3VzZXJBZ2VudD86IHN0cmluZztcbiAgcHJvdGVjdGVkIF9lY2RoWHBydj86IHN0cmluZztcbiAgcHJvdGVjdGVkIF9yZWZyZXNoVG9rZW4/OiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBfY2xpZW50SWQ/OiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBfY2xpZW50U2VjcmV0Pzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3ZhbGlkYXRlOiBib29sZWFuO1xuICBwdWJsaWMgcmVhZG9ubHkgY29va2llc1Byb3BhZ2F0aW9uRW5hYmxlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXM6IEJpdEdvQVBJT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5jb29raWVzUHJvcGFnYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKFxuICAgICAgIWNvbW1vbi52YWxpZGF0ZVBhcmFtcyhcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBbXSxcbiAgICAgICAgW1xuICAgICAgICAgICdhY2Nlc3NUb2tlbicsXG4gICAgICAgICAgJ3VzZXJBZ2VudCcsXG4gICAgICAgICAgJ2N1c3RvbVJvb3RVUkknLFxuICAgICAgICAgICdjdXN0b21CaXRjb2luTmV0d29yaycsXG4gICAgICAgICAgJ3NlcnZlclhwdWInLFxuICAgICAgICAgICdzdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybCcsXG4gICAgICAgIF1cbiAgICAgICkgfHxcbiAgICAgIChwYXJhbXMudXNlUHJvZHVjdGlvbiAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLnVzZVByb2R1Y3Rpb24pKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2Ugb3BlcmF0ZSBvbiB0aGUgdGVzdCBzZXJ2ZXIuXG4gICAgLy8gRGVwcmVjYXRlIHVzZVByb2R1Y3Rpb24gaW4gdGhlIGZ1dHVyZVxuICAgIGxldCBlbnY6IEVudmlyb25tZW50TmFtZTtcblxuICAgIGlmIChwYXJhbXMudXNlUHJvZHVjdGlvbikge1xuICAgICAgaWYgKHBhcmFtcy5lbnYgJiYgcGFyYW1zLmVudiAhPT0gJ3Byb2QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZSB1c2VQcm9kdWN0aW9uIHdoZW4gZW52PScgKyBwYXJhbXMuZW52KTtcbiAgICAgIH1cbiAgICAgIGVudiA9ICdwcm9kJztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcGFyYW1zLmN1c3RvbVJvb3RVUkkgfHxcbiAgICAgIHBhcmFtcy5jdXN0b21CaXRjb2luTmV0d29yayB8fFxuICAgICAgcGFyYW1zLmN1c3RvbVNpZ25pbmdBZGRyZXNzIHx8XG4gICAgICBwYXJhbXMuc2VydmVyWHB1YiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQklUR09fQ1VTVE9NX1JPT1RfVVJJIHx8XG4gICAgICBwcm9jZXNzLmVudi5CSVRHT19DVVNUT01fQklUQ09JTl9ORVRXT1JLXG4gICAgKSB7XG4gICAgICAvLyBmb3IgYnJhbmNoIGRlcGxveXMsIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBzcGVjaWZ5IGN1c3RvbSBlbmRwb2ludHMgd2hpbGUgc3RpbGxcbiAgICAgIC8vIG1haW50YWluaW5nIHRoZSBuYW1lIG9mIHNwZWNpZmllZCB0aGUgZW52aXJvbm1lbnRcbiAgICAgIGVudiA9IHBhcmFtcy5lbnYgPT09ICdicmFuY2gnID8gJ2JyYW5jaCcgOiAnY3VzdG9tJztcbiAgICAgIGlmIChwYXJhbXMuY3VzdG9tUm9vdFVSSSkge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0udXJpID0gcGFyYW1zLmN1c3RvbVJvb3RVUkk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmN1c3RvbUJpdGNvaW5OZXR3b3JrKSB7XG4gICAgICAgIGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS5uZXR3b3JrID0gcGFyYW1zLmN1c3RvbUJpdGNvaW5OZXR3b3JrO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5jdXN0b21TaWduaW5nQWRkcmVzcykge1xuICAgICAgICAoY29tbW9uLkVudmlyb25tZW50c1tlbnZdIGFzIGFueSkuY3VzdG9tU2lnbmluZ0FkZHJlc3MgPSBwYXJhbXMuY3VzdG9tU2lnbmluZ0FkZHJlc3M7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnNlcnZlclhwdWIpIHtcbiAgICAgICAgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnNlcnZlclhwdWIgPSBwYXJhbXMuc2VydmVyWHB1YjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmwpIHtcbiAgICAgICAgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsID0gcGFyYW1zLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5jb29raWVzUHJvcGFnYXRpb25FbmFibGVkKSB7XG4gICAgICAgIHRoaXMuY29va2llc1Byb3BhZ2F0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudiA9IHBhcmFtcy5lbnYgfHwgKHByb2Nlc3MuZW52LkJJVEdPX0VOViBhcyBFbnZpcm9ubWVudE5hbWUpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgaGFzbid0IGJlZW4gc2V0IHRvIHRydWUgYWxyZWFkeSBzb21lIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXRcbiAgICBpZiAocGFyYW1zLmNvb2tpZXNQcm9wYWdhdGlvbkVuYWJsZWQgJiYgIXRoaXMuY29va2llc1Byb3BhZ2F0aW9uRW5hYmxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29raWVzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBjdXN0b20gVVJJcyBhcmUgaW4gdXNlJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5hdXRoVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9hdXRoVmVyc2lvbiA9IHBhcmFtcy5hdXRoVmVyc2lvbjtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGlzIGVudiBpcyBhbiBhbGlhcywgc3dhcCBpdCBvdXQgd2l0aCB0aGUgZXF1aXZhbGVudCBzdXBwb3J0ZWQgZW52aXJvbm1lbnRcbiAgICBpZiAoZW52IGluIEFsaWFzRW52aXJvbm1lbnRzKSB7XG4gICAgICBlbnYgPSBBbGlhc0Vudmlyb25tZW50c1tlbnZdO1xuICAgIH1cblxuICAgIGlmIChlbnYgPT09ICdjdXN0b20nICYmIF8uaXNVbmRlZmluZWQoY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnVyaSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ211c3QgdXNlIC0tY3VzdG9tcm9vdHVyaSBvciBzZXQgdGhlIEJJVEdPX0NVU1RPTV9ST09UX1VSSSBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aGVuIHVzaW5nIHRoZSBjdXN0b20gZW52aXJvbm1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChlbnYpIHtcbiAgICAgIGlmIChjb21tb24uRW52aXJvbm1lbnRzW2Vudl0pIHtcbiAgICAgICAgdGhpcy5fYmFzZVVybCA9IGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS51cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW52aXJvbm1lbnQgJyArIGVudiArICcuIFN1cHBvcnRlZCBlbnZpcm9ubWVudHM6IHByb2QsIHRlc3QsIGRldiwgbGF0ZXN0Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudiA9ICd0ZXN0JztcbiAgICAgIGlmICghQml0R29BUEkuX3Rlc3RuZXRXYXJuaW5nTWVzc2FnZSkge1xuICAgICAgICBCaXRHb0FQSS5fdGVzdG5ldFdhcm5pbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5sb2coJ0JpdEdvIFNESyBlbnYgbm90IHNldCAtIGRlZmF1bHRpbmcgdG8gdGVzdCBhdCB0ZXN0LmJpdGdvLmNvbS4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Jhc2VVcmwgPSBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0udXJpO1xuICAgIH1cbiAgICB0aGlzLl9lbnYgPSB0aGlzLmVudiA9IGVudjtcblxuICAgIGNvbnN0IHN1cHBvcnRlZEFwaVRva2VucyA9IFtcbiAgICAgICdldGhlcnNjYW5BcGlUb2tlbicsXG4gICAgICAncG9seWdvbnNjYW5BcGlUb2tlbicsXG4gICAgICAnYXJiaXNjYW5BcGlUb2tlbicsXG4gICAgICAnb3B0aW1pc3RpY0V0aGVyc2NhbkFwaVRva2VuJyxcbiAgICAgICd6a3N5bmNFeHBsb3JlckFwaVRva2VuJyxcbiAgICAgICdic2NzY2FuQXBpVG9rZW4nLFxuICAgIF07XG5cbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKHN1cHBvcnRlZEFwaVRva2Vucy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb21tb24uc2V0TmV0d29yayhjb21tb24uRW52aXJvbm1lbnRzW2Vudl0ubmV0d29yayk7XG5cbiAgICB0aGlzLl9iYXNlQXBpVXJsID0gdGhpcy5fYmFzZVVybCArICcvYXBpL3YxJztcbiAgICB0aGlzLl9iYXNlQXBpVXJsVjIgPSB0aGlzLl9iYXNlVXJsICsgJy9hcGkvdjInO1xuICAgIHRoaXMuX3Rva2VuID0gcGFyYW1zLmFjY2Vzc1Rva2VuO1xuICAgIHRoaXMuX3VzZXJBZ2VudCA9IHBhcmFtcy51c2VyQWdlbnQgfHwgJ0JpdEdvSlMtYXBpLycgKyB0aGlzLnZlcnNpb24oKTtcbiAgICB0aGlzLl9yZXFJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBwYXJhbXMucmVmcmVzaFRva2VuO1xuICAgIHRoaXMuX2NsaWVudElkID0gcGFyYW1zLmNsaWVudElkO1xuICAgIHRoaXMuX2NsaWVudFNlY3JldCA9IHBhcmFtcy5jbGllbnRTZWNyZXQ7XG4gICAgdGhpcy5fa2V5Y2hhaW5zID0gbnVsbDtcbiAgICB0aGlzLl93YWxsZXRzID0gbnVsbDtcblxuICAgIC8vIHdoZXRoZXIgdG8gcGVyZm9ybSBleHRyYSBjbGllbnQtc2lkZSB2YWxpZGF0aW9uIGZvciBzb21lIHRoaW5ncywgc3VjaCBhc1xuICAgIC8vIGFkZHJlc3MgdmFsaWRhdGlvbiBvciBzaWduYXR1cmUgdmFsaWRhdGlvbi4gZGVmYXVsdHMgdG8gdHJ1ZSwgYnV0IGNhbiBiZVxuICAgIC8vIHR1cm5lZCBvZmYgYnkgc2V0dGluZyB0byBmYWxzZS4gY2FuIGFsc28gYmUgb3ZlcnJpZGRlbiBpbmRpdmlkdWFsbHkgaW4gdGhlXG4gICAgLy8gZnVuY3Rpb25zIHRoYXQgdXNlIGl0LlxuICAgIHRoaXMuX3ZhbGlkYXRlID0gcGFyYW1zLnZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLnZhbGlkYXRlO1xuXG4gICAgaWYgKCFwYXJhbXMuaG1hY1ZlcmlmaWNhdGlvbiAmJiBwYXJhbXMuaG1hY1ZlcmlmaWNhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoKGVudiA9PSAncHJvZCcgfHwgZW52ID09ICdhZG1pblByb2QnKSAmJiBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0uaG1hY1ZlcmlmaWNhdGlvbkVuZm9yY2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRpc2FibGUgcmVxdWVzdCBITUFDIHZlcmlmaWNhdGlvbiBpbiBlbnZpcm9ubWVudCAke3RoaXMuZ2V0RW52KCl9YCk7XG4gICAgICB9XG4gICAgICBkZWJ1ZygnSE1BQyB2ZXJpZmljYXRpb24gZXhwbGljaXRseSBkaXNhYmxlZCBieSBjb25zdHJ1Y3RvciBvcHRpb24nKTtcbiAgICAgIHRoaXMuX2htYWNWZXJpZmljYXRpb24gPSBwYXJhbXMuaG1hY1ZlcmlmaWNhdGlvbjtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMucHJveHkgJiYgcHJvY2Vzcy5lbnYuQklUR09fVVNFX1BST1hZKSB7XG4gICAgICBwYXJhbXMucHJveHkgPSBwcm9jZXNzLmVudi5CSVRHT19VU0VfUFJPWFk7XG4gICAgfVxuXG4gICAgaWYgKChwcm9jZXNzIGFzIGFueSkuYnJvd3NlciAmJiBwYXJhbXMucHJveHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZSBodHRwcyBwcm94eSBwYXJhbXMgd2hpbGUgaW4gYnJvd3NlcicpO1xuICAgIH1cblxuICAgIHRoaXMuX3Byb3h5ID0gcGFyYW1zLnByb3h5O1xuXG4gICAgLy8gY2FwdHVyZSBvdXRlciBzdGFjayBzbyB3ZSBoYXZlIHVzZWZ1bCBkZWJ1ZyBpbmZvcm1hdGlvbiBpZiBmZXRjaCBjb25zdGFudHMgZmFpbHNcbiAgICBjb25zdCBlID0gbmV3IEVycm9yKCk7XG5cbiAgICAvLyBLaWNrIG9mZiBmaXJzdCBsb2FkIG9mIGNvbnN0YW50c1xuICAgIHRoaXMuZmV0Y2hDb25zdGFudHMoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhbiBlcnJvciBkb2VzIG5vdCB0ZXJtaW5hdGUgdGhlIGVudGlyZSBzY3JpcHRcbiAgICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkIHRvIGZldGNoIGluaXRpYWwgY2xpZW50IGNvbnN0YW50cyBmcm9tIEJpdEdvJyk7XG4gICAgICAgIGRlYnVnKGUuc3RhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN1cGVyYWdlbnQgcmVxdWVzdCBmb3Igc3BlY2lmaWVkIGh0dHAgbWV0aG9kIGFuZCBVUkwgY29uZmlndXJlZCB0byB0aGUgU0RLIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIG1ldGhvZCAtIGh0dHAgbWV0aG9kIGZvciB0aGUgbmV3IHJlcXVlc3RcbiAgICogQHBhcmFtIHVybCAtIFVSTCBmb3IgdGhlIG5ldyByZXF1ZXN0XG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0QWdlbnRSZXF1ZXN0KG1ldGhvZDogKHR5cGVvZiBwYXRjaGVkUmVxdWVzdE1ldGhvZHMpW251bWJlcl0sIHVybDogc3RyaW5nKTogc3VwZXJhZ2VudC5TdXBlckFnZW50UmVxdWVzdCB7XG4gICAgbGV0IHJlcTogc3VwZXJhZ2VudC5TdXBlckFnZW50UmVxdWVzdCA9IHN1cGVyYWdlbnRbbWV0aG9kXSh1cmwpO1xuICAgIGlmICh0aGlzLmNvb2tpZXNQcm9wYWdhdGlvbkVuYWJsZWQpIHtcbiAgICAgIHJlcSA9IHJlcS53aXRoQ3JlZGVudGlhbHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgYmFzZWNvaW4gb2JqZWN0XG4gICAqIEBwYXJhbSBuYW1lXG4gICAqL1xuICBwdWJsaWMgY29pbihuYW1lOiBzdHJpbmcpOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIEdsb2JhbENvaW5GYWN0b3J5LmdldEluc3RhbmNlKHRoaXMsIG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBCaXRHbyBlbnZpcm9ubWVudFxuICAgKi9cbiAgZ2V0RW52KCk6IEVudmlyb25tZW50TmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgYXV0aCB2ZXJzaW9uIHVzZWQgZm9yIHJlcXVlc3RzIHRvIHRoZSBCaXRHbyBzZXJ2ZXJcbiAgICovXG4gIGdldEF1dGhWZXJzaW9uKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dGhWZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBwYXRjaGluZyBmdW5jdGlvbiB3aGljaCBjYW4gYXBwbHkgb3VyIGF1dGhvcml6YXRpb25cbiAgICogaGVhZGVycyB0byBhbnkgb3V0Ym91bmQgcmVxdWVzdC5cbiAgICogQHBhcmFtIG1ldGhvZFxuICAgKi9cbiAgcHJpdmF0ZSByZXF1ZXN0UGF0Y2gobWV0aG9kOiAodHlwZW9mIHBhdGNoZWRSZXF1ZXN0TWV0aG9kcylbbnVtYmVyXSwgdXJsOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXEgPSB0aGlzLmdldEFnZW50UmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgaWYgKHRoaXMuX3Byb3h5ICYmIGVuYWJsZVByb3h5QWdlbnQpIHtcbiAgICAgIGRlYnVnKCdwcm94eWluZyByZXF1ZXN0IHRocm91Z2ggJXMnLCB0aGlzLl9wcm94eSk7XG4gICAgICBjb25zdCBwcm94eVVybDogc3RyaW5nID0gdGhpcy5fcHJveHk7XG4gICAgICBjb25zdCBhZ2VudCA9IG5ldyBwcm94eUFnZW50TW9kdWxlLlByb3h5QWdlbnQoe1xuICAgICAgICBnZXRQcm94eUZvclVybDogKCkgPT4gcHJveHlVcmwsXG4gICAgICB9KTtcbiAgICAgIGlmIChhZ2VudCkge1xuICAgICAgICByZXEuYWdlbnQoYWdlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsVGhlbiA9IHJlcS50aGVuLmJpbmQocmVxKTtcbiAgICByZXEudGhlbiA9IChvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkgPT4ge1xuICAgICAgLy8gaW50ZXJjZXB0IGEgcmVxdWVzdCBiZWZvcmUgaXQncyBzdWJtaXR0ZWQgdG8gdGhlIHNlcnZlciBmb3IgdjIgYXV0aGVudGljYXRpb24gKGJhc2VkIG9uIHRva2VuKVxuICAgICAgaWYgKHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgICAgLy8gVE9ETyAtIGRlY2lkZSB3aGVyZSB0byBnZXQgdmVyc2lvblxuICAgICAgICByZXEuc2V0KCdCaXRHby1TREstVmVyc2lvbicsIHRoaXMuX3ZlcnNpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodGhpcy5fcmVxSWQpKSB7XG4gICAgICAgIHJlcS5zZXQoJ1JlcXVlc3QtSUQnLCB0aGlzLl9yZXFJZC50b1N0cmluZygpKTtcblxuICAgICAgICAvLyBpbmNyZW1lbnQgYWZ0ZXIgc2V0dGluZyB0aGUgaGVhZGVyIHNvIHRoZSBzZXF1ZW5jZSBudW1iZXJzIHN0YXJ0IGF0IDBcbiAgICAgICAgdGhpcy5fcmVxSWQuaW5jKCk7XG5cbiAgICAgICAgLy8gcmVxdWVzdCBpZHMgbXVzdCBiZSBzZXQgYmVmb3JlIGVhY2ggcmVxdWVzdCBpbnN0ZWFkIG9mIGJlaW5nIGtlcHRcbiAgICAgICAgLy8gaW5zaWRlIHRoZSBiaXRnbyBvYmplY3QuIFRoaXMgaXMgdG8gcHJldmVudCByZWVudHJhbmN5IGlzc3VlcyB3aGVyZVxuICAgICAgICAvLyBtdWx0aXBsZSBzaW11bHRhbmVvdXMgcmVxdWVzdHMgY291bGQgY2F1c2UgaW5jb3JyZWN0IHJlcUlkcyB0byBiZSB1c2VkXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZXFJZDtcbiAgICAgIH1cblxuICAgICAgLy8gcHJldmVudCBJRSBmcm9tIGNhY2hpbmcgcmVxdWVzdHNcbiAgICAgIHJlcS5zZXQoJ0lmLU1vZGlmaWVkLVNpbmNlJywgJ01vbiwgMjYgSnVsIDE5OTcgMDU6MDA6MDAgR01UJyk7XG5cbiAgICAgIGlmICghKHByb2Nlc3MgYXMgYW55KS5icm93c2VyICYmIHRoaXMuX3VzZXJBZ2VudCkge1xuICAgICAgICAvLyBJZiBub3QgaW4gdGhlIGJyb3dzZXIsIHNldCB0aGUgVXNlci1BZ2VudC4gQnJvd3NlcnMgZG9uJ3QgYWxsb3dcbiAgICAgICAgLy8gc2V0dGluZyBvZiBVc2VyLUFnZW50LCBzbyB3ZSBtdXN0IGRpc2FibGUgdGhpcyB3aGVuIHJ1biBpbiB0aGVcbiAgICAgICAgLy8gYnJvd3NlciAoYnJvd3NlcmlmeSBzZXRzIHByb2Nlc3MuYnJvd3NlcikuXG4gICAgICAgIHJlcS5zZXQoJ1VzZXItQWdlbnQnLCB0aGlzLl91c2VyQWdlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCB0byBqdXN0IGFib3ZlIDUgbWludXRlcyBieSBkZWZhdWx0XG4gICAgICByZXEudGltZW91dCgocHJvY2Vzcy5lbnYuQklUR09fVElNRU9VVCBhcyBhbnkpICogMTAwMCB8fCAzMDUgKiAxMDAwKTtcblxuICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gdG9rZW4sIGFuZCB3ZSdyZSBub3QgbG9nZ2VkIGluLCB0aGUgcmVxdWVzdCBjYW5ub3QgYmUgdjIgYXV0aGVudGljYXRlZFxuICAgICAgcmVxLmlzVjJBdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICAgIHJlcS5hdXRoZW50aWNhdGlvblRva2VuID0gdGhpcy5fdG9rZW47XG4gICAgICAvLyBzb21lIG9mIHRoZSBvbGRlciB0b2tlbnMgYXBwZWFyIHRvIGJlIG9ubHkgNDAgY2hhcmFjdGVycyBsb25nXG4gICAgICBpZiAoKHRoaXMuX3Rva2VuICYmIHRoaXMuX3Rva2VuLmxlbmd0aCAhPT0gNjcgJiYgdGhpcy5fdG9rZW4uaW5kZXhPZigndjJ4JykgIT09IDApIHx8IHJlcS5mb3JjZVYxQXV0aCkge1xuICAgICAgICAvLyB1c2UgdGhlIG9sZCBtZXRob2RcbiAgICAgICAgcmVxLmlzVjJBdXRoZW50aWNhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgcmVxLnNldCgnQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHRoaXMuX3Rva2VuKTtcbiAgICAgICAgZGVidWcoJ3NlbmRpbmcgdjEgJXMgcmVxdWVzdCB0byAlcyB3aXRoIHRva2VuICVzJywgbWV0aG9kLCB1cmwsIHRoaXMuX3Rva2VuPy5zdWJzdHIoMCwgOCkpO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxUaGVuKG9uZnVsZmlsbGVkKS5jYXRjaChvbnJlamVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgcmVxLnNldCgnQml0R28tQXV0aC1WZXJzaW9uJywgdGhpcy5fYXV0aFZlcnNpb24gPT09IDMgPyAnMy4wJyA6ICcyLjAnKTtcblxuICAgICAgaWYgKHRoaXMuX3Rva2VuKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBzZXJpYWxpemVSZXF1ZXN0RGF0YShyZXEpO1xuICAgICAgICBzZXRSZXF1ZXN0UXVlcnlTdHJpbmcocmVxKTtcblxuICAgICAgICBjb25zdCByZXF1ZXN0UHJvcGVydGllcyA9IHRoaXMuY2FsY3VsYXRlUmVxdWVzdEhlYWRlcnMoe1xuICAgICAgICAgIHVybDogcmVxLnVybCxcbiAgICAgICAgICB0b2tlbjogdGhpcy5fdG9rZW4sXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIHRleHQ6IGRhdGEgfHwgJycsXG4gICAgICAgIH0pO1xuICAgICAgICByZXEuc2V0KCdBdXRoLVRpbWVzdGFtcCcsIHJlcXVlc3RQcm9wZXJ0aWVzLnRpbWVzdGFtcC50b1N0cmluZygpKTtcblxuICAgICAgICAvLyB3ZSdyZSBub3Qgc2VuZGluZyB0aGUgYWN0dWFsIHRva2VuLCBidXQgb25seSBpdHMgaGFzaFxuICAgICAgICByZXEuc2V0KCdBdXRob3JpemF0aW9uJywgJ0JlYXJlciAnICsgcmVxdWVzdFByb3BlcnRpZXMudG9rZW5IYXNoKTtcbiAgICAgICAgZGVidWcoJ3NlbmRpbmcgdjIgJXMgcmVxdWVzdCB0byAlcyB3aXRoIHRva2VuICVzJywgbWV0aG9kLCB1cmwsIHRoaXMuX3Rva2VuPy5zdWJzdHIoMCwgOCkpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgSE1BQ1xuICAgICAgICByZXEuc2V0KCdITUFDJywgcmVxdWVzdFByb3BlcnRpZXMuaG1hYyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVmVyaWZ5IHRoZSByZXNwb25zZSBiZWZvcmUgY2FsbGluZyB0aGUgb3JpZ2luYWwgb25mdWxmaWxsZWQgaGFuZGxlcixcbiAgICAgICAqIGFuZCBtYWtlIHN1cmUgb25yZWplY3RlZCBpcyBjYWxsZWQgaWYgYSB2ZXJpZmljYXRpb24gZXJyb3IgaXMgZW5jb3VudGVyZWRcbiAgICAgICAqL1xuICAgICAgY29uc3QgbmV3T25GdWxmaWxsZWQgPSBvbmZ1bGZpbGxlZFxuICAgICAgICA/IChyZXNwb25zZTogc3VwZXJhZ2VudC5SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gSE1BQyB2ZXJpZmljYXRpb24gaXMgb25seSBhbGxvd2VkIHRvIGJlIHNraXBwZWQgaW4gY2VydGFpbiBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGNoZWNrZWQgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgY2hlY2tpbmcgaXQgYWdhaW4gYXQgcmVxdWVzdCB0aW1lXG4gICAgICAgICAgICAvLyB3aWxsIGhlbHAgcHJldmVudCBhZ2FpbnN0IHRhbXBlcmluZyBvZiB0aGlzIHByb3BlcnR5IGFmdGVyIHRoZSBvYmplY3QgaXMgY3JlYXRlZFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9obWFjVmVyaWZpY2F0aW9uICYmICFjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuZ2V0RW52KCldLmhtYWNWZXJpZmljYXRpb25FbmZvcmNlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gb25mdWxmaWxsZWQocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2ZXJpZmllZFJlc3BvbnNlID0gdmVyaWZ5UmVzcG9uc2UodGhpcywgdGhpcy5fdG9rZW4sIG1ldGhvZCwgcmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gb25mdWxmaWxsZWQodmVyaWZpZWRSZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICA6IG51bGw7XG4gICAgICByZXR1cm4gb3JpZ2luYWxUaGVuKG5ld09uRnVsZmlsbGVkKS5jYXRjaChvbnJlamVjdGVkKTtcbiAgICB9O1xuICAgIHJldHVybiB0b0JpdGdvUmVxdWVzdChyZXEpO1xuICB9XG5cbiAgZ2V0KHVybDogc3RyaW5nKTogQml0R29SZXF1ZXN0IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UGF0Y2goJ2dldCcsIHVybCk7XG4gIH1cbiAgcG9zdCh1cmw6IHN0cmluZyk6IEJpdEdvUmVxdWVzdCB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFBhdGNoKCdwb3N0JywgdXJsKTtcbiAgfVxuICBwdXQodXJsOiBzdHJpbmcpOiBCaXRHb1JlcXVlc3Qge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQYXRjaCgncHV0JywgdXJsKTtcbiAgfVxuICBkZWwodXJsOiBzdHJpbmcpOiBCaXRHb1JlcXVlc3Qge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQYXRjaCgnZGVsJywgdXJsKTtcbiAgfVxuICBwYXRjaCh1cmw6IHN0cmluZyk6IEJpdEdvUmVxdWVzdCB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFBhdGNoKCdwYXRjaCcsIHVybCk7XG4gIH1cbiAgb3B0aW9ucyh1cmw6IHN0cmluZyk6IEJpdEdvUmVxdWVzdCB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFBhdGNoKCdvcHRpb25zJywgdXJsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIEhNQUMgZm9yIHRoZSBnaXZlbiBrZXkgYW5kIG1lc3NhZ2VcbiAgICogQHBhcmFtIGtleSB7U3RyaW5nfSAtIHRoZSBrZXkgdG8gdXNlIGZvciB0aGUgSE1BQ1xuICAgKiBAcGFyYW0gbWVzc2FnZSB7U3RyaW5nfSAtIHRoZSBhY3R1YWwgbWVzc2FnZSB0byBITUFDXG4gICAqIEByZXR1cm5zIHsqfSAtIHRoZSByZXN1bHQgb2YgdGhlIEhNQUMgb3BlcmF0aW9uXG4gICAqL1xuICBjYWxjdWxhdGVITUFDKGtleTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc3ViamVjdCBzdHJpbmcgdGhhdCBpcyB0byBiZSBITUFDJ2VkIGZvciBhIEhUVFAgcmVxdWVzdCBvciByZXNwb25zZVxuICAgKiBAcGFyYW0gdXJsUGF0aCByZXF1ZXN0IHVybCwgaW5jbHVkaW5nIHF1ZXJ5IHBhcmFtc1xuICAgKiBAcGFyYW0gdGV4dCByZXF1ZXN0IGJvZHkgdGV4dFxuICAgKiBAcGFyYW0gdGltZXN0YW1wIHJlcXVlc3QgdGltZXN0YW1wIGZyb20gYERhdGUubm93KClgXG4gICAqIEBwYXJhbSBzdGF0dXNDb2RlIE9ubHkgc2V0IGZvciBIVFRQIHJlc3BvbnNlcywgbGVhdmUgYmxhbmsgZm9yIHJlcXVlc3RzXG4gICAqIEBwYXJhbSBtZXRob2QgcmVxdWVzdCBtZXRob2RcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNhbGN1bGF0ZUhNQUNTdWJqZWN0KHsgdXJsUGF0aCwgdGV4dCwgdGltZXN0YW1wLCBzdGF0dXNDb2RlLCBtZXRob2QgfTogQ2FsY3VsYXRlSG1hY1N1YmplY3RPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCB1cmxEZXRhaWxzID0gdXJsTGliLnBhcnNlKHVybFBhdGgpO1xuICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHVybERldGFpbHMucXVlcnkgJiYgdXJsRGV0YWlscy5xdWVyeS5sZW5ndGggPiAwID8gdXJsRGV0YWlscy5wYXRoIDogdXJsRGV0YWlscy5wYXRobmFtZTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3RhdHVzQ29kZSkgJiYgXy5pc0ludGVnZXIoc3RhdHVzQ29kZSkgJiYgXy5pc0Zpbml0ZShzdGF0dXNDb2RlKSkge1xuICAgICAgaWYgKHRoaXMuX2F1dGhWZXJzaW9uID09PSAzKSB7XG4gICAgICAgIHJldHVybiBbbWV0aG9kLnRvVXBwZXJDYXNlKCksIHRpbWVzdGFtcCwgcXVlcnlQYXRoLCBzdGF0dXNDb2RlLCB0ZXh0XS5qb2luKCd8Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3RpbWVzdGFtcCwgcXVlcnlQYXRoLCBzdGF0dXNDb2RlLCB0ZXh0XS5qb2luKCd8Jyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hdXRoVmVyc2lvbiA9PT0gMykge1xuICAgICAgcmV0dXJuIFttZXRob2QudG9VcHBlckNhc2UoKSwgdGltZXN0YW1wLCAnMy4wJywgcXVlcnlQYXRoLCB0ZXh0XS5qb2luKCd8Jyk7XG4gICAgfVxuICAgIHJldHVybiBbdGltZXN0YW1wLCBxdWVyeVBhdGgsIHRleHRdLmpvaW4oJ3wnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIEhNQUMgZm9yIGFuIEhUVFAgcmVxdWVzdFxuICAgKi9cbiAgY2FsY3VsYXRlUmVxdWVzdEhNQUMoeyB1cmw6IHVybFBhdGgsIHRleHQsIHRpbWVzdGFtcCwgdG9rZW4sIG1ldGhvZCB9OiBDYWxjdWxhdGVSZXF1ZXN0SG1hY09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IHNpZ25hdHVyZVN1YmplY3QgPSB0aGlzLmNhbGN1bGF0ZUhNQUNTdWJqZWN0KHsgdXJsUGF0aCwgdGV4dCwgdGltZXN0YW1wLCBtZXRob2QgfSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIEhNQUNcbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVITUFDKHRva2VuLCBzaWduYXR1cmVTdWJqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgcmVxdWVzdCBoZWFkZXJzIHdpdGggSE1BQ1xuICAgKi9cbiAgY2FsY3VsYXRlUmVxdWVzdEhlYWRlcnMoeyB1cmwsIHRleHQsIHRva2VuLCBtZXRob2QgfTogQ2FsY3VsYXRlUmVxdWVzdEhlYWRlcnNPcHRpb25zKTogUmVxdWVzdEhlYWRlcnMge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgaG1hYyA9IHRoaXMuY2FsY3VsYXRlUmVxdWVzdEhNQUMoeyB1cmwsIHRleHQsIHRpbWVzdGFtcCwgdG9rZW4sIG1ldGhvZCB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgU0hBMjU2IGhhc2ggb2YgdGhlIHRva2VuXG4gICAgY29uc3QgaGFzaERpZ2VzdCA9IHNqY2wuaGFzaC5zaGEyNTYuaGFzaCh0b2tlbik7XG4gICAgY29uc3QgdG9rZW5IYXNoID0gc2pjbC5jb2RlYy5oZXguZnJvbUJpdHMoaGFzaERpZ2VzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhtYWMsXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICB0b2tlbkhhc2gsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhlIEhNQUMgZm9yIGFuIEhUVFAgcmVzcG9uc2VcbiAgICovXG4gIHZlcmlmeVJlc3BvbnNlKHtcbiAgICB1cmw6IHVybFBhdGgsXG4gICAgc3RhdHVzQ29kZSxcbiAgICB0ZXh0LFxuICAgIHRpbWVzdGFtcCxcbiAgICB0b2tlbixcbiAgICBobWFjLFxuICAgIG1ldGhvZCxcbiAgfTogVmVyaWZ5UmVzcG9uc2VPcHRpb25zKTogVmVyaWZ5UmVzcG9uc2VJbmZvIHtcbiAgICBjb25zdCBzaWduYXR1cmVTdWJqZWN0ID0gdGhpcy5jYWxjdWxhdGVITUFDU3ViamVjdCh7XG4gICAgICB1cmxQYXRoLFxuICAgICAgdGV4dCxcbiAgICAgIHRpbWVzdGFtcCxcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICBtZXRob2QsXG4gICAgfSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIEhNQUNcbiAgICBjb25zdCBleHBlY3RlZEhtYWMgPSB0aGlzLmNhbGN1bGF0ZUhNQUModG9rZW4sIHNpZ25hdHVyZVN1YmplY3QpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGlmIHRoZSByZXNwb25zZSBpcyBzdGlsbCB3aXRoaW4gdGhlIHZhbGlkaXR5IHdpbmRvdyAoNSBtaW51dGUgd2luZG93KVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgaXNJblJlc3BvbnNlVmFsaWRpdHlXaW5kb3cgPSB0aW1lc3RhbXAgPj0gbm93IC0gMTAwMCAqIDYwICogNSAmJiB0aW1lc3RhbXAgPD0gbm93O1xuXG4gICAgLy8gdmVyaWZ5IHRoZSBITUFDIGFuZCB0aW1lc3RhbXBcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZXhwZWN0ZWRIbWFjID09PSBobWFjLFxuICAgICAgZXhwZWN0ZWRIbWFjLFxuICAgICAgc2lnbmF0dXJlU3ViamVjdCxcbiAgICAgIGlzSW5SZXNwb25zZVZhbGlkaXR5V2luZG93LFxuICAgICAgdmVyaWZpY2F0aW9uVGltZTogbm93LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdXNlZnVsIGNvbnN0YW50IHZhbHVlcyBmcm9tIHRoZSBCaXRHbyBzZXJ2ZXIuXG4gICAqIFRoZXNlIHZhbHVlcyBkbyBjaGFuZ2UgaW5mcmVxdWVudGx5LCBzbyB0aGV5IG5lZWQgdG8gYmUgZmV0Y2hlZCxcbiAgICogYnV0IGFyZSB1bmxpa2VseSB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZldGltZSBvZiBhIEJpdEdvIG9iamVjdCxcbiAgICogc28gdGhleSBjYW4gc2FmZWx5IGNhY2hlZC5cbiAgICovXG4gIGFzeW5jIGZldGNoQ29uc3RhbnRzKCk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgZW52ID0gdGhpcy5nZXRFbnYoKTtcblxuICAgIGlmICghQml0R29BUEkuX2NvbnN0YW50cykge1xuICAgICAgQml0R29BUEkuX2NvbnN0YW50cyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIUJpdEdvQVBJLl9jb25zdGFudHNFeHBpcmUpIHtcbiAgICAgIEJpdEdvQVBJLl9jb25zdGFudHNFeHBpcmUgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoQml0R29BUEkuX2NvbnN0YW50c1tlbnZdICYmIEJpdEdvQVBJLl9jb25zdGFudHNFeHBpcmVbZW52XSAmJiBuZXcgRGF0ZSgpIDwgQml0R29BUEkuX2NvbnN0YW50c0V4cGlyZVtlbnZdKSB7XG4gICAgICByZXR1cm4gQml0R29BUEkuX2NvbnN0YW50c1tlbnZdO1xuICAgIH1cblxuICAgIC8vIGNsaWVudCBjb25zdGFudHMgY2FsbCBjYW5ub3QgYmUgYXV0aGVudGljYXRlZCB1c2luZyB0aGUgbm9ybWFsIEhNQUMgdmFsaWRhdGlvblxuICAgIC8vIHNjaGVtZSwgc28gd2UgbmVlZCB0byB1c2UgYSByYXcgc3VwZXJhZ2VudCBpbnN0YW5jZSB0byBkbyB0aGlzIHJlcXVlc3QuXG4gICAgLy8gUHJveHkgc2V0dGluZ3MgbXVzdCBzdGlsbCBiZSByZXNwZWN0ZWQgaG93ZXZlclxuICAgIGNvbnN0IHJlc3VsdFByb21pc2UgPSB0aGlzLmdldEFnZW50UmVxdWVzdCgnZ2V0JywgdGhpcy51cmwoJy9jbGllbnQvY29uc3RhbnRzJykpO1xuICAgIHJlc3VsdFByb21pc2Uuc2V0KCdCaXRHby1TREstVmVyc2lvbicsIHRoaXMuX3ZlcnNpb24pO1xuICAgIGlmICh0aGlzLl9wcm94eSAmJiBlbmFibGVQcm94eUFnZW50KSB7XG4gICAgICBjb25zdCBwcm94eVVybDogc3RyaW5nID0gdGhpcy5fcHJveHk7XG4gICAgICBjb25zdCBhZ2VudCA9IG5ldyBwcm94eUFnZW50TW9kdWxlLlByb3h5QWdlbnQoe1xuICAgICAgICBnZXRQcm94eUZvclVybDogKCkgPT4gcHJveHlVcmwsXG4gICAgICB9KTtcbiAgICAgIGlmIChhZ2VudCkge1xuICAgICAgICByZXN1bHRQcm9taXNlLmFnZW50KGFnZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzdWx0UHJvbWlzZTtcbiAgICBCaXRHb0FQSS5fY29uc3RhbnRzW2Vudl0gPSByZXN1bHQuYm9keS5jb25zdGFudHM7XG5cbiAgICBpZiAocmVzdWx0LmJvZHk/LnR0bCAmJiB0eXBlb2YgcmVzdWx0LmJvZHk/LnR0bCA9PT0gJ251bWJlcicpIHtcbiAgICAgIEJpdEdvQVBJLl9jb25zdGFudHNFeHBpcmVbZW52XSA9IG5ldyBEYXRlKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgKHJlc3VsdC5ib2R5LnR0bCBhcyBudW1iZXIpICogMTAwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJpdEdvQVBJLl9jb25zdGFudHNbZW52XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB1cmwgZm9yIGNhbGxpbmcgQml0R28gcGxhdGZvcm0gQVBJc1xuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gdmVyc2lvblxuICAgKi9cbiAgdXJsKHBhdGg6IHN0cmluZywgdmVyc2lvbiA9IDEpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJhc2VVcmwgPSB2ZXJzaW9uID09PSAyID8gdGhpcy5fYmFzZUFwaVVybFYyIDogdGhpcy5fYmFzZUFwaVVybDtcbiAgICByZXR1cm4gYmFzZVVybCArIHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdXJsIGZvciBjYWxsaW5nIEJpdEdvIG1pY3Jvc2VydmljZSBBUElzXG4gICAqL1xuICBtaWNyb3NlcnZpY2VzVXJsKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VVcmwgKyBwYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZlcnNpb24gb2YgdGhlIEJpdEdvSlMgcGFja2FnZVxuICAgKi9cbiAgdmVyc2lvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgY29ubmVjdGl2aXR5IHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgcGluZyh7IHJlcUlkIH06IFBpbmdPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGlmIChyZXFJZCkge1xuICAgICAgdGhpcy5fcmVxSWQgPSByZXFJZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9waW5nJykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIHJlcXVlc3QgdHJhY2VyIHRvIHByb3ZpZGUgcmVxdWVzdCBJRHMgZHVyaW5nIG11bHRpLXJlcXVlc3Qgd29ya2Zsb3dzXG4gICAqL1xuICBzZXRSZXF1ZXN0VHJhY2VyKHJlcVRyYWNlcjogSVJlcXVlc3RUcmFjZXIpOiB2b2lkIHtcbiAgICBpZiAocmVxVHJhY2VyKSB7XG4gICAgICB0aGlzLl9yZXFJZCA9IHJlcVRyYWNlcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBlbmNyeXB0IGxvY2FsbHkuXG4gICAqL1xuICBlbmNyeXB0KHBhcmFtczogRW5jcnlwdE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaW5wdXQnLCAncGFzc3dvcmQnXSwgWydhZGF0YSddKTtcbiAgICBpZiAoIXBhcmFtcy5wYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZW5jcnlwdCB3aXRob3V0IHBhc3N3b3JkYCk7XG4gICAgfVxuICAgIHJldHVybiBlbmNyeXB0KHBhcmFtcy5wYXNzd29yZCwgcGFyYW1zLmlucHV0LCB7IGFkYXRhOiBwYXJhbXMuYWRhdGEgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdCBhbiBlbmNyeXB0ZWQgc3RyaW5nIGxvY2FsbHkuXG4gICAqL1xuICBkZWNyeXB0KHBhcmFtczogRGVjcnlwdE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lucHV0JywgJ3Bhc3N3b3JkJ10sIFtdKTtcbiAgICBpZiAoIXBhcmFtcy5wYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjcnlwdCB3aXRob3V0IHBhc3N3b3JkYCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZGVjcnlwdChwYXJhbXMucGFzc3dvcmQsIHBhcmFtcy5pbnB1dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiY2NtOiB0YWcgZG9lc24ndCBtYXRjaFwiKSkge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gJ3Bhc3N3b3JkIGVycm9yIC0gJyArIGVycm9yLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoaXMgQml0R28gb2JqZWN0IHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIENhdXRpb246IGNvbnRhaW5zIHNlbnNpdGl2ZSBkYXRhXG4gICAqL1xuICB0b0pTT04oKTogQml0R29Kc29uIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlcjogdGhpcy5fdXNlcixcbiAgICAgIHRva2VuOiB0aGlzLl90b2tlbixcbiAgICAgIGV4dGVuc2lvbktleTogdGhpcy5fZXh0ZW5zaW9uS2V5ID8gdGhpcy5fZXh0ZW5zaW9uS2V5LnRvV0lGKCkgOiB1bmRlZmluZWQsXG4gICAgICBlY2RoWHBydjogdGhpcy5fZWNkaFhwcnYsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdXNlclxuICAgKi9cbiAgdXNlcigpOiBVc2VyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIEpTT04gc2VyaWFsaXplZCBCaXRHbyBvYmplY3QuXG4gICAqXG4gICAqIE92ZXJ3cml0ZXMgdGhlIHByb3BlcnRpZXMgb24gdGhlIGN1cnJlbnQgQml0R28gb2JqZWN0IHdpdGhcbiAgICogdGhvc2Ugb2YgdGhlIGRlc2VyaWFsemVkIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIGpzb25cbiAgICovXG4gIGZyb21KU09OKGpzb246IEJpdEdvSnNvbik6IHZvaWQge1xuICAgIHRoaXMuX3VzZXIgPSBqc29uLnVzZXI7XG4gICAgdGhpcy5fdG9rZW4gPSBqc29uLnRva2VuO1xuICAgIHRoaXMuX2VjZGhYcHJ2ID0ganNvbi5lY2RoWHBydjtcbiAgICBpZiAoanNvbi5leHRlbnNpb25LZXkpIHtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuZ2V0RW52KCldLm5ldHdvcms7XG4gICAgICB0aGlzLl9leHRlbnNpb25LZXkgPSB1dHhvbGliLkVDUGFpci5mcm9tV0lGKFxuICAgICAgICBqc29uLmV4dGVuc2lvbktleSxcbiAgICAgICAgdXR4b2xpYi5uZXR3b3Jrc1tuZXR3b3JrXSBhcyB1dHhvbGliLkJpdGNvaW5KU05ldHdvcmtcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIHVzZXJuYW1lLCBwYXNzd29yZCBhbmQgb3RwIGludG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVzZXJuYW1lIGFuZCBoYXNoZWQgcGFzc3dvcmQsIHJlYWR5IHRvXG4gICAqIHNlbmQgdG8gYml0Z28gZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgKi9cbiAgcHJlcHJvY2Vzc0F1dGhlbnRpY2F0aW9uUGFyYW1zKHtcbiAgICB1c2VybmFtZSxcbiAgICBwYXNzd29yZCxcbiAgICBvdHAsXG4gICAgZm9yY2VTTVMsXG4gICAgZXh0ZW5zaWJsZSxcbiAgICB0cnVzdCxcbiAgICBmb3JSZXNldDJGQSxcbiAgfTogQXV0aGVudGljYXRlT3B0aW9ucyk6IFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHVzZXJuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgdXNlcm5hbWUnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvd2VyTmFtZSA9IHVzZXJuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwYXNzd29yZCBITUFDIHNvIHdlIGRvbid0IHNlbmQgY2xlYXItdGV4dCBwYXNzd29yZHNcbiAgICBjb25zdCBobWFjUGFzc3dvcmQgPSB0aGlzLmNhbGN1bGF0ZUhNQUMobG93ZXJOYW1lLCBwYXNzd29yZCk7XG5cbiAgICBjb25zdCBhdXRoUGFyYW1zOiBQcm9jZXNzZWRBdXRoZW50aWNhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBlbWFpbDogbG93ZXJOYW1lLFxuICAgICAgcGFzc3dvcmQ6IGhtYWNQYXNzd29yZCxcbiAgICAgIGZvcmNlU01TOiAhIWZvcmNlU01TLFxuICAgIH07XG5cbiAgICBpZiAob3RwKSB7XG4gICAgICBhdXRoUGFyYW1zLm90cCA9IG90cDtcbiAgICAgIGlmICh0cnVzdCkge1xuICAgICAgICBhdXRoUGFyYW1zLnRydXN0ID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaWJsZSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uS2V5ID0gbWFrZVJhbmRvbUtleSgpO1xuICAgICAgYXV0aFBhcmFtcy5leHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgIGF1dGhQYXJhbXMuZXh0ZW5zaW9uQWRkcmVzcyA9IGdldEFkZHJlc3NQMlBLSCh0aGlzLl9leHRlbnNpb25LZXkpO1xuICAgIH1cblxuICAgIGlmIChmb3JSZXNldDJGQSkge1xuICAgICAgYXV0aFBhcmFtcy5mb3JSZXNldDJGQSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1dGhQYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgbWV0aG9kIGZvciBhY3RpdmF0aW5nIGFuIGFjY2VzcyB0b2tlbi5cbiAgICovXG4gIGF1dGhlbnRpY2F0ZVdpdGhBY2Nlc3NUb2tlbih7IGFjY2Vzc1Rva2VuIH06IEFjY2Vzc1Rva2VuT3B0aW9ucyk6IHZvaWQge1xuICAgIGRlYnVnKCdub3cgYXV0aGVudGljYXRpbmcgd2l0aCBhY2Nlc3MgdG9rZW4gJXMnLCBhY2Nlc3NUb2tlbi5zdWJzdHJpbmcoMCwgOCkpO1xuICAgIHRoaXMuX3Rva2VuID0gYWNjZXNzVG9rZW47XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBFQ0RIIGtleWNoYWluIGZvciB0aGUgdXNlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvZ2luUGFzc3dvcmQgLSBUaGUgdXNlcidzIGxvZ2luIHBhc3N3b3JkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG5ldyBFQ0RIIGtleWNoYWluIGRhdGEuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBpcyBhbiBpc3N1ZSBjcmVhdGluZyB0aGUga2V5Y2hhaW4uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY3JlYXRlVXNlckVjZGhLZXljaGFpbihsb2dpblBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IGtleURhdGEgPSB0aGlzLmtleWNoYWlucygpLmNyZWF0ZSgpO1xuICAgIGNvbnN0IGhkTm9kZSA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgoa2V5RGF0YS54cHJ2KTtcblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgbmV3IEVDREgga2V5Y2hhaW4gdG8gdGhlIHVzZXIncyBhY2NvdW50LlxuICAgICAqIEB0eXBlIHtQcm9taXNlPGFueT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbmV3IEVDREgga2V5Y2hhaW4uXG4gICAgICovXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMua2V5Y2hhaW5zKCkuYWRkKHtcbiAgICAgIHNvdXJjZTogJ2VjZGgnLFxuICAgICAgeHB1YjogaGROb2RlLm5ldXRlcmVkKCkudG9CYXNlNTgoKSxcbiAgICAgIGVuY3J5cHRlZFhwcnY6IHRoaXMuZW5jcnlwdCh7XG4gICAgICAgIHBhc3N3b3JkOiBsb2dpblBhc3N3b3JkLFxuICAgICAgICBpbnB1dDogaGROb2RlLnRvQmFzZTU4KCksXG4gICAgICB9KSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB1c2VyJ3Mgc2V0dGluZ3Mgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIHVwZGF0ZSB0aGUgdXNlcidzIHNldHRpbmdzIHdpdGguXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBpcyBhbiBpc3N1ZSB1cGRhdGluZyB0aGUgdXNlcidzIHNldHRpbmdzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB1cGRhdGVVc2VyU2V0dGluZ3MocGFyYW1zOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnB1dCh0aGlzLnVybCgnL3VzZXIvc2V0dGluZ3MnLCAyKSkuc2VuZChwYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCB0aGUgdXNlcidzIEVDREgga2V5Y2hhaW4gaXMgY3JlYXRlZCBmb3Igd2FsbGV0IHNoYXJpbmcgYW5kIFRTUyB3YWxsZXRzLlxuICAgKiBJZiB0aGUga2V5Y2hhaW4gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlIHVzZXIncyBzZXR0aW5ncyB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2dpblBhc3N3b3JkIC0gVGhlIHVzZXIncyBsb2dpbiBwYXNzd29yZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB1c2VyJ3Mgc2V0dGluZ3MgZW5zdXJpbmcgd2UgaGF2ZSB0aGUgZWNkaEtleWNoYWluIGluIHRoZXJlLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgaXMgYW4gaXNzdWUgY3JlYXRpbmcgdGhlIGtleWNoYWluIG9yIHVwZGF0aW5nIHRoZSB1c2VyJ3Mgc2V0dGluZ3MuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGVuc3VyZVVzZXJFY2RoS2V5Y2hhaW5Jc0NyZWF0ZWQobG9naW5QYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVzZXIncyBjdXJyZW50IHNldHRpbmdzLlxuICAgICAqL1xuICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IGF3YWl0IHRoaXMuZ2V0KHRoaXMudXJsKCcvdXNlci9zZXR0aW5ncycpKS5yZXN1bHQoKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXNlcidzIEVDREgga2V5Y2hhaW4gZG9lcyBub3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBrZXljaGFpbiBhbmQgdXBkYXRlIHRoZSB1c2VyJ3Mgc2V0dGluZ3MuXG4gICAgICovXG4gICAgaWYgKCF1c2VyU2V0dGluZ3Muc2V0dGluZ3MuZWNkaEtleWNoYWluKSB7XG4gICAgICBjb25zdCBuZXdLZXljaGFpbiA9IGF3YWl0IHRoaXMuY3JlYXRlVXNlckVjZGhLZXljaGFpbihsb2dpblBhc3N3b3JkKTtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlVXNlclNldHRpbmdzKHtcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBlY2RoS2V5Y2hhaW46IG5ld0tleWNoYWluLnhwdWIsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIHRoZSB1c2VyJ3Mgc2V0dGluZ3Mgb2JqZWN0IHdpdGggdGhlIG5ldyBFQ0RIIGtleWNoYWluLlxuICAgICAgICovXG4gICAgICB1c2VyU2V0dGluZ3Muc2V0dGluZ3MuZWNkaEtleWNoYWluID0gbmV3S2V5Y2hhaW4ueHB1YjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB1c2VyJ3MgRUNESCBrZXljaGFpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICByZXR1cm4gdXNlclNldHRpbmdzLnNldHRpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ2luIHRvIHRoZSBiaXRnbyBwbGF0Zm9ybS5cbiAgICovXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZShwYXJhbXM6IEF1dGhlbnRpY2F0ZU9wdGlvbnMpOiBQcm9taXNlPExvZ2luUmVzcG9uc2UgfCBhbnk+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBvYmplY3QgcGFyYW1zJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucGFzc3dvcmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIHBhc3N3b3JkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcmNlVjFBdXRoID0gISFwYXJhbXMuZm9yY2VWMUF1dGg7XG4gICAgICBjb25zdCBhdXRoUGFyYW1zID0gdGhpcy5wcmVwcm9jZXNzQXV0aGVudGljYXRpb25QYXJhbXMocGFyYW1zKTtcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gcGFyYW1zLnBhc3N3b3JkO1xuXG4gICAgICBpZiAodGhpcy5fdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignYWxyZWFkeSBsb2dnZWQgaW4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXV0aFVybCA9IHRoaXMubWljcm9zZXJ2aWNlc1VybCgnL2FwaS9hdXRoL3YxL3Nlc3Npb24nKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnBvc3QoYXV0aFVybCk7XG5cbiAgICAgIGlmIChmb3JjZVYxQXV0aCkge1xuICAgICAgICByZXF1ZXN0LmZvcmNlVjFBdXRoID0gdHJ1ZTtcbiAgICAgICAgLy8gdGVsbCB0aGUgc2VydmVyIHRoYXQgdGhlIGNsaWVudCB3YXMgZm9yY2VkIHRvIGRvd25ncmFkZSB0aGUgYXV0aGVudGljYXRpb24gcHJvdG9jb2xcbiAgICAgICAgYXV0aFBhcmFtcy5mb3JjZVYxQXV0aCA9IHRydWU7XG4gICAgICAgIGRlYnVnKCdmb3JjaW5nIHYxIGF1dGggZm9yIGNhbGwgdG8gYXV0aGVudGljYXRlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZTogc3VwZXJhZ2VudC5SZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Quc2VuZChhdXRoUGFyYW1zKTtcbiAgICAgIC8vIGV4dHJhY3QgYm9keSBhbmQgdXNlciBpbmZvcm1hdGlvblxuICAgICAgY29uc3QgYm9keSA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICB0aGlzLl91c2VyID0gYm9keS51c2VyO1xuXG4gICAgICBpZiAoYm9keS5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgdGhpcy5fdG9rZW4gPSBib2R5LmFjY2Vzc190b2tlbjtcbiAgICAgICAgLy8gaWYgdGhlIGRvd25ncmFkZSB3YXMgZm9yY2VkLCBhZGRpbmcgYSB3YXJuaW5nIG1lc3NhZ2UgbWlnaHQgYmUgcHJ1ZGVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIGFuIGVuY3J5cHRlZCBFQ0RIIHhwcnZcbiAgICAgICAgLy8gaWYgbm90IHByZXNlbnQsIGxlZ2FjeSBhY2NvdW50XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZFhwcnYgPSBib2R5LmVuY3J5cHRlZEVDREhYcHJ2O1xuICAgICAgICBpZiAoIWVuY3J5cHRlZFhwcnYpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleWNoYWluIG5lZWRzIGVuY3J5cHRlZFhwcnYgcHJvcGVydHknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGV0YWlscyA9IHRoaXMuaGFuZGxlVG9rZW5Jc3N1YW5jZShyZXNwb25zZS5ib2R5LCBwYXNzd29yZCk7XG4gICAgICAgIHRoaXMuX3Rva2VuID0gcmVzcG9uc2VEZXRhaWxzLnRva2VuO1xuICAgICAgICB0aGlzLl9lY2RoWHBydiA9IHJlc3BvbnNlRGV0YWlscy5lY2RoWHBydjtcblxuICAgICAgICAvLyB2ZXJpZnkgdGhlIHJlc3BvbnNlJ3MgYXV0aGVudGljaXR5XG4gICAgICAgIHZlcmlmeVJlc3BvbnNlKHRoaXMsIHJlc3BvbnNlRGV0YWlscy50b2tlbiwgJ3Bvc3QnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSByZW1haW5pbmcgY29tcG9uZW50IGZvciBlYXNpZXIgYWNjZXNzXG4gICAgICAgIHJlc3BvbnNlLmJvZHkuYWNjZXNzX3Rva2VuID0gdGhpcy5fdG9rZW47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IHBhcmFtcy5lbnN1cmVFY2RoS2V5Y2hhaW4gPyBhd2FpdCB0aGlzLmVuc3VyZVVzZXJFY2RoS2V5Y2hhaW5Jc0NyZWF0ZWQocGFzc3dvcmQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHVzZXJTZXR0aW5ncz8uZWNkaEtleWNoYWluKSB7XG4gICAgICAgIHJlc3BvbnNlLmJvZHkudXNlci5lY2RoS2V5Y2hhaW4gPSB1c2VyU2V0dGluZ3MuZWNkaEtleWNoYWluO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFuZGxlUmVzcG9uc2VSZXN1bHQ8TG9naW5SZXNwb25zZT4oKShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlUmVzcG9uc2VFcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHJlc3BvbnNlQm9keSBSZXNwb25zZSBib2R5IG9iamVjdFxuICAgKiBAcGFyYW0gcGFzc3dvcmQgUGFzc3dvcmQgZm9yIHRoZSBzeW1tZXRyaWMgZGVjcnlwdGlvblxuICAgKi9cbiAgaGFuZGxlVG9rZW5Jc3N1YW5jZShyZXNwb25zZUJvZHk6IFRva2VuSXNzdWFuY2VSZXNwb25zZSwgcGFzc3dvcmQ/OiBzdHJpbmcpOiBUb2tlbklzc3VhbmNlIHtcbiAgICAvLyBtYWtlIHN1cmUgdGhlIHJlc3BvbnNlIGJvZHkgY29udGFpbnMgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHJlc3BvbnNlQm9keSwgWydkZXJpdmF0aW9uUGF0aCddLCBbJ2VuY3J5cHRlZEVDREhYcHJ2J10pO1xuXG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSB0aGlzLl9lbnY7XG4gICAgY29uc3QgZW52aXJvbm1lbnRDb25maWcgPSBjb21tb24uRW52aXJvbm1lbnRzW2Vudmlyb25tZW50XTtcbiAgICBjb25zdCBzZXJ2ZXJYcHViID0gZW52aXJvbm1lbnRDb25maWcuc2VydmVyWHB1YjtcbiAgICBsZXQgZWNkaFhwcnYgPSB0aGlzLl9lY2RoWHBydjtcbiAgICBpZiAoIWVjZGhYcHJ2KSB7XG4gICAgICBpZiAoIXBhc3N3b3JkIHx8ICFyZXNwb25zZUJvZHkuZW5jcnlwdGVkRUNESFhwcnYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlY2RoWHBydiBwcm9wZXJ0eSBtdXN0IGJlIHNldCBvciBwYXNzd29yZCBhbmQgZW5jcnlwdGVkIGVuY3J5cHRlZEVDREhYcHJ2IG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGVjZGhYcHJ2ID0gdGhpcy5kZWNyeXB0KHtcbiAgICAgICAgICBpbnB1dDogcmVzcG9uc2VCb2R5LmVuY3J5cHRlZEVDREhYcHJ2LFxuICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGUuZXJyb3JDb2RlID0gJ2VjZGhfeHBydl9kZWNyeXB0aW9uX2ZhaWx1cmUnO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCBlbmNyeXB0ZWRFQ0RIWHBydi4nKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3QgSEROb2RlIG9iamVjdHMgZm9yIGNsaWVudCdzIHhwcnYgYW5kIHNlcnZlcidzIHhwdWJcbiAgICBjb25zdCBjbGllbnRIRE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KGVjZGhYcHJ2KTtcbiAgICBjb25zdCBzZXJ2ZXJIRE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KHNlcnZlclhwdWIpO1xuXG4gICAgLy8gQklQMzIgZGVyaXZhdGlvbiBwYXRoIGlzIGFwcGxpZWQgdG8gYm90aCBjbGllbnQgYW5kIHNlcnZlciBtYXN0ZXIga2V5c1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gc2FuaXRpemVMZWdhY3lQYXRoKHJlc3BvbnNlQm9keS5kZXJpdmF0aW9uUGF0aCk7XG4gICAgY29uc3QgY2xpZW50RGVyaXZlZE5vZGUgPSBjbGllbnRIRE5vZGUuZGVyaXZlUGF0aChkZXJpdmF0aW9uUGF0aCk7XG4gICAgY29uc3Qgc2VydmVyRGVyaXZlZE5vZGUgPSBzZXJ2ZXJIRE5vZGUuZGVyaXZlUGF0aChkZXJpdmF0aW9uUGF0aCk7XG5cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzZXJ2ZXJEZXJpdmVkTm9kZS5wdWJsaWNLZXk7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gY2xpZW50RGVyaXZlZE5vZGUucHJpdmF0ZUtleTtcbiAgICBpZiAoIXNlY3JldEtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBjbGllbnQgcHJpdmF0ZSBLZXknKTtcbiAgICB9XG4gICAgY29uc3Qgc2VjcmV0ID0gQnVmZmVyLmZyb20oXG4gICAgICAvLyBGSVhNRShCRy0zNDM4Nik6IHdlIHNob3VsZCB1c2UgYHNlY3AyNTZrMS5lY2RoKClgIGluIHRoZSBmdXR1cmVcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgc2VlIGRpc2N1c3Npb24gaGVyZSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi1jb3JlL3NlY3AyNTZrMS9pc3N1ZXMvMzUyXG4gICAgICBzZWNwMjU2azEucHVibGljS2V5VHdlYWtNdWwocHVibGljS2V5LCBzZWNyZXRLZXkpXG4gICAgKS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICAvLyBkZWNyeXB0IHRva2VuIHdpdGggc3ltbWV0cmljIEVDREgga2V5XG4gICAgbGV0IHJlc3BvbnNlOiBUb2tlbklzc3VhbmNlO1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgdG9rZW46IHRoaXMuZGVjcnlwdCh7XG4gICAgICAgICAgaW5wdXQ6IHJlc3BvbnNlQm9keS5lbmNyeXB0ZWRUb2tlbixcbiAgICAgICAgICBwYXNzd29yZDogc2VjcmV0LFxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5lcnJvckNvZGUgPSAndG9rZW5fZGVjcnlwdGlvbl9mYWlsdXJlJztcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IHRva2VuLicpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9lY2RoWHBydikge1xuICAgICAgcmVzcG9uc2UuZWNkaFhwcnYgPSBlY2RoWHBydjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG4gICAqL1xuICB2ZXJpZnlQYXNzd29yZChwYXJhbXM6IFZlcmlmeVBhc3N3b3JkT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnBhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdXNlciB8fCAhdGhpcy5fdXNlci51c2VybmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBjdXJyZW50IHVzZXInKTtcbiAgICB9XG4gICAgY29uc3QgaG1hY1Bhc3N3b3JkID0gdGhpcy5jYWxjdWxhdGVITUFDKHRoaXMuX3VzZXIudXNlcm5hbWUsIHBhcmFtcy5wYXNzd29yZCk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci92ZXJpZnlwYXNzd29yZCcpKS5zZW5kKHsgcGFzc3dvcmQ6IGhtYWNQYXNzd29yZCB9KS5yZXN1bHQoJ3ZhbGlkJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgb3V0IGFsbCBzdGF0ZSBmcm9tIHRoaXMgQml0R28gb2JqZWN0LCBlZmZlY3RpdmVseSBsb2dnaW5nIG91dCB0aGUgY3VycmVudCB1c2VyLlxuICAgKi9cbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgLy8gVE9ETzogYXJlIHRoZXJlIGFueSBvdGhlciBmaWVsZHMgd2hpY2ggc2hvdWxkIGJlIGNsZWFyZWQ/XG4gICAgdGhpcy5fdXNlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b2tlbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZWNkaFhwcnYgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHJlZnJlc2ggdG9rZW4gdG8gZ2V0IG5ldyBhY2Nlc3MgdG9rZW4uXG4gICAqIElmIHRoZSByZWZyZXNoIHRva2VuIGlzIG51bGwvZGVmaW5lZCwgdGhlbiB3ZSB1c2UgdGhlIHN0b3JlZCB0b2tlbiBmcm9tIGF1dGhcbiAgICovXG4gIGFzeW5jIHJlZnJlc2hUb2tlbihwYXJhbXM6IHsgcmVmcmVzaFRva2VuPzogc3RyaW5nIH0gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsncmVmcmVzaFRva2VuJ10pO1xuXG4gICAgY29uc3QgcmVmcmVzaFRva2VuID0gcGFyYW1zLnJlZnJlc2hUb2tlbiB8fCB0aGlzLl9yZWZyZXNoVG9rZW47XG5cbiAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgcmVmcmVzaCB0b2tlbiBvciBoYXZlIGF1dGhlbnRpY2F0ZWQgd2l0aCBPYXV0aCBiZWZvcmUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2NsaWVudElkIHx8ICF0aGlzLl9jbGllbnRTZWNyZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBjbGllbnQgaWQgYW5kIHNlY3JldCBzZXQgZmlyc3QgdG8gdXNlIHRoaXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gYXdhaXQgdGhpcy5wb3N0KHRoaXMuX2Jhc2VVcmwgKyAnL29hdXRoL3Rva2VuJylcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4sXG4gICAgICAgIGNsaWVudF9pZDogdGhpcy5fY2xpZW50SWQsXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuX2NsaWVudFNlY3JldCxcbiAgICAgIH0pXG4gICAgICAucmVzdWx0KCk7XG4gICAgdGhpcy5fdG9rZW4gPSBib2R5LmFjY2Vzc190b2tlbjtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBib2R5LnJlZnJlc2hfdG9rZW47XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogbGlzdEFjY2Vzc1Rva2Vuc1xuICAgKiBHZXQgaW5mb3JtYXRpb24gb24gYWxsIG9mIHRoZSBCaXRHbyBhY2Nlc3MgdG9rZW5zIG9uIHRoZSB1c2VyXG4gICAqIEByZXR1cm4ge1xuICAgKiAgaWQ6IDxpZCBvZiB0aGUgdG9rZW4+XG4gICAqICBsYWJlbDogPHRoZSB1c2VyLXByb3ZpZGVkIGxhYmVsIGZvciB0aGlzIHRva2VuPlxuICAgKiAgdXNlcjogPGlkIG9mIHRoZSB1c2VyIG9uIHRoZSB0b2tlbj5cbiAgICogIGVudGVycHJpc2UgPGlkIG9mIHRoZSBlbnRlcnByaXNlIHRoaXMgdG9rZW4gaXMgdmFsaWQgZm9yPlxuICAgKiAgY2xpZW50OiA8dGhlIGF1dGggY2xpZW50IHRoYXQgdGhpcyB0b2tlbiBiZWxvbmdzIHRvPlxuICAgKiAgc2NvcGU6IDxsaXN0IG9mIGFsbG93ZWQgT0F1dGggc2NvcGUgdmFsdWVzPlxuICAgKiAgY3JlYXRlZDogPGRhdGUgdGhlIHRva2VuIHdhcyBjcmVhdGVkPlxuICAgKiAgZXhwaXJlczogPGRhdGUgdGhlIHRva2VuIHdpbGwgZXhwaXJlPlxuICAgKiAgb3JpZ2luOiA8dGhlIG9yaWdpbiBmb3Igd2hpY2ggdGhpcyB0b2tlbiBpcyB2YWxpZD5cbiAgICogIGlzRXh0ZW5zaWJsZTogPGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgdG9rZW4gY2FuIGJlIGV4dGVuZGVkPlxuICAgKiAgZXh0ZW5zaW9uQWRkcmVzczogPGFkZHJlc3Mgd2hvc2UgcHJpdmF0ZSBrZXkncyBzaWduYXR1cmUgaXMgbmVjZXNzYXJ5IGZvciBleHRlbnNpb25zPlxuICAgKiAgdW5sb2NrOiA8aW5mbyBmb3IgYWN0aW9ucyB0aGF0IHJlcXVpcmUgYW4gdW5sb2NrIGJlZm9yZSBmaXJpbmc+XG4gICAqIH1cbiAgICovXG4gIGFzeW5jIGxpc3RBY2Nlc3NUb2tlbnMoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy91c2VyL2FjY2Vzc3Rva2VuJykpLnNlbmQoKS5yZXN1bHQoJ2FjY2Vzc1Rva2VucycpO1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZEFjY2Vzc1Rva2VuXG4gICAqIEFkZCBhIEJpdEdvIEFQSSBBY2Nlc3MgVG9rZW4gdG8gdGhlIGN1cnJlbnQgdXNlciBhY2NvdW50XG4gICAqIEBwYXJhbSBwYXJhbXMge1xuICAgKiAgICBvdHA6IChyZXF1aXJlZCkgPHZhbGlkIG90cCBjb2RlPlxuICAgKiAgICBsYWJlbDogKHJlcXVpcmVkKSA8bGFiZWwgZm9yIHRoZSB0b2tlbj5cbiAgICogICAgZHVyYXRpb246IDxsZW5ndGggb2YgdGltZSBpbiBzZWNvbmRzIHRoZSB0b2tlbiB3aWxsIGJlIHZhbGlkIGZvcj5cbiAgICogICAgaXBSZXN0cmljdDogPGFycmF5IG9mIElQIGFkZHJlc3Mgc3RyaW5ncyB0byB3aGl0ZWxpc3Q+XG4gICAqICAgIHR4VmFsdWVMaW1pdDogPG51bWJlciBvZiBvdXRnb2luZyBzYXRvc2hpcyBhbGxvd2VkIG9uIHRoaXMgdG9rZW4+XG4gICAqICAgIHNjb3BlOiAocmVxdWlyZWQpIDxhdXRob3JpemF0aW9uIHNjb3BlIG9mIHRoZSByZXF1ZXN0ZWQgdG9rZW4+XG4gICAqIH1cbiAgICogQHJldHVybiB7XG4gICAqICAgIGlkOiA8aWQgb2YgdGhlIHRva2VuPlxuICAgKiAgICB0b2tlbjogPGFjY2VzcyB0b2tlbiBoZXggc3RyaW5nIHRvIGJlIHVzZWQgZm9yIEJpdEdvIEFQSSByZXF1ZXN0IHZlcmlmaWNhdGlvbj5cbiAgICogICAgbGFiZWw6IDx1c2VyLXByb3ZpZGVkIGxhYmVsIGZvciB0aGlzIHRva2VuPlxuICAgKiAgICB1c2VyOiA8aWQgb2YgdGhlIHVzZXIgb24gdGhlIHRva2VuPlxuICAgKiAgICBlbnRlcnByaXNlIDxpZCBvZiB0aGUgZW50ZXJwcmlzZSB0aGlzIHRva2VuIGlzIHZhbGlkIGZvcj5cbiAgICogICAgY2xpZW50OiA8dGhlIGF1dGggY2xpZW50IHRoYXQgdGhpcyB0b2tlbiBiZWxvbmdzIHRvPlxuICAgKiAgICBzY29wZTogPGxpc3Qgb2YgYWxsb3dlZCBPQXV0aCBzY29wZSB2YWx1ZXM+XG4gICAqICAgIGNyZWF0ZWQ6IDxkYXRlIHRoZSB0b2tlbiB3YXMgY3JlYXRlZD5cbiAgICogICAgZXhwaXJlczogPGRhdGUgdGhlIHRva2VuIHdpbGwgZXhwaXJlPlxuICAgKiAgICBvcmlnaW46IDx0aGUgb3JpZ2luIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIHZhbGlkPlxuICAgKiAgICBpc0V4dGVuc2libGU6IDxmbGFnIGluZGljYXRpbmcgaWYgdGhlIHRva2VuIGNhbiBiZSBleHRlbmRlZD5cbiAgICogICAgZXh0ZW5zaW9uQWRkcmVzczogPGFkZHJlc3Mgd2hvc2UgcHJpdmF0ZSBrZXkncyBzaWduYXR1cmUgaXMgbmVjZXNzYXJ5IGZvciBleHRlbnNpb25zPlxuICAgKiAgICB1bmxvY2s6IDxpbmZvIGZvciBhY3Rpb25zIHRoYXQgcmVxdWlyZSBhbiB1bmxvY2sgYmVmb3JlIGZpcmluZz5cbiAgICogfVxuICAgKi9cbiAgYXN5bmMgYWRkQWNjZXNzVG9rZW4ocGFyYW1zOiBBZGRBY2Nlc3NUb2tlbk9wdGlvbnMpOiBQcm9taXNlPEFkZEFjY2Vzc1Rva2VuUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5sYWJlbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgbGFiZWwnKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgbm9uLXN0cmluZyBwYXJhbXNcbiAgICAgIGlmIChwYXJhbXMuZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5kdXJhdGlvbikgfHwgcGFyYW1zLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHVyYXRpb24gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5pcFJlc3RyaWN0KSB7XG4gICAgICAgIGlmICghXy5pc0FycmF5KHBhcmFtcy5pcFJlc3RyaWN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBSZXN0cmljdCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXy5mb3JFYWNoKHBhcmFtcy5pcFJlc3RyaWN0LCAoaXBBZGRyKSA9PiB7XG4gICAgICAgICAgaWYgKCFfLmlzU3RyaW5nKGlwQWRkcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBSZXN0cmljdCBtdXN0IGJlIGFuIGFycmF5IG9mIElQIGFkZHJlc3Mgc3RyaW5ncycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnR4VmFsdWVMaW1pdCkge1xuICAgICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLnR4VmFsdWVMaW1pdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4VmFsdWVMaW1pdCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy50eFZhbHVlTGltaXQgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eFZhbHVlTGltaXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5zY29wZSAmJiBwYXJhbXMuc2NvcGUubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIV8uaXNBcnJheShwYXJhbXMuc2NvcGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY29wZSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzcGVjaWZ5IHNjb3BlIGZvciB0b2tlbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdXRoVXJsID0gdGhpcy5taWNyb3NlcnZpY2VzVXJsKCcvYXBpL2F1dGgvdjEvYWNjZXNzdG9rZW4nKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnBvc3QoYXV0aFVybCk7XG5cbiAgICAgIGlmICghdGhpcy5fZWNkaFhwcnYpIHtcbiAgICAgICAgLy8gd2l0aG91dCBhIHByaXZhdGUga2V5LCB0aGUgdXNlciBjYW5ub3QgZGVjcnlwdCB0aGUgbmV3IGFjY2VzcyB0b2tlbiB0aGUgc2VydmVyIHdpbGwgc2VuZFxuICAgICAgICByZXF1ZXN0LmZvcmNlVjFBdXRoID0gdHJ1ZTtcbiAgICAgICAgZGVidWcoJ2ZvcmNpbmcgdjEgYXV0aCBmb3IgYWRkaW5nIGFjY2VzcyB0b2tlbiB1c2luZyB0b2tlbiAlcycsIHRoaXMuX3Rva2VuPy5zdWJzdHIoMCwgOCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Quc2VuZChwYXJhbXMpO1xuICAgICAgaWYgKHJlcXVlc3QuZm9yY2VWMUF1dGgpIHtcbiAgICAgICAgKHJlc3BvbnNlIGFzIGFueSkuYm9keS53YXJuaW5nID0gJ0EgcHJvdG9jb2wgZG93bmdyYWRlIGhhcyBvY2N1cnJlZCBiZWNhdXNlIHRoaXMgaXMgYSBsZWdhY3kgYWNjb3VudC4nO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzcG9uc2VSZXN1bHQ8QWRkQWNjZXNzVG9rZW5SZXNwb25zZT4oKShyZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHZlcmlmeSB0aGUgYXV0aGVudGljaXR5IG9mIHRoZSBzZXJ2ZXIncyByZXNwb25zZSBiZWZvcmUgcHJvY2VlZGluZyBhbnkgZnVydGhlclxuICAgICAgdmVyaWZ5UmVzcG9uc2UodGhpcywgdGhpcy5fdG9rZW4sICdwb3N0JywgcmVxdWVzdCwgcmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXNwb25zZURldGFpbHMgPSB0aGlzLmhhbmRsZVRva2VuSXNzdWFuY2UocmVzcG9uc2UuYm9keSk7XG4gICAgICByZXNwb25zZS5ib2R5LnRva2VuID0gcmVzcG9uc2VEZXRhaWxzLnRva2VuO1xuXG4gICAgICByZXR1cm4gaGFuZGxlUmVzcG9uc2VSZXN1bHQ8QWRkQWNjZXNzVG9rZW5SZXNwb25zZT4oKShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlUmVzcG9uc2VFcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZXhwaXJlIHRpbWUgb2YgYW4gYWNjZXNzIHRva2VuIG1hdGNoaW5nIGVpdGhlciB0aGUgaWQgb3IgbGFiZWwgdG8gdGhlIGN1cnJlbnQgZGF0ZSwgZWZmZWN0aXZlbHkgZGVsZXRpbmcgaXRcbiAgICpcbiAgICogUGFyYW1zOlxuICAgKiBpZDogPGlkIG9mIHRoZSBhY2Nlc3MgdG9rZW4gdG8gYmUgZGVsZXRlZD5cbiAgICogbGFiZWw6IDxsYWJlbCBvZiB0aGUgYWNjZXNzIHRva2VuIHRvIGJlIGRlbGV0ZWQ+XG4gICAqXG4gICAqIFJldHVybnM6XG4gICAqIGlkOiA8aWQgb2YgdGhlIHRva2VuPlxuICAgKiBsYWJlbDogPHVzZXItcHJvdmlkZWQgbGFiZWwgZm9yIHRoaXMgdG9rZW4+XG4gICAqIHVzZXI6IDxpZCBvZiB0aGUgdXNlciBvbiB0aGUgdG9rZW4+XG4gICAqIGVudGVycHJpc2UgPGlkIG9mIHRoZSBlbnRlcnByaXNlIHRoaXMgdG9rZW4gaXMgdmFsaWQgZm9yPlxuICAgKiBjbGllbnQ6IDx0aGUgYXV0aCBjbGllbnQgdGhhdCB0aGlzIHRva2VuIGJlbG9uZ3MgdG8+XG4gICAqIHNjb3BlOiA8bGlzdCBvZiBhbGxvd2VkIE9BdXRoIHNjb3BlIHZhbHVlcz5cbiAgICogY3JlYXRlZDogPGRhdGUgdGhlIHRva2VuIHdhcyBjcmVhdGVkPlxuICAgKiBleHBpcmVzOiA8ZGF0ZSB0aGUgdG9rZW4gd2lsbCBleHBpcmU+XG4gICAqIG9yaWdpbjogPHRoZSBvcmlnaW4gZm9yIHdoaWNoIHRoaXMgdG9rZW4gaXMgdmFsaWQ+XG4gICAqIGlzRXh0ZW5zaWJsZTogPGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgdG9rZW4gY2FuIGJlIGV4dGVuZGVkPlxuICAgKiBleHRlbnNpb25BZGRyZXNzOiA8YWRkcmVzcyB3aG9zZSBwcml2YXRlIGtleSdzIHNpZ25hdHVyZSBpcyBuZSpjZXNzYXJ5IGZvciBleHRlbnNpb25zPlxuICAgKiB1bmxvY2s6IDxpbmZvIGZvciBhY3Rpb25zIHRoYXQgcmVxdWlyZSBhbiB1bmxvY2sgYmVmb3JlIGZpcmluZz5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjZXNzVG9rZW4oeyBpZCwgbGFiZWwgfTogUmVtb3ZlQWNjZXNzVG9rZW5PcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoKCFpZCAmJiAhbGFiZWwpIHx8IChpZCAmJiBsYWJlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIGV4YWN0bHkgb25lIG9mIGlkIG9yIGxhYmVsJyk7XG4gICAgfVxuICAgIGlmIChpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsKHRoaXMudXJsKGAvdXNlci9hY2Nlc3N0b2tlbi8ke2lkfWApKVxuICAgICAgICAuc2VuZCgpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCB0aGlzLmxpc3RBY2Nlc3NUb2tlbnMoKTtcblxuICAgIGlmICghdG9rZW5zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rva2VuIHdpdGggdGhpcyBsYWJlbCBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoaW5nVG9rZW5zID0gXy5maWx0ZXIodG9rZW5zLCB7IGxhYmVsIH0pO1xuICAgIGlmIChtYXRjaGluZ1Rva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FtYmlndW91cyBjYWxsOiBtdWx0aXBsZSB0b2tlbnMgbWF0Y2hpbmcgdGhpcyBsYWJlbCcpO1xuICAgIH1cbiAgICBpZiAobWF0Y2hpbmdUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rva2VuIHdpdGggdGhpcyBsYWJlbCBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRlbCh0aGlzLnVybChgL3VzZXIvYWNjZXNzdG9rZW4vJHttYXRjaGluZ1Rva2Vuc1swXS5pZH1gKSlcbiAgICAgIC5zZW5kKClcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBwYXNzd29yZFxuICAgKiBAcGFyYW0gICB7TnVtYmVyfSBudW1Xb3JkcyAgICAgTnVtYmVyIG9mIDMyLWJpdCB3b3Jkc1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSAgICAgICAgICBiYXNlNTggcmFuZG9tIHBhc3N3b3JkXG4gICAqL1xuICBnZW5lcmF0ZVJhbmRvbVBhc3N3b3JkKG51bVdvcmRzID0gNSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGdlbmVyYXRlUmFuZG9tUGFzc3dvcmQobnVtV29yZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ291dCBvZiBCaXRHb1xuICAgKi9cbiAgYXN5bmMgbG9nb3V0KCk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXQodGhpcy51cmwoJy91c2VyL2xvZ291dCcpKS5yZXN1bHQoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB1c2VyIGJ5IElEIChuYW1lL2VtYWlsIG9ubHkpXG4gICAqIEBwYXJhbSBpZFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcih7IGlkIH06IEdldFVzZXJPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoYC91c2VyLyR7aWR9YCkpLnJlc3VsdCgndXNlcicpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbG9nZ2VkIGluIHVzZXJcbiAgICovXG4gIGFzeW5jIG1lKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VXNlcih7IGlkOiAnbWUnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVubG9jayB0aGUgc2Vzc2lvbiBieSBwcm92aWRpbmcgT1RQXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvdHAgUmVxdWlyZWQgT1RQIGNvZGUgZm9yIHRoZSBhY2NvdW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRGVzaXJlZCBkdXJhdGlvbiBvZiB0aGUgdW5sb2NrIGluIHNlY29uZHMgKGRlZmF1bHQ9NjAwLCBtYXg9MzYwMCkuXG4gICAqL1xuICBhc3luYyB1bmxvY2soeyBvdHAsIGR1cmF0aW9uIH06IFVubG9ja09wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmIChvdHAgJiYgIV8uaXNTdHJpbmcob3RwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgb3IgdW5kZWZpbmVkIG90cCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci91bmxvY2snKSkuc2VuZCh7IG90cCwgZHVyYXRpb24gfSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogTG9jayB0aGUgc2Vzc2lvblxuICAgKi9cbiAgYXN5bmMgbG9jaygpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL2xvY2snKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICovXG4gIGFzeW5jIHNlc3Npb24oKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy91c2VyL3Nlc3Npb24nKSkucmVzdWx0KCdzZXNzaW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhIHB1c2gvc21zIGZvciB0aGUgT1RQIGNvZGVcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuZm9yY2VTTVMgSWYgc2V0IHRvIHRydWUsIHdpbGwgdXNlIFNNUyB0byBzZW5kIHRoZSBPVFAgdG8gdGhlIHVzZXIgZXZlbiBpZiB0aGV5IGhhdmUgb3RoZXIgMkZBIG1ldGhvZCBzZXQgdXAuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBzZW5kT1RQKHBhcmFtczogeyBmb3JjZVNNUz86IGJvb2xlYW4gfSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9zZW5kb3RwJykpLnNlbmQocGFyYW1zKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgdG9rZW4sIHByb3ZpZGVkIHRoZSBjdXJyZW50IHRva2VuIGlzIGV4dGVuZGFibGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIGR1cmF0aW9uOiBkdXJhdGlvbiBpbiBzZWNvbmRzIGJ5IHdoaWNoIHRvIGV4dGVuZCB0aGUgdG9rZW4sIHN0YXJ0aW5nIGF0IHRoZSBjdXJyZW50IHRpbWVcbiAgICovXG4gIGFzeW5jIGV4dGVuZFRva2VuKHBhcmFtczogRXh0ZW5kVG9rZW5PcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgX2V4dGVuc2lvbktleScpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb247XG4gICAgY29uc3QgbWVzc2FnZSA9IHRpbWVzdGFtcCArICd8JyArIHRoaXMuX3Rva2VuICsgJ3wnICsgZHVyYXRpb247XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHRoaXMuX2V4dGVuc2lvbktleS5wcml2YXRlS2V5O1xuICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBwcml2YXRlS2V5IG9uIGV4dGVuc2lvbktleScpO1xuICAgIH1cbiAgICBjb25zdCBpc0NvbXByZXNzZWQgPSB0aGlzLl9leHRlbnNpb25LZXkuY29tcHJlc3NlZDtcbiAgICBjb25zdCBwcmVmaXggPSB1dHhvbGliLm5ldHdvcmtzLmJpdGNvaW4ubWVzc2FnZVByZWZpeDtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiaXRjb2luTWVzc2FnZS5zaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCwgcHJlZml4KS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9leHRlbmR0b2tlbicpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnNldCgndGltZXN0YW1wJywgdGltZXN0YW1wLnRvU3RyaW5nKCkpXG4gICAgICAuc2V0KCdzaWduYXR1cmUnLCBzaWduYXR1cmUpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEga2V5IGZvciBzaGFyaW5nIGEgd2FsbGV0IHdpdGggYSB1c2VyXG4gICAqIEBwYXJhbSBlbWFpbCBlbWFpbCBvZiB1c2VyIHRvIHNoYXJlIHdhbGxldCB3aXRoXG4gICAqL1xuICBhc3luYyBnZXRTaGFyaW5nS2V5KHsgZW1haWwgfTogR2V0U2hhcmluZ0tleU9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhlbWFpbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGVtYWlsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvc2hhcmluZ2tleScpKS5zZW5kKHsgZW1haWwgfSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlcnMgdGhhdCB3YW50IHRvIHNpZ24gd2l0aCBhIGtleSB3aWxsIHVzZSB0aGlzIGFwaSB0byBmZXRjaCB0aGUga2V5Y2hhaW4gYW5kIHRoZSBwYXRoLlxuICAgKiBVc2VycyB0aGF0IHdhbnQgdG8gdmVyaWZ5IGEgc2lnbmF0dXJlIHdpbGwgdXNlIHRoaXMgYXBpIHRvIGZldGNoIGFub3RoZXIgdXNlcnMgZWNkaCBwdWJrZXkuXG4gICAqIE5vdGU6IElmIHRoZSB1c2VyIGlkIGlzIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBkZWZhdWx0IHRvIGdldHRpbmcgdGhlIGN1cnJlbnQgdXNlcidzIGtleWNoYWluLlxuICAgKiBAcGFyYW0gYml0Z29cbiAgICogQHBhcmFtIGVudGVycHJpc2VJZFxuICAgKiBAcGFyYW0gdXNlcklkXG4gICAqL1xuICBhc3luYyBnZXRTaWduaW5nS2V5Rm9yVXNlcihlbnRlcnByaXNlSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKTogUHJvbWlzZTxHZXRTaWduaW5nS2V5QXBpPiB7XG4gICAgY29uc3QgdXNlciA9IHVzZXJJZCA/PyAnbWUnO1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybChgL2VudGVycHJpc2UvJHtlbnRlcnByaXNlSWR9L3VzZXIvJHt1c2VyfS9zaWduaW5na2V5YCwgMikpXG4gICAgICAucXVlcnkoe30pXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIGdldFZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgc2V0VmFsaWRhdGUodmFsaWRhdGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKHZhbGlkYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHRoaXMuX3ZhbGlkYXRlID0gdmFsaWRhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBuZXcgY29pbiBpbnN0YW5jZSB3aXRoIGl0cyBidWlsZGVyIGZhY3RvcnlcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY29pbiBuYW1lIGFzIGl0IHdhcyByZWdpc3RlcmVkIGluIEBiaXRnby9zdGF0aWNzXG4gICAqIEBwYXJhbSB7Q29pbkNvbnN0cnVjdG9yfSBjb2luIHRoZSBidWlsZGVyIGZhY3RvcnkgY2xhc3MgZm9yIHRoYXQgY29pblxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHB1YmxpYyByZWdpc3RlcihuYW1lOiBzdHJpbmcsIGNvaW46IENvaW5Db25zdHJ1Y3Rvcik6IHZvaWQge1xuICAgIEdsb2JhbENvaW5GYWN0b3J5LnJlZ2lzdGVyKG5hbWUsIGNvaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBiaXRjb2luIG1hcmtldCBkYXRhXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBtYXJrZXRzKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl9tYXJrZXRzKSB7XG4gICAgICB0aGlzLl9tYXJrZXRzID0gbmV3IE1hcmtldHModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYXJrZXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF0ZXN0IGJpdGNvaW4gcHJpY2VzXG4gICAqIChEZXByZWNhdGVkOiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSkgdXNlIGBiaXRnby5tYXJrZXRzKCkubGF0ZXN0KClgXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICAvLyBjYi1jb21wYXRcbiAgYXN5bmMgbWFya2V0KCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvbWFya2V0L2xhdGVzdCcpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbWFya2V0IGRhdGEgZnJvbSB5ZXN0ZXJkYXlcbiAgICogKERlcHJlY2F0ZWQ6IFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlKSB1c2UgYml0Z28ubWFya2V0cygpLnllc3RlcmRheSgpXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyB5ZXN0ZXJkYXkoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9tYXJrZXQveWVzdGVyZGF5JykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYmxvY2tjaGFpbiBvYmplY3QuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBibG9ja2NoYWluKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl9ibG9ja2NoYWluKSB7XG4gICAgICB0aGlzLl9ibG9ja2NoYWluID0gbmV3IEJsb2NrY2hhaW4odGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ibG9ja2NoYWluO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIGtleWNoYWlucyBvYmplY3QuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBrZXljaGFpbnMoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX2tleWNoYWlucykge1xuICAgICAgdGhpcy5fa2V5Y2hhaW5zID0gbmV3IEtleWNoYWlucyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2tleWNoYWlucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRyYXZlbCBydWxlIG9iamVjdFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgdHJhdmVsUnVsZSgpOiBhbnkge1xuICAgIGlmICghdGhpcy5fdHJhdmVsUnVsZSkge1xuICAgICAgdGhpcy5fdHJhdmVsUnVsZSA9IG5ldyBUcmF2ZWxSdWxlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdHJhdmVsUnVsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIncyB3YWxsZXRzIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHdhbGxldHMoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX3dhbGxldHMpIHtcbiAgICAgIHRoaXMuX3dhbGxldHMgPSBuZXcgV2FsbGV0cyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBlbmRpbmcgYXBwcm92YWxzIHRoYXQgY2FuIGJlIGFwcHJvdmVkLyBvciByZWplY3RlZFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcGVuZGluZ0FwcHJvdmFscygpOiBhbnkge1xuICAgIGlmICghdGhpcy5fcGVuZGluZ0FwcHJvdmFscykge1xuICAgICAgdGhpcy5fcGVuZGluZ0FwcHJvdmFscyA9IG5ldyBQZW5kaW5nQXBwcm92YWxzKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFscztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBXYWxsZXQgb2JqZWN0LCBpbml0aWFsaXplZCB3aXRoIHRoZSB3YWxsZXQgcGFyYW1zXG4gICAqIENhbiBiZSB1c2VkIHRvIHJlY29uc3RpdHV0ZSBhIHdhbGxldCBmcm9tIGNhY2hlZCBkYXRhXG4gICAqIEBwYXJhbSB3YWxsZXRQYXJhbXNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIG5ld1dhbGxldE9iamVjdCh3YWxsZXRQYXJhbXMpOiBhbnkge1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMsIHdhbGxldFBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogVjEgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBtaW5lciBmZWUgYW1vdW50cywgZ2l2ZW4gdGhlIG51bWJlciBhbmRcbiAgICogdHlwZSBvZiB0cmFuc2FjdGlvbiBpbnB1dHMsIGFsb25nIHdpdGggYSBmZWUgcmF0ZSBpbiBzYXRvc2hpcyBwZXIgdmtCLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQgZm9yIG5ldyBjb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGFzeW5jIGNhbGN1bGF0ZU1pbmVyRmVlSW5mbyhwYXJhbXM6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uQnVpbGRlci5jYWxjdWxhdGVNaW5lckZlZUluZm8ocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgYSBCaXRjb2luIGFkZHJlc3MgaXMgYSB2YWxpZCBiYXNlNTggYWRkcmVzc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgdmVyaWZ5QWRkcmVzcyhwYXJhbXM6IERlcHJlY2F0ZWRWZXJpZnlBZGRyZXNzT3B0aW9ucyA9IHt9KTogYm9vbGVhbiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydhZGRyZXNzJ10sIFtdKTtcblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgYWRkcmVzcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ldHdvcmtOYW1lID0gY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmdldEVudigpXS5uZXR3b3JrO1xuICAgIGNvbnN0IG5ldHdvcmsgPSB1dHhvbGliLm5ldHdvcmtzW25ldHdvcmtOYW1lXTtcblxuICAgIHJldHVybiB2ZXJpZnlBZGRyZXNzKHBhcmFtcy5hZGRyZXNzLCBuZXR3b3JrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBhIHNlY3JldCBpbnRvIHNoYXJkcyB1c2luZyBTaGFtaXIgU2VjcmV0IFNoYXJpbmcuXG4gICAqIEBwYXJhbSBzZWVkIEEgaGV4YWRlY2ltYWwgc2VjcmV0IHRvIHNwbGl0XG4gICAqIEBwYXJhbSBwYXNzd29yZHMgQW4gYXJyYXkgb2YgdGhlIHBhc3N3b3JkcyB1c2VkIHRvIGVuY3J5cHQgZWFjaCBzaGFyZVxuICAgKiBAcGFyYW0gbSBUaGUgdGhyZXNob2xkIG51bWJlciBvZiBzaGFyZHMgbmVjZXNzYXJ5IHRvIHJlY29uc3RpdHV0ZSB0aGUgc2VjcmV0XG4gICAqL1xuICBzcGxpdFNlY3JldCh7IHNlZWQsIHBhc3N3b3JkcywgbSB9OiBTcGxpdFNlY3JldE9wdGlvbnMpOiBTcGxpdFNlY3JldCB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhc3N3b3JkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzSW50ZWdlcihtKSB8fCBtIDwgMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAyJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhc3N3b3Jkcy5sZW5ndGggPCBtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkcyBhcnJheSBsZW5ndGggY2Fubm90IGJlIGxlc3MgdGhhbiBtJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbiA9IHBhc3N3b3Jkcy5sZW5ndGg7XG4gICAgY29uc3Qgc2VjcmV0czogc3RyaW5nW10gPSBzaGFtaXIuc2hhcmUoc2VlZCwgbiwgbSk7XG4gICAgY29uc3Qgc2hhcmRzID0gXy56aXBXaXRoKHNlY3JldHMsIHBhc3N3b3JkcywgKHNoYXJkLCBwYXNzd29yZCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdCh7IGlucHV0OiBzaGFyZCwgcGFzc3dvcmQgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgbm9kZSA9IGJpcDMyLmZyb21TZWVkKEJ1ZmZlci5mcm9tKHNlZWQsICdoZXgnKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHhwdWI6IG5vZGUubmV1dGVyZWQoKS50b0Jhc2U1OCgpLFxuICAgICAgbSxcbiAgICAgIG4sXG4gICAgICBzZWVkU2hhcmVzOiBzaGFyZHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvbnN0aXR1dGUgYSBzZWNyZXQgd2hpY2ggd2FzIHNoYXJkZWQgd2l0aCBgc3BsaXRTZWNyZXRgLlxuICAgKiBAcGFyYW0gc2hhcmRzXG4gICAqIEBwYXJhbSBwYXNzd29yZHNcbiAgICovXG4gIHJlY29uc3RpdHV0ZVNlY3JldCh7IHNoYXJkcywgcGFzc3dvcmRzIH06IFJlY29uc3RpdHV0ZVNlY3JldE9wdGlvbnMpOiBSZWNvbnN0aXR1dGVkU2VjcmV0IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2hhcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFzc3dvcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cblxuICAgIGlmIChzaGFyZHMubGVuZ3RoICE9PSBwYXNzd29yZHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJkcyBhbmQgcGFzc3dvcmRzIGFycmF5cyBtdXN0IGhhdmUgc2FtZSBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNyZXRzID0gXy56aXBXaXRoKHNoYXJkcywgcGFzc3dvcmRzLCAoc2hhcmQsIHBhc3N3b3JkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KHsgaW5wdXQ6IHNoYXJkLCBwYXNzd29yZCB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBzZWVkOiBzdHJpbmcgPSBzaGFtaXIuY29tYmluZShzZWNyZXRzKTtcbiAgICBjb25zdCBub2RlID0gYmlwMzIuZnJvbVNlZWQoQnVmZmVyLmZyb20oc2VlZCwgJ2hleCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgeHB1Yjogbm9kZS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCkgYXMgc3RyaW5nLFxuICAgICAgeHBydjogbm9kZS50b0Jhc2U1OCgpIGFzIHN0cmluZyxcbiAgICAgIHNlZWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gc2hhcmRzXG4gICAqIEBwYXJhbSBwYXNzd29yZHNcbiAgICogQHBhcmFtIG1cbiAgICogQHBhcmFtIHhwdWIgT3B0aW9uYWwgeHB1YiB0byB2ZXJpZnkgdGhlIHJlc3VsdHMgYWdhaW5zdFxuICAgKi9cbiAgdmVyaWZ5U2hhcmRzKHsgc2hhcmRzLCBwYXNzd29yZHMsIG0sIHhwdWIgfTogVmVyaWZ5U2hhcmRzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFsbCBwb3NzaWJsZSBjb21iaW5hdGlvbnMgb2YgYSBnaXZlbiBhcnJheSdzIHZhbHVlcyBnaXZlbiBzdWJzZXQgc2l6ZSBtXG4gICAgICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB3aG9zZSB2YWx1ZXMgYXJlIHRvIGJlIGFycmFuZ2VkIGluIGFsbCBjb21iaW5hdGlvbnNcbiAgICAgKiBAcGFyYW0gbSBUaGUgc2l6ZSBvZiBlYWNoIHN1YnNldFxuICAgICAqIEBwYXJhbSBlbnRyeUluZGljZXMgUmVjdXJzaXZlbHkgdHJhaWxpbmcgc2V0IG9mIGN1cnJlbnRseSBjaG9zZW4gYXJyYXkgaW5kaWNlcyBmb3IgdGhlIGNvbWJpbmF0aW9uIHN1YnNldCB1bmRlciBjb25zdHJ1Y3Rpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgY29uc3QgZ2VuZXJhdGVDb21iaW5hdGlvbnMgPSAoYXJyYXk6IHN0cmluZ1tdLCBtOiBudW1iZXIsIGVudHJ5SW5kaWNlczogbnVtYmVyW10gPSBbXSk6IHN0cmluZ1tdW10gPT4ge1xuICAgICAgbGV0IGNvbWJpbmF0aW9uczogc3RyaW5nW11bXSA9IFtdO1xuXG4gICAgICBpZiAoZW50cnlJbmRpY2VzLmxlbmd0aCA9PT0gbSkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q29tYmluYXRpb24gPSBfLmF0KGFycmF5LCBlbnRyeUluZGljZXMpO1xuICAgICAgICByZXR1cm4gW2N1cnJlbnRDb21iaW5hdGlvbl07XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBoaWdoZXN0IGluZGV4XG4gICAgICBsZXQgZW50cnlJbmRleCA9IF8ubGFzdChlbnRyeUluZGljZXMpO1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIGN1cnJlbnRseSBubyBpbmRpY2VzLCBhc3N1bWUgLTFcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGVudHJ5SW5kZXgpKSB7XG4gICAgICAgIGVudHJ5SW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBlbnRyeUluZGV4ICsgMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgY3VycmVudCBpbmRleCB0byB0aGUgdHJhaWxpbmcgaW5kaWNlc1xuICAgICAgICBjb25zdCBjdXJyZW50RW50cnlJbmRpY2VzID0gWy4uLmVudHJ5SW5kaWNlcywgaV07XG4gICAgICAgIGNvbnN0IG5ld0NvbWJpbmF0aW9ucyA9IGdlbmVyYXRlQ29tYmluYXRpb25zKGFycmF5LCBtLCBjdXJyZW50RW50cnlJbmRpY2VzKTtcbiAgICAgICAgY29tYmluYXRpb25zID0gWy4uLmNvbWJpbmF0aW9ucywgLi4ubmV3Q29tYmluYXRpb25zXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbWJpbmF0aW9ucztcbiAgICB9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNoYXJkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcmRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhc3N3b3JkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG5cbiAgICBpZiAoc2hhcmRzLmxlbmd0aCAhPT0gcGFzc3dvcmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZHMgYW5kIHBhc3N3b3JkcyBhcnJheXMgbXVzdCBoYXZlIHNhbWUgbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjcmV0cyA9IF8uemlwV2l0aChzaGFyZHMsIHBhc3N3b3JkcywgKHNoYXJkLCBwYXNzd29yZCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdCh7IGlucHV0OiBzaGFyZCwgcGFzc3dvcmQgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VjcmV0Q29tYmluYXRpb25zID0gZ2VuZXJhdGVDb21iaW5hdGlvbnMoc2VjcmV0cywgbSk7XG4gICAgY29uc3Qgc2VlZHMgPSBzZWNyZXRDb21iaW5hdGlvbnMubWFwKChjdXJyZW50Q29tYmluYXRpb24pID0+IHtcbiAgICAgIHJldHVybiBzaGFtaXIuY29tYmluZShjdXJyZW50Q29tYmluYXRpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IHVuaXF1ZVNlZWRzID0gXy51bmlxKHNlZWRzKTtcbiAgICBpZiAodW5pcXVlU2VlZHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNlZWQgPSBfLmZpcnN0KHVuaXF1ZVNlZWRzKTtcbiAgICBjb25zdCBub2RlID0gYmlwMzIuZnJvbVNlZWQoQnVmZmVyLmZyb20oc2VlZCwgJ2hleCcpKTtcbiAgICBjb25zdCByZXN0b3JlZFhwdWIgPSBub2RlLm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh4cHViKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHhwdWIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigneHB1YiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdG9yZWRYcHViICE9PSB4cHViKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCAtIHVzZSBgZ2V0U2hhcmVkU2VjcmV0KClgXG4gICAqL1xuICBnZXRFQ0RIU2VjcmV0KHsgb3RoZXJQdWJLZXlIZXgsIGVja2V5IH06IEdldEVjZGhTZWNyZXRPcHRpb25zKTogc3RyaW5nIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcob3RoZXJQdWJLZXlIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ290aGVyUHViS2V5SGV4IHN0cmluZyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNPYmplY3QoZWNrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vja2V5IG9iamVjdCByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTaGFyZWRTZWNyZXQoZWNrZXksIEJ1ZmZlci5mcm9tKG90aGVyUHViS2V5SGV4LCAnaGV4JykpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1c2VyJ3MgcHJpdmF0ZSBFQ0RIIGtleWNoYWluXG4gICAqL1xuICBhc3luYyBnZXRFQ0RIS2V5Y2hhaW4oZWNkaEtleWNoYWluUHViPzogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIWVjZGhLZXljaGFpblB1Yikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXQodGhpcy51cmwoJy91c2VyL3NldHRpbmdzJykpLnJlc3VsdCgpO1xuICAgICAgaWYgKCFyZXN1bHQuc2V0dGluZ3MuZWNkaEtleWNoYWluKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2VjZGgga2V5Y2hhaW4gbm90IGZvdW5kIGZvciB1c2VyJyk7XG4gICAgICB9XG4gICAgICBlY2RoS2V5Y2hhaW5QdWIgPSByZXN1bHQuc2V0dGluZ3MuZWNkaEtleWNoYWluO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXljaGFpbnMoKS5nZXQoeyB4cHViOiBlY2RoS2V5Y2hhaW5QdWIgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXNlciBkZXJpdmVkIHB1YmxpYyBhbmQgcHJpdmF0ZSBFQ0RIIGtleXBhaXJcbiAgICogQHBhcmFtIHBhc3N3b3JkIHBhc3N3b3JkIHRvIGRlY3J5cHQgdGhlIHVzZXIncyBFQ0RIIGVuY3J5cHRlZCBwcml2YXRlIGtleVxuICAgKiBAcGFyYW0gZW50SWQ/IG9wdGlvbmFsIGVudGVycHJpc2UgaWQgdG8gY2hlY2sgZm9yIHBlcm1pc3Npb25zXG4gICAqL1xuICBhc3luYyBnZXRFY2RoS2V5cGFpclByaXZhdGUocGFzc3dvcmQ6IHN0cmluZywgZW50SWQ6IHN0cmluZyk6IFByb21pc2U8RWNkaERlcml2ZWRLZXlwYWlyPiB7XG4gICAgY29uc3QgdXNlclNpZ25pbmdLZXkgPSBhd2FpdCB0aGlzLmdldFNpZ25pbmdLZXlGb3JVc2VyKGVudElkKTtcbiAgICBjb25zdCBwdWJrZXlPZkFkbWluRWNkaEtleUhleCA9IHVzZXJTaWduaW5nS2V5LmRlcml2ZWRQdWJrZXk7XG4gICAgaWYgKCF1c2VyU2lnbmluZ0tleS5lY2RoS2V5Y2hhaW4gfHwgIXVzZXJTaWduaW5nS2V5LmRlcml2YXRpb25QYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggdGhlIHVzZXIga2V5Y2hhaW4uIFBsZWFzZSBjb250YWN0IHN1cHBvcnRAYml0Z28uY29tLicpO1xuICAgIH1cbiAgICBjb25zdCB1c2VyRWNkaEtleWNoYWluID0gYXdhaXQgdGhpcy5nZXRFQ0RIS2V5Y2hhaW4odXNlclNpZ25pbmdLZXkuZWNkaEtleWNoYWluKTtcbiAgICBsZXQgeHBydjtcbiAgICB0cnkge1xuICAgICAgeHBydiA9IHRoaXMuZGVjcnlwdCh7XG4gICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcbiAgICAgICAgaW5wdXQ6IHVzZXJFY2RoS2V5Y2hhaW4uZW5jcnlwdGVkWHBydixcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHBhc3N3b3JkLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGVyaXZlZFB1YktleTogcHVia2V5T2ZBZG1pbkVjZGhLZXlIZXgsXG4gICAgICBkZXJpdmF0aW9uUGF0aDogdXNlclNpZ25pbmdLZXkuZGVyaXZhdGlvblBhdGgsXG4gICAgICB4cHJ2LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIG9wZXJhdGluZ1N5c3RlbTogb25lIG9mIGlvcywgYW5kcm9pZFxuICAgKiAtIHB1c2hUb2tlbjogaGV4LWZvcm1hdHRlZCB0b2tlbiBmb3IgdGhlIHJlc3BlY3RpdmUgbmF0aXZlIHB1c2ggbm90aWZpY2F0aW9uIHNlcnZpY2VcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyByZWdpc3RlclB1c2hUb2tlbihwYXJhbXM6IFJlZ2lzdGVyUHVzaFRva2VuT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsncHVzaFRva2VuJywgJ29wZXJhdGluZ1N5c3RlbSddLCBbXSk7XG5cbiAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAvLyB0aGlzIGRldmljZSBoYXMgdG8gYmUgcmVnaXN0ZXJlZCB0byBhbiBleHRlbnNpYmxlIHNlc3Npb25cbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGxvZ2dlZCBpbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvc3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ3B1c2hUb2tlbicsICdvcGVyYXRpbmdTeXN0ZW0nXSk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvZGV2aWNlcycpKS5zZW5kKHBvc3RQYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSBwdXNoVmVyaWZpY2F0aW9uVG9rZW46IHRoZSB0b2tlbiByZWNlaXZlZCB2aWEgcHVzaCBub3RpZmljYXRpb24gdG8gY29uZmlybSB0aGUgZGV2aWNlJ3MgbW9iaWxpdHlcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHZlcmlmeVB1c2hUb2tlbihwYXJhbXM6IFZlcmlmeVB1c2hUb2tlbk9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIG9iamVjdCBwYXJhbXMnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnB1c2hWZXJpZmljYXRpb25Ub2tlbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHB1c2hWZXJpZmljYXRpb25Ub2tlbicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgIC8vIHRoaXMgZGV2aWNlIGhhcyB0byBiZSByZWdpc3RlcmVkIHRvIGFuIGV4dGVuc2libGUgc2Vzc2lvblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgbG9nZ2VkIGluJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9zdFBhcmFtcyA9IF8ucGljayhwYXJhbXMsICdwdXNoVmVyaWZpY2F0aW9uVG9rZW4nKTtcblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy9kZXZpY2VzL3ZlcmlmeScpKS5zZW5kKHBvc3RQYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ2luIHRvIHRoZSBiaXRnbyBzeXN0ZW0gdXNpbmcgYW4gYXV0aGNvZGUgZ2VuZXJhdGVkIHZpYSBPYXV0aFxuICAgKi9cbiAgYXN5bmMgYXV0aGVudGljYXRlV2l0aEF1dGhDb2RlKHBhcmFtczogQXV0aGVudGljYXRlV2l0aEF1dGhDb2RlT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgb2JqZWN0IHBhcmFtcycpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuYXV0aENvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBhdXRoQ29kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fY2xpZW50SWQgfHwgIXRoaXMuX2NsaWVudFNlY3JldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGNsaWVudCBpZCBhbmQgc2VjcmV0IHNldCBmaXJzdCB0byB1c2UgdGhpcycpO1xuICAgIH1cblxuICAgIGNvbnN0IGF1dGhDb2RlID0gcGFyYW1zLmF1dGhDb2RlO1xuXG4gICAgaWYgKHRoaXMuX3Rva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgbG9nZ2VkIGluJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucG9zdCh0aGlzLl9iYXNlVXJsICsgJy9vYXV0aC90b2tlbicpO1xuICAgIHJlcXVlc3QuZm9yY2VWMUF1dGggPSB0cnVlOyAvLyBPQXV0aCBjdXJyZW50bHkgb25seSBzdXBwb3J0cyB2MSBhdXRoZW50aWNhdGlvblxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXF1ZXN0XG4gICAgICAuc2VuZCh7XG4gICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICBjb2RlOiBhdXRoQ29kZSxcbiAgICAgICAgY2xpZW50X2lkOiB0aGlzLl9jbGllbnRJZCxcbiAgICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5fY2xpZW50U2VjcmV0LFxuICAgICAgfSlcbiAgICAgIC5yZXN1bHQoKTtcblxuICAgIHRoaXMuX3Rva2VuID0gYm9keS5hY2Nlc3NfdG9rZW47XG4gICAgdGhpcy5fcmVmcmVzaFRva2VuID0gYm9keS5yZWZyZXNoX3Rva2VuO1xuICAgIHRoaXMuX3VzZXIgPSBhd2FpdCB0aGlzLm1lKCk7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBwYXNzd29yZCBvZiB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgKiBBbHNvIGNoYW5nZSBhbGwgdjEgYW5kIHYyIGtleWNoYWluIHBhc3N3b3JkcyBpZiB0aGV5IG1hdGNoIHRoZVxuICAgKiBnaXZlbiBvbGRQYXNzd29yZC4gUmV0dXJucyBub3RoaW5nIG9uIHN1Y2Nlc3MuXG4gICAqIEBwYXJhbSBvbGRQYXNzd29yZCB7U3RyaW5nfSAtIHRoZSBjdXJyZW50IHBhc3N3b3JkXG4gICAqIEBwYXJhbSBuZXdQYXNzd29yZCB7U3RyaW5nfSAtIHRoZSBuZXcgcGFzc3dvcmRcbiAgICovXG4gIGFzeW5jIGNoYW5nZVBhc3N3b3JkKHsgb2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkIH06IENoYW5nZVBhc3N3b3JkT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKG9sZFBhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgb2xkUGFzc3dvcmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcobmV3UGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBuZXdQYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLnVzZXIoKTtcbiAgICBpZiAodHlwZW9mIHVzZXIgIT09ICdvYmplY3QnIHx8ICF1c2VyLnVzZXJuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgb2JqZWN0IHVzZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdGhpcy52ZXJpZnlQYXNzd29yZCh7IHBhc3N3b3JkOiBvbGRQYXNzd29yZCB9KTtcbiAgICBpZiAoIXZhbGlkYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIHByb3ZpZGVkIG9sZFBhc3N3b3JkIGlzIGluY29ycmVjdCcpO1xuICAgIH1cblxuICAgIC8vIGl0IGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGNvaW4gd2UgY2hvb3NlIGJlY2F1c2UgdGhlIHYyIHVwZGF0ZVBhc3N3b3JkIGZ1bmN0aW9ucyB1cGRhdGVzIGFsbCB2MiBrZXljaGFpbnNcbiAgICAvLyB3ZSBqdXN0IG5lZWQgdG8gY2hvb3NlIGEgY29pbiB0aGF0IGV4aXN0cyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFxuICAgIGNvbnN0IGNvaW4gPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuZ2V0RW52KCldLm5ldHdvcmsgPT09ICdiaXRjb2luJyA/ICdidGMnIDogJ3RidGMnO1xuXG4gICAgY29uc3QgdXBkYXRlS2V5Y2hhaW5QYXNzd29yZFBhcmFtcyA9IHsgb2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkIH07XG4gICAgY29uc3QgdjFLZXljaGFpblVwZGF0ZVBXUmVzdWx0ID0gYXdhaXQgdGhpcy5rZXljaGFpbnMoKS51cGRhdGVQYXNzd29yZCh1cGRhdGVLZXljaGFpblBhc3N3b3JkUGFyYW1zKTtcbiAgICBjb25zdCB2MktleWNoYWlucyA9IGF3YWl0IHRoaXMuY29pbihjb2luKS5rZXljaGFpbnMoKS51cGRhdGVQYXNzd29yZCh1cGRhdGVLZXljaGFpblBhc3N3b3JkUGFyYW1zKTtcblxuICAgIGNvbnN0IHVwZGF0ZVBhc3N3b3JkUGFyYW1zID0ge1xuICAgICAga2V5Y2hhaW5zOiB2MUtleWNoYWluVXBkYXRlUFdSZXN1bHQua2V5Y2hhaW5zLFxuICAgICAgdjJfa2V5Y2hhaW5zOiB2MktleWNoYWlucyxcbiAgICAgIHZlcnNpb246IHYxS2V5Y2hhaW5VcGRhdGVQV1Jlc3VsdC52ZXJzaW9uLFxuICAgICAgb2xkUGFzc3dvcmQ6IHRoaXMuY2FsY3VsYXRlSE1BQyh1c2VyLnVzZXJuYW1lLCBvbGRQYXNzd29yZCksXG4gICAgICBwYXNzd29yZDogdGhpcy5jYWxjdWxhdGVITUFDKHVzZXIudXNlcm5hbWUsIG5ld1Bhc3N3b3JkKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvY2hhbmdlcGFzc3dvcmQnKSkuc2VuZCh1cGRhdGVQYXNzd29yZFBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgYWRkcmVzcyBsYWJlbHMgb24gYWxsIG9mIHRoZSB1c2VyJ3Mgd2FsbGV0c1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgbGFiZWxzKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvbGFiZWxzJykpLnJlc3VsdCgnbGFiZWxzJyk7XG4gIH1cblxuICAvKipcbiAgICogRXN0aW1hdGVzIGFwcHJveGltYXRlIGZlZSBwZXIga2IgbmVlZGVkIGZvciBhIHR4IHRvIGdldCBpbnRvIGEgYmxvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5udW1CbG9ja3MgdGFyZ2V0IGJsb2NrcyBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIGNvbmZpcm1lZFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEZlZSBtYXhpbXVtIGZlZSB3aWxsaW5nIHRvIGJlIHBhaWQgKGZvciBzYWZldHkpXG4gICAqIEBwYXJhbSB7YXJyYXlbc3RyaW5nXX0gcGFyYW1zLmlucHV0cyBsaXN0IG9mIHVuY29uZmlybWVkIHR4SWRzIGZyb20gd2hpY2ggdGhpcyB0cmFuc2FjdGlvbiB1c2VzIGlucHV0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnR4U2l6ZSBlc3RpbWF0ZWQgdHJhbnNhY3Rpb24gc2l6ZSBpbiBieXRlcywgb3B0aW9uYWwgcGFyYW1ldGVyIHVzZWQgZm9yIENQRlAgZXN0aW1hdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuY3BmcEF3YXJlIGZsYWcgaW5kaWNhdGluZyBmZWUgc2hvdWxkIHRha2UgaW50byBhY2NvdW50IENQRlBcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIGVzdGltYXRlRmVlKHBhcmFtczogRXN0aW1hdGVGZWVPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zOiBhbnkgPSB7IHZlcnNpb246IDEyIH07XG4gICAgaWYgKHBhcmFtcy5udW1CbG9ja3MpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubnVtQmxvY2tzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zLm51bUJsb2NrcyA9IHBhcmFtcy5udW1CbG9ja3M7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubWF4RmVlKSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLm1heEZlZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5tYXhGZWUgPSBwYXJhbXMubWF4RmVlO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmlucHV0cykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy5pbnB1dHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMuaW5wdXRzID0gcGFyYW1zLmlucHV0cztcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50eFNpemUpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMudHhTaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zLnR4U2l6ZSA9IHBhcmFtcy50eFNpemU7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuY3BmcEF3YXJlKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5jcGZwQXdhcmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMuY3BmcEF3YXJlID0gcGFyYW1zLmNwZnBBd2FyZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy90eC9mZWUnKSkucXVlcnkocXVlcnlQYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBCaXRHbydzIGd1YXJhbnRlZSB1c2luZyBhbiBpbnN0YW50IGlkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIGluc3RhbnRHdWFyYW50ZWUocGFyYW1zOiB7IGlkOiBzdHJpbmcgfSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5pZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGlkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHRoaXMuZ2V0KHRoaXMudXJsKCcvaW5zdGFudC8nICsgcGFyYW1zLmlkKSkucmVzdWx0KCk7XG4gICAgaWYgKCFib2R5Lmd1YXJhbnRlZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBndWFyYW50ZWUgZm91bmQgaW4gcmVzcG9uc2UgYm9keScpO1xuICAgIH1cbiAgICBpZiAoIWJvZHkuc2lnbmF0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHNpZ25hdHVyZSBmb3VuZCBpbiBndWFyYW50ZWUgcmVzcG9uc2UgYm9keScpO1xuICAgIH1cbiAgICBjb25zdCBzaWduaW5nQWRkcmVzcyA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0uc2lnbmluZ0FkZHJlc3M7XG4gICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gQnVmZmVyLmZyb20oYm9keS5zaWduYXR1cmUsICdoZXgnKTtcbiAgICBjb25zdCBwcmVmaXggPSB1dHhvbGliLm5ldHdvcmtzW2NvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0ubmV0d29ya10ubWVzc2FnZVByZWZpeDtcbiAgICBjb25zdCBpc1ZhbGlkU2lnbmF0dXJlID0gYml0Y29pbk1lc3NhZ2UudmVyaWZ5KGJvZHkuZ3VhcmFudGVlLCBzaWduaW5nQWRkcmVzcywgc2lnbmF0dXJlQnVmZmVyLCBwcmVmaXgpO1xuICAgIGlmICghaXNWYWxpZFNpZ25hdHVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvcnJlY3Qgc2lnbmF0dXJlJyk7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHRhcmdldCBhZGRyZXNzIGZvciBwYXltZW50IG9mIGEgQml0R28gZmVlXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBnZXRCaXRHb0ZlZUFkZHJlc3MoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvYmlsbGluZy9hZGRyZXNzJykpLnNlbmQoe30pLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYWRkcmVzcyBvYmplY3QgKGluY2x1ZGluZyB0aGUgd2FsbGV0IGlkKSBmb3IgYSBnaXZlbiBhZGRyZXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gbG9vayB1cC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIGdldFdhbGxldEFkZHJlc3MoeyBhZGRyZXNzIH06IHsgYWRkcmVzczogc3RyaW5nIH0pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybChgL3dhbGxldGFkZHJlc3MvJHthZGRyZXNzfWApKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBsaXN0IG9mIHVzZXIgd2ViaG9va3NcbiAgICpcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBsaXN0V2ViaG9va3MoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy93ZWJob29rcycpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbmV3IHVzZXIgd2ViaG9va1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgYWRkV2ViaG9vayhwYXJhbXM6IFdlYmhvb2tPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnVybCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHVybCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHR5cGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvd2ViaG9va3MnKSkuc2VuZChwYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB1c2VyIHdlYmhvb2tcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIHJlbW92ZVdlYmhvb2socGFyYW1zOiBXZWJob29rT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy51cmwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB1cmwnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB0eXBlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGVsKHRoaXMudXJsKCcvd2ViaG9va3MnKSkuc2VuZChwYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxpc3Qgb2Ygd2ViaG9vayBub3RpZmljYXRpb25zIGZvciB0aGUgdXNlclxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgbGlzdFdlYmhvb2tOb3RpZmljYXRpb25zKHBhcmFtczogTGlzdFdlYmhvb2tOb3RpZmljYXRpb25zT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBxdWVyeTogYW55ID0ge307XG4gICAgaWYgKHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3dlYmhvb2tzL25vdGlmaWNhdGlvbnMnKSkucXVlcnkocXVlcnkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdXNlciB3ZWJob29rXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBzaW11bGF0ZVdlYmhvb2socGFyYW1zOiBCaXRHb1NpbXVsYXRlV2ViaG9va09wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2ViaG9va0lkJywgJ2Jsb2NrSWQnXSwgW10pO1xuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMud2ViaG9va0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgd2ViaG9va0lkJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5ibG9ja0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgYmxvY2tJZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoYC93ZWJob29rcy8ke3BhcmFtcy53ZWJob29rSWR9L3NpbXVsYXRlYCkpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXNseSBnZXQgY29uc3RhbnRzIHdoaWNoIGFyZSByZWxldmFudCB0byB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGhhcyBhIGtub3duIHJhY2UgY29uZGl0aW9uLiBJdCBtYXkgcmV0dXJuIGRpZmZlcmVudCB2YWx1ZXMgb3ZlciB0aW1lLFxuICAgKiBlc3BlY2lhbGx5IGlmIGNhbGxlZCBzaG9ydGx5IGFmdGVyIGNyZWF0aW9uIG9mIHRoZSBCaXRHbyBvYmplY3QuXG4gICAqXG4gICAqIE5ldyBjb2RlIHNob3VsZCBjYWxsIGZldGNoQ29uc3RhbnRzKCkgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xpZW50IGNvbnN0YW50cyBvYmplY3RcbiAgICovXG4gIGdldENvbnN0YW50cygpOiBhbnkge1xuICAgIC8vIGtpY2sgb2ZmIGEgZnJlc2ggcmVxdWVzdCBmb3IgdGhlIGNsaWVudCBjb25zdGFudHNcbiAgICB0aGlzLmZldGNoQ29uc3RhbnRzKCkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYW4gZXJyb3IgZG9lcyBub3QgdGVybWluYXRlIHRoZSBlbnRpcmUgc2NyaXB0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCBjbGllbnQgY29uc3RhbnRzIGZyb20gQml0R28nKTtcbiAgICAgICAgY29uc29sZS50cmFjZShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gdXNlIGRlZmF1bHRDb25zdGFudHMgYXMgdGhlIGJhY2t1cCBmb3Iga2V5cyB0aGF0IGFyZSBub3Qgc2V0IGluIHRoaXMuX2NvbnN0YW50c1xuICAgIHJldHVybiBfLm1lcmdlKHt9LCBkZWZhdWx0Q29uc3RhbnRzKHRoaXMuZ2V0RW52KCkpLCBCaXRHb0FQSS5fY29uc3RhbnRzW3RoaXMuZ2V0RW52KCldKTtcbiAgfVxufVxuIl19