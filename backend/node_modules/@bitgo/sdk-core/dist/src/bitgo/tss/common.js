"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTxRequestChallenge = exports.commonVerifyWalletSignature = exports.exchangeEddsaCommitments = exports.sendTxRequest = exports.sendSignatureShareV2 = exports.sendSignatureShare = exports.getTxRequest = void 0;
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("../utils");
/**
 * Gets the latest Tx Request by id
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest id
 * @param {IRequestTracer} reqId - the request tracer request id
 * @returns {Promise<TxRequest>}
 */
async function getTxRequest(bitgo, walletId, txRequestId, reqId) {
    const reqTracer = reqId || new utils_1.RequestTracer();
    bitgo.setRequestTracer(reqTracer);
    const txRequestRes = await bitgo
        .get(bitgo.url('/wallet/' + walletId + '/txrequests', 2))
        .query({ txRequestIds: txRequestId, latest: 'true' })
        .retry(3)
        .result();
    if (txRequestRes.txRequests.length <= 0) {
        throw new Error(`Unable to find TxRequest with id ${txRequestId}`);
    }
    return txRequestRes.txRequests[0];
}
exports.getTxRequest = getTxRequest;
/**
 * Sends a Signature Share
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id  *
 * @param {String} txRequestId - the txRequest Id
 * @param {SignatureShareRecord} signatureShare - a Signature Share
 * @param requestType - The type of request being submitted (either tx or message for signing)
 * @param signerShare
 * @param mpcAlgorithm
 * @param apiMode
 * @param {IRequestTracer} reqId - the request tracer request id
 * @returns {Promise<SignatureShareRecord>} - a Signature Share
 */
async function sendSignatureShare(bitgo, walletId, txRequestId, signatureShare, requestType, signerShare, mpcAlgorithm = 'eddsa', apiMode = 'lite', userPublicGpgKey, reqId) {
    let addendum = '';
    switch (requestType) {
        case utils_1.RequestType.tx:
            if (mpcAlgorithm === 'ecdsa' || apiMode === 'full') {
                addendum = '/transactions/0';
            }
            break;
        case utils_1.RequestType.message:
            if (mpcAlgorithm === 'ecdsa' || apiMode === 'full') {
                addendum = '/messages/0';
            }
            break;
    }
    const urlPath = '/wallet/' + walletId + '/txrequests/' + txRequestId + addendum + '/signatureshares';
    const reqTracer = reqId || new utils_1.RequestTracer();
    bitgo.setRequestTracer(reqTracer);
    return bitgo
        .post(bitgo.url(urlPath, 2))
        .send({
        signatureShare,
        signerShare,
        userPublicGpgKey,
    })
        .result();
}
exports.sendSignatureShare = sendSignatureShare;
/**
 * Sends a Signature Share using the sign txRequest route
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id  *
 * @param {String} txRequestId - the txRequest Id
 * @param signatureShares
 * @param requestType - The type of request being submitted (either tx or message for signing)
 * @param signerShare
 * @param mpcAlgorithm
 * @param multisigTypeVersion
 * @param signerGpgPublicKey
 * @param reqId
 * @returns {Promise<SignatureShareRecord>} - a Signature Share
 */
async function sendSignatureShareV2(bitgo, walletId, txRequestId, signatureShares, requestType, mpcAlgorithm, signerGpgPublicKey, signerShare, multisigTypeVersion, reqId) {
    const addendum = requestType === utils_1.RequestType.tx ? '/transactions/0' : '/messages/0';
    const urlPath = '/wallet/' + walletId + '/txrequests/' + txRequestId + addendum + '/sign';
    let type = '';
    if (multisigTypeVersion === 'MPCv2' && mpcAlgorithm === 'ecdsa') {
        type = 'ecdsaMpcV2';
    }
    else if (multisigTypeVersion === undefined && mpcAlgorithm === 'eddsa') {
        type = 'eddsaMpcV1';
    }
    const requestBody = {
        type,
        signatureShares,
        signerShare,
        signerGpgPublicKey,
    };
    const reqTracer = reqId || new utils_1.RequestTracer();
    bitgo.setRequestTracer(reqTracer);
    return bitgo.post(bitgo.url(urlPath, 2)).send(requestBody).result();
}
exports.sendSignatureShareV2 = sendSignatureShareV2;
/**
 * Sends a Transaction Request for broadcast once signing is complete
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id  *
 * @param {String} txRequestId - the txRequest Id
 * @param requestType - The type of request being submitted (either tx or message for signing)
 * @param {IRequestTracer} reqId - request tracer request id
 * @returns {Promise<SignatureShareRecord>} - a Signature Share
 */
async function sendTxRequest(bitgo, walletId, txRequestId, requestType, reqId) {
    const addendum = requestType === utils_1.RequestType.tx ? '/transactions/0' : '/messages/0';
    const urlPath = '/wallet/' + walletId + '/txrequests/' + txRequestId + addendum + '/send';
    const reqTracer = reqId || new utils_1.RequestTracer();
    bitgo.setRequestTracer(reqTracer);
    return bitgo.post(bitgo.url(urlPath, 2)).send().result();
}
exports.sendTxRequest = sendTxRequest;
/**
 * Sends the client commitment and encrypted signer share to the server, getting back the server commitment
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {string} walletId - the wallet id
 * @param {string} txRequestId - the txRequest Id
 * @param {CommitmentShareRecord} commitmentShare - the client commitment share
 * @param {EncryptedSignerShareRecord} encryptedSignerShare - the client encrypted signer share
 * @param {string} [apiMode] - the txRequest api mode (full or lite) - defaults to lite
 * @param {IRequestTracer} reqId - the request tracer request Id
 * @returns {Promise<ExchangeCommitmentResponse>} - the server commitment share
 */
async function exchangeEddsaCommitments(bitgo, walletId, txRequestId, commitmentShare, encryptedSignerShare, apiMode = 'lite', reqId) {
    let addendum = '';
    if (apiMode === 'full') {
        addendum = '/transactions/0';
    }
    const urlPath = '/wallet/' + walletId + '/txrequests/' + txRequestId + addendum + '/commit';
    const reqTracer = reqId || new utils_1.RequestTracer();
    bitgo.setRequestTracer(reqTracer);
    return await bitgo.post(bitgo.url(urlPath, 2)).send({ commitmentShare, encryptedSignerShare }).result();
}
exports.exchangeEddsaCommitments = exchangeEddsaCommitments;
/**
 * Verifies that a TSS wallet signature was produced with the expected key and that the signed data contains the
 * expected common keychain as well as the expected user and backup key ids
 */
async function commonVerifyWalletSignature(params) {
    const { walletSignature, bitgoPub, commonKeychain, userKeyId, backupKeyId } = params;
    // By ensuring that the fingerprints of the walletSignature and the bitgoPub are different and that any of the results
    // from calling verifyPrimaryUser is valid we know that the signature was actually produced by the private key
    // belonging to the bitgoPub.
    if (walletSignature.keyPacket.getFingerprint() === bitgoPub.keyPacket.getFingerprint()) {
        throw new Error('Invalid HSM GPG signature');
    }
    const verificationResult = await (0, utils_1.verifyPrimaryUserWrapper)(walletSignature, bitgoPub, false);
    const isValid = verificationResult.some((result) => result.valid);
    if (!isValid) {
        throw new Error('Invalid HSM GPG signature');
    }
    const primaryUser = await walletSignature.getPrimaryUser();
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore the rawNotations property is missing from the type but it actually exists
    const rawNotations = primaryUser.user.otherCertifications[0].rawNotations;
    (0, assert_1.default)(rawNotations.length === 5, 'invalid wallet signatures');
    (0, assert_1.default)(commonKeychain === Buffer.from(rawNotations[0].value).toString(), 'wallet signature does not match common keychain');
    (0, assert_1.default)(userKeyId === Buffer.from(rawNotations[1].value).toString(), `wallet signature does not match user key id`);
    (0, assert_1.default)(backupKeyId === Buffer.from(rawNotations[2].value).toString(), 'wallet signature does not match backup key id');
    return rawNotations;
}
exports.commonVerifyWalletSignature = commonVerifyWalletSignature;
/**
 * Gets challenge for a tx request from BitGo
 * supports Message and regular Transaction
 * @param bitgo
 * @param walletId
 * @param txRequestId
 * @param index
 * @param requestType
 * @param paillierModulus
 * @param reqId
 */
async function getTxRequestChallenge(bitgo, walletId, txRequestId, index, requestType, paillierModulus, reqId) {
    let addendum = '';
    switch (requestType) {
        case utils_1.RequestType.tx:
            addendum = '/transactions/' + index;
            break;
        case utils_1.RequestType.message:
            addendum = '/messages/' + index;
            break;
    }
    const urlPath = '/wallet/' + walletId + '/txrequests/' + txRequestId + addendum + '/challenge';
    const reqTracer = reqId || new utils_1.RequestTracer();
    bitgo.setRequestTracer(reqTracer);
    return await bitgo.post(bitgo.url(urlPath, 2)).send({ paillierModulus }).result();
}
exports.getTxRequestChallenge = getTxRequestChallenge;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3Rzcy9jb21tb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0RBQTRCO0FBSzVCLG9DQVNrQjtBQUdsQjs7Ozs7Ozs7R0FRRztBQUNJLEtBQUssVUFBVSxZQUFZLENBQ2hDLEtBQWdCLEVBQ2hCLFFBQWdCLEVBQ2hCLFdBQW1CLEVBQ25CLEtBQXNCO0lBRXRCLE1BQU0sU0FBUyxHQUFHLEtBQUssSUFBSSxJQUFJLHFCQUFhLEVBQUUsQ0FBQztJQUMvQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbEMsTUFBTSxZQUFZLEdBQUcsTUFBTSxLQUFLO1NBQzdCLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxRQUFRLEdBQUcsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3hELEtBQUssQ0FBQyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDO1NBQ3BELEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDUixNQUFNLEVBQUUsQ0FBQztJQUVaLElBQUksWUFBWSxDQUFDLFVBQVUsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO1FBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLFdBQVcsRUFBRSxDQUFDLENBQUM7S0FDcEU7SUFFRCxPQUFPLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsQ0FBQztBQW5CRCxvQ0FtQkM7QUFFRDs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0ksS0FBSyxVQUFVLGtCQUFrQixDQUN0QyxLQUFnQixFQUNoQixRQUFnQixFQUNoQixXQUFtQixFQUNuQixjQUFvQyxFQUNwQyxXQUF3QixFQUN4QixXQUFvQixFQUNwQixlQUFrQyxPQUFPLEVBQ3pDLFVBQTJCLE1BQU0sRUFDakMsZ0JBQXlCLEVBQ3pCLEtBQXNCO0lBRXRCLElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNsQixRQUFRLFdBQVcsRUFBRTtRQUNuQixLQUFLLG1CQUFXLENBQUMsRUFBRTtZQUNqQixJQUFJLFlBQVksS0FBSyxPQUFPLElBQUksT0FBTyxLQUFLLE1BQU0sRUFBRTtnQkFDbEQsUUFBUSxHQUFHLGlCQUFpQixDQUFDO2FBQzlCO1lBQ0QsTUFBTTtRQUNSLEtBQUssbUJBQVcsQ0FBQyxPQUFPO1lBQ3RCLElBQUksWUFBWSxLQUFLLE9BQU8sSUFBSSxPQUFPLEtBQUssTUFBTSxFQUFFO2dCQUNsRCxRQUFRLEdBQUcsYUFBYSxDQUFDO2FBQzFCO1lBQ0QsTUFBTTtLQUNUO0lBQ0QsTUFBTSxPQUFPLEdBQUcsVUFBVSxHQUFHLFFBQVEsR0FBRyxjQUFjLEdBQUcsV0FBVyxHQUFHLFFBQVEsR0FBRyxrQkFBa0IsQ0FBQztJQUNyRyxNQUFNLFNBQVMsR0FBRyxLQUFLLElBQUksSUFBSSxxQkFBYSxFQUFFLENBQUM7SUFDL0MsS0FBSyxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2xDLE9BQU8sS0FBSztTQUNULElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztTQUMzQixJQUFJLENBQUM7UUFDSixjQUFjO1FBQ2QsV0FBVztRQUNYLGdCQUFnQjtLQUNqQixDQUFDO1NBQ0QsTUFBTSxFQUFFLENBQUM7QUFDZCxDQUFDO0FBcENELGdEQW9DQztBQUVEOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0ksS0FBSyxVQUFVLG9CQUFvQixDQUN4QyxLQUFnQixFQUNoQixRQUFnQixFQUNoQixXQUFtQixFQUNuQixlQUF1QyxFQUN2QyxXQUF3QixFQUN4QixZQUErQixFQUMvQixrQkFBMEIsRUFDMUIsV0FBb0IsRUFDcEIsbUJBQXlDLEVBQ3pDLEtBQXNCO0lBRXRCLE1BQU0sUUFBUSxHQUFHLFdBQVcsS0FBSyxtQkFBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztJQUNwRixNQUFNLE9BQU8sR0FBRyxVQUFVLEdBQUcsUUFBUSxHQUFHLGNBQWMsR0FBRyxXQUFXLEdBQUcsUUFBUSxHQUFHLE9BQU8sQ0FBQztJQUMxRixJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7SUFDZCxJQUFJLG1CQUFtQixLQUFLLE9BQU8sSUFBSSxZQUFZLEtBQUssT0FBTyxFQUFFO1FBQy9ELElBQUksR0FBRyxZQUFZLENBQUM7S0FDckI7U0FBTSxJQUFJLG1CQUFtQixLQUFLLFNBQVMsSUFBSSxZQUFZLEtBQUssT0FBTyxFQUFFO1FBQ3hFLElBQUksR0FBRyxZQUFZLENBQUM7S0FDckI7SUFDRCxNQUFNLFdBQVcsR0FBRztRQUNsQixJQUFJO1FBQ0osZUFBZTtRQUNmLFdBQVc7UUFDWCxrQkFBa0I7S0FDbkIsQ0FBQztJQUNGLE1BQU0sU0FBUyxHQUFHLEtBQUssSUFBSSxJQUFJLHFCQUFhLEVBQUUsQ0FBQztJQUMvQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbEMsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ3RFLENBQUM7QUE3QkQsb0RBNkJDO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0ksS0FBSyxVQUFVLGFBQWEsQ0FDakMsS0FBZ0IsRUFDaEIsUUFBZ0IsRUFDaEIsV0FBbUIsRUFDbkIsV0FBd0IsRUFDeEIsS0FBc0I7SUFFdEIsTUFBTSxRQUFRLEdBQUcsV0FBVyxLQUFLLG1CQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDO0lBQ3BGLE1BQU0sT0FBTyxHQUFHLFVBQVUsR0FBRyxRQUFRLEdBQUcsY0FBYyxHQUFHLFdBQVcsR0FBRyxRQUFRLEdBQUcsT0FBTyxDQUFDO0lBQzFGLE1BQU0sU0FBUyxHQUFHLEtBQUssSUFBSSxJQUFJLHFCQUFhLEVBQUUsQ0FBQztJQUMvQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbEMsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDM0QsQ0FBQztBQVpELHNDQVlDO0FBRUQ7Ozs7Ozs7Ozs7R0FVRztBQUNJLEtBQUssVUFBVSx3QkFBd0IsQ0FDNUMsS0FBZ0IsRUFDaEIsUUFBZ0IsRUFDaEIsV0FBbUIsRUFDbkIsZUFBc0MsRUFDdEMsb0JBQWdELEVBQ2hELFVBQTJCLE1BQU0sRUFDakMsS0FBc0I7SUFFdEIsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO0lBQ2xCLElBQUksT0FBTyxLQUFLLE1BQU0sRUFBRTtRQUN0QixRQUFRLEdBQUcsaUJBQWlCLENBQUM7S0FDOUI7SUFDRCxNQUFNLE9BQU8sR0FBRyxVQUFVLEdBQUcsUUFBUSxHQUFHLGNBQWMsR0FBRyxXQUFXLEdBQUcsUUFBUSxHQUFHLFNBQVMsQ0FBQztJQUM1RixNQUFNLFNBQVMsR0FBRyxLQUFLLElBQUksSUFBSSxxQkFBYSxFQUFFLENBQUM7SUFDL0MsS0FBSyxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2xDLE9BQU8sTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsZUFBZSxFQUFFLG9CQUFvQixFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUMxRyxDQUFDO0FBakJELDREQWlCQztBQUVEOzs7R0FHRztBQUNJLEtBQUssVUFBVSwyQkFBMkIsQ0FBQyxNQU1qRDtJQUNDLE1BQU0sRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLEdBQUcsTUFBTSxDQUFDO0lBRXJGLHNIQUFzSDtJQUN0SCw4R0FBOEc7SUFDOUcsNkJBQTZCO0lBQzdCLElBQUksZUFBZSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUUsS0FBSyxRQUFRLENBQUMsU0FBUyxDQUFDLGNBQWMsRUFBRSxFQUFFO1FBQ3RGLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztLQUM5QztJQUVELE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxJQUFBLGdDQUF3QixFQUFDLGVBQWUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDNUYsTUFBTSxPQUFPLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbEUsSUFBSSxDQUFDLE9BQU8sRUFBRTtRQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztLQUM5QztJQUNELE1BQU0sV0FBVyxHQUFHLE1BQU0sZUFBZSxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBRTNELDZEQUE2RDtJQUM3RCx1RkFBdUY7SUFDdkYsTUFBTSxZQUFZLEdBQTRCLFdBQVcsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO0lBRW5HLElBQUEsZ0JBQU0sRUFBQyxZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSwyQkFBMkIsQ0FBQyxDQUFDO0lBRS9ELElBQUEsZ0JBQU0sRUFDSixjQUFjLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQ2hFLGlEQUFpRCxDQUNsRCxDQUFDO0lBQ0YsSUFBQSxnQkFBTSxFQUFDLFNBQVMsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSw2Q0FBNkMsQ0FBQyxDQUFDO0lBQ25ILElBQUEsZ0JBQU0sRUFDSixXQUFXLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQzdELCtDQUErQyxDQUNoRCxDQUFDO0lBRUYsT0FBTyxZQUFZLENBQUM7QUFDdEIsQ0FBQztBQXhDRCxrRUF3Q0M7QUFFRDs7Ozs7Ozs7OztHQVVHO0FBQ0ksS0FBSyxVQUFVLHFCQUFxQixDQUN6QyxLQUFnQixFQUNoQixRQUFnQixFQUNoQixXQUFtQixFQUNuQixLQUFhLEVBQ2IsV0FBd0IsRUFDeEIsZUFBdUIsRUFDdkIsS0FBc0I7SUFFdEIsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO0lBQ2xCLFFBQVEsV0FBVyxFQUFFO1FBQ25CLEtBQUssbUJBQVcsQ0FBQyxFQUFFO1lBQ2pCLFFBQVEsR0FBRyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7WUFDcEMsTUFBTTtRQUNSLEtBQUssbUJBQVcsQ0FBQyxPQUFPO1lBQ3RCLFFBQVEsR0FBRyxZQUFZLEdBQUcsS0FBSyxDQUFDO1lBQ2hDLE1BQU07S0FDVDtJQUNELE1BQU0sT0FBTyxHQUFHLFVBQVUsR0FBRyxRQUFRLEdBQUcsY0FBYyxHQUFHLFdBQVcsR0FBRyxRQUFRLEdBQUcsWUFBWSxDQUFDO0lBQy9GLE1BQU0sU0FBUyxHQUFHLEtBQUssSUFBSSxJQUFJLHFCQUFhLEVBQUUsQ0FBQztJQUMvQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbEMsT0FBTyxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ3BGLENBQUM7QUF0QkQsc0RBc0JDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IG9wZW5wZ3AgZnJvbSAnb3BlbnBncCc7XG5cbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgeyBUeFJlcXVlc3RDaGFsbGVuZ2VSZXNwb25zZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgUmVxdWVzdFR5cGUsXG4gIFR4UmVxdWVzdCxcbiAgdmVyaWZ5UHJpbWFyeVVzZXJXcmFwcGVyLFxuICBTaWduYXR1cmVTaGFyZVJlY29yZCxcbiAgQ29tbWl0bWVudFNoYXJlUmVjb3JkLFxuICBFbmNyeXB0ZWRTaWduZXJTaGFyZVJlY29yZCxcbiAgRXhjaGFuZ2VDb21taXRtZW50UmVzcG9uc2UsXG4gIFJlcXVlc3RUcmFjZXIsXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IElSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi4vLi4vYXBpJztcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXRlc3QgVHggUmVxdWVzdCBieSBpZFxuICpcbiAqIEBwYXJhbSB7Qml0R29CYXNlfSBiaXRnbyAtIHRoZSBiaXRnbyBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IHdhbGxldElkIC0gdGhlIHdhbGxldCBpZFxuICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBpZFxuICogQHBhcmFtIHtJUmVxdWVzdFRyYWNlcn0gcmVxSWQgLSB0aGUgcmVxdWVzdCB0cmFjZXIgcmVxdWVzdCBpZFxuICogQHJldHVybnMge1Byb21pc2U8VHhSZXF1ZXN0Pn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFR4UmVxdWVzdChcbiAgYml0Z286IEJpdEdvQmFzZSxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgdHhSZXF1ZXN0SWQ6IHN0cmluZyxcbiAgcmVxSWQ/OiBJUmVxdWVzdFRyYWNlclxuKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgY29uc3QgcmVxVHJhY2VyID0gcmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFUcmFjZXIpO1xuICBjb25zdCB0eFJlcXVlc3RSZXMgPSBhd2FpdCBiaXRnb1xuICAgIC5nZXQoYml0Z28udXJsKCcvd2FsbGV0LycgKyB3YWxsZXRJZCArICcvdHhyZXF1ZXN0cycsIDIpKVxuICAgIC5xdWVyeSh7IHR4UmVxdWVzdElkczogdHhSZXF1ZXN0SWQsIGxhdGVzdDogJ3RydWUnIH0pXG4gICAgLnJldHJ5KDMpXG4gICAgLnJlc3VsdCgpO1xuXG4gIGlmICh0eFJlcXVlc3RSZXMudHhSZXF1ZXN0cy5sZW5ndGggPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgVHhSZXF1ZXN0IHdpdGggaWQgJHt0eFJlcXVlc3RJZH1gKTtcbiAgfVxuXG4gIHJldHVybiB0eFJlcXVlc3RSZXMudHhSZXF1ZXN0c1swXTtcbn1cblxuLyoqXG4gKiBTZW5kcyBhIFNpZ25hdHVyZSBTaGFyZVxuICpcbiAqIEBwYXJhbSB7Qml0R29CYXNlfSBiaXRnbyAtIHRoZSBiaXRnbyBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IHdhbGxldElkIC0gdGhlIHdhbGxldCBpZCAgKlxuICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICogQHBhcmFtIHtTaWduYXR1cmVTaGFyZVJlY29yZH0gc2lnbmF0dXJlU2hhcmUgLSBhIFNpZ25hdHVyZSBTaGFyZVxuICogQHBhcmFtIHJlcXVlc3RUeXBlIC0gVGhlIHR5cGUgb2YgcmVxdWVzdCBiZWluZyBzdWJtaXR0ZWQgKGVpdGhlciB0eCBvciBtZXNzYWdlIGZvciBzaWduaW5nKVxuICogQHBhcmFtIHNpZ25lclNoYXJlXG4gKiBAcGFyYW0gbXBjQWxnb3JpdGhtXG4gKiBAcGFyYW0gYXBpTW9kZVxuICogQHBhcmFtIHtJUmVxdWVzdFRyYWNlcn0gcmVxSWQgLSB0aGUgcmVxdWVzdCB0cmFjZXIgcmVxdWVzdCBpZFxuICogQHJldHVybnMge1Byb21pc2U8U2lnbmF0dXJlU2hhcmVSZWNvcmQ+fSAtIGEgU2lnbmF0dXJlIFNoYXJlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kU2lnbmF0dXJlU2hhcmUoXG4gIGJpdGdvOiBCaXRHb0Jhc2UsXG4gIHdhbGxldElkOiBzdHJpbmcsXG4gIHR4UmVxdWVzdElkOiBzdHJpbmcsXG4gIHNpZ25hdHVyZVNoYXJlOiBTaWduYXR1cmVTaGFyZVJlY29yZCxcbiAgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlLFxuICBzaWduZXJTaGFyZT86IHN0cmluZyxcbiAgbXBjQWxnb3JpdGhtOiAnZWRkc2EnIHwgJ2VjZHNhJyA9ICdlZGRzYScsXG4gIGFwaU1vZGU6ICdmdWxsJyB8ICdsaXRlJyA9ICdsaXRlJyxcbiAgdXNlclB1YmxpY0dwZ0tleT86IHN0cmluZyxcbiAgcmVxSWQ/OiBJUmVxdWVzdFRyYWNlclxuKTogUHJvbWlzZTxTaWduYXR1cmVTaGFyZVJlY29yZD4ge1xuICBsZXQgYWRkZW5kdW0gPSAnJztcbiAgc3dpdGNoIChyZXF1ZXN0VHlwZSkge1xuICAgIGNhc2UgUmVxdWVzdFR5cGUudHg6XG4gICAgICBpZiAobXBjQWxnb3JpdGhtID09PSAnZWNkc2EnIHx8IGFwaU1vZGUgPT09ICdmdWxsJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcvdHJhbnNhY3Rpb25zLzAnO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSZXF1ZXN0VHlwZS5tZXNzYWdlOlxuICAgICAgaWYgKG1wY0FsZ29yaXRobSA9PT0gJ2VjZHNhJyB8fCBhcGlNb2RlID09PSAnZnVsbCcpIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnL21lc3NhZ2VzLzAnO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgY29uc3QgdXJsUGF0aCA9ICcvd2FsbGV0LycgKyB3YWxsZXRJZCArICcvdHhyZXF1ZXN0cy8nICsgdHhSZXF1ZXN0SWQgKyBhZGRlbmR1bSArICcvc2lnbmF0dXJlc2hhcmVzJztcbiAgY29uc3QgcmVxVHJhY2VyID0gcmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFUcmFjZXIpO1xuICByZXR1cm4gYml0Z29cbiAgICAucG9zdChiaXRnby51cmwodXJsUGF0aCwgMikpXG4gICAgLnNlbmQoe1xuICAgICAgc2lnbmF0dXJlU2hhcmUsXG4gICAgICBzaWduZXJTaGFyZSxcbiAgICAgIHVzZXJQdWJsaWNHcGdLZXksXG4gICAgfSlcbiAgICAucmVzdWx0KCk7XG59XG5cbi8qKlxuICogU2VuZHMgYSBTaWduYXR1cmUgU2hhcmUgdXNpbmcgdGhlIHNpZ24gdHhSZXF1ZXN0IHJvdXRlXG4gKlxuICogQHBhcmFtIHtCaXRHb0Jhc2V9IGJpdGdvIC0gdGhlIGJpdGdvIGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gd2FsbGV0SWQgLSB0aGUgd2FsbGV0IGlkICAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHhSZXF1ZXN0SWQgLSB0aGUgdHhSZXF1ZXN0IElkXG4gKiBAcGFyYW0gc2lnbmF0dXJlU2hhcmVzXG4gKiBAcGFyYW0gcmVxdWVzdFR5cGUgLSBUaGUgdHlwZSBvZiByZXF1ZXN0IGJlaW5nIHN1Ym1pdHRlZCAoZWl0aGVyIHR4IG9yIG1lc3NhZ2UgZm9yIHNpZ25pbmcpXG4gKiBAcGFyYW0gc2lnbmVyU2hhcmVcbiAqIEBwYXJhbSBtcGNBbGdvcml0aG1cbiAqIEBwYXJhbSBtdWx0aXNpZ1R5cGVWZXJzaW9uXG4gKiBAcGFyYW0gc2lnbmVyR3BnUHVibGljS2V5XG4gKiBAcGFyYW0gcmVxSWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25hdHVyZVNoYXJlUmVjb3JkPn0gLSBhIFNpZ25hdHVyZSBTaGFyZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZFNpZ25hdHVyZVNoYXJlVjIoXG4gIGJpdGdvOiBCaXRHb0Jhc2UsXG4gIHdhbGxldElkOiBzdHJpbmcsXG4gIHR4UmVxdWVzdElkOiBzdHJpbmcsXG4gIHNpZ25hdHVyZVNoYXJlczogU2lnbmF0dXJlU2hhcmVSZWNvcmRbXSxcbiAgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlLFxuICBtcGNBbGdvcml0aG06ICdlZGRzYScgfCAnZWNkc2EnLFxuICBzaWduZXJHcGdQdWJsaWNLZXk6IHN0cmluZyxcbiAgc2lnbmVyU2hhcmU/OiBzdHJpbmcsXG4gIG11bHRpc2lnVHlwZVZlcnNpb24/OiAnTVBDdjInIHwgdW5kZWZpbmVkLFxuICByZXFJZD86IElSZXF1ZXN0VHJhY2VyXG4pOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICBjb25zdCBhZGRlbmR1bSA9IHJlcXVlc3RUeXBlID09PSBSZXF1ZXN0VHlwZS50eCA/ICcvdHJhbnNhY3Rpb25zLzAnIDogJy9tZXNzYWdlcy8wJztcbiAgY29uc3QgdXJsUGF0aCA9ICcvd2FsbGV0LycgKyB3YWxsZXRJZCArICcvdHhyZXF1ZXN0cy8nICsgdHhSZXF1ZXN0SWQgKyBhZGRlbmR1bSArICcvc2lnbic7XG4gIGxldCB0eXBlID0gJyc7XG4gIGlmIChtdWx0aXNpZ1R5cGVWZXJzaW9uID09PSAnTVBDdjInICYmIG1wY0FsZ29yaXRobSA9PT0gJ2VjZHNhJykge1xuICAgIHR5cGUgPSAnZWNkc2FNcGNWMic7XG4gIH0gZWxzZSBpZiAobXVsdGlzaWdUeXBlVmVyc2lvbiA9PT0gdW5kZWZpbmVkICYmIG1wY0FsZ29yaXRobSA9PT0gJ2VkZHNhJykge1xuICAgIHR5cGUgPSAnZWRkc2FNcGNWMSc7XG4gIH1cbiAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgdHlwZSxcbiAgICBzaWduYXR1cmVTaGFyZXMsXG4gICAgc2lnbmVyU2hhcmUsXG4gICAgc2lnbmVyR3BnUHVibGljS2V5LFxuICB9O1xuICBjb25zdCByZXFUcmFjZXIgPSByZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICBiaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcVRyYWNlcik7XG4gIHJldHVybiBiaXRnby5wb3N0KGJpdGdvLnVybCh1cmxQYXRoLCAyKSkuc2VuZChyZXF1ZXN0Qm9keSkucmVzdWx0KCk7XG59XG5cbi8qKlxuICogU2VuZHMgYSBUcmFuc2FjdGlvbiBSZXF1ZXN0IGZvciBicm9hZGNhc3Qgb25jZSBzaWduaW5nIGlzIGNvbXBsZXRlXG4gKlxuICogQHBhcmFtIHtCaXRHb0Jhc2V9IGJpdGdvIC0gdGhlIGJpdGdvIGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gd2FsbGV0SWQgLSB0aGUgd2FsbGV0IGlkICAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHhSZXF1ZXN0SWQgLSB0aGUgdHhSZXF1ZXN0IElkXG4gKiBAcGFyYW0gcmVxdWVzdFR5cGUgLSBUaGUgdHlwZSBvZiByZXF1ZXN0IGJlaW5nIHN1Ym1pdHRlZCAoZWl0aGVyIHR4IG9yIG1lc3NhZ2UgZm9yIHNpZ25pbmcpXG4gKiBAcGFyYW0ge0lSZXF1ZXN0VHJhY2VyfSByZXFJZCAtIHJlcXVlc3QgdHJhY2VyIHJlcXVlc3QgaWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25hdHVyZVNoYXJlUmVjb3JkPn0gLSBhIFNpZ25hdHVyZSBTaGFyZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZFR4UmVxdWVzdChcbiAgYml0Z286IEJpdEdvQmFzZSxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgdHhSZXF1ZXN0SWQ6IHN0cmluZyxcbiAgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlLFxuICByZXFJZD86IElSZXF1ZXN0VHJhY2VyXG4pOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICBjb25zdCBhZGRlbmR1bSA9IHJlcXVlc3RUeXBlID09PSBSZXF1ZXN0VHlwZS50eCA/ICcvdHJhbnNhY3Rpb25zLzAnIDogJy9tZXNzYWdlcy8wJztcbiAgY29uc3QgdXJsUGF0aCA9ICcvd2FsbGV0LycgKyB3YWxsZXRJZCArICcvdHhyZXF1ZXN0cy8nICsgdHhSZXF1ZXN0SWQgKyBhZGRlbmR1bSArICcvc2VuZCc7XG4gIGNvbnN0IHJlcVRyYWNlciA9IHJlcUlkIHx8IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG4gIGJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxVHJhY2VyKTtcbiAgcmV0dXJuIGJpdGdvLnBvc3QoYml0Z28udXJsKHVybFBhdGgsIDIpKS5zZW5kKCkucmVzdWx0KCk7XG59XG5cbi8qKlxuICogU2VuZHMgdGhlIGNsaWVudCBjb21taXRtZW50IGFuZCBlbmNyeXB0ZWQgc2lnbmVyIHNoYXJlIHRvIHRoZSBzZXJ2ZXIsIGdldHRpbmcgYmFjayB0aGUgc2VydmVyIGNvbW1pdG1lbnRcbiAqIEBwYXJhbSB7Qml0R29CYXNlfSBiaXRnbyAtIHRoZSBiaXRnbyBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIC0gdGhlIHdhbGxldCBpZFxuICogQHBhcmFtIHtzdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICogQHBhcmFtIHtDb21taXRtZW50U2hhcmVSZWNvcmR9IGNvbW1pdG1lbnRTaGFyZSAtIHRoZSBjbGllbnQgY29tbWl0bWVudCBzaGFyZVxuICogQHBhcmFtIHtFbmNyeXB0ZWRTaWduZXJTaGFyZVJlY29yZH0gZW5jcnlwdGVkU2lnbmVyU2hhcmUgLSB0aGUgY2xpZW50IGVuY3J5cHRlZCBzaWduZXIgc2hhcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXBpTW9kZV0gLSB0aGUgdHhSZXF1ZXN0IGFwaSBtb2RlIChmdWxsIG9yIGxpdGUpIC0gZGVmYXVsdHMgdG8gbGl0ZVxuICogQHBhcmFtIHtJUmVxdWVzdFRyYWNlcn0gcmVxSWQgLSB0aGUgcmVxdWVzdCB0cmFjZXIgcmVxdWVzdCBJZFxuICogQHJldHVybnMge1Byb21pc2U8RXhjaGFuZ2VDb21taXRtZW50UmVzcG9uc2U+fSAtIHRoZSBzZXJ2ZXIgY29tbWl0bWVudCBzaGFyZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhjaGFuZ2VFZGRzYUNvbW1pdG1lbnRzKFxuICBiaXRnbzogQml0R29CYXNlLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICB0eFJlcXVlc3RJZDogc3RyaW5nLFxuICBjb21taXRtZW50U2hhcmU6IENvbW1pdG1lbnRTaGFyZVJlY29yZCxcbiAgZW5jcnlwdGVkU2lnbmVyU2hhcmU6IEVuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkLFxuICBhcGlNb2RlOiAnZnVsbCcgfCAnbGl0ZScgPSAnbGl0ZScsXG4gIHJlcUlkPzogSVJlcXVlc3RUcmFjZXJcbik6IFByb21pc2U8RXhjaGFuZ2VDb21taXRtZW50UmVzcG9uc2U+IHtcbiAgbGV0IGFkZGVuZHVtID0gJyc7XG4gIGlmIChhcGlNb2RlID09PSAnZnVsbCcpIHtcbiAgICBhZGRlbmR1bSA9ICcvdHJhbnNhY3Rpb25zLzAnO1xuICB9XG4gIGNvbnN0IHVybFBhdGggPSAnL3dhbGxldC8nICsgd2FsbGV0SWQgKyAnL3R4cmVxdWVzdHMvJyArIHR4UmVxdWVzdElkICsgYWRkZW5kdW0gKyAnL2NvbW1pdCc7XG4gIGNvbnN0IHJlcVRyYWNlciA9IHJlcUlkIHx8IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG4gIGJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxVHJhY2VyKTtcbiAgcmV0dXJuIGF3YWl0IGJpdGdvLnBvc3QoYml0Z28udXJsKHVybFBhdGgsIDIpKS5zZW5kKHsgY29tbWl0bWVudFNoYXJlLCBlbmNyeXB0ZWRTaWduZXJTaGFyZSB9KS5yZXN1bHQoKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGEgVFNTIHdhbGxldCBzaWduYXR1cmUgd2FzIHByb2R1Y2VkIHdpdGggdGhlIGV4cGVjdGVkIGtleSBhbmQgdGhhdCB0aGUgc2lnbmVkIGRhdGEgY29udGFpbnMgdGhlXG4gKiBleHBlY3RlZCBjb21tb24ga2V5Y2hhaW4gYXMgd2VsbCBhcyB0aGUgZXhwZWN0ZWQgdXNlciBhbmQgYmFja3VwIGtleSBpZHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbW1vblZlcmlmeVdhbGxldFNpZ25hdHVyZShwYXJhbXM6IHtcbiAgd2FsbGV0U2lnbmF0dXJlOiBvcGVucGdwLktleTtcbiAgYml0Z29QdWI6IG9wZW5wZ3AuS2V5O1xuICBjb21tb25LZXljaGFpbjogc3RyaW5nO1xuICB1c2VyS2V5SWQ6IHN0cmluZztcbiAgYmFja3VwS2V5SWQ6IHN0cmluZztcbn0pOiBQcm9taXNlPHsgdmFsdWU6IEFycmF5QnVmZmVyIH1bXT4ge1xuICBjb25zdCB7IHdhbGxldFNpZ25hdHVyZSwgYml0Z29QdWIsIGNvbW1vbktleWNoYWluLCB1c2VyS2V5SWQsIGJhY2t1cEtleUlkIH0gPSBwYXJhbXM7XG5cbiAgLy8gQnkgZW5zdXJpbmcgdGhhdCB0aGUgZmluZ2VycHJpbnRzIG9mIHRoZSB3YWxsZXRTaWduYXR1cmUgYW5kIHRoZSBiaXRnb1B1YiBhcmUgZGlmZmVyZW50IGFuZCB0aGF0IGFueSBvZiB0aGUgcmVzdWx0c1xuICAvLyBmcm9tIGNhbGxpbmcgdmVyaWZ5UHJpbWFyeVVzZXIgaXMgdmFsaWQgd2Uga25vdyB0aGF0IHRoZSBzaWduYXR1cmUgd2FzIGFjdHVhbGx5IHByb2R1Y2VkIGJ5IHRoZSBwcml2YXRlIGtleVxuICAvLyBiZWxvbmdpbmcgdG8gdGhlIGJpdGdvUHViLlxuICBpZiAod2FsbGV0U2lnbmF0dXJlLmtleVBhY2tldC5nZXRGaW5nZXJwcmludCgpID09PSBiaXRnb1B1Yi5rZXlQYWNrZXQuZ2V0RmluZ2VycHJpbnQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBIU00gR1BHIHNpZ25hdHVyZScpO1xuICB9XG5cbiAgY29uc3QgdmVyaWZpY2F0aW9uUmVzdWx0ID0gYXdhaXQgdmVyaWZ5UHJpbWFyeVVzZXJXcmFwcGVyKHdhbGxldFNpZ25hdHVyZSwgYml0Z29QdWIsIGZhbHNlKTtcbiAgY29uc3QgaXNWYWxpZCA9IHZlcmlmaWNhdGlvblJlc3VsdC5zb21lKChyZXN1bHQpID0+IHJlc3VsdC52YWxpZCk7XG4gIGlmICghaXNWYWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBIU00gR1BHIHNpZ25hdHVyZScpO1xuICB9XG4gIGNvbnN0IHByaW1hcnlVc2VyID0gYXdhaXQgd2FsbGV0U2lnbmF0dXJlLmdldFByaW1hcnlVc2VyKCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlIHRoZSByYXdOb3RhdGlvbnMgcHJvcGVydHkgaXMgbWlzc2luZyBmcm9tIHRoZSB0eXBlIGJ1dCBpdCBhY3R1YWxseSBleGlzdHNcbiAgY29uc3QgcmF3Tm90YXRpb25zOiB7IHZhbHVlOiBVaW50OEFycmF5IH1bXSA9IHByaW1hcnlVc2VyLnVzZXIub3RoZXJDZXJ0aWZpY2F0aW9uc1swXS5yYXdOb3RhdGlvbnM7XG5cbiAgYXNzZXJ0KHJhd05vdGF0aW9ucy5sZW5ndGggPT09IDUsICdpbnZhbGlkIHdhbGxldCBzaWduYXR1cmVzJyk7XG5cbiAgYXNzZXJ0KFxuICAgIGNvbW1vbktleWNoYWluID09PSBCdWZmZXIuZnJvbShyYXdOb3RhdGlvbnNbMF0udmFsdWUpLnRvU3RyaW5nKCksXG4gICAgJ3dhbGxldCBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggY29tbW9uIGtleWNoYWluJ1xuICApO1xuICBhc3NlcnQodXNlcktleUlkID09PSBCdWZmZXIuZnJvbShyYXdOb3RhdGlvbnNbMV0udmFsdWUpLnRvU3RyaW5nKCksIGB3YWxsZXQgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIHVzZXIga2V5IGlkYCk7XG4gIGFzc2VydChcbiAgICBiYWNrdXBLZXlJZCA9PT0gQnVmZmVyLmZyb20ocmF3Tm90YXRpb25zWzJdLnZhbHVlKS50b1N0cmluZygpLFxuICAgICd3YWxsZXQgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGJhY2t1cCBrZXkgaWQnXG4gICk7XG5cbiAgcmV0dXJuIHJhd05vdGF0aW9ucztcbn1cblxuLyoqXG4gKiBHZXRzIGNoYWxsZW5nZSBmb3IgYSB0eCByZXF1ZXN0IGZyb20gQml0R29cbiAqIHN1cHBvcnRzIE1lc3NhZ2UgYW5kIHJlZ3VsYXIgVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBiaXRnb1xuICogQHBhcmFtIHdhbGxldElkXG4gKiBAcGFyYW0gdHhSZXF1ZXN0SWRcbiAqIEBwYXJhbSBpbmRleFxuICogQHBhcmFtIHJlcXVlc3RUeXBlXG4gKiBAcGFyYW0gcGFpbGxpZXJNb2R1bHVzXG4gKiBAcGFyYW0gcmVxSWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFR4UmVxdWVzdENoYWxsZW5nZShcbiAgYml0Z286IEJpdEdvQmFzZSxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgdHhSZXF1ZXN0SWQ6IHN0cmluZyxcbiAgaW5kZXg6IHN0cmluZyxcbiAgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlLFxuICBwYWlsbGllck1vZHVsdXM6IHN0cmluZyxcbiAgcmVxSWQ/OiBJUmVxdWVzdFRyYWNlclxuKTogUHJvbWlzZTxUeFJlcXVlc3RDaGFsbGVuZ2VSZXNwb25zZT4ge1xuICBsZXQgYWRkZW5kdW0gPSAnJztcbiAgc3dpdGNoIChyZXF1ZXN0VHlwZSkge1xuICAgIGNhc2UgUmVxdWVzdFR5cGUudHg6XG4gICAgICBhZGRlbmR1bSA9ICcvdHJhbnNhY3Rpb25zLycgKyBpbmRleDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUmVxdWVzdFR5cGUubWVzc2FnZTpcbiAgICAgIGFkZGVuZHVtID0gJy9tZXNzYWdlcy8nICsgaW5kZXg7XG4gICAgICBicmVhaztcbiAgfVxuICBjb25zdCB1cmxQYXRoID0gJy93YWxsZXQvJyArIHdhbGxldElkICsgJy90eHJlcXVlc3RzLycgKyB0eFJlcXVlc3RJZCArIGFkZGVuZHVtICsgJy9jaGFsbGVuZ2UnO1xuICBjb25zdCByZXFUcmFjZXIgPSByZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICBiaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcVRyYWNlcik7XG4gIHJldHVybiBhd2FpdCBiaXRnby5wb3N0KGJpdGdvLnVybCh1cmxQYXRoLCAyKSkuc2VuZCh7IHBhaWxsaWVyTW9kdWx1cyB9KS5yZXN1bHQoKTtcbn1cbiJdfQ==