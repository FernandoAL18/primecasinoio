"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingApproval = void 0;
/**
 * @prettier
 */
const _ = __importStar(require("lodash"));
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const pendingApproval_1 = require("../pendingApproval");
const utils_1 = require("../utils");
const BuildParams_1 = require("../wallet/BuildParams");
const eddsa_1 = __importDefault(require("../utils/tss/eddsa"));
const ecdsa_1 = require("../utils/tss/ecdsa");
class PendingApproval {
    constructor(bitgo, baseCoin, pendingApprovalData, wallet) {
        var _a;
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
        this.wallet = wallet;
        if (this.baseCoin.supportsTss()) {
            if (this.baseCoin.getMPCAlgorithm() === 'ecdsa') {
                if (((_a = this.wallet) === null || _a === void 0 ? void 0 : _a.multisigTypeVersion()) === 'MPCv2') {
                    this.tssUtils = new ecdsa_1.EcdsaMPCv2Utils(this.bitgo, this.baseCoin, wallet);
                }
                else {
                    this.tssUtils = new ecdsa_1.EcdsaUtils(this.bitgo, this.baseCoin, wallet);
                }
            }
            else {
                this.tssUtils = new eddsa_1.default(this.bitgo, this.baseCoin, wallet);
            }
        }
        this._pendingApproval = pendingApprovalData;
    }
    /**
     * Get the id for this PendingApproval
     */
    id() {
        return this._pendingApproval.id;
    }
    toJSON() {
        return this._pendingApproval;
    }
    /**
     * Get the owner type (wallet or enterprise)
     * Pending approvals can be approved or modified by different scopes (depending on how they were created)
     * If a pending approval is owned by a wallet, then it can be approved by administrators of the wallet
     * If a pending approval is owned by an enterprise, then it can be approved by administrators of the enterprise
     */
    ownerType() {
        if (this._pendingApproval.wallet) {
            return pendingApproval_1.OwnerType.WALLET;
        }
        else if (this._pendingApproval.enterprise) {
            return pendingApproval_1.OwnerType.ENTERPRISE;
        }
        else {
            throw new Error('unexpected pending approval owner: neither wallet nor enterprise was present');
        }
    }
    /**
     * Get the id of the wallet which is associated with this PendingApproval
     */
    walletId() {
        return this._pendingApproval.wallet;
    }
    /**
     * Get the enterprise ID that is associated with this PendingApproval
     */
    enterpriseId() {
        return this._pendingApproval.enterprise;
    }
    /**
     * Get the state of this PendingApproval
     */
    state() {
        return this._pendingApproval.state;
    }
    /**
     * Get the id of the user that performed the action resulting in this PendingApproval
     */
    creator() {
        return this._pendingApproval.creator;
    }
    /**
     * Get the type of the pending approval (what it approves)
     */
    type() {
        if (!this._pendingApproval.info) {
            throw new Error('pending approval info is not available');
        }
        return this._pendingApproval.info.type;
    }
    /**
     * Get information about this PendingApproval
     */
    info() {
        return this._pendingApproval.info;
    }
    /**
     * Get the number of approvals that are required for this PendingApproval to be approved.
     * Defaults to 1 if approvalsRequired doesn't exist on the object
     */
    approvalsRequired() {
        return this._pendingApproval.approvalsRequired || 1;
    }
    /**
     * Generate a url for this PendingApproval for making requests to the server.
     * @param extra
     */
    url(extra = '') {
        return this.baseCoin.url('/pendingapprovals/' + this.id() + extra);
    }
    /**
     * Refetches this PendingApproval from the server and returns it.
     *
     * Note that this mutates the PendingApproval object in place.
     * @param params
     */
    async get(params = {}) {
        this._pendingApproval = await this.bitgo.get(this.url()).result();
        return this;
    }
    /**
     * Sets this PendingApproval to an approved state
     */
    async approve(params = {}) {
        params.previewPendingTxs = true;
        params.pendingApprovalId = this.id();
        const canRecreateTransaction = this.canRecreateTransaction(params);
        const reqId = new utils_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        await this.populateWallet();
        try {
            const transaction = await this.preApprove(params, reqId);
            const approvalParams = { state: 'approved', otp: params.otp };
            if (transaction) {
                // if the transaction already has a half signed property, we take that directly
                approvalParams.halfSigned = transaction.halfSigned || transaction;
            }
            const response = await this.bitgo.put(this.url()).send(approvalParams).result();
            // if the response comes with an error, means that the transaction triggered another condition
            if (response.hasOwnProperty('error') && response.hasOwnProperty('pendingApproval')) {
                return response;
            }
            this._pendingApproval = response;
            await this.postApprove(params, reqId);
            return this._pendingApproval;
        }
        catch (e) {
            if (!canRecreateTransaction &&
                (e.message.indexOf('could not find unspent output for input') !== -1 ||
                    e.message.indexOf('transaction conflicts with an existing transaction in the send queue') !== -1)) {
                throw new Error('unspents expired, wallet passphrase or xprv required to recreate transaction');
            }
            throw e;
        }
    }
    /**
     * Sets this PendingApproval to a rejected state
     * @param params
     */
    async reject(params = {}) {
        return await this.bitgo.put(this.url()).send({ state: 'rejected' }).result();
    }
    /**
     * Alias for PendingApproval.reject()
     *
     * @deprecated
     * @param params
     */
    async cancel(params = {}) {
        return await this.reject(params);
    }
    /**
     * Recreate and sign TSS transaction
     * @param {ApproveOptions} params needed to get txs and use the walletPassphrase to tss sign
     * @param {RequestTracer} reqId id tracer.
     */
    async recreateAndSignTSSTransaction(params, reqId) {
        const { walletPassphrase } = params;
        const txRequestId = this._pendingApproval.txRequestId;
        if (!this.wallet) {
            throw new Error('Wallet not found');
        }
        if (!walletPassphrase) {
            throw new Error('walletPassphrase not found');
        }
        if (!txRequestId) {
            throw new Error('txRequestId not found');
        }
        const decryptedPrv = await this.wallet.getPrv({ walletPassphrase });
        const txRequest = await this.tssUtils.recreateTxRequest(txRequestId, decryptedPrv, reqId);
        if (txRequest.apiVersion === 'lite') {
            if (!txRequest.unsignedTxs || txRequest.unsignedTxs.length === 0) {
                throw new Error('Unexpected error, no transactions found in txRequest.');
            }
            return {
                txHex: txRequest.unsignedTxs[0].serializedTxHex,
            };
        }
        else {
            if (!txRequest.transactions || txRequest.transactions.length === 0) {
                throw new Error('Unexpected error, no transactions found in txRequest.');
            }
            return {
                txHex: txRequest.transactions[0].unsignedTx.serializedTxHex,
            };
        }
    }
    /**
     * Recreate a transaction for a pending approval to respond to updated network conditions
     * @param params
     * @param reqId
     */
    async recreateAndSignTransaction(params = {}, reqId) {
        // this method only makes sense with existing transaction requests
        const transactionRequest = this.info().transactionRequest;
        if (_.isUndefined(transactionRequest)) {
            throw new Error('cannot recreate transaction without transaction request');
        }
        if (_.isUndefined(this.wallet)) {
            throw new Error('cannot recreate transaction without wallet');
        }
        const originalPrebuild = transactionRequest.coinSpecific[this.baseCoin.type];
        const recipients = transactionRequest.recipients;
        let prebuildParams = _.extend({}, params, { recipients: recipients }, transactionRequest.buildParams);
        if (!_.isUndefined(originalPrebuild.hopTransaction)) {
            prebuildParams.hop = true;
        }
        const reqTracer = reqId || new utils_1.RequestTracer();
        if (transactionRequest.buildParams && transactionRequest.buildParams.type === 'consolidate') {
            // consolidate tag is in the build params - this is a consolidation transaction, so
            // it needs to be rebuilt using the special consolidation build route
            this.bitgo.setRequestTracer(reqTracer);
            prebuildParams.prebuildTx = await this.bitgo
                .post(this.wallet.url(`/consolidateUnspents`))
                .send(BuildParams_1.BuildParams.encode(prebuildParams))
                .result();
            delete prebuildParams.recipients;
        }
        prebuildParams = _.extend({}, prebuildParams, { reqId: reqId });
        const signedTransaction = await this.wallet.prebuildAndSignTransaction(prebuildParams);
        // compare PAYGo fees
        const originalParsedTransaction = (await this.baseCoin.parseTransaction({
            txParams: prebuildParams,
            wallet: this.wallet,
            txPrebuild: originalPrebuild,
        }));
        const recreatedParsedTransaction = (await this.baseCoin.parseTransaction({
            txParams: prebuildParams,
            wallet: this.wallet,
            txPrebuild: signedTransaction,
        }));
        if (_.isUndefined(recreatedParsedTransaction.implicitExternalSpendAmount)) {
            return signedTransaction;
        }
        if (typeof recreatedParsedTransaction.implicitExternalSpendAmount !== 'bigint' &&
            !_.isFinite(recreatedParsedTransaction.implicitExternalSpendAmount)) {
            throw new Error('implicit external spend amount could not be determined');
        }
        if (!_.isUndefined(originalParsedTransaction.implicitExternalSpendAmount) &&
            recreatedParsedTransaction.implicitExternalSpendAmount > originalParsedTransaction.implicitExternalSpendAmount) {
            throw new Error('recreated transaction is using a higher pay-as-you-go-fee');
        }
        return signedTransaction;
    }
    /*
     * Cold wallets cannot recreate transactions if the only thing provided is the wallet passphrase
     *
     * The transaction can be recreated if either
     * – there is an xprv
     * – there is a walletPassphrase and the wallet is not cold (because if it's cold, the passphrase is of little use)
     *
     * Therefore, if neither of these is true, the transaction cannot be recreated, which is reflected in the if
     * statement below.
     */
    canRecreateTransaction(params) {
        var _a, _b, _c, _d, _e, _f;
        const isColdWallet = !!_.get(this.wallet, '_wallet.isCold');
        const isOFCWallet = this.baseCoin.getFamily() === 'ofc'; // Off-chain transactions don't need to be rebuilt
        if (!params.xprv && !(params.walletPassphrase && !isColdWallet && !isOFCWallet)) {
            return false;
        }
        // If there are no recipients, then the transaction cannot be recreated
        const recipients = ((_c = (_b = (_a = this.info()) === null || _a === void 0 ? void 0 : _a.transactionRequest) === null || _b === void 0 ? void 0 : _b.buildParams) === null || _c === void 0 ? void 0 : _c.recipients) || [];
        const type = (_f = (_e = (_d = this.info()) === null || _d === void 0 ? void 0 : _d.transactionRequest) === null || _e === void 0 ? void 0 : _e.buildParams) === null || _f === void 0 ? void 0 : _f.type;
        // We only want to not recreate transactions with no recipients if it is a UTXO coin.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return !(utxolib.isValidNetwork(this.baseCoin.network) &&
            recipients.length === 0 &&
            type !== 'consolidate');
    }
    /*
     * Internal helper function to get the serialized transaction which is being approved.
     * If this PA is of type 'transactionRequest' this function will try to rebuild and resign the transaction
     * @param {ApproveOptions} params
     * @param {boolean} canRecreateTransaction -
     * @param {RequestTracer} reqId id tracer
     */
    async preApprove(params = {}, reqId) {
        // TransactionRequestLite or Multisig tx's must sign before pending approval is approved
        // Re-signed tx is provided to the pending approval api
        if (this.type() === pendingApproval_1.Type.TRANSACTION_REQUEST) {
            /*
             * If this is a request for approving a transaction, depending on whether this user has a private key to the wallet
             * (some admins may not have the spend permission), the transaction could either be rebroadcast as is, or it could
             * be reconstructed. It is preferable to reconstruct a tx in order to adhere to the latest network conditions
             * such as newer unspents, different fees, or a higher sequence id
             */
            if (params.tx) {
                // the approval tx was reconstructed and explicitly specified - pass it through
                return {
                    txHex: params.tx,
                };
            }
            // this user may not have spending privileges or a passphrase may not have been passed in
            if (!this.canRecreateTransaction(params)) {
                // If this is a TransactionRequest, then the txRequest already has the unsigned transaction
                if (this._pendingApproval.txRequestId) {
                    return undefined;
                }
                // If this is a MultiSig, then we need to fetch the half signed tx to propagate to the approval API
                const transaction = _.get(this.info(), `transactionRequest.coinSpecific.${this.baseCoin.type}`);
                if (!_.isObject(transaction)) {
                    throw new Error('there is neither an original transaction object nor can a new one be recreated');
                }
                return transaction;
            }
            if (this._pendingApproval.txRequestId) {
                return await this.recreateAndSignTSSTransaction(params, reqId);
            }
            return await this.recreateAndSignTransaction(params, reqId);
        }
    }
    /**
     * Internal helper function to perform any post-approval actions.
     * If type is 'transactionRequestFull', this will sign the txRequestFull if possible
     * @param params
     * @param reqId
     * @private
     */
    async postApprove(params = {}, reqId) {
        switch (this.type()) {
            case pendingApproval_1.Type.TRANSACTION_REQUEST_FULL:
                // TransactionRequestFull for SMH or SMC wallets can only be signed after pending approval is approved
                if (this._pendingApproval.state === pendingApproval_1.State.APPROVED &&
                    this.canRecreateTransaction(params) &&
                    this.baseCoin.supportsTss()) {
                    await this.recreateAndSignTSSTransaction(params, reqId);
                }
        }
    }
    /**
     * Helper function to ensure that self.wallet is set
     */
    async populateWallet() {
        if (this.wallet) {
            return;
        }
        // TODO(WP-1341): consolidate/simplify this logic
        switch (this.type()) {
            case pendingApproval_1.Type.TRANSACTION_REQUEST:
                const transactionRequest = this.info().transactionRequest;
                if (_.isUndefined(transactionRequest)) {
                    throw new Error('missing required object property transactionRequest');
                }
                const updatedWallet = await this.baseCoin.wallets().get({ id: transactionRequest.sourceWallet });
                if (_.isUndefined(updatedWallet)) {
                    throw new Error('unexpected - unable to get wallet using sourcewallet');
                }
                this.wallet = updatedWallet;
                if (this.wallet.id() !== transactionRequest.sourceWallet) {
                    throw new Error('unexpected source wallet for pending approval');
                }
                break;
            case pendingApproval_1.Type.TRANSACTION_REQUEST_FULL:
                const walletId = this.walletId();
                if (!walletId) {
                    throw new Error('Unexpected error, pendingApproval.wallet is expected to be defined!');
                }
                this.wallet = await this.baseCoin.wallets().get({ id: this.walletId() });
                if (!this.wallet) {
                    throw new Error('unexpected - unable to get wallet using pendingApproval.wallet');
                }
                break;
        }
        return;
    }
}
exports.PendingApproval = PendingApproval;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVuZGluZ0FwcHJvdmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3BlbmRpbmdBcHByb3ZhbC9wZW5kaW5nQXBwcm92YWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILDBDQUE0QjtBQUM1Qix5REFBMkM7QUFHM0Msd0RBUTRCO0FBQzVCLG9DQUF5QztBQUV6Qyx1REFBb0Q7QUFHcEQsK0RBQTRDO0FBQzVDLDhDQUFpRTtBQWVqRSxNQUFhLGVBQWU7SUFPMUIsWUFBWSxLQUFnQixFQUFFLFFBQW1CLEVBQUUsbUJBQXdDLEVBQUUsTUFBZ0I7O1FBQzNHLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBRXJCLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsRUFBRTtZQUMvQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFLEtBQUssT0FBTyxFQUFFO2dCQUMvQyxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsTUFBTSwwQ0FBRSxtQkFBbUIsRUFBRSxNQUFLLE9BQU8sRUFBRTtvQkFDbEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLHVCQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2lCQUN4RTtxQkFBTTtvQkFDTCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksa0JBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7aUJBQ25FO2FBQ0Y7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGVBQVUsQ0FBQyxJQUFJ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QVEsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDekUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7b0JBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztpQkFDbkY7Z0JBQ0QsTUFBTTtTQUNUO1FBQ0QsT0FBTztJQUNULENBQUM7Q0FDRjtBQXBiRCwwQ0FvYkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyB1dHhvbGliIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBJQmFzZUNvaW4gfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBCaXRHb0Jhc2UgfSBmcm9tICcuLi9iaXRnb0Jhc2UnO1xuaW1wb3J0IHtcbiAgQXBwcm92ZU9wdGlvbnMsXG4gIElQZW5kaW5nQXBwcm92YWwsXG4gIE93bmVyVHlwZSxcbiAgUGVuZGluZ0FwcHJvdmFsRGF0YSxcbiAgUGVuZGluZ0FwcHJvdmFsSW5mbyxcbiAgU3RhdGUsXG4gIFR5cGUsXG59IGZyb20gJy4uL3BlbmRpbmdBcHByb3ZhbCc7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgSVdhbGxldCB9IGZyb20gJy4uL3dhbGxldCc7XG5pbXBvcnQgeyBCdWlsZFBhcmFtcyB9IGZyb20gJy4uL3dhbGxldC9CdWlsZFBhcmFtcyc7XG5pbXBvcnQgeyBJUmVxdWVzdFRyYWNlciB9IGZyb20gJy4uLy4uL2FwaSc7XG5pbXBvcnQgQmFzZVRzc1V0aWxzIGZyb20gJy4uL3V0aWxzL3Rzcy9iYXNlVFNTVXRpbHMnO1xuaW1wb3J0IEVkZHNhVXRpbHMgZnJvbSAnLi4vdXRpbHMvdHNzL2VkZHNhJztcbmltcG9ydCB7IEVjZHNhTVBDdjJVdGlscywgRWNkc2FVdGlscyB9IGZyb20gJy4uL3V0aWxzL3Rzcy9lY2RzYSc7XG5pbXBvcnQgeyBLZXlTaGFyZSBhcyBFY2RzYUtleVNoYXJlIH0gZnJvbSAnLi4vdXRpbHMvdHNzL2VjZHNhL3R5cGVzJztcbmltcG9ydCB7IEtleVNoYXJlIGFzIEVkZHNhS2V5U2hhcmUgfSBmcm9tICcuLi91dGlscy90c3MvZWRkc2EvdHlwZXMnO1xuXG50eXBlIFByZUFwcHJvdmVSZXN1bHQgPSB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIGhhbGZTaWduZWQ/OiBzdHJpbmc7XG59O1xuXG50eXBlIEFwcHJvdmVQZW5kaW5nQXBwcm92YWxSZXF1ZXN0Qm9keSA9IHtcbiAgc3RhdGU6ICdhcHByb3ZlZCc7XG4gIG90cDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBoYWxmU2lnbmVkPzogc3RyaW5nIHwgT21pdDxQcmVBcHByb3ZlUmVzdWx0LCAnaGFsZlNpZ25lZCc+O1xufTtcblxuZXhwb3J0IGNsYXNzIFBlbmRpbmdBcHByb3ZhbCBpbXBsZW1lbnRzIElQZW5kaW5nQXBwcm92YWwge1xuICBwcml2YXRlIHJlYWRvbmx5IGJpdGdvOiBCaXRHb0Jhc2U7XG4gIHByaXZhdGUgcmVhZG9ubHkgYmFzZUNvaW46IElCYXNlQ29pbjtcbiAgcHJpdmF0ZSB0c3NVdGlscz86IEJhc2VUc3NVdGlsczxFY2RzYUtleVNoYXJlIHwgRWRkc2FLZXlTaGFyZT47XG4gIHByaXZhdGUgd2FsbGV0PzogSVdhbGxldDtcbiAgcHJpdmF0ZSBfcGVuZGluZ0FwcHJvdmFsOiBQZW5kaW5nQXBwcm92YWxEYXRhO1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIGJhc2VDb2luOiBJQmFzZUNvaW4sIHBlbmRpbmdBcHByb3ZhbERhdGE6IFBlbmRpbmdBcHByb3ZhbERhdGEsIHdhbGxldD86IElXYWxsZXQpIHtcbiAgICB0aGlzLmJpdGdvID0gYml0Z287XG4gICAgdGhpcy5iYXNlQ29pbiA9IGJhc2VDb2luO1xuICAgIHRoaXMud2FsbGV0ID0gd2FsbGV0O1xuXG4gICAgaWYgKHRoaXMuYmFzZUNvaW4uc3VwcG9ydHNUc3MoKSkge1xuICAgICAgaWYgKHRoaXMuYmFzZUNvaW4uZ2V0TVBDQWxnb3JpdGhtKCkgPT09ICdlY2RzYScpIHtcbiAgICAgICAgaWYgKHRoaXMud2FsbGV0Py5tdWx0aXNpZ1R5cGVWZXJzaW9uKCkgPT09ICdNUEN2MicpIHtcbiAgICAgICAgICB0aGlzLnRzc1V0aWxzID0gbmV3IEVjZHNhTVBDdjJVdGlscyh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCB3YWxsZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHNzVXRpbHMgPSBuZXcgRWNkc2FVdGlscyh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCB3YWxsZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRzc1V0aWxzID0gbmV3IEVkZHNhVXRpbHModGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgd2FsbGV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wZW5kaW5nQXBwcm92YWwgPSBwZW5kaW5nQXBwcm92YWxEYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWQgZm9yIHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuaWQ7XG4gIH1cblxuICB0b0pTT04oKTogUGVuZGluZ0FwcHJvdmFsRGF0YSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG93bmVyIHR5cGUgKHdhbGxldCBvciBlbnRlcnByaXNlKVxuICAgKiBQZW5kaW5nIGFwcHJvdmFscyBjYW4gYmUgYXBwcm92ZWQgb3IgbW9kaWZpZWQgYnkgZGlmZmVyZW50IHNjb3BlcyAoZGVwZW5kaW5nIG9uIGhvdyB0aGV5IHdlcmUgY3JlYXRlZClcbiAgICogSWYgYSBwZW5kaW5nIGFwcHJvdmFsIGlzIG93bmVkIGJ5IGEgd2FsbGV0LCB0aGVuIGl0IGNhbiBiZSBhcHByb3ZlZCBieSBhZG1pbmlzdHJhdG9ycyBvZiB0aGUgd2FsbGV0XG4gICAqIElmIGEgcGVuZGluZyBhcHByb3ZhbCBpcyBvd25lZCBieSBhbiBlbnRlcnByaXNlLCB0aGVuIGl0IGNhbiBiZSBhcHByb3ZlZCBieSBhZG1pbmlzdHJhdG9ycyBvZiB0aGUgZW50ZXJwcmlzZVxuICAgKi9cbiAgb3duZXJUeXBlKCk6IE93bmVyVHlwZSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdBcHByb3ZhbC53YWxsZXQpIHtcbiAgICAgIHJldHVybiBPd25lclR5cGUuV0FMTEVUO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ0FwcHJvdmFsLmVudGVycHJpc2UpIHtcbiAgICAgIHJldHVybiBPd25lclR5cGUuRU5URVJQUklTRTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHBlbmRpbmcgYXBwcm92YWwgb3duZXI6IG5laXRoZXIgd2FsbGV0IG5vciBlbnRlcnByaXNlIHdhcyBwcmVzZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWQgb2YgdGhlIHdhbGxldCB3aGljaCBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIHdhbGxldElkKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC53YWxsZXQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbnRlcnByaXNlIElEIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICBlbnRlcnByaXNlSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmVudGVycHJpc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0ZSBvZiB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgc3RhdGUoKTogU3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpZCBvZiB0aGUgdXNlciB0aGF0IHBlcmZvcm1lZCB0aGUgYWN0aW9uIHJlc3VsdGluZyBpbiB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgY3JlYXRvcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuY3JlYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhlIHBlbmRpbmcgYXBwcm92YWwgKHdoYXQgaXQgYXBwcm92ZXMpXG4gICAqL1xuICB0eXBlKCk6IFR5cGUge1xuICAgIGlmICghdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGVuZGluZyBhcHByb3ZhbCBpbmZvIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmluZm8udHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIGluZm8oKTogUGVuZGluZ0FwcHJvdmFsSW5mbyB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5pbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIGFwcHJvdmFscyB0aGF0IGFyZSByZXF1aXJlZCBmb3IgdGhpcyBQZW5kaW5nQXBwcm92YWwgdG8gYmUgYXBwcm92ZWQuXG4gICAqIERlZmF1bHRzIHRvIDEgaWYgYXBwcm92YWxzUmVxdWlyZWQgZG9lc24ndCBleGlzdCBvbiB0aGUgb2JqZWN0XG4gICAqL1xuICBhcHByb3ZhbHNSZXF1aXJlZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuYXBwcm92YWxzUmVxdWlyZWQgfHwgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHVybCBmb3IgdGhpcyBQZW5kaW5nQXBwcm92YWwgZm9yIG1ha2luZyByZXF1ZXN0cyB0byB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0gZXh0cmFcbiAgICovXG4gIHVybChleHRyYSA9ICcnKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi51cmwoJy9wZW5kaW5nYXBwcm92YWxzLycgKyB0aGlzLmlkKCkgKyBleHRyYSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmZXRjaGVzIHRoaXMgUGVuZGluZ0FwcHJvdmFsIGZyb20gdGhlIHNlcnZlciBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbXV0YXRlcyB0aGUgUGVuZGluZ0FwcHJvdmFsIG9iamVjdCBpbiBwbGFjZS5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZ2V0KHBhcmFtczogUmVjb3JkPHN0cmluZywgbmV2ZXI+ID0ge30pOiBQcm9taXNlPFBlbmRpbmdBcHByb3ZhbD4ge1xuICAgIHRoaXMuX3BlbmRpbmdBcHByb3ZhbCA9IGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCkpLnJlc3VsdCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBQZW5kaW5nQXBwcm92YWwgdG8gYW4gYXBwcm92ZWQgc3RhdGVcbiAgICovXG4gIGFzeW5jIGFwcHJvdmUocGFyYW1zOiBBcHByb3ZlT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBwYXJhbXMucHJldmlld1BlbmRpbmdUeHMgPSB0cnVlO1xuICAgIHBhcmFtcy5wZW5kaW5nQXBwcm92YWxJZCA9IHRoaXMuaWQoKTtcbiAgICBjb25zdCBjYW5SZWNyZWF0ZVRyYW5zYWN0aW9uID0gdGhpcy5jYW5SZWNyZWF0ZVRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgYXdhaXQgdGhpcy5wb3B1bGF0ZVdhbGxldCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5wcmVBcHByb3ZlKHBhcmFtcywgcmVxSWQpO1xuXG4gICAgICBjb25zdCBhcHByb3ZhbFBhcmFtczogQXBwcm92ZVBlbmRpbmdBcHByb3ZhbFJlcXVlc3RCb2R5ID0geyBzdGF0ZTogJ2FwcHJvdmVkJywgb3RwOiBwYXJhbXMub3RwIH07XG4gICAgICBpZiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gaWYgdGhlIHRyYW5zYWN0aW9uIGFscmVhZHkgaGFzIGEgaGFsZiBzaWduZWQgcHJvcGVydHksIHdlIHRha2UgdGhhdCBkaXJlY3RseVxuICAgICAgICBhcHByb3ZhbFBhcmFtcy5oYWxmU2lnbmVkID0gdHJhbnNhY3Rpb24uaGFsZlNpZ25lZCB8fCB0cmFuc2FjdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5iaXRnby5wdXQodGhpcy51cmwoKSkuc2VuZChhcHByb3ZhbFBhcmFtcykucmVzdWx0KCk7XG5cbiAgICAgIC8vIGlmIHRoZSByZXNwb25zZSBjb21lcyB3aXRoIGFuIGVycm9yLCBtZWFucyB0aGF0IHRoZSB0cmFuc2FjdGlvbiB0cmlnZ2VyZWQgYW5vdGhlciBjb25kaXRpb25cbiAgICAgIGlmIChyZXNwb25zZS5oYXNPd25Qcm9wZXJ0eSgnZXJyb3InKSAmJiByZXNwb25zZS5oYXNPd25Qcm9wZXJ0eSgncGVuZGluZ0FwcHJvdmFsJykpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wZW5kaW5nQXBwcm92YWwgPSByZXNwb25zZTtcbiAgICAgIGF3YWl0IHRoaXMucG9zdEFwcHJvdmUocGFyYW1zLCByZXFJZCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKFxuICAgICAgICAhY2FuUmVjcmVhdGVUcmFuc2FjdGlvbiAmJlxuICAgICAgICAoZS5tZXNzYWdlLmluZGV4T2YoJ2NvdWxkIG5vdCBmaW5kIHVuc3BlbnQgb3V0cHV0IGZvciBpbnB1dCcpICE9PSAtMSB8fFxuICAgICAgICAgIGUubWVzc2FnZS5pbmRleE9mKCd0cmFuc2FjdGlvbiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyB0cmFuc2FjdGlvbiBpbiB0aGUgc2VuZCBxdWV1ZScpICE9PSAtMSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3BlbnRzIGV4cGlyZWQsIHdhbGxldCBwYXNzcGhyYXNlIG9yIHhwcnYgcmVxdWlyZWQgdG8gcmVjcmVhdGUgdHJhbnNhY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBQZW5kaW5nQXBwcm92YWwgdG8gYSByZWplY3RlZCBzdGF0ZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyByZWplY3QocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBuZXZlcj4gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28ucHV0KHRoaXMudXJsKCkpLnNlbmQoeyBzdGF0ZTogJ3JlamVjdGVkJyB9KS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgUGVuZGluZ0FwcHJvdmFsLnJlamVjdCgpXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGNhbmNlbChwYXJhbXM6IFJlY29yZDxzdHJpbmcsIG5ldmVyPiA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWplY3QocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNyZWF0ZSBhbmQgc2lnbiBUU1MgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtBcHByb3ZlT3B0aW9uc30gcGFyYW1zIG5lZWRlZCB0byBnZXQgdHhzIGFuZCB1c2UgdGhlIHdhbGxldFBhc3NwaHJhc2UgdG8gdHNzIHNpZ25cbiAgICogQHBhcmFtIHtSZXF1ZXN0VHJhY2VyfSByZXFJZCBpZCB0cmFjZXIuXG4gICAqL1xuICBhc3luYyByZWNyZWF0ZUFuZFNpZ25UU1NUcmFuc2FjdGlvbihwYXJhbXM6IEFwcHJvdmVPcHRpb25zLCByZXFJZDogSVJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPHsgdHhIZXg6IHN0cmluZyB9PiB7XG4gICAgY29uc3QgeyB3YWxsZXRQYXNzcGhyYXNlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHhSZXF1ZXN0SWQgPSB0aGlzLl9wZW5kaW5nQXBwcm92YWwudHhSZXF1ZXN0SWQ7XG5cbiAgICBpZiAoIXRoaXMud2FsbGV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXdhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd2FsbGV0UGFzc3BocmFzZSBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXR4UmVxdWVzdElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4UmVxdWVzdElkIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlY3J5cHRlZFBydiA9IGF3YWl0IHRoaXMud2FsbGV0LmdldFBydih7IHdhbGxldFBhc3NwaHJhc2UgfSk7XG4gICAgY29uc3QgdHhSZXF1ZXN0ID0gYXdhaXQgdGhpcy50c3NVdGlscyEucmVjcmVhdGVUeFJlcXVlc3QodHhSZXF1ZXN0SWQsIGRlY3J5cHRlZFBydiwgcmVxSWQpO1xuICAgIGlmICh0eFJlcXVlc3QuYXBpVmVyc2lvbiA9PT0gJ2xpdGUnKSB7XG4gICAgICBpZiAoIXR4UmVxdWVzdC51bnNpZ25lZFR4cyB8fCB0eFJlcXVlc3QudW5zaWduZWRUeHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlcnJvciwgbm8gdHJhbnNhY3Rpb25zIGZvdW5kIGluIHR4UmVxdWVzdC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGV4OiB0eFJlcXVlc3QudW5zaWduZWRUeHNbMF0uc2VyaWFsaXplZFR4SGV4LFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0eFJlcXVlc3QudHJhbnNhY3Rpb25zIHx8IHR4UmVxdWVzdC50cmFuc2FjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlcnJvciwgbm8gdHJhbnNhY3Rpb25zIGZvdW5kIGluIHR4UmVxdWVzdC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGV4OiB0eFJlcXVlc3QudHJhbnNhY3Rpb25zWzBdLnVuc2lnbmVkVHguc2VyaWFsaXplZFR4SGV4LFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjcmVhdGUgYSB0cmFuc2FjdGlvbiBmb3IgYSBwZW5kaW5nIGFwcHJvdmFsIHRvIHJlc3BvbmQgdG8gdXBkYXRlZCBuZXR3b3JrIGNvbmRpdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcmVxSWRcbiAgICovXG4gIGFzeW5jIHJlY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtczogYW55ID0ge30sIHJlcUlkPzogSVJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPGFueT4ge1xuICAgIC8vIHRoaXMgbWV0aG9kIG9ubHkgbWFrZXMgc2Vuc2Ugd2l0aCBleGlzdGluZyB0cmFuc2FjdGlvbiByZXF1ZXN0c1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVxdWVzdCA9IHRoaXMuaW5mbygpLnRyYW5zYWN0aW9uUmVxdWVzdDtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0cmFuc2FjdGlvblJlcXVlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWNyZWF0ZSB0cmFuc2FjdGlvbiB3aXRob3V0IHRyYW5zYWN0aW9uIHJlcXVlc3QnKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLndhbGxldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlY3JlYXRlIHRyYW5zYWN0aW9uIHdpdGhvdXQgd2FsbGV0Jyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWxQcmVidWlsZCA9IHRyYW5zYWN0aW9uUmVxdWVzdC5jb2luU3BlY2lmaWNbdGhpcy5iYXNlQ29pbi50eXBlXTtcblxuICAgIGNvbnN0IHJlY2lwaWVudHMgPSB0cmFuc2FjdGlvblJlcXVlc3QucmVjaXBpZW50cztcbiAgICBsZXQgcHJlYnVpbGRQYXJhbXMgPSBfLmV4dGVuZCh7fSwgcGFyYW1zLCB7IHJlY2lwaWVudHM6IHJlY2lwaWVudHMgfSwgdHJhbnNhY3Rpb25SZXF1ZXN0LmJ1aWxkUGFyYW1zKTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChvcmlnaW5hbFByZWJ1aWxkLmhvcFRyYW5zYWN0aW9uKSkge1xuICAgICAgcHJlYnVpbGRQYXJhbXMuaG9wID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXFUcmFjZXIgPSByZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIGlmICh0cmFuc2FjdGlvblJlcXVlc3QuYnVpbGRQYXJhbXMgJiYgdHJhbnNhY3Rpb25SZXF1ZXN0LmJ1aWxkUGFyYW1zLnR5cGUgPT09ICdjb25zb2xpZGF0ZScpIHtcbiAgICAgIC8vIGNvbnNvbGlkYXRlIHRhZyBpcyBpbiB0aGUgYnVpbGQgcGFyYW1zIC0gdGhpcyBpcyBhIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb24sIHNvXG4gICAgICAvLyBpdCBuZWVkcyB0byBiZSByZWJ1aWx0IHVzaW5nIHRoZSBzcGVjaWFsIGNvbnNvbGlkYXRpb24gYnVpbGQgcm91dGVcbiAgICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFUcmFjZXIpO1xuICAgICAgcHJlYnVpbGRQYXJhbXMucHJlYnVpbGRUeCA9IGF3YWl0IHRoaXMuYml0Z29cbiAgICAgICAgLnBvc3QodGhpcy53YWxsZXQudXJsKGAvY29uc29saWRhdGVVbnNwZW50c2ApKVxuICAgICAgICAuc2VuZChCdWlsZFBhcmFtcy5lbmNvZGUocHJlYnVpbGRQYXJhbXMpKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICBkZWxldGUgcHJlYnVpbGRQYXJhbXMucmVjaXBpZW50cztcbiAgICB9XG5cbiAgICBwcmVidWlsZFBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwcmVidWlsZFBhcmFtcywgeyByZXFJZDogcmVxSWQgfSk7XG4gICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLndhbGxldC5wcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbihwcmVidWlsZFBhcmFtcyk7XG4gICAgLy8gY29tcGFyZSBQQVlHbyBmZWVzXG4gICAgY29uc3Qgb3JpZ2luYWxQYXJzZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0aGlzLmJhc2VDb2luLnBhcnNlVHJhbnNhY3Rpb24oe1xuICAgICAgdHhQYXJhbXM6IHByZWJ1aWxkUGFyYW1zLFxuICAgICAgd2FsbGV0OiB0aGlzLndhbGxldCxcbiAgICAgIHR4UHJlYnVpbGQ6IG9yaWdpbmFsUHJlYnVpbGQsXG4gICAgfSkpIGFzIGFueTtcbiAgICBjb25zdCByZWNyZWF0ZWRQYXJzZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0aGlzLmJhc2VDb2luLnBhcnNlVHJhbnNhY3Rpb24oe1xuICAgICAgdHhQYXJhbXM6IHByZWJ1aWxkUGFyYW1zLFxuICAgICAgd2FsbGV0OiB0aGlzLndhbGxldCxcbiAgICAgIHR4UHJlYnVpbGQ6IHNpZ25lZFRyYW5zYWN0aW9uLFxuICAgIH0pKSBhcyBhbnk7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChyZWNyZWF0ZWRQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQpKSB7XG4gICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHJlY3JlYXRlZFBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCAhPT0gJ2JpZ2ludCcgJiZcbiAgICAgICFfLmlzRmluaXRlKHJlY3JlYXRlZFBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW1wbGljaXQgZXh0ZXJuYWwgc3BlbmQgYW1vdW50IGNvdWxkIG5vdCBiZSBkZXRlcm1pbmVkJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFfLmlzVW5kZWZpbmVkKG9yaWdpbmFsUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50KSAmJlxuICAgICAgcmVjcmVhdGVkUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50ID4gb3JpZ2luYWxQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVjcmVhdGVkIHRyYW5zYWN0aW9uIGlzIHVzaW5nIGEgaGlnaGVyIHBheS1hcy15b3UtZ28tZmVlJyk7XG4gICAgfVxuICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qXG4gICAqIENvbGQgd2FsbGV0cyBjYW5ub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb25zIGlmIHRoZSBvbmx5IHRoaW5nIHByb3ZpZGVkIGlzIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gY2FuIGJlIHJlY3JlYXRlZCBpZiBlaXRoZXJcbiAgICog4oCTIHRoZXJlIGlzIGFuIHhwcnZcbiAgICog4oCTIHRoZXJlIGlzIGEgd2FsbGV0UGFzc3BocmFzZSBhbmQgdGhlIHdhbGxldCBpcyBub3QgY29sZCAoYmVjYXVzZSBpZiBpdCdzIGNvbGQsIHRoZSBwYXNzcGhyYXNlIGlzIG9mIGxpdHRsZSB1c2UpXG4gICAqXG4gICAqIFRoZXJlZm9yZSwgaWYgbmVpdGhlciBvZiB0aGVzZSBpcyB0cnVlLCB0aGUgdHJhbnNhY3Rpb24gY2Fubm90IGJlIHJlY3JlYXRlZCwgd2hpY2ggaXMgcmVmbGVjdGVkIGluIHRoZSBpZlxuICAgKiBzdGF0ZW1lbnQgYmVsb3cuXG4gICAqL1xuICBwcml2YXRlIGNhblJlY3JlYXRlVHJhbnNhY3Rpb24ocGFyYW1zOiBBcHByb3ZlT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlzQ29sZFdhbGxldCA9ICEhXy5nZXQodGhpcy53YWxsZXQsICdfd2FsbGV0LmlzQ29sZCcpO1xuICAgIGNvbnN0IGlzT0ZDV2FsbGV0ID0gdGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKSA9PT0gJ29mYyc7IC8vIE9mZi1jaGFpbiB0cmFuc2FjdGlvbnMgZG9uJ3QgbmVlZCB0byBiZSByZWJ1aWx0XG4gICAgaWYgKCFwYXJhbXMueHBydiAmJiAhKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlICYmICFpc0NvbGRXYWxsZXQgJiYgIWlzT0ZDV2FsbGV0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyByZWNpcGllbnRzLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBjYW5ub3QgYmUgcmVjcmVhdGVkXG4gICAgY29uc3QgcmVjaXBpZW50cyA9IHRoaXMuaW5mbygpPy50cmFuc2FjdGlvblJlcXVlc3Q/LmJ1aWxkUGFyYW1zPy5yZWNpcGllbnRzIHx8IFtdO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmluZm8oKT8udHJhbnNhY3Rpb25SZXF1ZXN0Py5idWlsZFBhcmFtcz8udHlwZTtcblxuICAgIC8vIFdlIG9ubHkgd2FudCB0byBub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb25zIHdpdGggbm8gcmVjaXBpZW50cyBpZiBpdCBpcyBhIFVUWE8gY29pbi5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiAhKFxuICAgICAgdXR4b2xpYi5pc1ZhbGlkTmV0d29yaygodGhpcy5iYXNlQ29pbiBhcyBhbnkpLm5ldHdvcmspICYmXG4gICAgICByZWNpcGllbnRzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgdHlwZSAhPT0gJ2NvbnNvbGlkYXRlJ1xuICAgICk7XG4gIH1cblxuICAvKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIHdoaWNoIGlzIGJlaW5nIGFwcHJvdmVkLlxuICAgKiBJZiB0aGlzIFBBIGlzIG9mIHR5cGUgJ3RyYW5zYWN0aW9uUmVxdWVzdCcgdGhpcyBmdW5jdGlvbiB3aWxsIHRyeSB0byByZWJ1aWxkIGFuZCByZXNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7QXBwcm92ZU9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhblJlY3JlYXRlVHJhbnNhY3Rpb24gLVxuICAgKiBAcGFyYW0ge1JlcXVlc3RUcmFjZXJ9IHJlcUlkIGlkIHRyYWNlclxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwcmVBcHByb3ZlKHBhcmFtczogQXBwcm92ZU9wdGlvbnMgPSB7fSwgcmVxSWQ6IElSZXF1ZXN0VHJhY2VyKTogUHJvbWlzZTxQcmVBcHByb3ZlUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gICAgLy8gVHJhbnNhY3Rpb25SZXF1ZXN0TGl0ZSBvciBNdWx0aXNpZyB0eCdzIG11c3Qgc2lnbiBiZWZvcmUgcGVuZGluZyBhcHByb3ZhbCBpcyBhcHByb3ZlZFxuICAgIC8vIFJlLXNpZ25lZCB0eCBpcyBwcm92aWRlZCB0byB0aGUgcGVuZGluZyBhcHByb3ZhbCBhcGlcbiAgICBpZiAodGhpcy50eXBlKCkgPT09IFR5cGUuVFJBTlNBQ1RJT05fUkVRVUVTVCkge1xuICAgICAgLypcbiAgICAgICAqIElmIHRoaXMgaXMgYSByZXF1ZXN0IGZvciBhcHByb3ZpbmcgYSB0cmFuc2FjdGlvbiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhpcyB1c2VyIGhhcyBhIHByaXZhdGUga2V5IHRvIHRoZSB3YWxsZXRcbiAgICAgICAqIChzb21lIGFkbWlucyBtYXkgbm90IGhhdmUgdGhlIHNwZW5kIHBlcm1pc3Npb24pLCB0aGUgdHJhbnNhY3Rpb24gY291bGQgZWl0aGVyIGJlIHJlYnJvYWRjYXN0IGFzIGlzLCBvciBpdCBjb3VsZFxuICAgICAgICogYmUgcmVjb25zdHJ1Y3RlZC4gSXQgaXMgcHJlZmVyYWJsZSB0byByZWNvbnN0cnVjdCBhIHR4IGluIG9yZGVyIHRvIGFkaGVyZSB0byB0aGUgbGF0ZXN0IG5ldHdvcmsgY29uZGl0aW9uc1xuICAgICAgICogc3VjaCBhcyBuZXdlciB1bnNwZW50cywgZGlmZmVyZW50IGZlZXMsIG9yIGEgaGlnaGVyIHNlcXVlbmNlIGlkXG4gICAgICAgKi9cbiAgICAgIGlmIChwYXJhbXMudHgpIHtcbiAgICAgICAgLy8gdGhlIGFwcHJvdmFsIHR4IHdhcyByZWNvbnN0cnVjdGVkIGFuZCBleHBsaWNpdGx5IHNwZWNpZmllZCAtIHBhc3MgaXQgdGhyb3VnaFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR4SGV4OiBwYXJhbXMudHgsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIHRoaXMgdXNlciBtYXkgbm90IGhhdmUgc3BlbmRpbmcgcHJpdmlsZWdlcyBvciBhIHBhc3NwaHJhc2UgbWF5IG5vdCBoYXZlIGJlZW4gcGFzc2VkIGluXG4gICAgICBpZiAoIXRoaXMuY2FuUmVjcmVhdGVUcmFuc2FjdGlvbihwYXJhbXMpKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBUcmFuc2FjdGlvblJlcXVlc3QsIHRoZW4gdGhlIHR4UmVxdWVzdCBhbHJlYWR5IGhhcyB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdBcHByb3ZhbC50eFJlcXVlc3RJZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIE11bHRpU2lnLCB0aGVuIHdlIG5lZWQgdG8gZmV0Y2ggdGhlIGhhbGYgc2lnbmVkIHR4IHRvIHByb3BhZ2F0ZSB0byB0aGUgYXBwcm92YWwgQVBJXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gXy5nZXQoXG4gICAgICAgICAgdGhpcy5pbmZvKCksXG4gICAgICAgICAgYHRyYW5zYWN0aW9uUmVxdWVzdC5jb2luU3BlY2lmaWMuJHt0aGlzLmJhc2VDb2luLnR5cGV9YFxuICAgICAgICApIGFzIFByZUFwcHJvdmVSZXN1bHQ7XG4gICAgICAgIGlmICghXy5pc09iamVjdCh0cmFuc2FjdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZXJlIGlzIG5laXRoZXIgYW4gb3JpZ2luYWwgdHJhbnNhY3Rpb24gb2JqZWN0IG5vciBjYW4gYSBuZXcgb25lIGJlIHJlY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdBcHByb3ZhbC50eFJlcXVlc3RJZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWNyZWF0ZUFuZFNpZ25UU1NUcmFuc2FjdGlvbihwYXJhbXMsIHJlcUlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtcywgcmVxSWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gcGVyZm9ybSBhbnkgcG9zdC1hcHByb3ZhbCBhY3Rpb25zLlxuICAgKiBJZiB0eXBlIGlzICd0cmFuc2FjdGlvblJlcXVlc3RGdWxsJywgdGhpcyB3aWxsIHNpZ24gdGhlIHR4UmVxdWVzdEZ1bGwgaWYgcG9zc2libGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcmVxSWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcG9zdEFwcHJvdmUocGFyYW1zOiBBcHByb3ZlT3B0aW9ucyA9IHt9LCByZXFJZDogSVJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSgpKSB7XG4gICAgICBjYXNlIFR5cGUuVFJBTlNBQ1RJT05fUkVRVUVTVF9GVUxMOlxuICAgICAgICAvLyBUcmFuc2FjdGlvblJlcXVlc3RGdWxsIGZvciBTTUggb3IgU01DIHdhbGxldHMgY2FuIG9ubHkgYmUgc2lnbmVkIGFmdGVyIHBlbmRpbmcgYXBwcm92YWwgaXMgYXBwcm92ZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5zdGF0ZSA9PT0gU3RhdGUuQVBQUk9WRUQgJiZcbiAgICAgICAgICB0aGlzLmNhblJlY3JlYXRlVHJhbnNhY3Rpb24ocGFyYW1zKSAmJlxuICAgICAgICAgIHRoaXMuYmFzZUNvaW4uc3VwcG9ydHNUc3MoKVxuICAgICAgICApIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlY3JlYXRlQW5kU2lnblRTU1RyYW5zYWN0aW9uKHBhcmFtcywgcmVxSWQpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBlbnN1cmUgdGhhdCBzZWxmLndhbGxldCBpcyBzZXRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcG9wdWxhdGVXYWxsZXQoKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICBpZiAodGhpcy53YWxsZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVE9ETyhXUC0xMzQxKTogY29uc29saWRhdGUvc2ltcGxpZnkgdGhpcyBsb2dpY1xuICAgIHN3aXRjaCAodGhpcy50eXBlKCkpIHtcbiAgICAgIGNhc2UgVHlwZS5UUkFOU0FDVElPTl9SRVFVRVNUOlxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvblJlcXVlc3QgPSB0aGlzLmluZm8oKS50cmFuc2FjdGlvblJlcXVlc3Q7XG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHRyYW5zYWN0aW9uUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgb2JqZWN0IHByb3BlcnR5IHRyYW5zYWN0aW9uUmVxdWVzdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXBkYXRlZFdhbGxldDogSVdhbGxldCA9IGF3YWl0IHRoaXMuYmFzZUNvaW4ud2FsbGV0cygpLmdldCh7IGlkOiB0cmFuc2FjdGlvblJlcXVlc3Quc291cmNlV2FsbGV0IH0pO1xuXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHVwZGF0ZWRXYWxsZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIC0gdW5hYmxlIHRvIGdldCB3YWxsZXQgdXNpbmcgc291cmNld2FsbGV0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndhbGxldCA9IHVwZGF0ZWRXYWxsZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMud2FsbGV0LmlkKCkgIT09IHRyYW5zYWN0aW9uUmVxdWVzdC5zb3VyY2VXYWxsZXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgc291cmNlIHdhbGxldCBmb3IgcGVuZGluZyBhcHByb3ZhbCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUeXBlLlRSQU5TQUNUSU9OX1JFUVVFU1RfRlVMTDpcbiAgICAgICAgY29uc3Qgd2FsbGV0SWQgPSB0aGlzLndhbGxldElkKCk7XG4gICAgICAgIGlmICghd2FsbGV0SWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IsIHBlbmRpbmdBcHByb3ZhbC53YWxsZXQgaXMgZXhwZWN0ZWQgdG8gYmUgZGVmaW5lZCEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhbGxldCA9IGF3YWl0IHRoaXMuYmFzZUNvaW4ud2FsbGV0cygpLmdldCh7IGlkOiB0aGlzLndhbGxldElkKCkgfSk7XG4gICAgICAgIGlmICghdGhpcy53YWxsZXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgLSB1bmFibGUgdG8gZ2V0IHdhbGxldCB1c2luZyBwZW5kaW5nQXBwcm92YWwud2FsbGV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufVxuIl19