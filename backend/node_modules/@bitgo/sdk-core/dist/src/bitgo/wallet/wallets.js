"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallets = exports.isWalletWithKeychains = void 0;
/**
 * @prettier
 */
const assert_1 = __importDefault(require("assert"));
const bignumber_js_1 = require("bignumber.js");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const _ = __importStar(require("lodash"));
const statics_1 = require("@bitgo/statics");
const api_1 = require("../../api");
const common = __importStar(require("../../common"));
const ecdh_1 = require("../ecdh");
const utils_1 = require("../utils");
const iWallets_1 = require("./iWallets");
const wallet_1 = require("./wallet");
/**
 * Check if a wallet is a WalletWithKeychains
 */
function isWalletWithKeychains(wallet) {
    return wallet.responseType === 'WalletWithKeychains';
}
exports.isWalletWithKeychains = isWalletWithKeychains;
class Wallets {
    constructor(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a wallet by ID (proxy for getWallet)
     * @param params
     */
    async get(params = {}) {
        return this.getWallet(params);
    }
    /**
     * List a user's wallets
     * @param params
     * @returns {*}
     */
    async list(params = {}) {
        if (params.skip && params.prevId) {
            throw new Error('cannot specify both skip and prevId');
        }
        const body = (await this.bitgo.get(this.baseCoin.url('/wallet')).query(params).result());
        body.wallets = body.wallets.map((w) => new wallet_1.Wallet(this.bitgo, this.baseCoin, w));
        return body;
    }
    /**
     * add
     * Add a new wallet (advanced mode).
     * This allows you to manually submit the keys, type, m and n of the wallet
     * Parameters include:
     *    "label": label of the wallet to be shown in UI
     *    "m": number of keys required to unlock wallet (2)
     *    "n": number of keys available on the wallet (3)
     *    "keys": array of keychain ids
     */
    async add(params) {
        var _a, _b;
        params = params || {};
        common.validateParams(params, [], ['label', 'enterprise', 'type']);
        if (typeof params.label !== 'string') {
            throw new Error('missing required string parameter label');
        }
        // no need to pass keys for (single) custodial wallets
        if (params.type !== 'custodial') {
            if (Array.isArray(params.keys) === false || !_.isNumber(params.m) || !_.isNumber(params.n)) {
                throw new Error('invalid argument');
            }
            // TODO: support more types of multisig
            if (!this.baseCoin.isValidMofNSetup(params)) {
                throw new Error('unsupported multi-sig type');
            }
        }
        if (params.gasPrice && !_.isNumber(params.gasPrice)) {
            throw new Error('invalid argument for gasPrice - number expected');
        }
        if (params.walletVersion) {
            if (!_.isNumber(params.walletVersion)) {
                throw new Error('invalid argument for walletVersion - number expected');
            }
            if (params.multisigType === 'tss' && this.baseCoin.getMPCAlgorithm() === 'ecdsa' && params.walletVersion === 3) {
                const tssSettings = await this.bitgo
                    .get(this.bitgo.microservicesUrl('/api/v2/tss/settings'))
                    .result();
                const multisigTypeVersion = (_b = (_a = tssSettings.coinSettings[this.baseCoin.getFamily()]) === null || _a === void 0 ? void 0 : _a.walletCreationSettings) === null || _b === void 0 ? void 0 : _b.multiSigTypeVersion;
                if (multisigTypeVersion === 'MPCv2') {
                    params.walletVersion = 5;
                }
            }
        }
        if (params.tags && Array.isArray(params.tags) === false) {
            throw new Error('invalid argument for tags - array expected');
        }
        if (params.clientFlags && Array.isArray(params.clientFlags) === false) {
            throw new Error('invalid argument for clientFlags - array expected');
        }
        if (params.isCold && !_.isBoolean(params.isCold)) {
            throw new Error('invalid argument for isCold - boolean expected');
        }
        if (params.isCustodial && !_.isBoolean(params.isCustodial)) {
            throw new Error('invalid argument for isCustodial - boolean expected');
        }
        if (params.address && (!_.isString(params.address) || !this.baseCoin.isValidAddress(params.address))) {
            throw new Error('invalid argument for address - valid address string expected');
        }
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(params).result();
        return {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
        };
    }
    async generateLightningWallet(params) {
        const reqId = new utils_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        const { label, passphrase, enterprise, passcodeEncryptionCode } = params;
        const keychainPromises = [undefined, 'userAuth', 'nodeAuth'].map((purpose) => {
            return async () => {
                let keychain = this.baseCoin.keychains().create();
                const pub = keychain.pub;
                const encryptedPrv = this.bitgo.encrypt({ password: passphrase, input: keychain.prv });
                delete keychain.prv;
                keychain = null;
                const keychainParams = {
                    pub,
                    encryptedPrv,
                    originalPasscodeEncryptionCode: purpose === undefined ? passcodeEncryptionCode : undefined,
                    coinSpecific: purpose === undefined ? undefined : { [this.baseCoin.getChain()]: { purpose } },
                    keyType: 'independent',
                    source: 'user',
                };
                return await this.baseCoin.keychains().add(keychainParams);
            };
        });
        const { userKeychain, userAuthKeychain, nodeAuthKeychain } = await (0, utils_1.promiseProps)({
            userKeychain: keychainPromises[0](),
            userAuthKeychain: keychainPromises[1](),
            nodeAuthKeychain: keychainPromises[2](),
        });
        const walletParams = {
            label,
            m: 1,
            n: 1,
            type: 'hot',
            enterprise,
            keys: [userKeychain.id],
            coinSpecific: { [this.baseCoin.getChain()]: { keys: [userAuthKeychain.id, nodeAuthKeychain.id] } },
        };
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(walletParams).result();
        const wallet = new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet);
        return {
            wallet,
            userKeychain,
            userAuthKeychain,
            nodeAuthKeychain,
            responseType: 'LightningWalletWithKeychains',
        };
    }
    /**
     * Generate a new wallet
     * 1. Creates the user keychain locally on the client, and encrypts it with the provided passphrase
     * 2. If no pub was provided, creates the backup keychain locally on the client, and encrypts it with the provided passphrase
     * 3. Uploads the encrypted user and backup keychains to BitGo
     * 4. Creates the BitGo key on the service
     * 5. Creates the wallet on BitGo with the 3 public keys above
     * @param params
     * @param params.label Label for the wallet
     * @param params.passphrase Passphrase to be used to encrypt the user and backup keychains
     * @param params.userKey User xpub
     * @param params.backupXpub Backup xpub
     * @param params.backupXpubProvider
     * @param params.backupProvider Third party backup provider for TSS
     * @param params.enterprise the enterpriseId
     * @param params.disableTransactionNotifications
     * @param params.passcodeEncryptionCode optional this is a recovery code that can be used to decrypt the original passphrase in a recovery case.
     *                                      The user must generate and keep the encrypted original passphrase safe while this code is stored on BitGo
     * @param params.coldDerivationSeed optional seed for SMC wallets
     * @param params.gasPrice
     * @param params.disableKRSEmail
     * @param params.walletVersion
     * @param params.multisigType optional multisig type, 'onchain' or 'tss' or 'blsdkg'; if absent, we will defer to the coin's default type
     * @param params.isDistributedCustody optional parameter for creating bitgo key. This is only necessary if you want to create
     *                                    a distributed custody wallet. If provided, you must have the enterprise license and pass in
     *                                    `params.enterprise` into `generateWallet` as well.
     * @param params.type optional wallet type, 'hot' or 'cold' or 'custodial'; if absent, we will defer to 'hot'
     * @param params.bitgoKeyId optional bitgo key id for SMC TSS wallets
     * @param params.commonKeychain optional common keychain for SMC TSS wallets
     *
     * @returns {*}
     */
    async generateWallet(params = {}) {
        var _a;
        if (this.baseCoin.getFamily() === 'lnbtc') {
            const options = (0, utils_1.decodeOrElse)(iWallets_1.GenerateLightningWalletOptionsCodec.name, iWallets_1.GenerateLightningWalletOptionsCodec, params, (errors) => {
                throw new Error(`error(s) parsing generate lightning wallet request params: ${errors}`);
            });
            return this.generateLightningWallet(options);
        }
        common.validateParams(params, ['label'], ['passphrase', 'userKey', 'backupXpub']);
        if (typeof params.label !== 'string') {
            throw new Error('missing required string parameter label');
        }
        const { type = 'hot', label, passphrase, enterprise, isDistributedCustody } = params;
        const isTss = params.multisigType === 'tss' && this.baseCoin.supportsTss();
        const canEncrypt = !!passphrase && typeof passphrase === 'string';
        const walletParams = {
            label: label,
            m: 2,
            n: 3,
            keys: [],
            type: !!params.userKey && params.multisigType !== 'onchain' ? 'cold' : type,
        };
        if (!_.isUndefined(params.passcodeEncryptionCode)) {
            if (!_.isString(params.passcodeEncryptionCode)) {
                throw new Error('passcodeEncryptionCode must be a string');
            }
        }
        if (!_.isUndefined(enterprise)) {
            if (!_.isString(enterprise)) {
                throw new Error('invalid enterprise argument, expecting string');
            }
            walletParams.enterprise = enterprise;
        }
        // EVM TSS wallets must use wallet version 3 and 5
        if (isTss && this.baseCoin.isEVM() && !(params.walletVersion === 3 || params.walletVersion === 5)) {
            throw new Error('EVM TSS wallets are only supported for wallet version 3 and 5');
        }
        if (isTss) {
            if (!this.baseCoin.supportsTss()) {
                throw new Error(`coin ${this.baseCoin.getFamily()} does not support TSS at this time`);
            }
            if (params.walletVersion === 5 && !this.baseCoin.getConfig().features.includes(statics_1.CoinFeature.MPCV2)) {
                throw new Error(`coin ${this.baseCoin.getFamily()} does not support TSS MPCv2 at this time`);
            }
            (0, assert_1.default)(enterprise, 'enterprise is required for TSS wallet');
            if (type === 'cold') {
                if (params.walletVersion === 5) {
                    throw new Error('EVM TSS MPCv2 wallets are not supported for cold wallets');
                }
                // validate
                (0, assert_1.default)(params.bitgoKeyId, 'bitgoKeyId is required for SMC TSS wallet');
                (0, assert_1.default)(params.commonKeychain, 'commonKeychain is required for SMC TSS wallet');
                return this.generateSMCMpcWallet({
                    multisigType: 'tss',
                    label,
                    enterprise,
                    walletVersion: params.walletVersion,
                    bitgoKeyId: params.bitgoKeyId,
                    commonKeychain: params.commonKeychain,
                    coldDerivationSeed: params.coldDerivationSeed,
                });
            }
            if (type === 'custodial') {
                if (params.walletVersion === 5) {
                    throw new Error('EVM TSS MPCv2 wallets are not supported for custodial wallets');
                }
                return this.generateCustodialMpcWallet({
                    multisigType: 'tss',
                    label,
                    enterprise,
                    walletVersion: params.walletVersion,
                });
            }
            (0, assert_1.default)(passphrase, 'cannot generate TSS keys without passphrase');
            return this.generateMpcWallet({
                multisigType: 'tss',
                label,
                passphrase,
                originalPasscodeEncryptionCode: params.passcodeEncryptionCode,
                enterprise,
                walletVersion: params.walletVersion,
                backupProvider: params.backupProvider,
            });
        }
        const isBlsDkg = params.multisigType ? params.multisigType === 'blsdkg' : this.baseCoin.supportsBlsDkg();
        if (isBlsDkg) {
            if (!this.baseCoin.supportsBlsDkg()) {
                throw new Error(`coin ${this.baseCoin.getFamily()} does not support BLS-DKG at this time`);
            }
            (0, assert_1.default)(enterprise, 'enterprise is required for BLS-DKG wallet');
            if (type === 'cold') {
                throw new Error('BLS-DKG SMC wallets are not supported at this time');
            }
            if (type === 'custodial') {
                throw new Error('BLS-DKG custodial wallets are not supported at this time');
            }
            (0, assert_1.default)(passphrase, 'cannot generate BLS-DKG keys without passphrase');
            return this.generateMpcWallet({ multisigType: 'blsdkg', label, passphrase, enterprise });
        }
        // Handle distributed custody
        if (isDistributedCustody) {
            if (!enterprise) {
                throw new Error('must provide enterprise when creating distributed custody wallet');
            }
            if (!type || type !== 'cold') {
                throw new Error('distributed custody wallets must be type: cold');
            }
        }
        const hasBackupXpub = !!params.backupXpub;
        const hasBackupXpubProvider = !!params.backupXpubProvider;
        if (hasBackupXpub && hasBackupXpubProvider) {
            throw new Error('Cannot provide more than one backupXpub or backupXpubProvider flag');
        }
        if (params.gasPrice && params.eip1559) {
            throw new Error('can not use both eip1559 and gasPrice values');
        }
        if (!_.isUndefined(params.disableTransactionNotifications)) {
            if (!_.isBoolean(params.disableTransactionNotifications)) {
                throw new Error('invalid disableTransactionNotifications argument, expecting boolean');
            }
            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
        }
        if (!_.isUndefined(params.gasPrice)) {
            const gasPriceBN = new bignumber_js_1.BigNumber(params.gasPrice);
            if (gasPriceBN.isNaN()) {
                throw new Error('invalid gas price argument, expecting number or number as string');
            }
            walletParams.gasPrice = gasPriceBN.toString();
        }
        if (!_.isUndefined(params.eip1559) && !_.isEmpty(params.eip1559)) {
            const maxFeePerGasBN = new bignumber_js_1.BigNumber(params.eip1559.maxFeePerGas);
            if (maxFeePerGasBN.isNaN()) {
                throw new Error('invalid max fee argument, expecting number or number as string');
            }
            const maxPriorityFeePerGasBN = new bignumber_js_1.BigNumber(params.eip1559.maxPriorityFeePerGas);
            if (maxPriorityFeePerGasBN.isNaN()) {
                throw new Error('invalid priority fee argument, expecting number or number as string');
            }
            walletParams.eip1559 = {
                maxFeePerGas: maxFeePerGasBN.toString(),
                maxPriorityFeePerGas: maxPriorityFeePerGasBN.toString(),
            };
        }
        if (!_.isUndefined(params.disableKRSEmail)) {
            if (!_.isBoolean(params.disableKRSEmail)) {
                throw new Error('invalid disableKRSEmail argument, expecting boolean');
            }
            walletParams.disableKRSEmail = params.disableKRSEmail;
        }
        if (!_.isUndefined(params.walletVersion)) {
            if (!_.isNumber(params.walletVersion)) {
                throw new Error('invalid walletVersion provided, expecting number');
            }
            walletParams.walletVersion = params.walletVersion;
        }
        // Ensure each krsSpecific param is either a string, boolean, or number
        const { krsSpecific } = params;
        if (!_.isUndefined(krsSpecific)) {
            Object.keys(krsSpecific).forEach((key) => {
                const val = krsSpecific[key];
                if (!_.isBoolean(val) && !_.isString(val) && !_.isNumber(val)) {
                    throw new Error('krsSpecific object contains illegal values. values must be strings, booleans, or numbers');
                }
            });
        }
        let derivationPath = undefined;
        const reqId = new utils_1.RequestTracer();
        // Add the user keychain
        const userKeychainPromise = async () => {
            let userKeychainParams;
            let userKeychain;
            // User provided user key
            if (params.userKey) {
                userKeychain = { pub: params.userKey };
                userKeychainParams = userKeychain;
                if (params.coldDerivationSeed) {
                    // the derivation only makes sense when a key already exists
                    const derivation = this.baseCoin.deriveKeyWithSeed({
                        key: params.userKey,
                        seed: params.coldDerivationSeed,
                    });
                    derivationPath = derivation.derivationPath;
                    userKeychain.pub = derivation.key;
                    userKeychain.derivedFromParentWithSeed = params.coldDerivationSeed;
                }
            }
            else {
                if (!canEncrypt) {
                    throw new Error('cannot generate user keypair without passphrase');
                }
                // Create the user key.
                userKeychain = this.baseCoin.keychains().create();
                userKeychain.encryptedPrv = this.bitgo.encrypt({ password: passphrase, input: userKeychain.prv });
                userKeychainParams = {
                    pub: userKeychain.pub,
                    encryptedPrv: userKeychain.encryptedPrv,
                    originalPasscodeEncryptionCode: params.passcodeEncryptionCode,
                };
            }
            userKeychainParams.reqId = reqId;
            const newUserKeychain = await this.baseCoin.keychains().add(userKeychainParams);
            return _.extend({}, newUserKeychain, userKeychain);
        };
        const backupKeychainPromise = async () => {
            if (params.backupXpubProvider) {
                // If requested, use a KRS or backup key provider
                return this.baseCoin.keychains().createBackup({
                    provider: params.backupXpubProvider || 'defaultRMGBackupProvider',
                    disableKRSEmail: params.disableKRSEmail,
                    krsSpecific: params.krsSpecific,
                    type: this.baseCoin.getChain(),
                    passphrase: params.passphrase,
                    reqId,
                });
            }
            // User provided backup xpub
            if (params.backupXpub) {
                // user provided backup ethereum address
                return this.baseCoin.keychains().add({
                    pub: params.backupXpub,
                    source: 'backup',
                    reqId,
                });
            }
            else {
                if (!canEncrypt) {
                    throw new Error('cannot generate backup keypair without passphrase');
                }
                // No provided backup xpub or address, so default to creating one here
                return this.baseCoin.keychains().createBackup({ reqId, passphrase: params.passphrase });
            }
        };
        const { userKeychain, backupKeychain, bitgoKeychain } = await (0, utils_1.promiseProps)({
            userKeychain: userKeychainPromise(),
            backupKeychain: backupKeychainPromise(),
            bitgoKeychain: this.baseCoin
                .keychains()
                .createBitGo({ enterprise: params.enterprise, reqId, isDistributedCustody: params.isDistributedCustody }),
        });
        walletParams.keys = [userKeychain.id, backupKeychain.id, bitgoKeychain.id];
        const { prv } = userKeychain;
        if (_.isString(prv)) {
            (0, assert_1.default)(backupKeychain.pub);
            (0, assert_1.default)(bitgoKeychain.pub);
            walletParams.keySignatures = {
                backup: (await this.baseCoin.signMessage({ prv }, backupKeychain.pub)).toString('hex'),
                bitgo: (await this.baseCoin.signMessage({ prv }, bitgoKeychain.pub)).toString('hex'),
            };
        }
        if (_.includes(['xrp', 'xlm', 'cspr'], this.baseCoin.getFamily()) && !_.isUndefined(params.rootPrivateKey)) {
            walletParams.rootPrivateKey = params.rootPrivateKey;
        }
        // Custodial onchain wallets do not need m, n, keys, or keySignatures
        if (params.type === 'custodial' && ((_a = params.multisigType) !== null && _a !== void 0 ? _a : 'onchain') === 'onchain') {
            walletParams.n = undefined;
            walletParams.m = undefined;
            walletParams.keys = undefined;
            walletParams.keySignatures = undefined;
        }
        const keychains = {
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        const finalWalletParams = await this.baseCoin.supplementGenerateWallet(walletParams, keychains);
        this.bitgo.setRequestTracer(reqId);
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const result = {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
            userKeychain: userKeychain,
            backupKeychain: backupKeychain,
            bitgoKeychain: bitgoKeychain,
            responseType: 'WalletWithKeychains',
        };
        if (!_.isUndefined(backupKeychain.prv)) {
            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
        }
        if (!_.isUndefined(derivationPath)) {
            userKeychain.derivationPath = derivationPath;
        }
        return result;
    }
    /**
     * List the user's wallet shares
     * @param params
     */
    async listShares(params = {}) {
        return await this.bitgo.get(this.baseCoin.url('/walletshare')).result();
    }
    /**
     * Gets a wallet share information, including the encrypted sharing keychain. requires unlock if keychain is present.
     * @param params
     * @param params.walletShareId - the wallet share to get information on
     */
    async getShare(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo.get(this.baseCoin.url('/walletshare/' + params.walletShareId)).result();
    }
    /**
     * Update a wallet share
     * @param params.walletShareId - the wallet share to update
     * @param params.state - the new state of the wallet share
     * @param params
     */
    async updateShare(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo
            .post(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send(params)
            .result();
    }
    /**
     * Resend a wallet share invitation email
     * @param params
     * @param params.walletShareId - the wallet share whose invitiation should be resent
     */
    async resendShareInvite(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        const urlParts = params.walletShareId + '/resendemail';
        return this.bitgo.post(this.baseCoin.url('/walletshare/' + urlParts)).result();
    }
    /**
     * Cancel a wallet share
     * @param params
     * @param params.walletShareId - the wallet share to update
     */
    async cancelShare(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo
            .del(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send()
            .result();
    }
    /**
     * Re-share wallet with existing spenders of the wallet
     * @param walletId
     * @param userPassword
     */
    async reshareWalletWithSpenders(walletId, userPassword) {
        var _a, _b;
        const wallet = await this.get({ id: walletId });
        if (!((_a = wallet === null || wallet === void 0 ? void 0 : wallet._wallet) === null || _a === void 0 ? void 0 : _a.enterprise)) {
            throw new Error('Enterprise not found for the wallet');
        }
        const enterpriseUsersResponse = await this.bitgo
            .get(this.bitgo.url(`/enterprise/${(_b = wallet === null || wallet === void 0 ? void 0 : wallet._wallet) === null || _b === void 0 ? void 0 : _b.enterprise}/user`))
            .result();
        // create a map of users for easy lookup - we need the user email id to share the wallet
        const usersMap = new Map([...enterpriseUsersResponse === null || enterpriseUsersResponse === void 0 ? void 0 : enterpriseUsersResponse.adminUsers, ...enterpriseUsersResponse === null || enterpriseUsersResponse === void 0 ? void 0 : enterpriseUsersResponse.nonAdminUsers].map((obj) => [obj.id, obj]));
        if (wallet._wallet.users) {
            for (const user of wallet._wallet.users) {
                const userObject = usersMap.get(user.user);
                if (user.permissions.includes('spend') && !user.permissions.includes('admin') && userObject) {
                    const shareParams = {
                        walletId: walletId,
                        user: user.user,
                        permissions: user.permissions.join(','),
                        walletPassphrase: userPassword,
                        email: userObject.email.email,
                        reshare: true,
                        skipKeychain: false,
                    };
                    await wallet.shareWallet(shareParams);
                }
            }
        }
    }
    /**
     * Accepts a wallet share, adding the wallet to the user's list
     * Needs a user's password to decrypt the shared key
     *
     * @param params
     * @param params.walletShareId - the wallet share to accept
     * @param params.userPassword - (required if more a keychain was shared) user's password to decrypt the shared wallet
     * @param params.newWalletPassphrase - new wallet passphrase for saving the shared wallet prv.
     *                                     If left blank and a wallet with more than view permissions was shared,
     *                                     then the user's login password is used.
     * @param params.overrideEncryptedPrv - set only if the prv was received out-of-band.
     */
    async acceptShare(params = {}) {
        common.validateParams(params, ['walletShareId'], ['overrideEncryptedPrv', 'userPassword', 'newWalletPassphrase']);
        let encryptedPrv = params.overrideEncryptedPrv;
        const walletShare = await this.getShare({ walletShareId: params.walletShareId });
        if (walletShare.keychainOverrideRequired &&
            walletShare.permissions.indexOf('admin') !== -1 &&
            walletShare.permissions.indexOf('spend') !== -1) {
            if (_.isUndefined(params.userPassword)) {
                throw new Error('userPassword param must be provided to decrypt shared key');
            }
            const walletKeychain = await this.baseCoin.keychains().createUserKeychain(params.userPassword);
            if (_.isUndefined(walletKeychain.encryptedPrv)) {
                throw new Error('encryptedPrv was not found on wallet keychain');
            }
            const payload = {
                tradingAccountId: walletShare.wallet,
                pubkey: walletKeychain.pub,
                timestamp: new Date().toISOString(),
            };
            const payloadString = JSON.stringify(payload);
            const privateKey = this.bitgo.decrypt({
                password: params.userPassword,
                input: walletKeychain.encryptedPrv,
            });
            const signature = await this.baseCoin.signMessage({ prv: privateKey }, payloadString);
            const response = await this.updateShare({
                walletShareId: params.walletShareId,
                state: 'accepted',
                keyId: walletKeychain.id,
                signature: signature.toString('hex'),
                payload: payloadString,
            });
            // If the wallet share was accepted successfully (changed=true), reshare the wallet with the spenders
            if (response.changed && response.state === 'accepted') {
                try {
                    await this.reshareWalletWithSpenders(walletShare.wallet, params.userPassword);
                }
                catch (e) {
                    // TODO: PX-3826
                    // Do nothing
                }
            }
            return response;
        }
        // Return right away if there is no keychain to decrypt, or if explicit encryptedPrv was provided
        if (!walletShare.keychain || !walletShare.keychain.encryptedPrv || encryptedPrv) {
            return this.updateShare({
                walletShareId: params.walletShareId,
                state: 'accepted',
            });
        }
        // More than viewing was requested, so we need to process the wallet keys using the shared ecdh scheme
        if (_.isUndefined(params.userPassword)) {
            throw new Error('userPassword param must be provided to decrypt shared key');
        }
        const sharingKeychain = (await this.bitgo.getECDHKeychain());
        if (_.isUndefined(sharingKeychain.encryptedXprv)) {
            throw new Error('encryptedXprv was not found on sharing keychain');
        }
        // Now we have the sharing keychain, we can work out the secret used for sharing the wallet with us
        sharingKeychain.prv = this.bitgo.decrypt({
            password: params.userPassword,
            input: sharingKeychain.encryptedXprv,
        });
        const secret = (0, ecdh_1.getSharedSecret)(
        // Derive key by path (which is used between these 2 users only)
        utxo_lib_1.bip32.fromBase58(sharingKeychain.prv).derivePath((0, api_1.sanitizeLegacyPath)(walletShare.keychain.path)), Buffer.from(walletShare.keychain.fromPubKey, 'hex')).toString('hex');
        // Yes! We got the secret successfully here, now decrypt the shared wallet prv
        const decryptedSharedWalletPrv = this.bitgo.decrypt({
            password: secret,
            input: walletShare.keychain.encryptedPrv,
        });
        // We will now re-encrypt the wallet with our own password
        const newWalletPassphrase = params.newWalletPassphrase || params.userPassword;
        encryptedPrv = this.bitgo.encrypt({
            password: newWalletPassphrase,
            input: decryptedSharedWalletPrv,
        });
        const updateParams = {
            walletShareId: params.walletShareId,
            state: 'accepted',
        };
        if (encryptedPrv) {
            updateParams.encryptedPrv = encryptedPrv;
        }
        return this.updateShare(updateParams);
    }
    /**
     * Get a wallet by its ID
     * @param params
     * @param params.id wallet id
     * @returns {*}
     */
    async getWallet(params = {}) {
        common.validateParams(params, ['id'], []);
        const query = {};
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            query.allTokens = params.allTokens;
        }
        this.bitgo.setRequestTracer(params.reqId || new utils_1.RequestTracer());
        const wallet = await this.bitgo
            .get(this.baseCoin.url('/wallet/' + params.id))
            .query(query)
            .result();
        return new wallet_1.Wallet(this.bitgo, this.baseCoin, wallet);
    }
    /**
     * Get a wallet by its address
     * @param params
     * @param params.address wallet address
     * @returns {*}
     */
    async getWalletByAddress(params = {}) {
        common.validateParams(params, ['address'], []);
        this.bitgo.setRequestTracer(params.reqId || new utils_1.RequestTracer());
        const wallet = await this.bitgo.get(this.baseCoin.url('/wallet/address/' + params.address)).result();
        return new wallet_1.Wallet(this.bitgo, this.baseCoin, wallet);
    }
    /**
     * For any given supported coin, get total balances for all wallets of that
     * coin type on the account.
     * @param params
     * @returns {*}
     */
    async getTotalBalances(params = {}) {
        return await this.bitgo.get(this.baseCoin.url('/wallet/balances')).result();
    }
    /**
     * Generates a TSS or BLS-DKG Wallet.
     * @param params
     * @private
     */
    async generateMpcWallet({ passphrase, label, multisigType, enterprise, walletVersion, originalPasscodeEncryptionCode, backupProvider, }) {
        var _a, _b;
        if (multisigType === 'tss' && this.baseCoin.getMPCAlgorithm() === 'ecdsa') {
            const tssSettings = await this.bitgo
                .get(this.bitgo.microservicesUrl('/api/v2/tss/settings'))
                .result();
            const multisigTypeVersion = (_b = (_a = tssSettings.coinSettings[this.baseCoin.getFamily()]) === null || _a === void 0 ? void 0 : _a.walletCreationSettings) === null || _b === void 0 ? void 0 : _b.multiSigTypeVersion;
            if (this.baseCoin.isEVM() && multisigTypeVersion === 'MPCv2') {
                walletVersion = 5;
            }
        }
        const reqId = new utils_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        // Create MPC Keychains
        const keychains = await this.baseCoin.keychains().createMpc({
            multisigType,
            passphrase,
            enterprise,
            originalPasscodeEncryptionCode,
            backupProvider,
        });
        // Create Wallet
        const { userKeychain, backupKeychain, bitgoKeychain } = keychains;
        const walletParams = {
            label,
            m: 2,
            n: 3,
            keys: [userKeychain.id, backupKeychain.id, bitgoKeychain.id],
            type: 'hot',
            multisigType,
            enterprise,
            walletVersion,
        };
        const finalWalletParams = await this.baseCoin.supplementGenerateWallet(walletParams, keychains);
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const result = {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
            userKeychain,
            backupKeychain,
            bitgoKeychain,
            responseType: 'WalletWithKeychains',
        };
        if (!_.isUndefined(backupKeychain.prv) && !_.isUndefined(backupProvider)) {
            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
        }
        return result;
    }
    /**
     * Generates a Self-Managed Cold TSS Wallet.
     * @param params
     * @private
     */
    async generateSMCMpcWallet({ label, multisigType, enterprise, walletVersion, bitgoKeyId, commonKeychain, coldDerivationSeed, }) {
        const reqId = new utils_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        // Create MPC Keychains
        const bitgoKeychain = await this.baseCoin.keychains().get({ id: bitgoKeyId });
        if (!bitgoKeychain || !bitgoKeychain.commonKeychain) {
            throw new Error('BitGo keychain not found');
        }
        if (bitgoKeychain.source !== 'bitgo') {
            throw new Error('The provided bitgoKeyId is not a BitGo keychain');
        }
        if (bitgoKeychain.commonKeychain !== commonKeychain) {
            throw new Error('The provided Common keychain mismatch with the provided Bitgo key');
        }
        if (!coldDerivationSeed) {
            throw new Error('derivedFromParentWithSeed is required');
        }
        const userKeychainParams = {
            source: 'user',
            keyType: 'tss',
            commonKeychain: commonKeychain,
            derivedFromParentWithSeed: coldDerivationSeed,
        };
        const userKeychain = await this.baseCoin.keychains().add(userKeychainParams);
        const backupKeyChainParams = {
            source: 'backup',
            keyType: 'tss',
            commonKeychain: commonKeychain,
            derivedFromParentWithSeed: coldDerivationSeed,
        };
        const backupKeychain = await this.baseCoin.keychains().add(backupKeyChainParams);
        // Create Wallet
        const keychains = { userKeychain, backupKeychain, bitgoKeychain };
        const walletParams = {
            label,
            m: 2,
            n: 3,
            keys: [userKeychain.id, backupKeychain.id, bitgoKeychain.id],
            type: 'cold',
            multisigType,
            enterprise,
            walletVersion,
        };
        const finalWalletParams = await this.baseCoin.supplementGenerateWallet(walletParams, keychains);
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const result = {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
            userKeychain,
            backupKeychain,
            bitgoKeychain,
            responseType: 'WalletWithKeychains',
        };
        return result;
    }
    /**
     * Generates a Custodial TSS Wallet.
     * @param params
     * @private
     */
    async generateCustodialMpcWallet({ label, multisigType, enterprise, walletVersion, }) {
        const reqId = new utils_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        const finalWalletParams = {
            label,
            multisigType,
            enterprise,
            walletVersion,
            type: 'custodial',
        };
        // Create Wallet
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const wallet = new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet);
        const keychains = wallet.keyIds();
        const result = {
            wallet,
            userKeychain: { id: keychains[0], type: multisigType, source: 'user' },
            backupKeychain: { id: keychains[1], type: multisigType, source: 'backup' },
            bitgoKeychain: { id: keychains[2], type: multisigType, source: 'bitgo' },
            responseType: 'WalletWithKeychains',
        };
        return result;
    }
}
exports.Wallets = Wallets;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iaXRnby93YWxsZXQvd2FsbGV0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsb0RBQTRCO0FBQzVCLCtDQUF5QztBQUN6Qyw4Q0FBd0M7QUFDeEMsMENBQTRCO0FBQzVCLDRDQUE2QztBQUU3QyxtQ0FBK0M7QUFDL0MscURBQXVDO0FBR3ZDLGtDQUEwQztBQUUxQyxvQ0FBcUU7QUFDckUseUNBZ0JvQjtBQUNwQixxQ0FBa0M7QUFHbEM7O0dBRUc7QUFDSCxTQUFnQixxQkFBcUIsQ0FDbkMsTUFBMEQ7SUFFMUQsT0FBTyxNQUFNLENBQUMsWUFBWSxLQUFLLHFCQUFxQixDQUFDO0FBQ3ZELENBQUM7QUFKRCxzREFJQztBQUVELE1BQWEsT0FBTztJQUlsQixZQUFZLEtBQWdCLEVBQUUsUUFBbUI7UUFDL0MsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxHQUFHLENBQUMsU0FBMkIsRUFBRTtRQUNyQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQXNELEVBQUU7UUFDakUsSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1NBQ3hEO1FBQ0QsTUFBTSxJQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFD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QUN4RSxZQUFZLEVBQUUscUJBQXFCO1NBQ3BDLENBQUM7UUFFRixPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUFyOEJELDBCQXE4QkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgYmlwMzIgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgQ29pbkZlYXR1cmUgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5cbmltcG9ydCB7IHNhbml0aXplTGVnYWN5UGF0aCB9IGZyb20gJy4uLy4uL2FwaSc7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi4vLi4vY29tbW9uJztcbmltcG9ydCB7IElCYXNlQ29pbiwgS2V5Y2hhaW5zVHJpcGxldCwgS2V5UGFpciwgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgeyBnZXRTaGFyZWRTZWNyZXQgfSBmcm9tICcuLi9lY2RoJztcbmltcG9ydCB7IEFkZEtleWNoYWluT3B0aW9ucywgS2V5Y2hhaW4gfSBmcm9tICcuLi9rZXljaGFpbic7XG5pbXBvcnQgeyBkZWNvZGVPckVsc2UsIHByb21pc2VQcm9wcywgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7XG4gIEFjY2VwdFNoYXJlT3B0aW9ucyxcbiAgQWRkV2FsbGV0T3B0aW9ucyxcbiAgR2VuZXJhdGVCYXNlTXBjV2FsbGV0T3B0aW9ucyxcbiAgR2VuZXJhdGVMaWdodG5pbmdXYWxsZXRPcHRpb25zLFxuICBHZW5lcmF0ZUxpZ2h0bmluZ1dhbGxldE9wdGlvbnNDb2RlYyxcbiAgR2VuZXJhdGVNcGNXYWxsZXRPcHRpb25zLFxuICBHZW5lcmF0ZVNNQ01wY1dhbGxldE9wdGlvbnMsXG4gIEdlbmVyYXRlV2FsbGV0T3B0aW9ucyxcbiAgR2V0V2FsbGV0QnlBZGRyZXNzT3B0aW9ucyxcbiAgR2V0V2FsbGV0T3B0aW9ucyxcbiAgSVdhbGxldHMsXG4gIExpZ2h0bmluZ1dhbGxldFdpdGhLZXljaGFpbnMsXG4gIExpc3RXYWxsZXRPcHRpb25zLFxuICBVcGRhdGVTaGFyZU9wdGlvbnMsXG4gIFdhbGxldFdpdGhLZXljaGFpbnMsXG59IGZyb20gJy4vaVdhbGxldHMnO1xuaW1wb3J0IHsgV2FsbGV0IH0gZnJvbSAnLi93YWxsZXQnO1xuaW1wb3J0IHsgVHNzU2V0dGluZ3MgfSBmcm9tICdAYml0Z28vcHVibGljLXR5cGVzJztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHdhbGxldCBpcyBhIFdhbGxldFdpdGhLZXljaGFpbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2FsbGV0V2l0aEtleWNoYWlucyhcbiAgd2FsbGV0OiBXYWxsZXRXaXRoS2V5Y2hhaW5zIHwgTGlnaHRuaW5nV2FsbGV0V2l0aEtleWNoYWluc1xuKTogd2FsbGV0IGlzIFdhbGxldFdpdGhLZXljaGFpbnMge1xuICByZXR1cm4gd2FsbGV0LnJlc3BvbnNlVHlwZSA9PT0gJ1dhbGxldFdpdGhLZXljaGFpbnMnO1xufVxuXG5leHBvcnQgY2xhc3MgV2FsbGV0cyBpbXBsZW1lbnRzIElXYWxsZXRzIHtcbiAgcHJpdmF0ZSByZWFkb25seSBiaXRnbzogQml0R29CYXNlO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBJQmFzZUNvaW47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgYmFzZUNvaW46IElCYXNlQ29pbikge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgd2FsbGV0IGJ5IElEIChwcm94eSBmb3IgZ2V0V2FsbGV0KVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBnZXQocGFyYW1zOiBHZXRXYWxsZXRPcHRpb25zID0ge30pOiBQcm9taXNlPFdhbGxldD4ge1xuICAgIHJldHVybiB0aGlzLmdldFdhbGxldChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgYSB1c2VyJ3Mgd2FsbGV0c1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgbGlzdChwYXJhbXM6IExpc3RXYWxsZXRPcHRpb25zICYgeyBlbnRlcnByaXNlPzogc3RyaW5nIH0gPSB7fSk6IFByb21pc2U8eyB3YWxsZXRzOiBXYWxsZXRbXSB9PiB7XG4gICAgaWYgKHBhcmFtcy5za2lwICYmIHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwZWNpZnkgYm90aCBza2lwIGFuZCBwcmV2SWQnKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IChhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldCcpKS5xdWVyeShwYXJhbXMpLnJlc3VsdCgpKSBhcyBhbnk7XG4gICAgYm9keS53YWxsZXRzID0gYm9keS53YWxsZXRzLm1hcCgodykgPT4gbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCB3KSk7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICAvKipcbiAgICogYWRkXG4gICAqIEFkZCBhIG5ldyB3YWxsZXQgKGFkdmFuY2VkIG1vZGUpLlxuICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gbWFudWFsbHkgc3VibWl0IHRoZSBrZXlzLCB0eXBlLCBtIGFuZCBuIG9mIHRoZSB3YWxsZXRcbiAgICogUGFyYW1ldGVycyBpbmNsdWRlOlxuICAgKiAgICBcImxhYmVsXCI6IGxhYmVsIG9mIHRoZSB3YWxsZXQgdG8gYmUgc2hvd24gaW4gVUlcbiAgICogICAgXCJtXCI6IG51bWJlciBvZiBrZXlzIHJlcXVpcmVkIHRvIHVubG9jayB3YWxsZXQgKDIpXG4gICAqICAgIFwiblwiOiBudW1iZXIgb2Yga2V5cyBhdmFpbGFibGUgb24gdGhlIHdhbGxldCAoMylcbiAgICogICAgXCJrZXlzXCI6IGFycmF5IG9mIGtleWNoYWluIGlkc1xuICAgKi9cbiAgYXN5bmMgYWRkKHBhcmFtczogQWRkV2FsbGV0T3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnbGFiZWwnLCAnZW50ZXJwcmlzZScsICd0eXBlJ10pO1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMubGFiZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIHBhcmFtZXRlciBsYWJlbCcpO1xuICAgIH1cblxuICAgIC8vIG5vIG5lZWQgdG8gcGFzcyBrZXlzIGZvciAoc2luZ2xlKSBjdXN0b2RpYWwgd2FsbGV0c1xuICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ2N1c3RvZGlhbCcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcy5rZXlzKSA9PT0gZmFsc2UgfHwgIV8uaXNOdW1iZXIocGFyYW1zLm0pIHx8ICFfLmlzTnVtYmVyKHBhcmFtcy5uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogc3VwcG9ydCBtb3JlIHR5cGVzIG9mIG11bHRpc2lnXG4gICAgICBpZiAoIXRoaXMuYmFzZUNvaW4uaXNWYWxpZE1vZk5TZXR1cChwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgbXVsdGktc2lnIHR5cGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmdhc1ByaWNlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5nYXNQcmljZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgZ2FzUHJpY2UgLSBudW1iZXIgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLndhbGxldFZlcnNpb24pIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMud2FsbGV0VmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciB3YWxsZXRWZXJzaW9uIC0gbnVtYmVyIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLm11bHRpc2lnVHlwZSA9PT0gJ3RzcycgJiYgdGhpcy5iYXNlQ29pbi5nZXRNUENBbGdvcml0aG0oKSA9PT0gJ2VjZHNhJyAmJiBwYXJhbXMud2FsbGV0VmVyc2lvbiA9PT0gMykge1xuICAgICAgICBjb25zdCB0c3NTZXR0aW5nczogVHNzU2V0dGluZ3MgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAgICAgLmdldCh0aGlzLmJpdGdvLm1pY3Jvc2VydmljZXNVcmwoJy9hcGkvdjIvdHNzL3NldHRpbmdzJykpXG4gICAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgICBjb25zdCBtdWx0aXNpZ1R5cGVWZXJzaW9uID1cbiAgICAgICAgICB0c3NTZXR0aW5ncy5jb2luU2V0dGluZ3NbdGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKV0/LndhbGxldENyZWF0aW9uU2V0dGluZ3M/Lm11bHRpU2lnVHlwZVZlcnNpb247XG4gICAgICAgIGlmIChtdWx0aXNpZ1R5cGVWZXJzaW9uID09PSAnTVBDdjInKSB7XG4gICAgICAgICAgcGFyYW1zLndhbGxldFZlcnNpb24gPSA1O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy50YWdzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLnRhZ3MpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciB0YWdzIC0gYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmNsaWVudEZsYWdzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLmNsaWVudEZsYWdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgY2xpZW50RmxhZ3MgLSBhcnJheSBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuaXNDb2xkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuaXNDb2xkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBpc0NvbGQgLSBib29sZWFuIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5pc0N1c3RvZGlhbCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmlzQ3VzdG9kaWFsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBpc0N1c3RvZGlhbCAtIGJvb2xlYW4gZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFkZHJlc3MgJiYgKCFfLmlzU3RyaW5nKHBhcmFtcy5hZGRyZXNzKSB8fCAhdGhpcy5iYXNlQ29pbi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMuYWRkcmVzcykpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGFkZHJlc3MgLSB2YWxpZCBhZGRyZXNzIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1dhbGxldCA9IGF3YWl0IHRoaXMuYml0Z28ucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldCcpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhbGxldDogbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCBuZXdXYWxsZXQpLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlTGlnaHRuaW5nV2FsbGV0KHBhcmFtczogR2VuZXJhdGVMaWdodG5pbmdXYWxsZXRPcHRpb25zKTogUHJvbWlzZTxMaWdodG5pbmdXYWxsZXRXaXRoS2V5Y2hhaW5zPiB7XG4gICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG5cbiAgICBjb25zdCB7IGxhYmVsLCBwYXNzcGhyYXNlLCBlbnRlcnByaXNlLCBwYXNzY29kZUVuY3J5cHRpb25Db2RlIH0gPSBwYXJhbXM7XG5cbiAgICBjb25zdCBrZXljaGFpblByb21pc2VzID0gKFt1bmRlZmluZWQsICd1c2VyQXV0aCcsICdub2RlQXV0aCddIGFzIGNvbnN0KS5tYXAoKHB1cnBvc2UpID0+IHtcbiAgICAgIHJldHVybiBhc3luYyAoKTogUHJvbWlzZTxLZXljaGFpbj4gPT4ge1xuICAgICAgICBsZXQga2V5Y2hhaW46IEtleVBhaXIgfCBudWxsID0gdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5jcmVhdGUoKTtcbiAgICAgICAgY29uc3QgcHViID0ga2V5Y2hhaW4ucHViO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWRQcnYgPSB0aGlzLmJpdGdvLmVuY3J5cHQoeyBwYXNzd29yZDogcGFzc3BocmFzZSwgaW5wdXQ6IGtleWNoYWluLnBydiB9KTtcbiAgICAgICAgZGVsZXRlIChrZXljaGFpbiBhcyBhbnkpLnBydjtcbiAgICAgICAga2V5Y2hhaW4gPSBudWxsO1xuICAgICAgICBjb25zdCBrZXljaGFpblBhcmFtczogQWRkS2V5Y2hhaW5PcHRpb25zID0ge1xuICAgICAgICAgIHB1YixcbiAgICAgICAgICBlbmNyeXB0ZWRQcnYsXG4gICAgICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlOiBwdXJwb3NlID09PSB1bmRlZmluZWQgPyBwYXNzY29kZUVuY3J5cHRpb25Db2RlIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNvaW5TcGVjaWZpYzogcHVycG9zZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogeyBbdGhpcy5iYXNlQ29pbi5nZXRDaGFpbigpXTogeyBwdXJwb3NlIH0gfSxcbiAgICAgICAgICBrZXlUeXBlOiAnaW5kZXBlbmRlbnQnLFxuICAgICAgICAgIHNvdXJjZTogJ3VzZXInLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5hZGQoa2V5Y2hhaW5QYXJhbXMpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlcktleWNoYWluLCB1c2VyQXV0aEtleWNoYWluLCBub2RlQXV0aEtleWNoYWluIH0gPSBhd2FpdCBwcm9taXNlUHJvcHMoe1xuICAgICAgdXNlcktleWNoYWluOiBrZXljaGFpblByb21pc2VzWzBdKCksXG4gICAgICB1c2VyQXV0aEtleWNoYWluOiBrZXljaGFpblByb21pc2VzWzFdKCksXG4gICAgICBub2RlQXV0aEtleWNoYWluOiBrZXljaGFpblByb21pc2VzWzJdKCksXG4gICAgfSk7XG5cbiAgICBjb25zdCB3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMgPSB7XG4gICAgICBsYWJlbCxcbiAgICAgIG06IDEsXG4gICAgICBuOiAxLFxuICAgICAgdHlwZTogJ2hvdCcsXG4gICAgICBlbnRlcnByaXNlLFxuICAgICAga2V5czogW3VzZXJLZXljaGFpbi5pZF0sXG4gICAgICBjb2luU3BlY2lmaWM6IHsgW3RoaXMuYmFzZUNvaW4uZ2V0Q2hhaW4oKV06IHsga2V5czogW3VzZXJBdXRoS2V5Y2hhaW4uaWQsIG5vZGVBdXRoS2V5Y2hhaW4uaWRdIH0gfSxcbiAgICB9O1xuXG4gICAgY29uc3QgbmV3V2FsbGV0ID0gYXdhaXQgdGhpcy5iaXRnby5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0JykpLnNlbmQod2FsbGV0UGFyYW1zKS5yZXN1bHQoKTtcbiAgICBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIG5ld1dhbGxldCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhbGxldCxcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIHVzZXJBdXRoS2V5Y2hhaW4sXG4gICAgICBub2RlQXV0aEtleWNoYWluLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnTGlnaHRuaW5nV2FsbGV0V2l0aEtleWNoYWlucycsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyB3YWxsZXRcbiAgICogMS4gQ3JlYXRlcyB0aGUgdXNlciBrZXljaGFpbiBsb2NhbGx5IG9uIHRoZSBjbGllbnQsIGFuZCBlbmNyeXB0cyBpdCB3aXRoIHRoZSBwcm92aWRlZCBwYXNzcGhyYXNlXG4gICAqIDIuIElmIG5vIHB1YiB3YXMgcHJvdmlkZWQsIGNyZWF0ZXMgdGhlIGJhY2t1cCBrZXljaGFpbiBsb2NhbGx5IG9uIHRoZSBjbGllbnQsIGFuZCBlbmNyeXB0cyBpdCB3aXRoIHRoZSBwcm92aWRlZCBwYXNzcGhyYXNlXG4gICAqIDMuIFVwbG9hZHMgdGhlIGVuY3J5cHRlZCB1c2VyIGFuZCBiYWNrdXAga2V5Y2hhaW5zIHRvIEJpdEdvXG4gICAqIDQuIENyZWF0ZXMgdGhlIEJpdEdvIGtleSBvbiB0aGUgc2VydmljZVxuICAgKiA1LiBDcmVhdGVzIHRoZSB3YWxsZXQgb24gQml0R28gd2l0aCB0aGUgMyBwdWJsaWMga2V5cyBhYm92ZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMubGFiZWwgTGFiZWwgZm9yIHRoZSB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtcy5wYXNzcGhyYXNlIFBhc3NwaHJhc2UgdG8gYmUgdXNlZCB0byBlbmNyeXB0IHRoZSB1c2VyIGFuZCBiYWNrdXAga2V5Y2hhaW5zXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcktleSBVc2VyIHhwdWJcbiAgICogQHBhcmFtIHBhcmFtcy5iYWNrdXBYcHViIEJhY2t1cCB4cHViXG4gICAqIEBwYXJhbSBwYXJhbXMuYmFja3VwWHB1YlByb3ZpZGVyXG4gICAqIEBwYXJhbSBwYXJhbXMuYmFja3VwUHJvdmlkZXIgVGhpcmQgcGFydHkgYmFja3VwIHByb3ZpZGVyIGZvciBUU1NcbiAgICogQHBhcmFtIHBhcmFtcy5lbnRlcnByaXNlIHRoZSBlbnRlcnByaXNlSWRcbiAgICogQHBhcmFtIHBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zXG4gICAqIEBwYXJhbSBwYXJhbXMucGFzc2NvZGVFbmNyeXB0aW9uQ29kZSBvcHRpb25hbCB0aGlzIGlzIGEgcmVjb3ZlcnkgY29kZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlY3J5cHQgdGhlIG9yaWdpbmFsIHBhc3NwaHJhc2UgaW4gYSByZWNvdmVyeSBjYXNlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHVzZXIgbXVzdCBnZW5lcmF0ZSBhbmQga2VlcCB0aGUgZW5jcnlwdGVkIG9yaWdpbmFsIHBhc3NwaHJhc2Ugc2FmZSB3aGlsZSB0aGlzIGNvZGUgaXMgc3RvcmVkIG9uIEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXMuY29sZERlcml2YXRpb25TZWVkIG9wdGlvbmFsIHNlZWQgZm9yIFNNQyB3YWxsZXRzXG4gICAqIEBwYXJhbSBwYXJhbXMuZ2FzUHJpY2VcbiAgICogQHBhcmFtIHBhcmFtcy5kaXNhYmxlS1JTRW1haWxcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRWZXJzaW9uXG4gICAqIEBwYXJhbSBwYXJhbXMubXVsdGlzaWdUeXBlIG9wdGlvbmFsIG11bHRpc2lnIHR5cGUsICdvbmNoYWluJyBvciAndHNzJyBvciAnYmxzZGtnJzsgaWYgYWJzZW50LCB3ZSB3aWxsIGRlZmVyIHRvIHRoZSBjb2luJ3MgZGVmYXVsdCB0eXBlXG4gICAqIEBwYXJhbSBwYXJhbXMuaXNEaXN0cmlidXRlZEN1c3RvZHkgb3B0aW9uYWwgcGFyYW1ldGVyIGZvciBjcmVhdGluZyBiaXRnbyBrZXkuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgaWYgeW91IHdhbnQgdG8gY3JlYXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBkaXN0cmlidXRlZCBjdXN0b2R5IHdhbGxldC4gSWYgcHJvdmlkZWQsIHlvdSBtdXN0IGhhdmUgdGhlIGVudGVycHJpc2UgbGljZW5zZSBhbmQgcGFzcyBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBwYXJhbXMuZW50ZXJwcmlzZWAgaW50byBgZ2VuZXJhdGVXYWxsZXRgIGFzIHdlbGwuXG4gICAqIEBwYXJhbSBwYXJhbXMudHlwZSBvcHRpb25hbCB3YWxsZXQgdHlwZSwgJ2hvdCcgb3IgJ2NvbGQnIG9yICdjdXN0b2RpYWwnOyBpZiBhYnNlbnQsIHdlIHdpbGwgZGVmZXIgdG8gJ2hvdCdcbiAgICogQHBhcmFtIHBhcmFtcy5iaXRnb0tleUlkIG9wdGlvbmFsIGJpdGdvIGtleSBpZCBmb3IgU01DIFRTUyB3YWxsZXRzXG4gICAqIEBwYXJhbSBwYXJhbXMuY29tbW9uS2V5Y2hhaW4gb3B0aW9uYWwgY29tbW9uIGtleWNoYWluIGZvciBTTUMgVFNTIHdhbGxldHNcbiAgICpcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVdhbGxldChcbiAgICBwYXJhbXM6IEdlbmVyYXRlV2FsbGV0T3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8V2FsbGV0V2l0aEtleWNoYWlucyB8IExpZ2h0bmluZ1dhbGxldFdpdGhLZXljaGFpbnM+IHtcbiAgICBpZiAodGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKSA9PT0gJ2xuYnRjJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGRlY29kZU9yRWxzZShcbiAgICAgICAgR2VuZXJhdGVMaWdodG5pbmdXYWxsZXRPcHRpb25zQ29kZWMubmFtZSxcbiAgICAgICAgR2VuZXJhdGVMaWdodG5pbmdXYWxsZXRPcHRpb25zQ29kZWMsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgKGVycm9ycykgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXJyb3IocykgcGFyc2luZyBnZW5lcmF0ZSBsaWdodG5pbmcgd2FsbGV0IHJlcXVlc3QgcGFyYW1zOiAke2Vycm9yc31gKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTGlnaHRuaW5nV2FsbGV0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnbGFiZWwnXSwgWydwYXNzcGhyYXNlJywgJ3VzZXJLZXknLCAnYmFja3VwWHB1YiddKTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5sYWJlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFyYW1ldGVyIGxhYmVsJyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyB0eXBlID0gJ2hvdCcsIGxhYmVsLCBwYXNzcGhyYXNlLCBlbnRlcnByaXNlLCBpc0Rpc3RyaWJ1dGVkQ3VzdG9keSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGlzVHNzID0gcGFyYW1zLm11bHRpc2lnVHlwZSA9PT0gJ3RzcycgJiYgdGhpcy5iYXNlQ29pbi5zdXBwb3J0c1RzcygpO1xuICAgIGNvbnN0IGNhbkVuY3J5cHQgPSAhIXBhc3NwaHJhc2UgJiYgdHlwZW9mIHBhc3NwaHJhc2UgPT09ICdzdHJpbmcnO1xuXG4gICAgY29uc3Qgd2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zID0ge1xuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgbTogMixcbiAgICAgIG46IDMsXG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHR5cGU6ICEhcGFyYW1zLnVzZXJLZXkgJiYgcGFyYW1zLm11bHRpc2lnVHlwZSAhPT0gJ29uY2hhaW4nID8gJ2NvbGQnIDogdHlwZSxcbiAgICB9O1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3Njb2RlRW5jcnlwdGlvbkNvZGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChlbnRlcnByaXNlKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKGVudGVycHJpc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbnRlcnByaXNlIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICB3YWxsZXRQYXJhbXMuZW50ZXJwcmlzZSA9IGVudGVycHJpc2U7XG4gICAgfVxuXG4gICAgLy8gRVZNIFRTUyB3YWxsZXRzIG11c3QgdXNlIHdhbGxldCB2ZXJzaW9uIDMgYW5kIDVcbiAgICBpZiAoaXNUc3MgJiYgdGhpcy5iYXNlQ29pbi5pc0VWTSgpICYmICEocGFyYW1zLndhbGxldFZlcnNpb24gPT09IDMgfHwgcGFyYW1zLndhbGxldFZlcnNpb24gPT09IDUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VWTSBUU1Mgd2FsbGV0cyBhcmUgb25seSBzdXBwb3J0ZWQgZm9yIHdhbGxldCB2ZXJzaW9uIDMgYW5kIDUnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNUc3MpIHtcbiAgICAgIGlmICghdGhpcy5iYXNlQ29pbi5zdXBwb3J0c1RzcygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29pbiAke3RoaXMuYmFzZUNvaW4uZ2V0RmFtaWx5KCl9IGRvZXMgbm90IHN1cHBvcnQgVFNTIGF0IHRoaXMgdGltZWApO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy53YWxsZXRWZXJzaW9uID09PSA1ICYmICF0aGlzLmJhc2VDb2luLmdldENvbmZpZygpLmZlYXR1cmVzLmluY2x1ZGVzKENvaW5GZWF0dXJlLk1QQ1YyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvaW4gJHt0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpfSBkb2VzIG5vdCBzdXBwb3J0IFRTUyBNUEN2MiBhdCB0aGlzIHRpbWVgKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChlbnRlcnByaXNlLCAnZW50ZXJwcmlzZSBpcyByZXF1aXJlZCBmb3IgVFNTIHdhbGxldCcpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2NvbGQnKSB7XG4gICAgICAgIGlmIChwYXJhbXMud2FsbGV0VmVyc2lvbiA9PT0gNSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRVZNIFRTUyBNUEN2MiB3YWxsZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBjb2xkIHdhbGxldHMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YWxpZGF0ZVxuICAgICAgICBhc3NlcnQocGFyYW1zLmJpdGdvS2V5SWQsICdiaXRnb0tleUlkIGlzIHJlcXVpcmVkIGZvciBTTUMgVFNTIHdhbGxldCcpO1xuICAgICAgICBhc3NlcnQocGFyYW1zLmNvbW1vbktleWNoYWluLCAnY29tbW9uS2V5Y2hhaW4gaXMgcmVxdWlyZWQgZm9yIFNNQyBUU1Mgd2FsbGV0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlU01DTXBjV2FsbGV0KHtcbiAgICAgICAgICBtdWx0aXNpZ1R5cGU6ICd0c3MnLFxuICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgIGVudGVycHJpc2UsXG4gICAgICAgICAgd2FsbGV0VmVyc2lvbjogcGFyYW1zLndhbGxldFZlcnNpb24sXG4gICAgICAgICAgYml0Z29LZXlJZDogcGFyYW1zLmJpdGdvS2V5SWQsXG4gICAgICAgICAgY29tbW9uS2V5Y2hhaW46IHBhcmFtcy5jb21tb25LZXljaGFpbixcbiAgICAgICAgICBjb2xkRGVyaXZhdGlvblNlZWQ6IHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ2N1c3RvZGlhbCcpIHtcbiAgICAgICAgaWYgKHBhcmFtcy53YWxsZXRWZXJzaW9uID09PSA1KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFVk0gVFNTIE1QQ3YyIHdhbGxldHMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGN1c3RvZGlhbCB3YWxsZXRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVDdXN0b2RpYWxNcGNXYWxsZXQoe1xuICAgICAgICAgIG11bHRpc2lnVHlwZTogJ3RzcycsXG4gICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgZW50ZXJwcmlzZSxcbiAgICAgICAgICB3YWxsZXRWZXJzaW9uOiBwYXJhbXMud2FsbGV0VmVyc2lvbixcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChwYXNzcGhyYXNlLCAnY2Fubm90IGdlbmVyYXRlIFRTUyBrZXlzIHdpdGhvdXQgcGFzc3BocmFzZScpO1xuXG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU1wY1dhbGxldCh7XG4gICAgICAgIG11bHRpc2lnVHlwZTogJ3RzcycsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBwYXNzcGhyYXNlLFxuICAgICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU6IHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgICBlbnRlcnByaXNlLFxuICAgICAgICB3YWxsZXRWZXJzaW9uOiBwYXJhbXMud2FsbGV0VmVyc2lvbixcbiAgICAgICAgYmFja3VwUHJvdmlkZXI6IHBhcmFtcy5iYWNrdXBQcm92aWRlcixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlzQmxzRGtnID0gcGFyYW1zLm11bHRpc2lnVHlwZSA/IHBhcmFtcy5tdWx0aXNpZ1R5cGUgPT09ICdibHNka2cnIDogdGhpcy5iYXNlQ29pbi5zdXBwb3J0c0Jsc0RrZygpO1xuICAgIGlmIChpc0Jsc0RrZykge1xuICAgICAgaWYgKCF0aGlzLmJhc2VDb2luLnN1cHBvcnRzQmxzRGtnKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2luICR7dGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKX0gZG9lcyBub3Qgc3VwcG9ydCBCTFMtREtHIGF0IHRoaXMgdGltZWApO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGVudGVycHJpc2UsICdlbnRlcnByaXNlIGlzIHJlcXVpcmVkIGZvciBCTFMtREtHIHdhbGxldCcpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2NvbGQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQkxTLURLRyBTTUMgd2FsbGV0cyBhcmUgbm90IHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdjdXN0b2RpYWwnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQkxTLURLRyBjdXN0b2RpYWwgd2FsbGV0cyBhcmUgbm90IHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUnKTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KHBhc3NwaHJhc2UsICdjYW5ub3QgZ2VuZXJhdGUgQkxTLURLRyBrZXlzIHdpdGhvdXQgcGFzc3BocmFzZScpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVNcGNXYWxsZXQoeyBtdWx0aXNpZ1R5cGU6ICdibHNka2cnLCBsYWJlbCwgcGFzc3BocmFzZSwgZW50ZXJwcmlzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZGlzdHJpYnV0ZWQgY3VzdG9keVxuICAgIGlmIChpc0Rpc3RyaWJ1dGVkQ3VzdG9keSkge1xuICAgICAgaWYgKCFlbnRlcnByaXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIGVudGVycHJpc2Ugd2hlbiBjcmVhdGluZyBkaXN0cmlidXRlZCBjdXN0b2R5IHdhbGxldCcpO1xuICAgICAgfVxuICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgIT09ICdjb2xkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3RyaWJ1dGVkIGN1c3RvZHkgd2FsbGV0cyBtdXN0IGJlIHR5cGU6IGNvbGQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoYXNCYWNrdXBYcHViID0gISFwYXJhbXMuYmFja3VwWHB1YjtcbiAgICBjb25zdCBoYXNCYWNrdXBYcHViUHJvdmlkZXIgPSAhIXBhcmFtcy5iYWNrdXBYcHViUHJvdmlkZXI7XG4gICAgaWYgKGhhc0JhY2t1cFhwdWIgJiYgaGFzQmFja3VwWHB1YlByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwcm92aWRlIG1vcmUgdGhhbiBvbmUgYmFja3VwWHB1YiBvciBiYWNrdXBYcHViUHJvdmlkZXIgZmxhZycpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZ2FzUHJpY2UgJiYgcGFyYW1zLmVpcDE1NTkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FuIG5vdCB1c2UgYm90aCBlaXAxNTU5IGFuZCBnYXNQcmljZSB2YWx1ZXMnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMpKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucyBhcmd1bWVudCwgZXhwZWN0aW5nIGJvb2xlYW4nKTtcbiAgICAgIH1cbiAgICAgIHdhbGxldFBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zID0gcGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5nYXNQcmljZSkpIHtcbiAgICAgIGNvbnN0IGdhc1ByaWNlQk4gPSBuZXcgQmlnTnVtYmVyKHBhcmFtcy5nYXNQcmljZSk7XG4gICAgICBpZiAoZ2FzUHJpY2VCTi5pc05hTigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBnYXMgcHJpY2UgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXIgb3IgbnVtYmVyIGFzIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgd2FsbGV0UGFyYW1zLmdhc1ByaWNlID0gZ2FzUHJpY2VCTi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZWlwMTU1OSkgJiYgIV8uaXNFbXB0eShwYXJhbXMuZWlwMTU1OSkpIHtcbiAgICAgIGNvbnN0IG1heEZlZVBlckdhc0JOID0gbmV3IEJpZ051bWJlcihwYXJhbXMuZWlwMTU1OS5tYXhGZWVQZXJHYXMpO1xuICAgICAgaWYgKG1heEZlZVBlckdhc0JOLmlzTmFOKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1heCBmZWUgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXIgb3IgbnVtYmVyIGFzIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXNCTiA9IG5ldyBCaWdOdW1iZXIocGFyYW1zLmVpcDE1NTkubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgaWYgKG1heFByaW9yaXR5RmVlUGVyR2FzQk4uaXNOYU4oKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpb3JpdHkgZmVlIGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyIG9yIG51bWJlciBhcyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHdhbGxldFBhcmFtcy5laXAxNTU5ID0ge1xuICAgICAgICBtYXhGZWVQZXJHYXM6IG1heEZlZVBlckdhc0JOLnRvU3RyaW5nKCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBtYXhQcmlvcml0eUZlZVBlckdhc0JOLnRvU3RyaW5nKCksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZGlzYWJsZUtSU0VtYWlsKSkge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuZGlzYWJsZUtSU0VtYWlsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGlzYWJsZUtSU0VtYWlsIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgd2FsbGV0UGFyYW1zLmRpc2FibGVLUlNFbWFpbCA9IHBhcmFtcy5kaXNhYmxlS1JTRW1haWw7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXRWZXJzaW9uKSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy53YWxsZXRWZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd2FsbGV0VmVyc2lvbiBwcm92aWRlZCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgd2FsbGV0UGFyYW1zLndhbGxldFZlcnNpb24gPSBwYXJhbXMud2FsbGV0VmVyc2lvbjtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgZWFjaCBrcnNTcGVjaWZpYyBwYXJhbSBpcyBlaXRoZXIgYSBzdHJpbmcsIGJvb2xlYW4sIG9yIG51bWJlclxuICAgIGNvbnN0IHsga3JzU3BlY2lmaWMgfSA9IHBhcmFtcztcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoa3JzU3BlY2lmaWMpKSB7XG4gICAgICBPYmplY3Qua2V5cyhrcnNTcGVjaWZpYykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGtyc1NwZWNpZmljW2tleV07XG4gICAgICAgIGlmICghXy5pc0Jvb2xlYW4odmFsKSAmJiAhXy5pc1N0cmluZyh2YWwpICYmICFfLmlzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tyc1NwZWNpZmljIG9iamVjdCBjb250YWlucyBpbGxlZ2FsIHZhbHVlcy4gdmFsdWVzIG11c3QgYmUgc3RyaW5ncywgYm9vbGVhbnMsIG9yIG51bWJlcnMnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IGRlcml2YXRpb25QYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCByZXFJZCA9IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG5cbiAgICAvLyBBZGQgdGhlIHVzZXIga2V5Y2hhaW5cbiAgICBjb25zdCB1c2VyS2V5Y2hhaW5Qcm9taXNlID0gYXN5bmMgKCk6IFByb21pc2U8S2V5Y2hhaW4+ID0+IHtcbiAgICAgIGxldCB1c2VyS2V5Y2hhaW5QYXJhbXM7XG4gICAgICBsZXQgdXNlcktleWNoYWluO1xuICAgICAgLy8gVXNlciBwcm92aWRlZCB1c2VyIGtleVxuICAgICAgaWYgKHBhcmFtcy51c2VyS2V5KSB7XG4gICAgICAgIHVzZXJLZXljaGFpbiA9IHsgcHViOiBwYXJhbXMudXNlcktleSB9O1xuICAgICAgICB1c2VyS2V5Y2hhaW5QYXJhbXMgPSB1c2VyS2V5Y2hhaW47XG4gICAgICAgIGlmIChwYXJhbXMuY29sZERlcml2YXRpb25TZWVkKSB7XG4gICAgICAgICAgLy8gdGhlIGRlcml2YXRpb24gb25seSBtYWtlcyBzZW5zZSB3aGVuIGEga2V5IGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgY29uc3QgZGVyaXZhdGlvbiA9IHRoaXMuYmFzZUNvaW4uZGVyaXZlS2V5V2l0aFNlZWQoe1xuICAgICAgICAgICAga2V5OiBwYXJhbXMudXNlcktleSxcbiAgICAgICAgICAgIHNlZWQ6IHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVyaXZhdGlvblBhdGggPSBkZXJpdmF0aW9uLmRlcml2YXRpb25QYXRoO1xuICAgICAgICAgIHVzZXJLZXljaGFpbi5wdWIgPSBkZXJpdmF0aW9uLmtleTtcbiAgICAgICAgICB1c2VyS2V5Y2hhaW4uZGVyaXZlZEZyb21QYXJlbnRXaXRoU2VlZCA9IHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY2FuRW5jcnlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdlbmVyYXRlIHVzZXIga2V5cGFpciB3aXRob3V0IHBhc3NwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIHVzZXIga2V5LlxuICAgICAgICB1c2VyS2V5Y2hhaW4gPSB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZSgpO1xuICAgICAgICB1c2VyS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2ID0gdGhpcy5iaXRnby5lbmNyeXB0KHsgcGFzc3dvcmQ6IHBhc3NwaHJhc2UsIGlucHV0OiB1c2VyS2V5Y2hhaW4ucHJ2IH0pO1xuICAgICAgICB1c2VyS2V5Y2hhaW5QYXJhbXMgPSB7XG4gICAgICAgICAgcHViOiB1c2VyS2V5Y2hhaW4ucHViLFxuICAgICAgICAgIGVuY3J5cHRlZFBydjogdXNlcktleWNoYWluLmVuY3J5cHRlZFBydixcbiAgICAgICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU6IHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB1c2VyS2V5Y2hhaW5QYXJhbXMucmVxSWQgPSByZXFJZDtcbiAgICAgIGNvbnN0IG5ld1VzZXJLZXljaGFpbiA9IGF3YWl0IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuYWRkKHVzZXJLZXljaGFpblBhcmFtcyk7XG4gICAgICByZXR1cm4gXy5leHRlbmQoe30sIG5ld1VzZXJLZXljaGFpbiwgdXNlcktleWNoYWluKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwS2V5Y2hhaW5Qcm9taXNlID0gYXN5bmMgKCk6IFByb21pc2U8S2V5Y2hhaW4+ID0+IHtcbiAgICAgIGlmIChwYXJhbXMuYmFja3VwWHB1YlByb3ZpZGVyKSB7XG4gICAgICAgIC8vIElmIHJlcXVlc3RlZCwgdXNlIGEgS1JTIG9yIGJhY2t1cCBrZXkgcHJvdmlkZXJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlQmFja3VwKHtcbiAgICAgICAgICBwcm92aWRlcjogcGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlciB8fCAnZGVmYXVsdFJNR0JhY2t1cFByb3ZpZGVyJyxcbiAgICAgICAgICBkaXNhYmxlS1JTRW1haWw6IHBhcmFtcy5kaXNhYmxlS1JTRW1haWwsXG4gICAgICAgICAga3JzU3BlY2lmaWM6IHBhcmFtcy5rcnNTcGVjaWZpYyxcbiAgICAgICAgICB0eXBlOiB0aGlzLmJhc2VDb2luLmdldENoYWluKCksXG4gICAgICAgICAgcGFzc3BocmFzZTogcGFyYW1zLnBhc3NwaHJhc2UsXG4gICAgICAgICAgcmVxSWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIHByb3ZpZGVkIGJhY2t1cCB4cHViXG4gICAgICBpZiAocGFyYW1zLmJhY2t1cFhwdWIpIHtcbiAgICAgICAgLy8gdXNlciBwcm92aWRlZCBiYWNrdXAgZXRoZXJldW0gYWRkcmVzc1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5hZGQoe1xuICAgICAgICAgIHB1YjogcGFyYW1zLmJhY2t1cFhwdWIsXG4gICAgICAgICAgc291cmNlOiAnYmFja3VwJyxcbiAgICAgICAgICByZXFJZCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWNhbkVuY3J5cHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZW5lcmF0ZSBiYWNrdXAga2V5cGFpciB3aXRob3V0IHBhc3NwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBwcm92aWRlZCBiYWNrdXAgeHB1YiBvciBhZGRyZXNzLCBzbyBkZWZhdWx0IHRvIGNyZWF0aW5nIG9uZSBoZXJlXG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZUJhY2t1cCh7IHJlcUlkLCBwYXNzcGhyYXNlOiBwYXJhbXMucGFzc3BocmFzZSB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgeyB1c2VyS2V5Y2hhaW4sIGJhY2t1cEtleWNoYWluLCBiaXRnb0tleWNoYWluIH06IEtleWNoYWluc1RyaXBsZXQgPSBhd2FpdCBwcm9taXNlUHJvcHMoe1xuICAgICAgdXNlcktleWNoYWluOiB1c2VyS2V5Y2hhaW5Qcm9taXNlKCksXG4gICAgICBiYWNrdXBLZXljaGFpbjogYmFja3VwS2V5Y2hhaW5Qcm9taXNlKCksXG4gICAgICBiaXRnb0tleWNoYWluOiB0aGlzLmJhc2VDb2luXG4gICAgICAgIC5rZXljaGFpbnMoKVxuICAgICAgICAuY3JlYXRlQml0R28oeyBlbnRlcnByaXNlOiBwYXJhbXMuZW50ZXJwcmlzZSwgcmVxSWQsIGlzRGlzdHJpYnV0ZWRDdXN0b2R5OiBwYXJhbXMuaXNEaXN0cmlidXRlZEN1c3RvZHkgfSksXG4gICAgfSk7XG5cbiAgICB3YWxsZXRQYXJhbXMua2V5cyA9IFt1c2VyS2V5Y2hhaW4uaWQsIGJhY2t1cEtleWNoYWluLmlkLCBiaXRnb0tleWNoYWluLmlkXTtcblxuICAgIGNvbnN0IHsgcHJ2IH0gPSB1c2VyS2V5Y2hhaW47XG4gICAgaWYgKF8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgYXNzZXJ0KGJhY2t1cEtleWNoYWluLnB1Yik7XG4gICAgICBhc3NlcnQoYml0Z29LZXljaGFpbi5wdWIpO1xuICAgICAgd2FsbGV0UGFyYW1zLmtleVNpZ25hdHVyZXMgPSB7XG4gICAgICAgIGJhY2t1cDogKGF3YWl0IHRoaXMuYmFzZUNvaW4uc2lnbk1lc3NhZ2UoeyBwcnYgfSwgYmFja3VwS2V5Y2hhaW4ucHViKSkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBiaXRnbzogKGF3YWl0IHRoaXMuYmFzZUNvaW4uc2lnbk1lc3NhZ2UoeyBwcnYgfSwgYml0Z29LZXljaGFpbi5wdWIpKS50b1N0cmluZygnaGV4JyksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChfLmluY2x1ZGVzKFsneHJwJywgJ3hsbScsICdjc3ByJ10sIHRoaXMuYmFzZUNvaW4uZ2V0RmFtaWx5KCkpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5yb290UHJpdmF0ZUtleSkpIHtcbiAgICAgIHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSA9IHBhcmFtcy5yb290UHJpdmF0ZUtleTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b2RpYWwgb25jaGFpbiB3YWxsZXRzIGRvIG5vdCBuZWVkIG0sIG4sIGtleXMsIG9yIGtleVNpZ25hdHVyZXNcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdjdXN0b2RpYWwnICYmIChwYXJhbXMubXVsdGlzaWdUeXBlID8/ICdvbmNoYWluJykgPT09ICdvbmNoYWluJykge1xuICAgICAgd2FsbGV0UGFyYW1zLm4gPSB1bmRlZmluZWQ7XG4gICAgICB3YWxsZXRQYXJhbXMubSA9IHVuZGVmaW5lZDtcbiAgICAgIHdhbGxldFBhcmFtcy5rZXlzID0gdW5kZWZpbmVkO1xuICAgICAgd2FsbGV0UGFyYW1zLmtleVNpZ25hdHVyZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5Y2hhaW5zID0ge1xuICAgICAgdXNlcktleWNoYWluLFxuICAgICAgYmFja3VwS2V5Y2hhaW4sXG4gICAgICBiaXRnb0tleWNoYWluLFxuICAgIH07XG4gICAgY29uc3QgZmluYWxXYWxsZXRQYXJhbXMgPSBhd2FpdCB0aGlzLmJhc2VDb2luLnN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXMsIGtleWNoYWlucyk7XG4gICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICBjb25zdCBuZXdXYWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQnKSkuc2VuZChmaW5hbFdhbGxldFBhcmFtcykucmVzdWx0KCk7XG5cbiAgICBjb25zdCByZXN1bHQ6IFdhbGxldFdpdGhLZXljaGFpbnMgPSB7XG4gICAgICB3YWxsZXQ6IG5ldyBXYWxsZXQodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgbmV3V2FsbGV0KSxcbiAgICAgIHVzZXJLZXljaGFpbjogdXNlcktleWNoYWluLFxuICAgICAgYmFja3VwS2V5Y2hhaW46IGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbjogYml0Z29LZXljaGFpbixcbiAgICAgIHJlc3BvbnNlVHlwZTogJ1dhbGxldFdpdGhLZXljaGFpbnMnLFxuICAgIH07XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoYmFja3VwS2V5Y2hhaW4ucHJ2KSkge1xuICAgICAgcmVzdWx0Lndhcm5pbmcgPSAnQmUgc3VyZSB0byBiYWNrdXAgdGhlIGJhY2t1cCBrZXljaGFpbiAtLSBpdCBpcyBub3Qgc3RvcmVkIGFueXdoZXJlIGVsc2UhJztcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZGVyaXZhdGlvblBhdGgpKSB7XG4gICAgICB1c2VyS2V5Y2hhaW4uZGVyaXZhdGlvblBhdGggPSBkZXJpdmF0aW9uUGF0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIHVzZXIncyB3YWxsZXQgc2hhcmVzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGxpc3RTaGFyZXMocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZScpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgd2FsbGV0IHNoYXJlIGluZm9ybWF0aW9uLCBpbmNsdWRpbmcgdGhlIGVuY3J5cHRlZCBzaGFyaW5nIGtleWNoYWluLiByZXF1aXJlcyB1bmxvY2sgaWYga2V5Y2hhaW4gaXMgcHJlc2VudC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIGdldCBpbmZvcm1hdGlvbiBvblxuICAgKi9cbiAgYXN5bmMgZ2V0U2hhcmUocGFyYW1zOiB7IHdhbGxldFNoYXJlSWQ/OiBzdHJpbmcgfSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0c2hhcmUvJyArIHBhcmFtcy53YWxsZXRTaGFyZUlkKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGEgd2FsbGV0IHNoYXJlXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBwYXJhbXMuc3RhdGUgLSB0aGUgbmV3IHN0YXRlIG9mIHRoZSB3YWxsZXQgc2hhcmVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgdXBkYXRlU2hhcmUocGFyYW1zOiBVcGRhdGVTaGFyZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFtdKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldHNoYXJlLycgKyBwYXJhbXMud2FsbGV0U2hhcmVJZCkpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZW5kIGEgd2FsbGV0IHNoYXJlIGludml0YXRpb24gZW1haWxcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHdob3NlIGludml0aWF0aW9uIHNob3VsZCBiZSByZXNlbnRcbiAgICovXG4gIGFzeW5jIHJlc2VuZFNoYXJlSW52aXRlKHBhcmFtczogeyB3YWxsZXRTaGFyZUlkPzogc3RyaW5nIH0gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFtdKTtcblxuICAgIGNvbnN0IHVybFBhcnRzID0gcGFyYW1zLndhbGxldFNoYXJlSWQgKyAnL3Jlc2VuZGVtYWlsJztcbiAgICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0c2hhcmUvJyArIHVybFBhcnRzKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGEgd2FsbGV0IHNoYXJlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byB1cGRhdGVcbiAgICovXG4gIGFzeW5jIGNhbmNlbFNoYXJlKHBhcmFtczogeyB3YWxsZXRTaGFyZUlkPzogc3RyaW5nIH0gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFtdKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAuZGVsKHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0c2hhcmUvJyArIHBhcmFtcy53YWxsZXRTaGFyZUlkKSlcbiAgICAgIC5zZW5kKClcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZS1zaGFyZSB3YWxsZXQgd2l0aCBleGlzdGluZyBzcGVuZGVycyBvZiB0aGUgd2FsbGV0XG4gICAqIEBwYXJhbSB3YWxsZXRJZFxuICAgKiBAcGFyYW0gdXNlclBhc3N3b3JkXG4gICAqL1xuICBhc3luYyByZXNoYXJlV2FsbGV0V2l0aFNwZW5kZXJzKHdhbGxldElkOiBzdHJpbmcsIHVzZXJQYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgdGhpcy5nZXQoeyBpZDogd2FsbGV0SWQgfSk7XG4gICAgaWYgKCF3YWxsZXQ/Ll93YWxsZXQ/LmVudGVycHJpc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW50ZXJwcmlzZSBub3QgZm91bmQgZm9yIHRoZSB3YWxsZXQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbnRlcnByaXNlVXNlcnNSZXNwb25zZSA9IGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5nZXQodGhpcy5iaXRnby51cmwoYC9lbnRlcnByaXNlLyR7d2FsbGV0Py5fd2FsbGV0Py5lbnRlcnByaXNlfS91c2VyYCkpXG4gICAgICAucmVzdWx0KCk7XG4gICAgLy8gY3JlYXRlIGEgbWFwIG9mIHVzZXJzIGZvciBlYXN5IGxvb2t1cCAtIHdlIG5lZWQgdGhlIHVzZXIgZW1haWwgaWQgdG8gc2hhcmUgdGhlIHdhbGxldFxuICAgIGNvbnN0IHVzZXJzTWFwID0gbmV3IE1hcChcbiAgICAgIFsuLi5lbnRlcnByaXNlVXNlcnNSZXNwb25zZT8uYWRtaW5Vc2VycywgLi4uZW50ZXJwcmlzZVVzZXJzUmVzcG9uc2U/Lm5vbkFkbWluVXNlcnNdLm1hcCgob2JqKSA9PiBbb2JqLmlkLCBvYmpdKVxuICAgICk7XG5cbiAgICBpZiAod2FsbGV0Ll93YWxsZXQudXNlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgdXNlciBvZiB3YWxsZXQuX3dhbGxldC51c2Vycykge1xuICAgICAgICBjb25zdCB1c2VyT2JqZWN0ID0gdXNlcnNNYXAuZ2V0KHVzZXIudXNlcik7XG4gICAgICAgIGlmICh1c2VyLnBlcm1pc3Npb25zLmluY2x1ZGVzKCdzcGVuZCcpICYmICF1c2VyLnBlcm1pc3Npb25zLmluY2x1ZGVzKCdhZG1pbicpICYmIHVzZXJPYmplY3QpIHtcbiAgICAgICAgICBjb25zdCBzaGFyZVBhcmFtcyA9IHtcbiAgICAgICAgICAgIHdhbGxldElkOiB3YWxsZXRJZCxcbiAgICAgICAgICAgIHVzZXI6IHVzZXIudXNlcixcbiAgICAgICAgICAgIHBlcm1pc3Npb25zOiB1c2VyLnBlcm1pc3Npb25zLmpvaW4oJywnKSxcbiAgICAgICAgICAgIHdhbGxldFBhc3NwaHJhc2U6IHVzZXJQYXNzd29yZCxcbiAgICAgICAgICAgIGVtYWlsOiB1c2VyT2JqZWN0LmVtYWlsLmVtYWlsLFxuICAgICAgICAgICAgcmVzaGFyZTogdHJ1ZSxcbiAgICAgICAgICAgIHNraXBLZXljaGFpbjogZmFsc2UsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBhd2FpdCB3YWxsZXQuc2hhcmVXYWxsZXQoc2hhcmVQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSB3YWxsZXQgc2hhcmUsIGFkZGluZyB0aGUgd2FsbGV0IHRvIHRoZSB1c2VyJ3MgbGlzdFxuICAgKiBOZWVkcyBhIHVzZXIncyBwYXNzd29yZCB0byBkZWNyeXB0IHRoZSBzaGFyZWQga2V5XG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byBhY2NlcHRcbiAgICogQHBhcmFtIHBhcmFtcy51c2VyUGFzc3dvcmQgLSAocmVxdWlyZWQgaWYgbW9yZSBhIGtleWNoYWluIHdhcyBzaGFyZWQpIHVzZXIncyBwYXNzd29yZCB0byBkZWNyeXB0IHRoZSBzaGFyZWQgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXMubmV3V2FsbGV0UGFzc3BocmFzZSAtIG5ldyB3YWxsZXQgcGFzc3BocmFzZSBmb3Igc2F2aW5nIHRoZSBzaGFyZWQgd2FsbGV0IHBydi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbGVmdCBibGFuayBhbmQgYSB3YWxsZXQgd2l0aCBtb3JlIHRoYW4gdmlldyBwZXJtaXNzaW9ucyB3YXMgc2hhcmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIHRoZSB1c2VyJ3MgbG9naW4gcGFzc3dvcmQgaXMgdXNlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5vdmVycmlkZUVuY3J5cHRlZFBydiAtIHNldCBvbmx5IGlmIHRoZSBwcnYgd2FzIHJlY2VpdmVkIG91dC1vZi1iYW5kLlxuICAgKi9cbiAgYXN5bmMgYWNjZXB0U2hhcmUocGFyYW1zOiBBY2NlcHRTaGFyZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFsnb3ZlcnJpZGVFbmNyeXB0ZWRQcnYnLCAndXNlclBhc3N3b3JkJywgJ25ld1dhbGxldFBhc3NwaHJhc2UnXSk7XG5cbiAgICBsZXQgZW5jcnlwdGVkUHJ2ID0gcGFyYW1zLm92ZXJyaWRlRW5jcnlwdGVkUHJ2O1xuICAgIGNvbnN0IHdhbGxldFNoYXJlID0gYXdhaXQgdGhpcy5nZXRTaGFyZSh7IHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkIH0pO1xuICAgIGlmIChcbiAgICAgIHdhbGxldFNoYXJlLmtleWNoYWluT3ZlcnJpZGVSZXF1aXJlZCAmJlxuICAgICAgd2FsbGV0U2hhcmUucGVybWlzc2lvbnMuaW5kZXhPZignYWRtaW4nKSAhPT0gLTEgJiZcbiAgICAgIHdhbGxldFNoYXJlLnBlcm1pc3Npb25zLmluZGV4T2YoJ3NwZW5kJykgIT09IC0xXG4gICAgKSB7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudXNlclBhc3N3b3JkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXJQYXNzd29yZCBwYXJhbSBtdXN0IGJlIHByb3ZpZGVkIHRvIGRlY3J5cHQgc2hhcmVkIGtleScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3YWxsZXRLZXljaGFpbiA9IGF3YWl0IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlVXNlcktleWNoYWluKHBhcmFtcy51c2VyUGFzc3dvcmQpO1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQod2FsbGV0S2V5Y2hhaW4uZW5jcnlwdGVkUHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuY3J5cHRlZFBydiB3YXMgbm90IGZvdW5kIG9uIHdhbGxldCBrZXljaGFpbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0cmFkaW5nQWNjb3VudElkOiB3YWxsZXRTaGFyZS53YWxsZXQsXG4gICAgICAgIHB1YmtleTogd2FsbGV0S2V5Y2hhaW4ucHViLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICBjb25zdCBwYXlsb2FkU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG5cbiAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBwYXNzd29yZDogcGFyYW1zLnVzZXJQYXNzd29yZCxcbiAgICAgICAgaW5wdXQ6IHdhbGxldEtleWNoYWluLmVuY3J5cHRlZFBydixcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5iYXNlQ29pbi5zaWduTWVzc2FnZSh7IHBydjogcHJpdmF0ZUtleSB9LCBwYXlsb2FkU3RyaW5nKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnVwZGF0ZVNoYXJlKHtcbiAgICAgICAgd2FsbGV0U2hhcmVJZDogcGFyYW1zLndhbGxldFNoYXJlSWQsXG4gICAgICAgIHN0YXRlOiAnYWNjZXB0ZWQnLFxuICAgICAgICBrZXlJZDogd2FsbGV0S2V5Y2hhaW4uaWQsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZFN0cmluZyxcbiAgICAgIH0pO1xuICAgICAgLy8gSWYgdGhlIHdhbGxldCBzaGFyZSB3YXMgYWNjZXB0ZWQgc3VjY2Vzc2Z1bGx5IChjaGFuZ2VkPXRydWUpLCByZXNoYXJlIHRoZSB3YWxsZXQgd2l0aCB0aGUgc3BlbmRlcnNcbiAgICAgIGlmIChyZXNwb25zZS5jaGFuZ2VkICYmIHJlc3BvbnNlLnN0YXRlID09PSAnYWNjZXB0ZWQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5yZXNoYXJlV2FsbGV0V2l0aFNwZW5kZXJzKHdhbGxldFNoYXJlLndhbGxldCwgcGFyYW1zLnVzZXJQYXNzd29yZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBUT0RPOiBQWC0zODI2XG4gICAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8vIFJldHVybiByaWdodCBhd2F5IGlmIHRoZXJlIGlzIG5vIGtleWNoYWluIHRvIGRlY3J5cHQsIG9yIGlmIGV4cGxpY2l0IGVuY3J5cHRlZFBydiB3YXMgcHJvdmlkZWRcbiAgICBpZiAoIXdhbGxldFNoYXJlLmtleWNoYWluIHx8ICF3YWxsZXRTaGFyZS5rZXljaGFpbi5lbmNyeXB0ZWRQcnYgfHwgZW5jcnlwdGVkUHJ2KSB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVTaGFyZSh7XG4gICAgICAgIHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkLFxuICAgICAgICBzdGF0ZTogJ2FjY2VwdGVkJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE1vcmUgdGhhbiB2aWV3aW5nIHdhcyByZXF1ZXN0ZWQsIHNvIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgd2FsbGV0IGtleXMgdXNpbmcgdGhlIHNoYXJlZCBlY2RoIHNjaGVtZVxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy51c2VyUGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXJQYXNzd29yZCBwYXJhbSBtdXN0IGJlIHByb3ZpZGVkIHRvIGRlY3J5cHQgc2hhcmVkIGtleScpO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYXJpbmdLZXljaGFpbiA9IChhd2FpdCB0aGlzLmJpdGdvLmdldEVDREhLZXljaGFpbigpKSBhcyBhbnk7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoc2hhcmluZ0tleWNoYWluLmVuY3J5cHRlZFhwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuY3J5cHRlZFhwcnYgd2FzIG5vdCBmb3VuZCBvbiBzaGFyaW5nIGtleWNoYWluJyk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgdGhlIHNoYXJpbmcga2V5Y2hhaW4sIHdlIGNhbiB3b3JrIG91dCB0aGUgc2VjcmV0IHVzZWQgZm9yIHNoYXJpbmcgdGhlIHdhbGxldCB3aXRoIHVzXG4gICAgc2hhcmluZ0tleWNoYWluLnBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7XG4gICAgICBwYXNzd29yZDogcGFyYW1zLnVzZXJQYXNzd29yZCxcbiAgICAgIGlucHV0OiBzaGFyaW5nS2V5Y2hhaW4uZW5jcnlwdGVkWHBydixcbiAgICB9KTtcbiAgICBjb25zdCBzZWNyZXQgPSBnZXRTaGFyZWRTZWNyZXQoXG4gICAgICAvLyBEZXJpdmUga2V5IGJ5IHBhdGggKHdoaWNoIGlzIHVzZWQgYmV0d2VlbiB0aGVzZSAyIHVzZXJzIG9ubHkpXG4gICAgICBiaXAzMi5mcm9tQmFzZTU4KHNoYXJpbmdLZXljaGFpbi5wcnYpLmRlcml2ZVBhdGgoc2FuaXRpemVMZWdhY3lQYXRoKHdhbGxldFNoYXJlLmtleWNoYWluLnBhdGgpKSxcbiAgICAgIEJ1ZmZlci5mcm9tKHdhbGxldFNoYXJlLmtleWNoYWluLmZyb21QdWJLZXksICdoZXgnKVxuICAgICkudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgLy8gWWVzISBXZSBnb3QgdGhlIHNlY3JldCBzdWNjZXNzZnVsbHkgaGVyZSwgbm93IGRlY3J5cHQgdGhlIHNoYXJlZCB3YWxsZXQgcHJ2XG4gICAgY29uc3QgZGVjcnlwdGVkU2hhcmVkV2FsbGV0UHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgIHBhc3N3b3JkOiBzZWNyZXQsXG4gICAgICBpbnB1dDogd2FsbGV0U2hhcmUua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2LFxuICAgIH0pO1xuXG4gICAgLy8gV2Ugd2lsbCBub3cgcmUtZW5jcnlwdCB0aGUgd2FsbGV0IHdpdGggb3VyIG93biBwYXNzd29yZFxuICAgIGNvbnN0IG5ld1dhbGxldFBhc3NwaHJhc2UgPSBwYXJhbXMubmV3V2FsbGV0UGFzc3BocmFzZSB8fCBwYXJhbXMudXNlclBhc3N3b3JkO1xuICAgIGVuY3J5cHRlZFBydiA9IHRoaXMuYml0Z28uZW5jcnlwdCh7XG4gICAgICBwYXNzd29yZDogbmV3V2FsbGV0UGFzc3BocmFzZSxcbiAgICAgIGlucHV0OiBkZWNyeXB0ZWRTaGFyZWRXYWxsZXRQcnYsXG4gICAgfSk7XG4gICAgY29uc3QgdXBkYXRlUGFyYW1zOiBVcGRhdGVTaGFyZU9wdGlvbnMgPSB7XG4gICAgICB3YWxsZXRTaGFyZUlkOiBwYXJhbXMud2FsbGV0U2hhcmVJZCxcbiAgICAgIHN0YXRlOiAnYWNjZXB0ZWQnLFxuICAgIH07XG5cbiAgICBpZiAoZW5jcnlwdGVkUHJ2KSB7XG4gICAgICB1cGRhdGVQYXJhbXMuZW5jcnlwdGVkUHJ2ID0gZW5jcnlwdGVkUHJ2O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51cGRhdGVTaGFyZSh1cGRhdGVQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHdhbGxldCBieSBpdHMgSURcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmlkIHdhbGxldCBpZFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIGdldFdhbGxldChwYXJhbXM6IEdldFdhbGxldE9wdGlvbnMgPSB7fSk6IFByb21pc2U8V2FsbGV0PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSk7XG5cbiAgICBjb25zdCBxdWVyeTogR2V0V2FsbGV0T3B0aW9ucyA9IHt9O1xuICAgIGlmIChwYXJhbXMuYWxsVG9rZW5zKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5hbGxUb2tlbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhbGxUb2tlbnMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5hbGxUb2tlbnMgPSBwYXJhbXMuYWxsVG9rZW5zO1xuICAgIH1cblxuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKSk7XG5cbiAgICBjb25zdCB3YWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAuZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBwYXJhbXMuaWQpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgLnJlc3VsdCgpO1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIHdhbGxldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgd2FsbGV0IGJ5IGl0cyBhZGRyZXNzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5hZGRyZXNzIHdhbGxldCBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgZ2V0V2FsbGV0QnlBZGRyZXNzKHBhcmFtczogR2V0V2FsbGV0QnlBZGRyZXNzT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxXYWxsZXQ+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnXSwgW10pO1xuXG4gICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpKTtcblxuICAgIGNvbnN0IHdhbGxldCA9IGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0L2FkZHJlc3MvJyArIHBhcmFtcy5hZGRyZXNzKSkucmVzdWx0KCk7XG4gICAgcmV0dXJuIG5ldyBXYWxsZXQodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgd2FsbGV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYW55IGdpdmVuIHN1cHBvcnRlZCBjb2luLCBnZXQgdG90YWwgYmFsYW5jZXMgZm9yIGFsbCB3YWxsZXRzIG9mIHRoYXRcbiAgICogY29pbiB0eXBlIG9uIHRoZSBhY2NvdW50LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgZ2V0VG90YWxCYWxhbmNlcyhwYXJhbXM6IFJlY29yZDxzdHJpbmcsIG5ldmVyPiA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvYmFsYW5jZXMnKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgVFNTIG9yIEJMUy1ES0cgV2FsbGV0LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlTXBjV2FsbGV0KHtcbiAgICBwYXNzcGhyYXNlLFxuICAgIGxhYmVsLFxuICAgIG11bHRpc2lnVHlwZSxcbiAgICBlbnRlcnByaXNlLFxuICAgIHdhbGxldFZlcnNpb24sXG4gICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgIGJhY2t1cFByb3ZpZGVyLFxuICB9OiBHZW5lcmF0ZU1wY1dhbGxldE9wdGlvbnMpOiBQcm9taXNlPFdhbGxldFdpdGhLZXljaGFpbnM+IHtcbiAgICBpZiAobXVsdGlzaWdUeXBlID09PSAndHNzJyAmJiB0aGlzLmJhc2VDb2luLmdldE1QQ0FsZ29yaXRobSgpID09PSAnZWNkc2EnKSB7XG4gICAgICBjb25zdCB0c3NTZXR0aW5nczogVHNzU2V0dGluZ3MgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAgIC5nZXQodGhpcy5iaXRnby5taWNyb3NlcnZpY2VzVXJsKCcvYXBpL3YyL3Rzcy9zZXR0aW5ncycpKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICBjb25zdCBtdWx0aXNpZ1R5cGVWZXJzaW9uID1cbiAgICAgICAgdHNzU2V0dGluZ3MuY29pblNldHRpbmdzW3RoaXMuYmFzZUNvaW4uZ2V0RmFtaWx5KCldPy53YWxsZXRDcmVhdGlvblNldHRpbmdzPy5tdWx0aVNpZ1R5cGVWZXJzaW9uO1xuICAgICAgaWYgKHRoaXMuYmFzZUNvaW4uaXNFVk0oKSAmJiBtdWx0aXNpZ1R5cGVWZXJzaW9uID09PSAnTVBDdjInKSB7XG4gICAgICAgIHdhbGxldFZlcnNpb24gPSA1O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuXG4gICAgLy8gQ3JlYXRlIE1QQyBLZXljaGFpbnNcbiAgICBjb25zdCBrZXljaGFpbnMgPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZU1wYyh7XG4gICAgICBtdWx0aXNpZ1R5cGUsXG4gICAgICBwYXNzcGhyYXNlLFxuICAgICAgZW50ZXJwcmlzZSxcbiAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgIGJhY2t1cFByb3ZpZGVyLFxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIFdhbGxldFxuICAgIGNvbnN0IHsgdXNlcktleWNoYWluLCBiYWNrdXBLZXljaGFpbiwgYml0Z29LZXljaGFpbiB9ID0ga2V5Y2hhaW5zO1xuICAgIGNvbnN0IHdhbGxldFBhcmFtczogU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyA9IHtcbiAgICAgIGxhYmVsLFxuICAgICAgbTogMixcbiAgICAgIG46IDMsXG4gICAgICBrZXlzOiBbdXNlcktleWNoYWluLmlkLCBiYWNrdXBLZXljaGFpbi5pZCwgYml0Z29LZXljaGFpbi5pZF0sXG4gICAgICB0eXBlOiAnaG90JyxcbiAgICAgIG11bHRpc2lnVHlwZSxcbiAgICAgIGVudGVycHJpc2UsXG4gICAgICB3YWxsZXRWZXJzaW9uLFxuICAgIH07XG4gICAgY29uc3QgZmluYWxXYWxsZXRQYXJhbXMgPSBhd2FpdCB0aGlzLmJhc2VDb2luLnN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXMsIGtleWNoYWlucyk7XG4gICAgY29uc3QgbmV3V2FsbGV0ID0gYXdhaXQgdGhpcy5iaXRnby5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0JykpLnNlbmQoZmluYWxXYWxsZXRQYXJhbXMpLnJlc3VsdCgpO1xuXG4gICAgY29uc3QgcmVzdWx0OiBXYWxsZXRXaXRoS2V5Y2hhaW5zID0ge1xuICAgICAgd2FsbGV0OiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIG5ld1dhbGxldCksXG4gICAgICB1c2VyS2V5Y2hhaW4sXG4gICAgICBiYWNrdXBLZXljaGFpbixcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICByZXNwb25zZVR5cGU6ICdXYWxsZXRXaXRoS2V5Y2hhaW5zJyxcbiAgICB9O1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGJhY2t1cEtleWNoYWluLnBydikgJiYgIV8uaXNVbmRlZmluZWQoYmFja3VwUHJvdmlkZXIpKSB7XG4gICAgICByZXN1bHQud2FybmluZyA9ICdCZSBzdXJlIHRvIGJhY2t1cCB0aGUgYmFja3VwIGtleWNoYWluIC0tIGl0IGlzIG5vdCBzdG9yZWQgYW55d2hlcmUgZWxzZSEnO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgU2VsZi1NYW5hZ2VkIENvbGQgVFNTIFdhbGxldC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZVNNQ01wY1dhbGxldCh7XG4gICAgbGFiZWwsXG4gICAgbXVsdGlzaWdUeXBlLFxuICAgIGVudGVycHJpc2UsXG4gICAgd2FsbGV0VmVyc2lvbixcbiAgICBiaXRnb0tleUlkLFxuICAgIGNvbW1vbktleWNoYWluLFxuICAgIGNvbGREZXJpdmF0aW9uU2VlZCxcbiAgfTogR2VuZXJhdGVTTUNNcGNXYWxsZXRPcHRpb25zKTogUHJvbWlzZTxXYWxsZXRXaXRoS2V5Y2hhaW5zPiB7XG4gICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG5cbiAgICAvLyBDcmVhdGUgTVBDIEtleWNoYWluc1xuICAgIGNvbnN0IGJpdGdvS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmdldCh7IGlkOiBiaXRnb0tleUlkIH0pO1xuXG4gICAgaWYgKCFiaXRnb0tleWNoYWluIHx8ICFiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdEdvIGtleWNoYWluIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGlmIChiaXRnb0tleWNoYWluLnNvdXJjZSAhPT0gJ2JpdGdvJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgYml0Z29LZXlJZCBpcyBub3QgYSBCaXRHbyBrZXljaGFpbicpO1xuICAgIH1cblxuICAgIGlmIChiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluICE9PSBjb21tb25LZXljaGFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgQ29tbW9uIGtleWNoYWluIG1pc21hdGNoIHdpdGggdGhlIHByb3ZpZGVkIEJpdGdvIGtleScpO1xuICAgIH1cblxuICAgIGlmICghY29sZERlcml2YXRpb25TZWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyS2V5Y2hhaW5QYXJhbXM6IEFkZEtleWNoYWluT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZTogJ3VzZXInLFxuICAgICAga2V5VHlwZTogJ3RzcycsXG4gICAgICBjb21tb25LZXljaGFpbjogY29tbW9uS2V5Y2hhaW4sXG4gICAgICBkZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkOiBjb2xkRGVyaXZhdGlvblNlZWQsXG4gICAgfTtcbiAgICBjb25zdCB1c2VyS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZCh1c2VyS2V5Y2hhaW5QYXJhbXMpO1xuXG4gICAgY29uc3QgYmFja3VwS2V5Q2hhaW5QYXJhbXM6IEFkZEtleWNoYWluT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZTogJ2JhY2t1cCcsXG4gICAgICBrZXlUeXBlOiAndHNzJyxcbiAgICAgIGNvbW1vbktleWNoYWluOiBjb21tb25LZXljaGFpbixcbiAgICAgIGRlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQ6IGNvbGREZXJpdmF0aW9uU2VlZCxcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZChiYWNrdXBLZXlDaGFpblBhcmFtcyk7XG5cbiAgICAvLyBDcmVhdGUgV2FsbGV0XG4gICAgY29uc3Qga2V5Y2hhaW5zID0geyB1c2VyS2V5Y2hhaW4sIGJhY2t1cEtleWNoYWluLCBiaXRnb0tleWNoYWluIH07XG4gICAgY29uc3Qgd2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zID0ge1xuICAgICAgbGFiZWwsXG4gICAgICBtOiAyLFxuICAgICAgbjogMyxcbiAgICAgIGtleXM6IFt1c2VyS2V5Y2hhaW4uaWQsIGJhY2t1cEtleWNoYWluLmlkLCBiaXRnb0tleWNoYWluLmlkXSxcbiAgICAgIHR5cGU6ICdjb2xkJyxcbiAgICAgIG11bHRpc2lnVHlwZSxcbiAgICAgIGVudGVycHJpc2UsXG4gICAgICB3YWxsZXRWZXJzaW9uLFxuICAgIH07XG5cbiAgICBjb25zdCBmaW5hbFdhbGxldFBhcmFtcyA9IGF3YWl0IHRoaXMuYmFzZUNvaW4uc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KHdhbGxldFBhcmFtcywga2V5Y2hhaW5zKTtcbiAgICBjb25zdCBuZXdXYWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQnKSkuc2VuZChmaW5hbFdhbGxldFBhcmFtcykucmVzdWx0KCk7XG5cbiAgICBjb25zdCByZXN1bHQ6IFdhbGxldFdpdGhLZXljaGFpbnMgPSB7XG4gICAgICB3YWxsZXQ6IG5ldyBXYWxsZXQodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgbmV3V2FsbGV0KSxcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgIHJlc3BvbnNlVHlwZTogJ1dhbGxldFdpdGhLZXljaGFpbnMnLFxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIEN1c3RvZGlhbCBUU1MgV2FsbGV0LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlQ3VzdG9kaWFsTXBjV2FsbGV0KHtcbiAgICBsYWJlbCxcbiAgICBtdWx0aXNpZ1R5cGUsXG4gICAgZW50ZXJwcmlzZSxcbiAgICB3YWxsZXRWZXJzaW9uLFxuICB9OiBHZW5lcmF0ZUJhc2VNcGNXYWxsZXRPcHRpb25zKTogUHJvbWlzZTxXYWxsZXRXaXRoS2V5Y2hhaW5zPiB7XG4gICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG5cbiAgICBjb25zdCBmaW5hbFdhbGxldFBhcmFtcyA9IHtcbiAgICAgIGxhYmVsLFxuICAgICAgbXVsdGlzaWdUeXBlLFxuICAgICAgZW50ZXJwcmlzZSxcbiAgICAgIHdhbGxldFZlcnNpb24sXG4gICAgICB0eXBlOiAnY3VzdG9kaWFsJyxcbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIFdhbGxldFxuICAgIGNvbnN0IG5ld1dhbGxldCA9IGF3YWl0IHRoaXMuYml0Z28ucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldCcpKS5zZW5kKGZpbmFsV2FsbGV0UGFyYW1zKS5yZXN1bHQoKTtcbiAgICBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIG5ld1dhbGxldCk7XG4gICAgY29uc3Qga2V5Y2hhaW5zID0gd2FsbGV0LmtleUlkcygpO1xuICAgIGNvbnN0IHJlc3VsdDogV2FsbGV0V2l0aEtleWNoYWlucyA9IHtcbiAgICAgIHdhbGxldCxcbiAgICAgIHVzZXJLZXljaGFpbjogeyBpZDoga2V5Y2hhaW5zWzBdLCB0eXBlOiBtdWx0aXNpZ1R5cGUsIHNvdXJjZTogJ3VzZXInIH0sXG4gICAgICBiYWNrdXBLZXljaGFpbjogeyBpZDoga2V5Y2hhaW5zWzFdLCB0eXBlOiBtdWx0aXNpZ1R5cGUsIHNvdXJjZTogJ2JhY2t1cCcgfSxcbiAgICAgIGJpdGdvS2V5Y2hhaW46IHsgaWQ6IGtleWNoYWluc1syXSwgdHlwZTogbXVsdGlzaWdUeXBlLCBzb3VyY2U6ICdiaXRnbycgfSxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ1dhbGxldFdpdGhLZXljaGFpbnMnLFxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iXX0=