"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCoin = void 0;
/**
 * @prettier
 */
const crypto = __importStar(require("crypto"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bignumber_js_1 = require("bignumber.js");
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const bip32util_1 = require("../bip32util");
const account_lib_1 = require("../../account-lib");
const enterprise_1 = require("../enterprise");
const keychain_1 = require("../keychain");
const market_1 = require("../market");
const pendingApproval_1 = require("../pendingApproval");
const wallet_1 = require("../wallet");
const webhook_1 = require("../webhook");
class BaseCoin {
    constructor(bitgo) {
        this.bitgo = bitgo;
        this._url = this.bitgo.url('/', 2);
        this._wallets = new wallet_1.Wallets(this.bitgo, this);
        this._keychains = new keychain_1.Keychains(this.bitgo, this);
        this._webhooks = new webhook_1.Webhooks(this.bitgo, this);
        this._pendingApprovals = new pendingApproval_1.PendingApprovals(this.bitgo, this);
        this._enterprises = new enterprise_1.Enterprises(this.bitgo, this);
        this._markets = new market_1.Markets(this.bitgo, this);
    }
    url(suffix) {
        return this._url + this.getChain() + suffix;
    }
    wallets() {
        return this._wallets;
    }
    enterprises() {
        return this._enterprises;
    }
    keychains() {
        return this._keychains;
    }
    webhooks() {
        return this._webhooks;
    }
    pendingApprovals() {
        return this._pendingApprovals;
    }
    markets() {
        return this._markets;
    }
    static get coinTokenPatternSeparator() {
        return this._coinTokenPatternSeparator;
    }
    get type() {
        return this.getChain();
    }
    /**
     * Gets the statics coin object
     * @returns {Readonly<StaticsBaseCoin>} the statics coin object
     */
    getConfig() {
        return this._staticsCoin;
    }
    /**
     * Flag for sending value of 0.
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return false;
    }
    /**
     * Use `sendMany()` to perform wallet sweep.
     * FIXME(BG-39738): add coin.sweepWallet() instead
     */
    sweepWithSendMany() {
        return false;
    }
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed() {
        return false;
    }
    /**
     * Flag for determining whether this coin supports account consolidations
     * from its receive addresses to the root address.
     * @returns {boolean} True if okay to consolidate over this coin; false, otherwise
     */
    allowsAccountConsolidations() {
        return false;
    }
    /**
     * Gets config for how token enablements work for this coin
     * @returns
     *    requiresTokenEnablement: True if tokens need to be enabled for this coin
     *    supportsMultipleTokenEnablements: True if multiple tokens can be enabled in one transaction
     */
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: false,
            supportsMultipleTokenEnablements: false,
        };
    }
    /**
     * Flag indicating if this coin supports TSS wallets.
     * @returns {boolean} True if TSS Wallets can be created for this coin
     */
    supportsTss() {
        return false;
    }
    /**
     * Flag indicating if the coin supports deriving a key with a seed (keyID)
     * to the user/backup keys.
     */
    supportsDeriveKeyWithSeed() {
        return true;
    }
    /**
     * Flag indicating if this blockchain runs on EVM architecture.
     * @returns {boolean} True if the blockchain runs on EVM architecture.
     */
    isEVM() {
        return false;
    }
    /**
     * Flag indicating if this coin supports BLS-DKG wallets.
     * @returns {boolean} True if BLS-DKG Wallets can be created for this coin
     */
    supportsBlsDkg() {
        return false;
    }
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, xrp, xlm)
     */
    baseUnitsToBigUnits(baseUnits) {
        bignumber_js_1.BigNumber.set({ DECIMAL_PLACES: 24 });
        const dividend = this.getBaseFactor();
        const bigNumber = new bignumber_js_1.BigNumber(baseUnits).dividedBy(dividend);
        // set the format so commas aren't added to large coin amounts
        return bigNumber.toFormat(null, null, { groupSeparator: '', decimalSeparator: '.' });
    }
    /**
     * Convert a currency amount represented in big units (btc, eth, xrp, xlm)
     * to base units (satoshi, wei, atoms, drops, stroops)
     * @param bigUnits
     */
    bigUnitsToBaseUnits(bigUnits) {
        const multiplier = this.getBaseFactor();
        const bigNumber = new bignumber_js_1.BigNumber(bigUnits).times(multiplier);
        if (!bigNumber.isInteger()) {
            throw new Error(`non-integer output resulted from multiplying ${bigUnits} by ${multiplier}`);
        }
        return bigNumber.toFixed(0);
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        return (0, bip32util_1.signMessage)(message, utxo_lib_1.bip32.fromBase58(key.prv), utxolib.networks.bitcoin);
    }
    /**
     * Create signatures for the backup and bitgo keys using the user key.
     * We can verify the signatures when fetching the keys from wallet-platform later.
     * Currently only `AbstractUtxoCoin` implements and uses the complementary `verifyKeySignature` method.
     * @param prv - the user private key
     * @param backupKeychain - contains the backup public key
     * @param bitgoKeychain - contains the bitgo public key
     */
    async createKeySignatures(prv, backupKeychain, bitgoKeychain) {
        return {
            backup: (await this.signMessage({ prv }, backupKeychain.pub)).toString('hex'),
            bitgo: (await this.signMessage({ prv }, bitgoKeychain.pub)).toString('hex'),
        };
    }
    /**
     * Decompose a raw transaction into useful information.
     * @param options - coin-specific
     */
    explainTransaction(options) {
        throw new Error(`not implemented`);
    }
    /**
     * @deprecated use {@see isWalletAddress} instead
     */
    verifyAddress(params) {
        return this.isWalletAddress(params);
    }
    /**
     * convert address into desired address format.
     * @param address
     * @param format
     */
    canonicalAddress(address, format) {
        return address;
    }
    /**
     * Check whether a coin supports blockTarget for transactions to be included in
     * @returns {boolean}
     */
    supportsBlockTarget() {
        return false;
    }
    /**
     * Check whether a coin supports lightning transactions
     * @returns {boolean}
     */
    supportsLightning() {
        return false;
    }
    /**
     * Check whether a coin supports message signing
     * @returns {boolean}
     */
    supportsMessageSigning() {
        return false;
    }
    /**
     * Check whether a coin supports signing of Typed data
     * @returns {boolean}
     */
    supportsSigningTypedData() {
        return false;
    }
    /**
     * Hook to add additional parameters to the wallet generation
     * @param walletParams
     * @param keychains
     * @return {*}
     */
    supplementGenerateWallet(walletParams, keychains) {
        return Promise.resolve(walletParams);
    }
    /**
     * Get extra parameters for prebuilding a tx. Add things like hop transaction params
     */
    getExtraPrebuildParams(buildParams) {
        return Promise.resolve({});
    }
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(prebuildResponse) {
        return Promise.resolve(prebuildResponse);
    }
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     */
    presignTransaction(params) {
        return Promise.resolve(params);
    }
    /**
     * Create a new wallet object from a wallet data object
     * @param walletParams
     */
    newWalletObject(walletParams) {
        return new wallet_1.Wallet(this.bitgo, this, walletParams);
    }
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Integer} params.numBlocks The number of blocks to target for conformation (Only works for btc)
     * @returns {Object} The info returned from the merchant server
     */
    async feeEstimate(params) {
        const query = {};
        if (params && params.numBlocks) {
            query.numBlocks = params.numBlocks;
        }
        return this.bitgo.get(this.url('/tx/fee')).query(query).result();
    }
    /**
     * The cold wallet tool uses this function to derive an extended key that is based on the passed key and seed
     * @param key
     * @param seed
     * @returns {{key: string, derivationPath: string}}
     */
    deriveKeyWithSeed({ key, seed }) {
        function sha256(input) {
            return crypto.createHash('sha256').update(input).digest();
        }
        const derivationPathInput = sha256(sha256(`${seed}`)).toString('hex');
        const derivationPathParts = [
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        const derivationPath = 'm/999999/' + derivationPathParts.join('/');
        const keyNode = utxo_lib_1.bip32.fromBase58(key);
        const derivedKeyNode = keyNode.derivePath(derivationPath);
        return {
            key: derivedKeyNode.toBase58(),
            derivationPath: derivationPath,
        };
    }
    /**
     * Specifies what key we will need for signing - right now we just need the
     * user key.
     */
    keyIdsForSigning() {
        return [keychain_1.KeyIndices.USER];
    }
    /**
     * Perform additional checks before adding a bitgo key. Base controller
     * is a no-op, but coin-specific controller may do something
     * @param params
     */
    preCreateBitGo(params) {
        return;
    }
    /**
     * @deprecated - use getBip32Keys() in conjunction with isValidAddress instead
     */
    initiateRecovery(params) {
        throw new Error('deprecated method');
    }
    /**
     * Generate a root key pair on the curve used by the coin
     * @param {Buffer} seed - seed to use for key pair generation
     * @returns {KeyPair} the generated key pair
     */
    generateRootKeyPair(seed) {
        throw new account_lib_1.NotImplementedError('generateRootKeyPair is not supported for this coin');
    }
    /**
     * Return wether the given m of n wallet signers/ key amounts are valid for the coin
     */
    isValidMofNSetup({ m, n }) {
        return m === 2 && n === 3;
    }
    /**
     * Returns the portion of the transaction that needs to be signed in Buffer format.
     * Only needed for coins that support adding signatures directly (e.g. TSS).
     *
     * @param {String} serializedTx - the unsigned transaction in broadcast format
     * @returns {Promise<Buffer>} - the portion of the transaction that needs to be signed
     */
    async getSignablePayload(serializedTx) {
        return Buffer.from(serializedTx);
    }
    /**
     * Returns the MPC algorithm (ecdsa or eddsa) used for coins that support TSS
     */
    getMPCAlgorithm() {
        throw new Error('no MPC algorithm is defined for this coin');
    }
    async recoverToken(params) {
        throw new account_lib_1.NotImplementedError('recoverToken is not supported for this coin');
    }
    getInscriptionBuilder(wallet) {
        throw new account_lib_1.NotImplementedError('Inscription Builder is not supported for this coin');
    }
    /**
     * Function to get coin specific hash function used to generate transaction digests.
     * @returns {@see Hash} hash function if implemented, otherwise throws exception
     */
    getHashFunction() {
        throw new account_lib_1.NotImplementedError('getHashFunction is not supported for this coin');
    }
    buildNftTransferData(params) {
        throw new account_lib_1.NotImplementedError('buildNftTransferData is not supported for this coin');
    }
    /**
     * Broadcast a transaction to the network
     * @param params options for broadcasting
     * @returns {Promise<BaseBroadcastTransactionResult>} result of broadcast
     * @throws {NotImplementedError} if not implemented
     */
    broadcastTransaction(params) {
        throw new account_lib_1.NotImplementedError('broadcastTransaction is not supported for this coin');
    }
    /**
     * Creates funds sweep recovery transaction(s) without BitGo
     *
     * @param {MPCSweepRecoveryOptions} params parameters needed to combine the signatures
     * and transactions to create broadcastable transactions
     *
     * @returns {MPCTxs} array of the serialized transaction hex strings and indices
     * of the addresses being swept
     */
    async createBroadcastableSweepTransaction(params) {
        throw new account_lib_1.NotImplementedError('createBroadcastableSweepTransaction is not supported for this coin');
    }
}
exports.BaseCoin = BaseCoin;
BaseCoin._coinTokenPatternSeparator = ':';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZUNvaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYml0Z28vYmFzZUNvaW4vYmFzZUNvaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILCtDQUFpQztBQUNqQyw4Q0FBd0M7QUFDeEMsK0NBQXlDO0FBRXpDLHlEQUEyQztBQUkzQyw0Q0FBMkM7QUFDM0MsbURBQXdEO0FBRXhELDhDQUE0QztBQUM1QywwQ0FBb0Q7QUFDcEQsc0NBQW9DO0FBQ3BDLHdEQUFzRDtBQUN0RCxzQ0FBcUQ7QUFDckQsd0NBQXNDO0FBOEJ0QyxNQUFzQixRQUFRO0lBWTVCLFlBQXNCLEtBQWdCO1FBQ3BDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxnQkFBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLG9CQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksa0JBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLGtDQUFnQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDaEUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLHdCQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN0RCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksZ0JBQU8s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RDs7Ozs7Ozs7T0FRRztJQUNILEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxNQUErQjtRQUN2RSxNQUFNLElBQUksaUNBQW1CLENBQUMsb0VBQW9FLENBQUMsQ0FBQztJQUN0RyxDQUFDOztBQXZmSCw0QkF3ZkM7QUEvZTJCLG1DQUEwQixHQUFHLEdBQUcsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgYmlwMzIgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcblxuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgU3RhdGljc0Jhc2VDb2luIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuXG5pbXBvcnQgeyBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyB9IGZyb20gJy4uL3JlY292ZXJ5JztcbmltcG9ydCB7IHNpZ25NZXNzYWdlIH0gZnJvbSAnLi4vYmlwMzJ1dGlsJztcbmltcG9ydCB7IE5vdEltcGxlbWVudGVkRXJyb3IgfSBmcm9tICcuLi8uLi9hY2NvdW50LWxpYic7XG5pbXBvcnQgeyBCaXRHb0Jhc2UgfSBmcm9tICcuLi9iaXRnb0Jhc2UnO1xuaW1wb3J0IHsgRW50ZXJwcmlzZXMgfSBmcm9tICcuLi9lbnRlcnByaXNlJztcbmltcG9ydCB7IEtleWNoYWlucywgS2V5SW5kaWNlcyB9IGZyb20gJy4uL2tleWNoYWluJztcbmltcG9ydCB7IE1hcmtldHMgfSBmcm9tICcuLi9tYXJrZXQnO1xuaW1wb3J0IHsgUGVuZGluZ0FwcHJvdmFscyB9IGZyb20gJy4uL3BlbmRpbmdBcHByb3ZhbCc7XG5pbXBvcnQgeyBXYWxsZXRzLCBJV2FsbGV0LCBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuaW1wb3J0IHsgV2ViaG9va3MgfSBmcm9tICcuLi93ZWJob29rJztcbmltcG9ydCB7XG4gIEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zLFxuICBGZWVFc3RpbWF0ZU9wdGlvbnMsXG4gIElCYXNlQ29pbixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIElUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBLZXljaGFpbnNUcmlwbGV0LFxuICBLZXlQYWlyLFxuICBNUENBbGdvcml0aG0sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBQcmVjcmVhdGVCaXRHb09wdGlvbnMsXG4gIFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFJlY292ZXJUb2tlblRyYW5zYWN0aW9uLFxuICBSZWNvdmVyV2FsbGV0VG9rZW5PcHRpb25zLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyxcbiAgVG9rZW5FbmFibGVtZW50Q29uZmlnLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBCdWlsZE5mdFRyYW5zZmVyRGF0YU9wdGlvbnMsXG4gIEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvblJlc3VsdCxcbn0gZnJvbSAnLi9pQmFzZUNvaW4nO1xuaW1wb3J0IHsgSUluc2NyaXB0aW9uQnVpbGRlciB9IGZyb20gJy4uL2luc2NyaXB0aW9uQnVpbGRlcic7XG5pbXBvcnQgeyBIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IE1QQ1N3ZWVwUmVjb3ZlcnlPcHRpb25zLCBNUENUeHMgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQ29pbiBpbXBsZW1lbnRzIElCYXNlQ29pbiB7XG4gIHByb3RlY3RlZCByZWFkb25seSBiaXRnbzogQml0R29CYXNlO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3VybDogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2VudGVycHJpc2VzOiBFbnRlcnByaXNlcztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF93YWxsZXRzOiBXYWxsZXRzO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2tleWNoYWluczogS2V5Y2hhaW5zO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3dlYmhvb2tzOiBXZWJob29rcztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9wZW5kaW5nQXBwcm92YWxzOiBQZW5kaW5nQXBwcm92YWxzO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX21hcmtldHM6IE1hcmtldHM7XG4gIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgX2NvaW5Ub2tlblBhdHRlcm5TZXBhcmF0b3IgPSAnOic7XG4gIHByb3RlY3RlZCByZWFkb25seSBfc3RhdGljc0NvaW46IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj47XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UpIHtcbiAgICB0aGlzLmJpdGdvID0gYml0Z287XG4gICAgdGhpcy5fdXJsID0gdGhpcy5iaXRnby51cmwoJy8nLCAyKTtcbiAgICB0aGlzLl93YWxsZXRzID0gbmV3IFdhbGxldHModGhpcy5iaXRnbywgdGhpcyk7XG4gICAgdGhpcy5fa2V5Y2hhaW5zID0gbmV3IEtleWNoYWlucyh0aGlzLmJpdGdvLCB0aGlzKTtcbiAgICB0aGlzLl93ZWJob29rcyA9IG5ldyBXZWJob29rcyh0aGlzLmJpdGdvLCB0aGlzKTtcbiAgICB0aGlzLl9wZW5kaW5nQXBwcm92YWxzID0gbmV3IFBlbmRpbmdBcHByb3ZhbHModGhpcy5iaXRnbywgdGhpcyk7XG4gICAgdGhpcy5fZW50ZXJwcmlzZXMgPSBuZXcgRW50ZXJwcmlzZXModGhpcy5iaXRnbywgdGhpcyk7XG4gICAgdGhpcy5fbWFya2V0cyA9IG5ldyBNYXJrZXRzKHRoaXMuYml0Z28sIHRoaXMpO1xuICB9XG5cbiAgcHVibGljIHVybChzdWZmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3VybCArIHRoaXMuZ2V0Q2hhaW4oKSArIHN1ZmZpeDtcbiAgfVxuXG4gIHB1YmxpYyB3YWxsZXRzKCk6IFdhbGxldHMge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXRzO1xuICB9XG5cbiAgcHVibGljIGVudGVycHJpc2VzKCk6IEVudGVycHJpc2VzIHtcbiAgICByZXR1cm4gdGhpcy5fZW50ZXJwcmlzZXM7XG4gIH1cblxuICBwdWJsaWMga2V5Y2hhaW5zKCk6IEtleWNoYWlucyB7XG4gICAgcmV0dXJuIHRoaXMuX2tleWNoYWlucztcbiAgfVxuXG4gIHB1YmxpYyB3ZWJob29rcygpOiBXZWJob29rcyB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYmhvb2tzO1xuICB9XG5cbiAgcHVibGljIHBlbmRpbmdBcHByb3ZhbHMoKTogUGVuZGluZ0FwcHJvdmFscyB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbHM7XG4gIH1cblxuICBwdWJsaWMgbWFya2V0cygpOiBNYXJrZXRzIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya2V0cztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IGNvaW5Ub2tlblBhdHRlcm5TZXBhcmF0b3IoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fY29pblRva2VuUGF0dGVyblNlcGFyYXRvcjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmdldENoYWluKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdGljcyBjb2luIG9iamVjdFxuICAgKiBAcmV0dXJucyB7UmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPn0gdGhlIHN0YXRpY3MgY29pbiBvYmplY3RcbiAgICovXG4gIGdldENvbmZpZygpOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW47XG4gIH1cblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY2hhaW4gd2hpY2ggc3VwcG9ydHMgdGhpcyBjb2luIChlZywgJ2J0YycsICdldGgnKVxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0Q2hhaW4oKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBjb2luIGZhbWlseSAoZWcuIGZvciB0YnRjLCB0aGlzIHdvdWxkIGJlIGJ0YylcbiAgICovXG4gIGFic3RyYWN0IGdldEZhbWlseSgpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEh1bWFuIHJlYWRhYmxlIGZ1bGwgbmFtZSBmb3IgdGhlIGNvaW5cbiAgICovXG4gIGFic3RyYWN0IGdldEZ1bGxOYW1lKCk6IHN0cmluZztcblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBgc2VuZE1hbnkoKWAgdG8gcGVyZm9ybSB3YWxsZXQgc3dlZXAuXG4gICAqIEZJWE1FKEJHLTM5NzM4KTogYWRkIGNvaW4uc3dlZXBXYWxsZXQoKSBpbnN0ZWFkXG4gICAqL1xuICBzd2VlcFdpdGhTZW5kTWFueSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyBkYXRhIGFsb25nIHdpdGggdHJhbnNhY3Rpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCB0eCBkYXRhIChFVEgpLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHRyYW5zYWN0aW9uRGF0YUFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhpcyBjb2luIHN1cHBvcnRzIGFjY291bnQgY29uc29saWRhdGlvbnNcbiAgICogZnJvbSBpdHMgcmVjZWl2ZSBhZGRyZXNzZXMgdG8gdGhlIHJvb3QgYWRkcmVzcy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBjb25zb2xpZGF0ZSBvdmVyIHRoaXMgY29pbjsgZmFsc2UsIG90aGVyd2lzZVxuICAgKi9cbiAgYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNvbmZpZyBmb3IgaG93IHRva2VuIGVuYWJsZW1lbnRzIHdvcmsgZm9yIHRoaXMgY29pblxuICAgKiBAcmV0dXJuc1xuICAgKiAgICByZXF1aXJlc1Rva2VuRW5hYmxlbWVudDogVHJ1ZSBpZiB0b2tlbnMgbmVlZCB0byBiZSBlbmFibGVkIGZvciB0aGlzIGNvaW5cbiAgICogICAgc3VwcG9ydHNNdWx0aXBsZVRva2VuRW5hYmxlbWVudHM6IFRydWUgaWYgbXVsdGlwbGUgdG9rZW5zIGNhbiBiZSBlbmFibGVkIGluIG9uZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZ2V0VG9rZW5FbmFibGVtZW50Q29uZmlnKCk6IFRva2VuRW5hYmxlbWVudENvbmZpZyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVpcmVzVG9rZW5FbmFibGVtZW50OiBmYWxzZSxcbiAgICAgIHN1cHBvcnRzTXVsdGlwbGVUb2tlbkVuYWJsZW1lbnRzOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGNvaW4gc3VwcG9ydHMgVFNTIHdhbGxldHMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFRTUyBXYWxsZXRzIGNhbiBiZSBjcmVhdGVkIGZvciB0aGlzIGNvaW5cbiAgICovXG4gIHN1cHBvcnRzVHNzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhlIGNvaW4gc3VwcG9ydHMgZGVyaXZpbmcgYSBrZXkgd2l0aCBhIHNlZWQgKGtleUlEKVxuICAgKiB0byB0aGUgdXNlci9iYWNrdXAga2V5cy5cbiAgICovXG4gIHN1cHBvcnRzRGVyaXZlS2V5V2l0aFNlZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgYmxvY2tjaGFpbiBydW5zIG9uIEVWTSBhcmNoaXRlY3R1cmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBibG9ja2NoYWluIHJ1bnMgb24gRVZNIGFyY2hpdGVjdHVyZS5cbiAgICovXG4gIGlzRVZNKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBjb2luIHN1cHBvcnRzIEJMUy1ES0cgd2FsbGV0cy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgQkxTLURLRyBXYWxsZXRzIGNhbiBiZSBjcmVhdGVkIGZvciB0aGlzIGNvaW5cbiAgICovXG4gIHN1cHBvcnRzQmxzRGtnKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmYWN0b3IgYmV0d2VlbiB0aGUgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhYnN0cmFjdCBnZXRCYXNlRmFjdG9yKCk6IG51bWJlciB8IHN0cmluZztcblxuICAvKipcbiAgICogQ29udmVydCBhIGN1cnJlbmN5IGFtb3VudCByZXByZXNlbnRlZCBpbiBiYXNlIHVuaXRzIChzYXRvc2hpLCB3ZWksIGF0b21zLCBkcm9wcywgc3Ryb29wcylcbiAgICogdG8gYmlnIHVuaXRzIChidGMsIGV0aCwgeHJwLCB4bG0pXG4gICAqL1xuICBiYXNlVW5pdHNUb0JpZ1VuaXRzKGJhc2VVbml0czogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgICBCaWdOdW1iZXIuc2V0KHsgREVDSU1BTF9QTEFDRVM6IDI0IH0pO1xuICAgIGNvbnN0IGRpdmlkZW5kID0gdGhpcy5nZXRCYXNlRmFjdG9yKCk7XG4gICAgY29uc3QgYmlnTnVtYmVyID0gbmV3IEJpZ051bWJlcihiYXNlVW5pdHMpLmRpdmlkZWRCeShkaXZpZGVuZCk7XG4gICAgLy8gc2V0IHRoZSBmb3JtYXQgc28gY29tbWFzIGFyZW4ndCBhZGRlZCB0byBsYXJnZSBjb2luIGFtb3VudHNcbiAgICByZXR1cm4gYmlnTnVtYmVyLnRvRm9ybWF0KG51bGwgYXMgYW55LCBudWxsIGFzIGFueSwgeyBncm91cFNlcGFyYXRvcjogJycsIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgY3VycmVuY3kgYW1vdW50IHJlcHJlc2VudGVkIGluIGJpZyB1bml0cyAoYnRjLCBldGgsIHhycCwgeGxtKVxuICAgKiB0byBiYXNlIHVuaXRzIChzYXRvc2hpLCB3ZWksIGF0b21zLCBkcm9wcywgc3Ryb29wcylcbiAgICogQHBhcmFtIGJpZ1VuaXRzXG4gICAqL1xuICBiaWdVbml0c1RvQmFzZVVuaXRzKGJpZ1VuaXRzOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IG11bHRpcGxpZXIgPSB0aGlzLmdldEJhc2VGYWN0b3IoKTtcbiAgICBjb25zdCBiaWdOdW1iZXIgPSBuZXcgQmlnTnVtYmVyKGJpZ1VuaXRzKS50aW1lcyhtdWx0aXBsaWVyKTtcbiAgICBpZiAoIWJpZ051bWJlci5pc0ludGVnZXIoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBub24taW50ZWdlciBvdXRwdXQgcmVzdWx0ZWQgZnJvbSBtdWx0aXBseWluZyAke2JpZ1VuaXRzfSBieSAke211bHRpcGxpZXJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBiaWdOdW1iZXIudG9GaXhlZCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIG1lc3NhZ2Ugd2l0aCBwcml2YXRlIGtleVxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqL1xuICBhc3luYyBzaWduTWVzc2FnZShrZXk6IHsgcHJ2OiBzdHJpbmcgfSwgbWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICByZXR1cm4gc2lnbk1lc3NhZ2UobWVzc2FnZSwgYmlwMzIuZnJvbUJhc2U1OChrZXkucHJ2KSwgdXR4b2xpYi5uZXR3b3Jrcy5iaXRjb2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgc2lnbmF0dXJlcyBmb3IgdGhlIGJhY2t1cCBhbmQgYml0Z28ga2V5cyB1c2luZyB0aGUgdXNlciBrZXkuXG4gICAqIFdlIGNhbiB2ZXJpZnkgdGhlIHNpZ25hdHVyZXMgd2hlbiBmZXRjaGluZyB0aGUga2V5cyBmcm9tIHdhbGxldC1wbGF0Zm9ybSBsYXRlci5cbiAgICogQ3VycmVudGx5IG9ubHkgYEFic3RyYWN0VXR4b0NvaW5gIGltcGxlbWVudHMgYW5kIHVzZXMgdGhlIGNvbXBsZW1lbnRhcnkgYHZlcmlmeUtleVNpZ25hdHVyZWAgbWV0aG9kLlxuICAgKiBAcGFyYW0gcHJ2IC0gdGhlIHVzZXIgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIGJhY2t1cEtleWNoYWluIC0gY29udGFpbnMgdGhlIGJhY2t1cCBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBiaXRnb0tleWNoYWluIC0gY29udGFpbnMgdGhlIGJpdGdvIHB1YmxpYyBrZXlcbiAgICovXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVLZXlTaWduYXR1cmVzKFxuICAgIHBydjogc3RyaW5nLFxuICAgIGJhY2t1cEtleWNoYWluOiB7IHB1Yjogc3RyaW5nIH0sXG4gICAgYml0Z29LZXljaGFpbjogeyBwdWI6IHN0cmluZyB9XG4gICk6IFByb21pc2U8e1xuICAgIGJhY2t1cDogc3RyaW5nO1xuICAgIGJpdGdvOiBzdHJpbmc7XG4gIH0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFja3VwOiAoYXdhaXQgdGhpcy5zaWduTWVzc2FnZSh7IHBydiB9LCBiYWNrdXBLZXljaGFpbi5wdWIpKS50b1N0cmluZygnaGV4JyksXG4gICAgICBiaXRnbzogKGF3YWl0IHRoaXMuc2lnbk1lc3NhZ2UoeyBwcnYgfSwgYml0Z29LZXljaGFpbi5wdWIpKS50b1N0cmluZygnaGV4JyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXBvc2UgYSByYXcgdHJhbnNhY3Rpb24gaW50byB1c2VmdWwgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gY29pbi1zcGVjaWZpY1xuICAgKi9cbiAgZXhwbGFpblRyYW5zYWN0aW9uKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPElUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPGFueSwgc3RyaW5nIHwgbnVtYmVyPiB8IHVuZGVmaW5lZD4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgbm90IGltcGxlbWVudGVkYCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBjb21wbGllcyB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICovXG4gIGFic3RyYWN0IHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPjtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHtAc2VlIGlzV2FsbGV0QWRkcmVzc30gaW5zdGVhZFxuICAgKi9cbiAgdmVyaWZ5QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuaXNXYWxsZXRBZGRyZXNzKHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJuIHRydWUgaWZmIGFkZHJlc3MgaXMgYSB3YWxsZXQgYWRkcmVzcy4gTXVzdCByZXR1cm4gZmFsc2UgaWYgYWRkcmVzcyBpcyBvdXRzaWRlIHdhbGxldC5cbiAgICovXG4gIGFic3RyYWN0IGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPjtcblxuICAvKipcbiAgICogY29udmVydCBhZGRyZXNzIGludG8gZGVzaXJlZCBhZGRyZXNzIGZvcm1hdC5cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICogQHBhcmFtIGZvcm1hdFxuICAgKi9cbiAgY2Fub25pY2FsQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcsIGZvcm1hdD86IHVua25vd24pOiBzdHJpbmcge1xuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYSBjb2luIHN1cHBvcnRzIGJsb2NrVGFyZ2V0IGZvciB0cmFuc2FjdGlvbnMgdG8gYmUgaW5jbHVkZWQgaW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdXBwb3J0c0Jsb2NrVGFyZ2V0KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGEgY29pbiBzdXBwb3J0cyBsaWdodG5pbmcgdHJhbnNhY3Rpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3VwcG9ydHNMaWdodG5pbmcoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYSBjb2luIHN1cHBvcnRzIG1lc3NhZ2Ugc2lnbmluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN1cHBvcnRzTWVzc2FnZVNpZ25pbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYSBjb2luIHN1cHBvcnRzIHNpZ25pbmcgb2YgVHlwZWQgZGF0YVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN1cHBvcnRzU2lnbmluZ1R5cGVkRGF0YSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSG9vayB0byBhZGQgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHRoZSB3YWxsZXQgZ2VuZXJhdGlvblxuICAgKiBAcGFyYW0gd2FsbGV0UGFyYW1zXG4gICAqIEBwYXJhbSBrZXljaGFpbnNcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMsIGtleWNoYWluczogS2V5Y2hhaW5zVHJpcGxldCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh3YWxsZXRQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBleHRyYSBwYXJhbWV0ZXJzIGZvciBwcmVidWlsZGluZyBhIHR4LiBBZGQgdGhpbmdzIGxpa2UgaG9wIHRyYW5zYWN0aW9uIHBhcmFtc1xuICAgKi9cbiAgZ2V0RXh0cmFQcmVidWlsZFBhcmFtcyhidWlsZFBhcmFtczogRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZ5IHByZWJ1aWxkIGFmdGVyIHJlY2VpdmluZyBpdCBmcm9tIHRoZSBzZXJ2ZXIuIEFkZCB0aGluZ3MgbGlrZSBubG9ja3RpbWVcbiAgICovXG4gIHBvc3RQcm9jZXNzUHJlYnVpbGQocHJlYnVpbGRSZXNwb25zZTogVHJhbnNhY3Rpb25QcmVidWlsZCk6IFByb21pc2U8VHJhbnNhY3Rpb25QcmVidWlsZD4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJlYnVpbGRSZXNwb25zZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29pbi1zcGVjaWZpYyB0aGluZ3MgZG9uZSBiZWZvcmUgc2lnbmluZyBhIHRyYW5zYWN0aW9uLCBpLmUuIHZlcmlmaWNhdGlvblxuICAgKi9cbiAgcHJlc2lnblRyYW5zYWN0aW9uKHBhcmFtczogUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8UHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucz4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgd2FsbGV0IG9iamVjdCBmcm9tIGEgd2FsbGV0IGRhdGEgb2JqZWN0XG4gICAqIEBwYXJhbSB3YWxsZXRQYXJhbXNcbiAgICovXG4gIG5ld1dhbGxldE9iamVjdCh3YWxsZXRQYXJhbXM6IGFueSk6IElXYWxsZXQge1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMsIHdhbGxldFBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggZmVlIGVzdGltYXRlIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBwYXJhbXMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gcGFyYW1zLm51bUJsb2NrcyBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0byB0YXJnZXQgZm9yIGNvbmZvcm1hdGlvbiAoT25seSB3b3JrcyBmb3IgYnRjKVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaW5mbyByZXR1cm5lZCBmcm9tIHRoZSBtZXJjaGFudCBzZXJ2ZXJcbiAgICovXG4gIGFzeW5jIGZlZUVzdGltYXRlKHBhcmFtczogRmVlRXN0aW1hdGVPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBxdWVyeTogYW55ID0ge307XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMubnVtQmxvY2tzKSB7XG4gICAgICBxdWVyeS5udW1CbG9ja3MgPSBwYXJhbXMubnVtQmxvY2tzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3R4L2ZlZScpKS5xdWVyeShxdWVyeSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbGQgd2FsbGV0IHRvb2wgdXNlcyB0aGlzIGZ1bmN0aW9uIHRvIGRlcml2ZSBhbiBleHRlbmRlZCBrZXkgdGhhdCBpcyBiYXNlZCBvbiB0aGUgcGFzc2VkIGtleSBhbmQgc2VlZFxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHt7a2V5OiBzdHJpbmcsIGRlcml2YXRpb25QYXRoOiBzdHJpbmd9fVxuICAgKi9cbiAgZGVyaXZlS2V5V2l0aFNlZWQoeyBrZXksIHNlZWQgfTogeyBrZXk6IHN0cmluZzsgc2VlZDogc3RyaW5nIH0pOiB7IGtleTogc3RyaW5nOyBkZXJpdmF0aW9uUGF0aDogc3RyaW5nIH0ge1xuICAgIGZ1bmN0aW9uIHNoYTI1NihpbnB1dCkge1xuICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aElucHV0ID0gc2hhMjU2KHNoYTI1NihgJHtzZWVkfWApKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGhQYXJ0cyA9IFtcbiAgICAgIHBhcnNlSW50KGRlcml2YXRpb25QYXRoSW5wdXQuc2xpY2UoMCwgNyksIDE2KSxcbiAgICAgIHBhcnNlSW50KGRlcml2YXRpb25QYXRoSW5wdXQuc2xpY2UoNywgMTQpLCAxNiksXG4gICAgXTtcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9ICdtLzk5OTk5OS8nICsgZGVyaXZhdGlvblBhdGhQYXJ0cy5qb2luKCcvJyk7XG4gICAgY29uc3Qga2V5Tm9kZSA9IGJpcDMyLmZyb21CYXNlNTgoa2V5KTtcbiAgICBjb25zdCBkZXJpdmVkS2V5Tm9kZSA9IGtleU5vZGUuZGVyaXZlUGF0aChkZXJpdmF0aW9uUGF0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZGVyaXZlZEtleU5vZGUudG9CYXNlNTgoKSxcbiAgICAgIGRlcml2YXRpb25QYXRoOiBkZXJpdmF0aW9uUGF0aCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB3aGF0IGtleSB3ZSB3aWxsIG5lZWQgZm9yIHNpZ25pbmcgLSByaWdodCBub3cgd2UganVzdCBuZWVkIHRoZVxuICAgKiB1c2VyIGtleS5cbiAgICovXG4gIGtleUlkc0ZvclNpZ25pbmcoKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBbS2V5SW5kaWNlcy5VU0VSXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFkZGl0aW9uYWwgY2hlY2tzIGJlZm9yZSBhZGRpbmcgYSBiaXRnbyBrZXkuIEJhc2UgY29udHJvbGxlclxuICAgKiBpcyBhIG5vLW9wLCBidXQgY29pbi1zcGVjaWZpYyBjb250cm9sbGVyIG1heSBkbyBzb21ldGhpbmdcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgcHJlQ3JlYXRlQml0R28ocGFyYW1zOiBQcmVjcmVhdGVCaXRHb09wdGlvbnMpOiB2b2lkIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgLSB1c2UgZ2V0QmlwMzJLZXlzKCkgaW4gY29uanVuY3Rpb24gd2l0aCBpc1ZhbGlkQWRkcmVzcyBpbnN0ZWFkXG4gICAqL1xuICBpbml0aWF0ZVJlY292ZXJ5KHBhcmFtczogSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZXByZWNhdGVkIG1ldGhvZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgdXNlZCBpbiBQZW5kaW5nQXBwcm92YWwgZm9yIGNvbXBhcmluZyBQQVlHbyBmZWVzIHB1cnBvc2VcbiAgICogQHBhcmFtIHBhcmFtcyBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqL1xuICBhYnN0cmFjdCBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPjtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBrZXkgcGFpciBvbiB0aGUgY3VydmUgdXNlZCBieSB0aGUgY29pblxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2VlZCAtIHNlZWQgdG8gdXNlIGZvciBrZXkgcGFpciBnZW5lcmF0aW9uXG4gICAqIEByZXR1cm5zIHtLZXlQYWlyfSB0aGUgZ2VuZXJhdGVkIGtleSBwYWlyXG4gICAqL1xuICBhYnN0cmFjdCBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXI7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcm9vdCBrZXkgcGFpciBvbiB0aGUgY3VydmUgdXNlZCBieSB0aGUgY29pblxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2VlZCAtIHNlZWQgdG8gdXNlIGZvciBrZXkgcGFpciBnZW5lcmF0aW9uXG4gICAqIEByZXR1cm5zIHtLZXlQYWlyfSB0aGUgZ2VuZXJhdGVkIGtleSBwYWlyXG4gICAqL1xuICBnZW5lcmF0ZVJvb3RLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignZ2VuZXJhdGVSb290S2V5UGFpciBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIGNvaW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGFic3RyYWN0IGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2V0aGVyIHRoZSBnaXZlbiBtIG9mIG4gd2FsbGV0IHNpZ25lcnMvIGtleSBhbW91bnRzIGFyZSB2YWxpZCBmb3IgdGhlIGNvaW5cbiAgICovXG4gIGlzVmFsaWRNb2ZOU2V0dXAoeyBtLCBuIH06IHsgbT86IG51bWJlcjsgbj86IG51bWJlciB9KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG0gPT09IDIgJiYgbiA9PT0gMztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBgYWRkcmVzc2AgaXMgYSBwbGF1c2libHkgdmFsaWQgYWRkcmVzcyBmb3IgdGhlIGdpdmVuIGNvaW4uXG4gICAqXG4gICAqIERvZXMgbm90IHZlcmlmeSB0aGF0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8gYSB3YWxsZXQuIEZvciB0aGF0LFxuICAgKiB1c2UgW1t2ZXJpZnlBZGRyZXNzXV1cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGFic3RyYWN0IGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNpZ24gYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYWJzdHJhY3Qgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3J0aW9uIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGF0IG5lZWRzIHRvIGJlIHNpZ25lZCBpbiBCdWZmZXIgZm9ybWF0LlxuICAgKiBPbmx5IG5lZWRlZCBmb3IgY29pbnMgdGhhdCBzdXBwb3J0IGFkZGluZyBzaWduYXR1cmVzIGRpcmVjdGx5IChlLmcuIFRTUykuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJpYWxpemVkVHggLSB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb24gaW4gYnJvYWRjYXN0IGZvcm1hdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSAtIHRoZSBwb3J0aW9uIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGF0IG5lZWRzIHRvIGJlIHNpZ25lZFxuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmFibGVQYXlsb2FkKHNlcmlhbGl6ZWRUeDogc3RyaW5nKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VyaWFsaXplZFR4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBNUEMgYWxnb3JpdGhtIChlY2RzYSBvciBlZGRzYSkgdXNlZCBmb3IgY29pbnMgdGhhdCBzdXBwb3J0IFRTU1xuICAgKi9cbiAgZ2V0TVBDQWxnb3JpdGhtKCk6IE1QQ0FsZ29yaXRobSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdubyBNUEMgYWxnb3JpdGhtIGlzIGRlZmluZWQgZm9yIHRoaXMgY29pbicpO1xuICB9XG5cbiAgYXN5bmMgcmVjb3ZlclRva2VuKHBhcmFtczogUmVjb3ZlcldhbGxldFRva2VuT3B0aW9ucyk6IFByb21pc2U8UmVjb3ZlclRva2VuVHJhbnNhY3Rpb24+IHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigncmVjb3ZlclRva2VuIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgY29pbicpO1xuICB9XG5cbiAgZ2V0SW5zY3JpcHRpb25CdWlsZGVyKHdhbGxldDogV2FsbGV0KTogSUluc2NyaXB0aW9uQnVpbGRlciB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ0luc2NyaXB0aW9uIEJ1aWxkZXIgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBjb2luJyk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gZ2V0IGNvaW4gc3BlY2lmaWMgaGFzaCBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRyYW5zYWN0aW9uIGRpZ2VzdHMuXG4gICAqIEByZXR1cm5zIHtAc2VlIEhhc2h9IGhhc2ggZnVuY3Rpb24gaWYgaW1wbGVtZW50ZWQsIG90aGVyd2lzZSB0aHJvd3MgZXhjZXB0aW9uXG4gICAqL1xuICBnZXRIYXNoRnVuY3Rpb24oKTogSGFzaCB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2dldEhhc2hGdW5jdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIGNvaW4nKTtcbiAgfVxuXG4gIGJ1aWxkTmZ0VHJhbnNmZXJEYXRhKHBhcmFtczogQnVpbGROZnRUcmFuc2ZlckRhdGFPcHRpb25zKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignYnVpbGROZnRUcmFuc2ZlckRhdGEgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBjb2luJyk7XG4gIH1cblxuICAvKipcbiAgICogQnJvYWRjYXN0IGEgdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmtcbiAgICogQHBhcmFtIHBhcmFtcyBvcHRpb25zIGZvciBicm9hZGNhc3RpbmdcbiAgICogQHJldHVybnMge1Byb21pc2U8QmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uUmVzdWx0Pn0gcmVzdWx0IG9mIGJyb2FkY2FzdFxuICAgKiBAdGhyb3dzIHtOb3RJbXBsZW1lbnRlZEVycm9yfSBpZiBub3QgaW1wbGVtZW50ZWRcbiAgICovXG4gIGJyb2FkY2FzdFRyYW5zYWN0aW9uKHBhcmFtczogQmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8QmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uUmVzdWx0PiB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2Jyb2FkY2FzdFRyYW5zYWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgY29pbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgZnVuZHMgc3dlZXAgcmVjb3ZlcnkgdHJhbnNhY3Rpb24ocykgd2l0aG91dCBCaXRHb1xuICAgKlxuICAgKiBAcGFyYW0ge01QQ1N3ZWVwUmVjb3ZlcnlPcHRpb25zfSBwYXJhbXMgcGFyYW1ldGVycyBuZWVkZWQgdG8gY29tYmluZSB0aGUgc2lnbmF0dXJlc1xuICAgKiBhbmQgdHJhbnNhY3Rpb25zIHRvIGNyZWF0ZSBicm9hZGNhc3RhYmxlIHRyYW5zYWN0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7TVBDVHhzfSBhcnJheSBvZiB0aGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBoZXggc3RyaW5ncyBhbmQgaW5kaWNlc1xuICAgKiBvZiB0aGUgYWRkcmVzc2VzIGJlaW5nIHN3ZXB0XG4gICAqL1xuICBhc3luYyBjcmVhdGVCcm9hZGNhc3RhYmxlU3dlZXBUcmFuc2FjdGlvbihwYXJhbXM6IE1QQ1N3ZWVwUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxNUENUeHM+IHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignY3JlYXRlQnJvYWRjYXN0YWJsZVN3ZWVwVHJhbnNhY3Rpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBjb2luJyk7XG4gIH1cbn1cbiJdfQ==