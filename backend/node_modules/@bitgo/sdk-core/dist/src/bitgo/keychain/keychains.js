"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Keychains = void 0;
const assert_1 = __importDefault(require("assert"));
const _ = __importStar(require("lodash"));
const common = __importStar(require("../../common"));
const utils_1 = require("../utils");
const ovcJsonCodec_1 = require("./ovcJsonCodec");
class Keychains {
    constructor(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a keychain by ID
     * @param params
     * @param params.id
     * @param params.xpub (optional)
     * @param params.ethAddress (optional)
     * @param params.reqId (optional)
     */
    async get(params) {
        common.validateParams(params, [], ['xpub', 'ethAddress']);
        if (_.isUndefined(params.id)) {
            throw new Error('id must be defined');
        }
        const id = params.id;
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return await this.bitgo.get(this.baseCoin.url('/key/' + encodeURIComponent(id))).result();
    }
    /**
     * list the users keychains
     * @param params
     * @param params.limit - Max number of results in a single call.
     * @param params.prevId - Continue iterating (provided by nextBatchPrevId in the previous list)
     * @returns {*}
     */
    async list(params = {}) {
        const queryObject = {};
        if (!_.isUndefined(params.limit)) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            queryObject.limit = params.limit;
        }
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            queryObject.prevId = params.prevId;
        }
        return this.bitgo.get(this.baseCoin.url('/key')).query(queryObject).result();
    }
    /**
     * Change the decryption password for all possible keychains associated with a user.
     *
     * This function iterates through all keys associated with the user, decrypts
     * them with the old password and re-encrypts them with the new password.
     *
     * This should be called when a user changes their login password, and are expecting
     * that their wallet passwords are changed to match the new login password.
     *
     * @param params
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns changedKeys Object - e.g.:
     *  {
     *    xpub1: encryptedPrv,
     *    ...
     *  }
     */
    async updatePassword(params) {
        common.validateParams(params, ['oldPassword', 'newPassword'], []);
        const changedKeys = {};
        let prevId;
        let keysLeft = true;
        while (keysLeft) {
            const result = await this.list({ limit: 500, prevId });
            for (const key of result.keys) {
                const oldEncryptedPrv = key.encryptedPrv;
                if (_.isUndefined(oldEncryptedPrv)) {
                    continue;
                }
                try {
                    const updatedKeychain = this.updateSingleKeychainPassword({
                        keychain: key,
                        oldPassword: params.oldPassword,
                        newPassword: params.newPassword,
                    });
                    if (updatedKeychain.encryptedPrv) {
                        const changedKeyIdentifier = updatedKeychain.type === 'tss' ? updatedKeychain.id : updatedKeychain.pub;
                        if (changedKeyIdentifier) {
                            changedKeys[changedKeyIdentifier] = updatedKeychain.encryptedPrv;
                        }
                    }
                }
                catch (e) {
                    // if the password was incorrect, silence the error, throw otherwise
                    if (!e.message.includes('private key is incorrect')) {
                        throw e;
                    }
                }
            }
            if (result.nextBatchPrevId) {
                prevId = result.nextBatchPrevId;
            }
            else {
                keysLeft = false;
            }
        }
        return changedKeys;
    }
    /**
     * Update the password used to decrypt a single keychain
     * @param params
     * @param params.keychain - The keychain whose password should be updated
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns {object}
     */
    updateSingleKeychainPassword(params = {}) {
        if (!_.isString(params.oldPassword)) {
            throw new Error('expected old password to be a string');
        }
        if (!_.isString(params.newPassword)) {
            throw new Error('expected new password to be a string');
        }
        if (!_.isObject(params.keychain) || !_.isString(params.keychain.encryptedPrv)) {
            throw new Error('expected keychain to be an object with an encryptedPrv property');
        }
        const oldEncryptedPrv = params.keychain.encryptedPrv;
        try {
            const decryptedPrv = this.bitgo.decrypt({ input: oldEncryptedPrv, password: params.oldPassword });
            const newEncryptedPrv = this.bitgo.encrypt({ input: decryptedPrv, password: params.newPassword });
            return _.assign({}, params.keychain, { encryptedPrv: newEncryptedPrv });
        }
        catch (e) {
            // catching an error here means that the password was incorrect or, less likely, the input to decrypt is corrupted
            throw new Error('password used to decrypt keychain private key is incorrect');
        }
    }
    /**
     * Create a public/private key pair
     * @param params - optional params
     * @param params.seed optional - seed to use for keypair generation
     * @param params.isRootKey optional - whether the resulting keypair should be a root key
     * @returns {KeyPair} - the generated keypair
     */
    create(params = {}) {
        if (params === null || params === void 0 ? void 0 : params.isRootKey) {
            return this.baseCoin.generateRootKeyPair(params.seed);
        }
        return this.baseCoin.generateKeyPair(params.seed);
    }
    /**
     * Add a keychain to BitGo's records
     * @param params
     */
    async add(params = {}) {
        params = params || {};
        common.validateParams(params, [], [
            'pub',
            'encryptedPrv',
            'keyType',
            'type',
            'source',
            'originalPasscodeEncryptionCode',
            'enterprise',
            'derivedFromParentWithSeed',
        ]);
        if (!_.isUndefined(params.disableKRSEmail)) {
            if (!_.isBoolean(params.disableKRSEmail)) {
                throw new Error('invalid disableKRSEmail argument, expecting boolean');
            }
        }
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return await this.bitgo
            .post(this.baseCoin.url('/key'))
            .send({
            pub: params.pub,
            commonPub: params.commonPub,
            commonKeychain: params.commonKeychain,
            encryptedPrv: params.encryptedPrv,
            type: params.type,
            keyType: params.keyType,
            source: params.source,
            provider: params.provider,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            enterprise: params.enterprise,
            derivedFromParentWithSeed: params.derivedFromParentWithSeed,
            disableKRSEmail: params.disableKRSEmail,
            krsSpecific: params.krsSpecific,
            keyShares: params.keyShares,
            userGPGPublicKey: params.userGPGPublicKey,
            backupGPGPublicKey: params.backupGPGPublicKey,
            algoUsed: params.algoUsed,
            isDistributedCustody: params.isDistributedCustody,
            isMPCv2: params.isMPCv2,
            coinSpecific: params.coinSpecific,
        })
            .result();
    }
    /**
     * Create a BitGo key
     * @param params (empty)
     */
    async createBitGo(params = {}) {
        params.source = 'bitgo';
        this.baseCoin.preCreateBitGo(params);
        return await this.add(params);
    }
    /**
     * Create a backup key
     * @param params
     * @param params.provider (optional)
     */
    async createBackup(params = {}) {
        params.source = 'backup';
        const isTssBackupKey = params.prv && (params.commonKeychain || params.commonPub);
        if (_.isUndefined(params.provider) && !isTssBackupKey) {
            // if the provider is undefined, we generate a local key and add the source details
            const key = this.create();
            _.extend(params, key);
            if (params.passphrase !== undefined) {
                _.extend(params, { encryptedPrv: this.bitgo.encrypt({ input: key.prv, password: params.passphrase }) });
            }
        }
        const serverResponse = await this.add(params);
        return _.extend({}, serverResponse, _.pick(params, ['prv', 'encryptedPrv', 'provider', 'source']));
    }
    /**
     * Gets keys for signing from a wallet
     * @param params
     * @returns {Promise<Keychain[]>}
     */
    async getKeysForSigning(params = {}) {
        if (!_.isObject(params.wallet)) {
            throw new Error('missing required param wallet');
        }
        const wallet = params.wallet;
        const reqId = params.reqId || new utils_1.RequestTracer();
        const ids = wallet.baseCoin.keyIdsForSigning();
        const keychainQueriesBluebirds = ids.map((id) => this.get({ id: wallet.keyIds()[id], reqId }));
        return Promise.all(keychainQueriesBluebirds);
    }
    /**
     * Convenience function to create and store MPC keychains with BitGo.
     * @param params passphrase used to encrypt secret materials
     * @return {Promise<KeychainsTriplet>} newly created User, Backup, and BitGo keys
     */
    async createMpc(params) {
        var _a, _b;
        let MpcUtils;
        let multisigTypeVersion = undefined;
        if (params.multisigType === 'tss' && this.baseCoin.getMPCAlgorithm() === 'ecdsa') {
            const tssSettings = await this.bitgo
                .get(this.bitgo.microservicesUrl('/api/v2/tss/settings'))
                .result();
            multisigTypeVersion =
                (_b = (_a = tssSettings.coinSettings[this.baseCoin.getFamily()]) === null || _a === void 0 ? void 0 : _a.walletCreationSettings) === null || _b === void 0 ? void 0 : _b.multiSigTypeVersion;
        }
        switch (params.multisigType) {
            case 'tss':
                MpcUtils =
                    this.baseCoin.getMPCAlgorithm() === 'eddsa'
                        ? utils_1.EDDSAUtils.default
                        : multisigTypeVersion === 'MPCv2'
                            ? utils_1.ECDSAUtils.EcdsaMPCv2Utils
                            : utils_1.ECDSAUtils.EcdsaUtils;
                break;
            case 'blsdkg':
                if (_.isUndefined(params.passphrase)) {
                    throw new Error('missing required param passphrase');
                }
                MpcUtils = utils_1.BlsUtils;
                break;
            default:
                throw new Error('Unsupported multi-sig type');
        }
        const mpcUtils = new MpcUtils(this.bitgo, this.baseCoin);
        return await mpcUtils.createKeychains({
            passphrase: params.passphrase,
            enterprise: params.enterprise,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            backupProvider: params.backupProvider,
            retrofit: params.retrofit,
        });
    }
    async recreateMpc(params) {
        (0, assert_1.default)(params.coin, new Error('missing required param coin'));
        (0, assert_1.default)(params.walletId, new Error('missing required param walletId'));
        (0, assert_1.default)(params.otp, new Error('missing required param otp'));
        (0, assert_1.default)(params.passphrase, new Error('missing required param passphrase'));
        (0, assert_1.default)(params.encryptedMaterial.encryptedWalletPassphrase, new Error('missing required param encryptedWalletPassphrase'));
        (0, assert_1.default)(params.encryptedMaterial.encryptedUserKey, new Error('missing required param encryptedUserKey'));
        (0, assert_1.default)(params.encryptedMaterial.encryptedBackupKey, new Error('missing required param encryptedBackupKey'));
        await this.bitgo.post(this.bitgo.microservicesUrl('/api/v1/user/unlock')).send({ otp: params.otp }).result();
        const { recoveryInfo } = await this.bitgo
            .post(this.bitgo.microservicesUrl(`/api/v2/${params.coin}/wallet/${params.walletId}/passcoderecovery`))
            .result();
        if (!recoveryInfo || !('passcodeEncryptionCode' in recoveryInfo)) {
            throw new Error('failed to get recovery info');
        }
        const decryptedWalletPassphrase = this.bitgo.decrypt({
            input: params.encryptedMaterial.encryptedWalletPassphrase,
            password: recoveryInfo.passcodeEncryptionCode,
        });
        const decryptedUserKey = this.bitgo.decrypt({
            input: params.encryptedMaterial.encryptedUserKey,
            password: decryptedWalletPassphrase,
        });
        const decryptedBackupKey = this.bitgo.decrypt({
            input: params.encryptedMaterial.encryptedBackupKey,
            password: decryptedWalletPassphrase,
        });
        return this.createMpc({
            ...params,
            multisigType: 'tss',
            retrofit: {
                decryptedUserKey,
                decryptedBackupKey,
                walletId: params.walletId,
            },
        });
    }
    /**
     * It parses the JSON downloaded from the OVC for platform (BitGo),
     * and creates a corresponding TSS BitGo key. It also returns the JSON that needs
     * to be uploaded back to the OVCs containing the BitGo -> OVC shares.
     * @param ovcOutputJson JSON format of the file downloaded from the OVC for platform
     * @returns {BitGoKeyFromOvcShares}
     */
    async createTssBitGoKeyFromOvcShares(ovcOutputJson) {
        var _a, _b, _c, _d;
        const decodedOvcOutput = (0, utils_1.decodeOrElse)(ovcJsonCodec_1.OvcToBitGoJSON.name, ovcJsonCodec_1.OvcToBitGoJSON, ovcOutputJson, (errors) => {
            throw new Error(`Error(s) parsing OVC JSON: ${errors}`);
        });
        if (decodedOvcOutput.state !== 1) {
            throw new Error('State expected to be "1". Please complete the first two OVC operations');
        }
        // OVC-1 is responsible for the User key
        const ovc1 = decodedOvcOutput.ovc[1];
        // OVC-2 is responsible for the Backup key
        const ovc2 = decodedOvcOutput.ovc[2];
        const keyShares = [
            {
                from: 'user',
                to: 'bitgo',
                publicShare: ovc1.ovcToBitgoShare.publicShare,
                privateShare: ovc1.ovcToBitgoShare.privateShare,
                privateShareProof: (_a = ovc1.ovcToBitgoShare.uSig.toString()) !== null && _a !== void 0 ? _a : '',
                vssProof: (_b = ovc1.ovcToBitgoShare.vssProof) !== null && _b !== void 0 ? _b : '',
            },
            {
                from: 'backup',
                to: 'bitgo',
                publicShare: ovc2.ovcToBitgoShare.publicShare,
                privateShare: ovc2.ovcToBitgoShare.privateShare,
                privateShareProof: (_c = ovc2.ovcToBitgoShare.uSig.toString()) !== null && _c !== void 0 ? _c : '',
                vssProof: (_d = ovc2.ovcToBitgoShare.vssProof) !== null && _d !== void 0 ? _d : '',
            },
        ];
        const key = await this.baseCoin.keychains().add({
            source: 'bitgo',
            keyShares,
            keyType: 'tss',
            userGPGPublicKey: ovc1.gpgPubKey,
            backupGPGPublicKey: ovc2.gpgPubKey,
        });
        (0, assert_1.default)(key.keyShares);
        (0, assert_1.default)(key.commonKeychain);
        (0, assert_1.default)(key.walletHSMGPGPublicKeySigs);
        const bitgoToUserShare = key.keyShares.find((value) => value.from === 'bitgo' && value.to === 'user');
        (0, assert_1.default)(bitgoToUserShare);
        (0, assert_1.default)(bitgoToUserShare.vssProof);
        (0, assert_1.default)(bitgoToUserShare.paillierPublicKey);
        const bitgoToBackupShare = key.keyShares.find((value) => value.from === 'bitgo' && value.to === 'backup');
        (0, assert_1.default)(bitgoToBackupShare);
        (0, assert_1.default)(bitgoToBackupShare.vssProof);
        (0, assert_1.default)(bitgoToBackupShare.paillierPublicKey);
        // Create JSON data with platform shares for OVC-1 and OVC-2
        const bitgoToOvcOutput = {
            wallet: {
                ...decodedOvcOutput,
                platform: {
                    commonKeychain: key.commonKeychain,
                    walletGpgPubKeySigs: key.walletHSMGPGPublicKeySigs,
                    ovc: {
                        // BitGo to User (OVC-1)
                        1: {
                            bitgoToOvcShare: {
                                i: 1,
                                j: 3,
                                publicShare: bitgoToUserShare.publicShare,
                                privateShare: bitgoToUserShare.privateShare,
                                paillierPublicKey: bitgoToUserShare.paillierPublicKey,
                                vssProof: bitgoToUserShare.vssProof,
                            },
                        },
                        // BitGo to Backup (OVC-2)
                        2: {
                            bitgoToOvcShare: {
                                i: 2,
                                j: 3,
                                publicShare: bitgoToBackupShare.publicShare,
                                privateShare: bitgoToBackupShare.privateShare,
                                paillierPublicKey: bitgoToBackupShare.paillierPublicKey,
                                vssProof: bitgoToBackupShare.vssProof,
                            },
                        },
                    },
                },
            },
        };
        // Mark it ready for next operation, should be 2
        bitgoToOvcOutput.wallet.state += 1;
        const output = {
            bitGoKeyId: key.id,
            bitGoOutputJsonForOvc: bitgoToOvcOutput,
        };
        return (0, utils_1.decodeOrElse)(ovcJsonCodec_1.BitGoKeyFromOvcShares.name, ovcJsonCodec_1.BitGoKeyFromOvcShares, output, (errors) => {
            throw new Error(`Error producing the output: ${errors}`);
        });
    }
    /**
     * Create keychain for ofc wallet using the password
     * @param userPassword
     * @returns
     */
    async createUserKeychain(userPassword) {
        const keychains = this.baseCoin.keychains();
        const newKeychain = keychains.create();
        const originalPasscodeEncryptionCode = (0, utils_1.generateRandomPassword)(5);
        const encryptedPrv = this.bitgo.encrypt({
            password: userPassword,
            input: newKeychain.prv,
        });
        return await keychains.add({
            encryptedPrv,
            originalPasscodeEncryptionCode,
            pub: newKeychain.pub,
            source: 'user',
        });
    }
}
exports.Keychains = Keychains;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5Y2hhaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL2tleWNoYWluL2tleWNoYWlucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLG9EQUE0QjtBQUM1QiwwQ0FBNEI7QUFDNUIscURBQXVDO0FBR3ZDLG9DQUFpSDtBQWtCakgsaURBQXVGO0FBRXZGLE1BQWEsU0FBUztJQUlwQixZQUFZLEtBQWdCLEVBQUUsUUFBbUI7UUFDL0MsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQTBCO1FBQ2xDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBRTFELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1NBQ3ZDO1FBRUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUNyQixJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0M7UUFDRCxPQUFPLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUM1RixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSyxD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U0FBUyxFQUFFLENBQUM7UUFDNUMsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3ZDLE1BQU0sOEJBQThCLEdBQUcsSUFBQSw4QkFBc0IsRUFBQyxDQUFDLENBQUMsQ0FBQztRQUVqRSxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztZQUN0QyxRQUFRLEVBQUUsWUFBWTtZQUN0QixLQUFLLEVBQUUsV0FBVyxDQUFDLEdBQUc7U0FDdkIsQ0FBQyxDQUFDO1FBRUgsT0FBTyxNQUFNLFNBQVMsQ0FBQyxHQUFHLENBQUM7WUFDekIsWUFBWTtZQUNaLDhCQUE4QjtZQUM5QixHQUFHLEVBQUUsV0FBVyxDQUFDLEdBQUc7WUFDcEIsTUFBTSxFQUFFLE1BQU07U0FDZixDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0Y7QUEvZUQsOEJBK2VDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHNzU2V0dGluZ3MgfSBmcm9tICdAYml0Z28vcHVibGljLXR5cGVzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuLi8uLi9jb21tb24nO1xuaW1wb3J0IHsgSUJhc2VDb2luLCBLZXljaGFpbnNUcmlwbGV0LCBLZXlQYWlyIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgQml0R29CYXNlIH0gZnJvbSAnLi4vYml0Z29CYXNlJztcbmltcG9ydCB7IEJsc1V0aWxzLCBkZWNvZGVPckVsc2UsIEVDRFNBVXRpbHMsIEVERFNBVXRpbHMsIGdlbmVyYXRlUmFuZG9tUGFzc3dvcmQsIFJlcXVlc3RUcmFjZXIgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge1xuICBBZGRLZXljaGFpbk9wdGlvbnMsXG4gIEFwaUtleVNoYXJlLFxuICBDaGFuZ2VkS2V5Y2hhaW5zLFxuICBDcmVhdGVCYWNrdXBPcHRpb25zLFxuICBDcmVhdGVCaXRHb09wdGlvbnMsXG4gIENyZWF0ZU1wY09wdGlvbnMsXG4gIEdldEtleWNoYWluT3B0aW9ucyxcbiAgR2V0S2V5c0ZvclNpZ25pbmdPcHRpb25zLFxuICBJS2V5Y2hhaW5zLFxuICBLZXljaGFpbixcbiAgTGlzdEtleWNoYWluT3B0aW9ucyxcbiAgTGlzdEtleWNoYWluc1Jlc3VsdCxcbiAgUmVjcmVhdGVNcGNPcHRpb25zLFxuICBVcGRhdGVQYXNzd29yZE9wdGlvbnMsXG4gIFVwZGF0ZVNpbmdsZUtleWNoYWluUGFzc3dvcmRPcHRpb25zLFxufSBmcm9tICcuL2lLZXljaGFpbnMnO1xuaW1wb3J0IHsgQml0R29LZXlGcm9tT3ZjU2hhcmVzLCBCaXRHb1RvT3ZjSlNPTiwgT3ZjVG9CaXRHb0pTT04gfSBmcm9tICcuL292Y0pzb25Db2RlYyc7XG5cbmV4cG9ydCBjbGFzcyBLZXljaGFpbnMgaW1wbGVtZW50cyBJS2V5Y2hhaW5zIHtcbiAgcHJpdmF0ZSByZWFkb25seSBiaXRnbzogQml0R29CYXNlO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBJQmFzZUNvaW47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgYmFzZUNvaW46IElCYXNlQ29pbikge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEga2V5Y2hhaW4gYnkgSURcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmlkXG4gICAqIEBwYXJhbSBwYXJhbXMueHB1YiAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBwYXJhbXMuZXRoQWRkcmVzcyAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBwYXJhbXMucmVxSWQgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZ2V0KHBhcmFtczogR2V0S2V5Y2hhaW5PcHRpb25zKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3hwdWInLCAnZXRoQWRkcmVzcyddKTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5pZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaWQgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBwYXJhbXMuaWQ7XG4gICAgaWYgKHBhcmFtcy5yZXFJZCkge1xuICAgICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL2tleS8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKSkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGxpc3QgdGhlIHVzZXJzIGtleWNoYWluc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMubGltaXQgLSBNYXggbnVtYmVyIG9mIHJlc3VsdHMgaW4gYSBzaW5nbGUgY2FsbC5cbiAgICogQHBhcmFtIHBhcmFtcy5wcmV2SWQgLSBDb250aW51ZSBpdGVyYXRpbmcgKHByb3ZpZGVkIGJ5IG5leHRCYXRjaFByZXZJZCBpbiB0aGUgcHJldmlvdXMgbGlzdClcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBsaXN0KHBhcmFtczogTGlzdEtleWNoYWluT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxMaXN0S2V5Y2hhaW5zUmVzdWx0PiB7XG4gICAgY29uc3QgcXVlcnlPYmplY3Q6IGFueSA9IHt9O1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnlPYmplY3QubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMucHJldklkKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5T2JqZWN0LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcva2V5JykpLnF1ZXJ5KHF1ZXJ5T2JqZWN0KS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGRlY3J5cHRpb24gcGFzc3dvcmQgZm9yIGFsbCBwb3NzaWJsZSBrZXljaGFpbnMgYXNzb2NpYXRlZCB3aXRoIGEgdXNlci5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpdGVyYXRlcyB0aHJvdWdoIGFsbCBrZXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciwgZGVjcnlwdHNcbiAgICogdGhlbSB3aXRoIHRoZSBvbGQgcGFzc3dvcmQgYW5kIHJlLWVuY3J5cHRzIHRoZW0gd2l0aCB0aGUgbmV3IHBhc3N3b3JkLlxuICAgKlxuICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgd2hlbiBhIHVzZXIgY2hhbmdlcyB0aGVpciBsb2dpbiBwYXNzd29yZCwgYW5kIGFyZSBleHBlY3RpbmdcbiAgICogdGhhdCB0aGVpciB3YWxsZXQgcGFzc3dvcmRzIGFyZSBjaGFuZ2VkIHRvIG1hdGNoIHRoZSBuZXcgbG9naW4gcGFzc3dvcmQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5vbGRQYXNzd29yZCAtIFRoZSBvbGQgcGFzc3dvcmQgdXNlZCBmb3IgZW5jcnlwdGluZyB0aGUga2V5XG4gICAqIEBwYXJhbSBwYXJhbXMubmV3UGFzc3dvcmQgLSBUaGUgbmV3IHBhc3N3b3JkIHRvIGJlIHVzZWQgZm9yIGVuY3J5cHRpbmcgdGhlIGtleVxuICAgKiBAcmV0dXJucyBjaGFuZ2VkS2V5cyBPYmplY3QgLSBlLmcuOlxuICAgKiAge1xuICAgKiAgICB4cHViMTogZW5jcnlwdGVkUHJ2LFxuICAgKiAgICAuLi5cbiAgICogIH1cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVBhc3N3b3JkKHBhcmFtczogVXBkYXRlUGFzc3dvcmRPcHRpb25zKTogUHJvbWlzZTxDaGFuZ2VkS2V5Y2hhaW5zPiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydvbGRQYXNzd29yZCcsICduZXdQYXNzd29yZCddLCBbXSk7XG4gICAgY29uc3QgY2hhbmdlZEtleXM6IENoYW5nZWRLZXljaGFpbnMgPSB7fTtcbiAgICBsZXQgcHJldklkO1xuICAgIGxldCBrZXlzTGVmdCA9IHRydWU7XG4gICAgd2hpbGUgKGtleXNMZWZ0KSB7XG4gICAgICBjb25zdCByZXN1bHQ6IExpc3RLZXljaGFpbnNSZXN1bHQgPSBhd2FpdCB0aGlzLmxpc3QoeyBsaW1pdDogNTAwLCBwcmV2SWQgfSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiByZXN1bHQua2V5cykge1xuICAgICAgICBjb25zdCBvbGRFbmNyeXB0ZWRQcnYgPSBrZXkuZW5jcnlwdGVkUHJ2O1xuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChvbGRFbmNyeXB0ZWRQcnYpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkS2V5Y2hhaW4gPSB0aGlzLnVwZGF0ZVNpbmdsZUtleWNoYWluUGFzc3dvcmQoe1xuICAgICAgICAgICAga2V5Y2hhaW46IGtleSxcbiAgICAgICAgICAgIG9sZFBhc3N3b3JkOiBwYXJhbXMub2xkUGFzc3dvcmQsXG4gICAgICAgICAgICBuZXdQYXNzd29yZDogcGFyYW1zLm5ld1Bhc3N3b3JkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh1cGRhdGVkS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2KSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkS2V5SWRlbnRpZmllciA9IHVwZGF0ZWRLZXljaGFpbi50eXBlID09PSAndHNzJyA/IHVwZGF0ZWRLZXljaGFpbi5pZCA6IHVwZGF0ZWRLZXljaGFpbi5wdWI7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZEtleUlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZEtleXNbY2hhbmdlZEtleUlkZW50aWZpZXJdID0gdXBkYXRlZEtleWNoYWluLmVuY3J5cHRlZFBydjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgcGFzc3dvcmQgd2FzIGluY29ycmVjdCwgc2lsZW5jZSB0aGUgZXJyb3IsIHRocm93IG90aGVyd2lzZVxuICAgICAgICAgIGlmICghZS5tZXNzYWdlLmluY2x1ZGVzKCdwcml2YXRlIGtleSBpcyBpbmNvcnJlY3QnKSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQubmV4dEJhdGNoUHJldklkKSB7XG4gICAgICAgIHByZXZJZCA9IHJlc3VsdC5uZXh0QmF0Y2hQcmV2SWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzTGVmdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZEtleXM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwYXNzd29yZCB1c2VkIHRvIGRlY3J5cHQgYSBzaW5nbGUga2V5Y2hhaW5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmtleWNoYWluIC0gVGhlIGtleWNoYWluIHdob3NlIHBhc3N3b3JkIHNob3VsZCBiZSB1cGRhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXMub2xkUGFzc3dvcmQgLSBUaGUgb2xkIHBhc3N3b3JkIHVzZWQgZm9yIGVuY3J5cHRpbmcgdGhlIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zLm5ld1Bhc3N3b3JkIC0gVGhlIG5ldyBwYXNzd29yZCB0byBiZSB1c2VkIGZvciBlbmNyeXB0aW5nIHRoZSBrZXlcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHVwZGF0ZVNpbmdsZUtleWNoYWluUGFzc3dvcmQocGFyYW1zOiBVcGRhdGVTaW5nbGVLZXljaGFpblBhc3N3b3JkT3B0aW9ucyA9IHt9KTogS2V5Y2hhaW4ge1xuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMub2xkUGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG9sZCBwYXNzd29yZCB0byBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMubmV3UGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG5ldyBwYXNzd29yZCB0byBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghXy5pc09iamVjdChwYXJhbXMua2V5Y2hhaW4pIHx8ICFfLmlzU3RyaW5nKHBhcmFtcy5rZXljaGFpbi5lbmNyeXB0ZWRQcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGtleWNoYWluIHRvIGJlIGFuIG9iamVjdCB3aXRoIGFuIGVuY3J5cHRlZFBydiBwcm9wZXJ0eScpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZEVuY3J5cHRlZFBydiA9IHBhcmFtcy5rZXljaGFpbi5lbmNyeXB0ZWRQcnY7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZFBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7IGlucHV0OiBvbGRFbmNyeXB0ZWRQcnYsIHBhc3N3b3JkOiBwYXJhbXMub2xkUGFzc3dvcmQgfSk7XG4gICAgICBjb25zdCBuZXdFbmNyeXB0ZWRQcnYgPSB0aGlzLmJpdGdvLmVuY3J5cHQoeyBpbnB1dDogZGVjcnlwdGVkUHJ2LCBwYXNzd29yZDogcGFyYW1zLm5ld1Bhc3N3b3JkIH0pO1xuICAgICAgcmV0dXJuIF8uYXNzaWduKHt9LCBwYXJhbXMua2V5Y2hhaW4sIHsgZW5jcnlwdGVkUHJ2OiBuZXdFbmNyeXB0ZWRQcnYgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gY2F0Y2hpbmcgYW4gZXJyb3IgaGVyZSBtZWFucyB0aGF0IHRoZSBwYXNzd29yZCB3YXMgaW5jb3JyZWN0IG9yLCBsZXNzIGxpa2VseSwgdGhlIGlucHV0IHRvIGRlY3J5cHQgaXMgY29ycnVwdGVkXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkIHVzZWQgdG8gZGVjcnlwdCBrZXljaGFpbiBwcml2YXRlIGtleSBpcyBpbmNvcnJlY3QnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcHVibGljL3ByaXZhdGUga2V5IHBhaXJcbiAgICogQHBhcmFtIHBhcmFtcyAtIG9wdGlvbmFsIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnNlZWQgb3B0aW9uYWwgLSBzZWVkIHRvIHVzZSBmb3Iga2V5cGFpciBnZW5lcmF0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXMuaXNSb290S2V5IG9wdGlvbmFsIC0gd2hldGhlciB0aGUgcmVzdWx0aW5nIGtleXBhaXIgc2hvdWxkIGJlIGEgcm9vdCBrZXlcbiAgICogQHJldHVybnMge0tleVBhaXJ9IC0gdGhlIGdlbmVyYXRlZCBrZXlwYWlyXG4gICAqL1xuICBjcmVhdGUocGFyYW1zOiB7IHNlZWQ/OiBCdWZmZXI7IGlzUm9vdEtleT86IGJvb2xlYW4gfSA9IHt9KTogS2V5UGFpciB7XG4gICAgaWYgKHBhcmFtcz8uaXNSb290S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi5nZW5lcmF0ZVJvb3RLZXlQYWlyKHBhcmFtcy5zZWVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmFzZUNvaW4uZ2VuZXJhdGVLZXlQYWlyKHBhcmFtcy5zZWVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBrZXljaGFpbiB0byBCaXRHbydzIHJlY29yZHNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgYWRkKHBhcmFtczogQWRkS2V5Y2hhaW5PcHRpb25zID0ge30pOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhcbiAgICAgIHBhcmFtcyxcbiAgICAgIFtdLFxuICAgICAgW1xuICAgICAgICAncHViJyxcbiAgICAgICAgJ2VuY3J5cHRlZFBydicsXG4gICAgICAgICdrZXlUeXBlJyxcbiAgICAgICAgJ3R5cGUnLFxuICAgICAgICAnc291cmNlJyxcbiAgICAgICAgJ29yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZScsXG4gICAgICAgICdlbnRlcnByaXNlJyxcbiAgICAgICAgJ2Rlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQnLFxuICAgICAgXVxuICAgICk7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmRpc2FibGVLUlNFbWFpbCkpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmRpc2FibGVLUlNFbWFpbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRpc2FibGVLUlNFbWFpbCBhcmd1bWVudCwgZXhwZWN0aW5nIGJvb2xlYW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnJlcUlkKSB7XG4gICAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocGFyYW1zLnJlcUlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy9rZXknKSlcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgcHViOiBwYXJhbXMucHViLFxuICAgICAgICBjb21tb25QdWI6IHBhcmFtcy5jb21tb25QdWIsXG4gICAgICAgIGNvbW1vbktleWNoYWluOiBwYXJhbXMuY29tbW9uS2V5Y2hhaW4sXG4gICAgICAgIGVuY3J5cHRlZFBydjogcGFyYW1zLmVuY3J5cHRlZFBydixcbiAgICAgICAgdHlwZTogcGFyYW1zLnR5cGUsXG4gICAgICAgIGtleVR5cGU6IHBhcmFtcy5rZXlUeXBlLFxuICAgICAgICBzb3VyY2U6IHBhcmFtcy5zb3VyY2UsXG4gICAgICAgIHByb3ZpZGVyOiBwYXJhbXMucHJvdmlkZXIsXG4gICAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZTogcGFyYW1zLm9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgICAgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsXG4gICAgICAgIGRlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQ6IHBhcmFtcy5kZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkLFxuICAgICAgICBkaXNhYmxlS1JTRW1haWw6IHBhcmFtcy5kaXNhYmxlS1JTRW1haWwsXG4gICAgICAgIGtyc1NwZWNpZmljOiBwYXJhbXMua3JzU3BlY2lmaWMsXG4gICAgICAgIGtleVNoYXJlczogcGFyYW1zLmtleVNoYXJlcyxcbiAgICAgICAgdXNlckdQR1B1YmxpY0tleTogcGFyYW1zLnVzZXJHUEdQdWJsaWNLZXksXG4gICAgICAgIGJhY2t1cEdQR1B1YmxpY0tleTogcGFyYW1zLmJhY2t1cEdQR1B1YmxpY0tleSxcbiAgICAgICAgYWxnb1VzZWQ6IHBhcmFtcy5hbGdvVXNlZCxcbiAgICAgICAgaXNEaXN0cmlidXRlZEN1c3RvZHk6IHBhcmFtcy5pc0Rpc3RyaWJ1dGVkQ3VzdG9keSxcbiAgICAgICAgaXNNUEN2MjogcGFyYW1zLmlzTVBDdjIsXG4gICAgICAgIGNvaW5TcGVjaWZpYzogcGFyYW1zLmNvaW5TcGVjaWZpYyxcbiAgICAgIH0pXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgQml0R28ga2V5XG4gICAqIEBwYXJhbSBwYXJhbXMgKGVtcHR5KVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQml0R28ocGFyYW1zOiBDcmVhdGVCaXRHb09wdGlvbnMgPSB7fSk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICBwYXJhbXMuc291cmNlID0gJ2JpdGdvJztcblxuICAgIHRoaXMuYmFzZUNvaW4ucHJlQ3JlYXRlQml0R28ocGFyYW1zIGFzIGFueSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRkKHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgYmFja3VwIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMucHJvdmlkZXIgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQmFja3VwKHBhcmFtczogQ3JlYXRlQmFja3VwT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIHBhcmFtcy5zb3VyY2UgPSAnYmFja3VwJztcblxuICAgIGNvbnN0IGlzVHNzQmFja3VwS2V5ID0gcGFyYW1zLnBydiAmJiAocGFyYW1zLmNvbW1vbktleWNoYWluIHx8IHBhcmFtcy5jb21tb25QdWIpO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnByb3ZpZGVyKSAmJiAhaXNUc3NCYWNrdXBLZXkpIHtcbiAgICAgIC8vIGlmIHRoZSBwcm92aWRlciBpcyB1bmRlZmluZWQsIHdlIGdlbmVyYXRlIGEgbG9jYWwga2V5IGFuZCBhZGQgdGhlIHNvdXJjZSBkZXRhaWxzXG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmNyZWF0ZSgpO1xuICAgICAgXy5leHRlbmQocGFyYW1zLCBrZXkpO1xuICAgICAgaWYgKHBhcmFtcy5wYXNzcGhyYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgXy5leHRlbmQocGFyYW1zLCB7IGVuY3J5cHRlZFBydjogdGhpcy5iaXRnby5lbmNyeXB0KHsgaW5wdXQ6IGtleS5wcnYsIHBhc3N3b3JkOiBwYXJhbXMucGFzc3BocmFzZSB9KSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IGF3YWl0IHRoaXMuYWRkKHBhcmFtcyk7XG4gICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBzZXJ2ZXJSZXNwb25zZSwgXy5waWNrKHBhcmFtcywgWydwcnYnLCAnZW5jcnlwdGVkUHJ2JywgJ3Byb3ZpZGVyJywgJ3NvdXJjZSddKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBrZXlzIGZvciBzaWduaW5nIGZyb20gYSB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXljaGFpbltdPn1cbiAgICovXG4gIGFzeW5jIGdldEtleXNGb3JTaWduaW5nKHBhcmFtczogR2V0S2V5c0ZvclNpZ25pbmdPcHRpb25zID0ge30pOiBQcm9taXNlPEtleWNoYWluW10+IHtcbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLndhbGxldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSB3YWxsZXQnKTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0ID0gcGFyYW1zLndhbGxldDtcbiAgICBjb25zdCByZXFJZCA9IHBhcmFtcy5yZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIGNvbnN0IGlkcyA9IHdhbGxldC5iYXNlQ29pbi5rZXlJZHNGb3JTaWduaW5nKCk7XG4gICAgY29uc3Qga2V5Y2hhaW5RdWVyaWVzQmx1ZWJpcmRzID0gaWRzLm1hcCgoaWQpID0+IHRoaXMuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVtpZF0sIHJlcUlkIH0pKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoa2V5Y2hhaW5RdWVyaWVzQmx1ZWJpcmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBjcmVhdGUgYW5kIHN0b3JlIE1QQyBrZXljaGFpbnMgd2l0aCBCaXRHby5cbiAgICogQHBhcmFtIHBhcmFtcyBwYXNzcGhyYXNlIHVzZWQgdG8gZW5jcnlwdCBzZWNyZXQgbWF0ZXJpYWxzXG4gICAqIEByZXR1cm4ge1Byb21pc2U8S2V5Y2hhaW5zVHJpcGxldD59IG5ld2x5IGNyZWF0ZWQgVXNlciwgQmFja3VwLCBhbmQgQml0R28ga2V5c1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlTXBjKHBhcmFtczogQ3JlYXRlTXBjT3B0aW9ucyk6IFByb21pc2U8S2V5Y2hhaW5zVHJpcGxldD4ge1xuICAgIGxldCBNcGNVdGlscztcbiAgICBsZXQgbXVsdGlzaWdUeXBlVmVyc2lvbjogJ01QQ3YyJyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyYW1zLm11bHRpc2lnVHlwZSA9PT0gJ3RzcycgJiYgdGhpcy5iYXNlQ29pbi5nZXRNUENBbGdvcml0aG0oKSA9PT0gJ2VjZHNhJykge1xuICAgICAgY29uc3QgdHNzU2V0dGluZ3M6IFRzc1NldHRpbmdzID0gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgICAuZ2V0KHRoaXMuYml0Z28ubWljcm9zZXJ2aWNlc1VybCgnL2FwaS92Mi90c3Mvc2V0dGluZ3MnKSlcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgbXVsdGlzaWdUeXBlVmVyc2lvbiA9XG4gICAgICAgIHRzc1NldHRpbmdzLmNvaW5TZXR0aW5nc1t0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpXT8ud2FsbGV0Q3JlYXRpb25TZXR0aW5ncz8ubXVsdGlTaWdUeXBlVmVyc2lvbjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHBhcmFtcy5tdWx0aXNpZ1R5cGUpIHtcbiAgICAgIGNhc2UgJ3Rzcyc6XG4gICAgICAgIE1wY1V0aWxzID1cbiAgICAgICAgICB0aGlzLmJhc2VDb2luLmdldE1QQ0FsZ29yaXRobSgpID09PSAnZWRkc2EnXG4gICAgICAgICAgICA/IEVERFNBVXRpbHMuZGVmYXVsdFxuICAgICAgICAgICAgOiBtdWx0aXNpZ1R5cGVWZXJzaW9uID09PSAnTVBDdjInXG4gICAgICAgICAgICA/IEVDRFNBVXRpbHMuRWNkc2FNUEN2MlV0aWxzXG4gICAgICAgICAgICA6IEVDRFNBVXRpbHMuRWNkc2FVdGlscztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdibHNka2cnOlxuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMucGFzc3BocmFzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gcGFzc3BocmFzZScpO1xuICAgICAgICB9XG4gICAgICAgIE1wY1V0aWxzID0gQmxzVXRpbHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBtdWx0aS1zaWcgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBtcGNVdGlscyA9IG5ldyBNcGNVdGlscyh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luKTtcbiAgICByZXR1cm4gYXdhaXQgbXBjVXRpbHMuY3JlYXRlS2V5Y2hhaW5zKHtcbiAgICAgIHBhc3NwaHJhc2U6IHBhcmFtcy5wYXNzcGhyYXNlLFxuICAgICAgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsXG4gICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU6IHBhcmFtcy5vcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgICBiYWNrdXBQcm92aWRlcjogcGFyYW1zLmJhY2t1cFByb3ZpZGVyLFxuICAgICAgcmV0cm9maXQ6IHBhcmFtcy5yZXRyb2ZpdCxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlY3JlYXRlTXBjKHBhcmFtczogUmVjcmVhdGVNcGNPcHRpb25zKTogUHJvbWlzZTxLZXljaGFpbnNUcmlwbGV0PiB7XG4gICAgYXNzZXJ0KHBhcmFtcy5jb2luLCBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gY29pbicpKTtcbiAgICBhc3NlcnQocGFyYW1zLndhbGxldElkLCBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gd2FsbGV0SWQnKSk7XG4gICAgYXNzZXJ0KHBhcmFtcy5vdHAsIG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSBvdHAnKSk7XG4gICAgYXNzZXJ0KHBhcmFtcy5wYXNzcGhyYXNlLCBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gcGFzc3BocmFzZScpKTtcblxuICAgIGFzc2VydChcbiAgICAgIHBhcmFtcy5lbmNyeXB0ZWRNYXRlcmlhbC5lbmNyeXB0ZWRXYWxsZXRQYXNzcGhyYXNlLFxuICAgICAgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtIGVuY3J5cHRlZFdhbGxldFBhc3NwaHJhc2UnKVxuICAgICk7XG4gICAgYXNzZXJ0KHBhcmFtcy5lbmNyeXB0ZWRNYXRlcmlhbC5lbmNyeXB0ZWRVc2VyS2V5LCBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gZW5jcnlwdGVkVXNlcktleScpKTtcbiAgICBhc3NlcnQocGFyYW1zLmVuY3J5cHRlZE1hdGVyaWFsLmVuY3J5cHRlZEJhY2t1cEtleSwgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtIGVuY3J5cHRlZEJhY2t1cEtleScpKTtcblxuICAgIGF3YWl0IHRoaXMuYml0Z28ucG9zdCh0aGlzLmJpdGdvLm1pY3Jvc2VydmljZXNVcmwoJy9hcGkvdjEvdXNlci91bmxvY2snKSkuc2VuZCh7IG90cDogcGFyYW1zLm90cCB9KS5yZXN1bHQoKTtcbiAgICBjb25zdCB7IHJlY292ZXJ5SW5mbyB9ID0gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iaXRnby5taWNyb3NlcnZpY2VzVXJsKGAvYXBpL3YyLyR7cGFyYW1zLmNvaW59L3dhbGxldC8ke3BhcmFtcy53YWxsZXRJZH0vcGFzc2NvZGVyZWNvdmVyeWApKVxuICAgICAgLnJlc3VsdCgpO1xuXG4gICAgaWYgKCFyZWNvdmVyeUluZm8gfHwgISgncGFzc2NvZGVFbmNyeXB0aW9uQ29kZScgaW4gcmVjb3ZlcnlJbmZvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IHJlY292ZXJ5IGluZm8nKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNyeXB0ZWRXYWxsZXRQYXNzcGhyYXNlID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgIGlucHV0OiBwYXJhbXMuZW5jcnlwdGVkTWF0ZXJpYWwuZW5jcnlwdGVkV2FsbGV0UGFzc3BocmFzZSxcbiAgICAgIHBhc3N3b3JkOiByZWNvdmVyeUluZm8ucGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGRlY3J5cHRlZFVzZXJLZXkgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgaW5wdXQ6IHBhcmFtcy5lbmNyeXB0ZWRNYXRlcmlhbC5lbmNyeXB0ZWRVc2VyS2V5LFxuICAgICAgcGFzc3dvcmQ6IGRlY3J5cHRlZFdhbGxldFBhc3NwaHJhc2UsXG4gICAgfSk7XG5cbiAgICBjb25zdCBkZWNyeXB0ZWRCYWNrdXBLZXkgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgaW5wdXQ6IHBhcmFtcy5lbmNyeXB0ZWRNYXRlcmlhbC5lbmNyeXB0ZWRCYWNrdXBLZXksXG4gICAgICBwYXNzd29yZDogZGVjcnlwdGVkV2FsbGV0UGFzc3BocmFzZSxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZU1wYyh7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBtdWx0aXNpZ1R5cGU6ICd0c3MnLFxuICAgICAgcmV0cm9maXQ6IHtcbiAgICAgICAgZGVjcnlwdGVkVXNlcktleSxcbiAgICAgICAgZGVjcnlwdGVkQmFja3VwS2V5LFxuICAgICAgICB3YWxsZXRJZDogcGFyYW1zLndhbGxldElkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCBwYXJzZXMgdGhlIEpTT04gZG93bmxvYWRlZCBmcm9tIHRoZSBPVkMgZm9yIHBsYXRmb3JtIChCaXRHbyksXG4gICAqIGFuZCBjcmVhdGVzIGEgY29ycmVzcG9uZGluZyBUU1MgQml0R28ga2V5LiBJdCBhbHNvIHJldHVybnMgdGhlIEpTT04gdGhhdCBuZWVkc1xuICAgKiB0byBiZSB1cGxvYWRlZCBiYWNrIHRvIHRoZSBPVkNzIGNvbnRhaW5pbmcgdGhlIEJpdEdvIC0+IE9WQyBzaGFyZXMuXG4gICAqIEBwYXJhbSBvdmNPdXRwdXRKc29uIEpTT04gZm9ybWF0IG9mIHRoZSBmaWxlIGRvd25sb2FkZWQgZnJvbSB0aGUgT1ZDIGZvciBwbGF0Zm9ybVxuICAgKiBAcmV0dXJucyB7Qml0R29LZXlGcm9tT3ZjU2hhcmVzfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVHNzQml0R29LZXlGcm9tT3ZjU2hhcmVzKG92Y091dHB1dEpzb246IHVua25vd24pOiBQcm9taXNlPEJpdEdvS2V5RnJvbU92Y1NoYXJlcz4ge1xuICAgIGNvbnN0IGRlY29kZWRPdmNPdXRwdXQgPSBkZWNvZGVPckVsc2UoT3ZjVG9CaXRHb0pTT04ubmFtZSwgT3ZjVG9CaXRHb0pTT04sIG92Y091dHB1dEpzb24sIChlcnJvcnMpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IocykgcGFyc2luZyBPVkMgSlNPTjogJHtlcnJvcnN9YCk7XG4gICAgfSk7XG5cbiAgICBpZiAoZGVjb2RlZE92Y091dHB1dC5zdGF0ZSAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZSBleHBlY3RlZCB0byBiZSBcIjFcIi4gUGxlYXNlIGNvbXBsZXRlIHRoZSBmaXJzdCB0d28gT1ZDIG9wZXJhdGlvbnMnKTtcbiAgICB9XG5cbiAgICAvLyBPVkMtMSBpcyByZXNwb25zaWJsZSBmb3IgdGhlIFVzZXIga2V5XG4gICAgY29uc3Qgb3ZjMSA9IGRlY29kZWRPdmNPdXRwdXQub3ZjWzFdO1xuICAgIC8vIE9WQy0yIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgQmFja3VwIGtleVxuICAgIGNvbnN0IG92YzIgPSBkZWNvZGVkT3ZjT3V0cHV0Lm92Y1syXTtcblxuICAgIGNvbnN0IGtleVNoYXJlczogQXBpS2V5U2hhcmVbXSA9IFtcbiAgICAgIHtcbiAgICAgICAgZnJvbTogJ3VzZXInLFxuICAgICAgICB0bzogJ2JpdGdvJyxcbiAgICAgICAgcHVibGljU2hhcmU6IG92YzEub3ZjVG9CaXRnb1NoYXJlLnB1YmxpY1NoYXJlLFxuICAgICAgICBwcml2YXRlU2hhcmU6IG92YzEub3ZjVG9CaXRnb1NoYXJlLnByaXZhdGVTaGFyZSxcbiAgICAgICAgcHJpdmF0ZVNoYXJlUHJvb2Y6IG92YzEub3ZjVG9CaXRnb1NoYXJlLnVTaWcudG9TdHJpbmcoKSA/PyAnJyxcbiAgICAgICAgdnNzUHJvb2Y6IG92YzEub3ZjVG9CaXRnb1NoYXJlLnZzc1Byb29mID8/ICcnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZnJvbTogJ2JhY2t1cCcsXG4gICAgICAgIHRvOiAnYml0Z28nLFxuICAgICAgICBwdWJsaWNTaGFyZTogb3ZjMi5vdmNUb0JpdGdvU2hhcmUucHVibGljU2hhcmUsXG4gICAgICAgIHByaXZhdGVTaGFyZTogb3ZjMi5vdmNUb0JpdGdvU2hhcmUucHJpdmF0ZVNoYXJlLFxuICAgICAgICBwcml2YXRlU2hhcmVQcm9vZjogb3ZjMi5vdmNUb0JpdGdvU2hhcmUudVNpZy50b1N0cmluZygpID8/ICcnLFxuICAgICAgICB2c3NQcm9vZjogb3ZjMi5vdmNUb0JpdGdvU2hhcmUudnNzUHJvb2YgPz8gJycsXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZCh7XG4gICAgICBzb3VyY2U6ICdiaXRnbycsXG4gICAgICBrZXlTaGFyZXMsXG4gICAgICBrZXlUeXBlOiAndHNzJyxcbiAgICAgIHVzZXJHUEdQdWJsaWNLZXk6IG92YzEuZ3BnUHViS2V5LFxuICAgICAgYmFja3VwR1BHUHVibGljS2V5OiBvdmMyLmdwZ1B1YktleSxcbiAgICB9KTtcbiAgICBhc3NlcnQoa2V5LmtleVNoYXJlcyk7XG4gICAgYXNzZXJ0KGtleS5jb21tb25LZXljaGFpbik7XG4gICAgYXNzZXJ0KGtleS53YWxsZXRIU01HUEdQdWJsaWNLZXlTaWdzKTtcblxuICAgIGNvbnN0IGJpdGdvVG9Vc2VyU2hhcmUgPSBrZXkua2V5U2hhcmVzLmZpbmQoXG4gICAgICAodmFsdWU6IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nIH0pID0+IHZhbHVlLmZyb20gPT09ICdiaXRnbycgJiYgdmFsdWUudG8gPT09ICd1c2VyJ1xuICAgICk7XG4gICAgYXNzZXJ0KGJpdGdvVG9Vc2VyU2hhcmUpO1xuICAgIGFzc2VydChiaXRnb1RvVXNlclNoYXJlLnZzc1Byb29mKTtcbiAgICBhc3NlcnQoYml0Z29Ub1VzZXJTaGFyZS5wYWlsbGllclB1YmxpY0tleSk7XG4gICAgY29uc3QgYml0Z29Ub0JhY2t1cFNoYXJlID0ga2V5LmtleVNoYXJlcy5maW5kKFxuICAgICAgKHZhbHVlOiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZyB9KSA9PiB2YWx1ZS5mcm9tID09PSAnYml0Z28nICYmIHZhbHVlLnRvID09PSAnYmFja3VwJ1xuICAgICk7XG4gICAgYXNzZXJ0KGJpdGdvVG9CYWNrdXBTaGFyZSk7XG4gICAgYXNzZXJ0KGJpdGdvVG9CYWNrdXBTaGFyZS52c3NQcm9vZik7XG4gICAgYXNzZXJ0KGJpdGdvVG9CYWNrdXBTaGFyZS5wYWlsbGllclB1YmxpY0tleSk7XG5cbiAgICAvLyBDcmVhdGUgSlNPTiBkYXRhIHdpdGggcGxhdGZvcm0gc2hhcmVzIGZvciBPVkMtMSBhbmQgT1ZDLTJcbiAgICBjb25zdCBiaXRnb1RvT3ZjT3V0cHV0OiBCaXRHb1RvT3ZjSlNPTiA9IHtcbiAgICAgIHdhbGxldDoge1xuICAgICAgICAuLi5kZWNvZGVkT3ZjT3V0cHV0LFxuICAgICAgICBwbGF0Zm9ybToge1xuICAgICAgICAgIGNvbW1vbktleWNoYWluOiBrZXkuY29tbW9uS2V5Y2hhaW4sXG4gICAgICAgICAgd2FsbGV0R3BnUHViS2V5U2lnczoga2V5LndhbGxldEhTTUdQR1B1YmxpY0tleVNpZ3MsXG4gICAgICAgICAgb3ZjOiB7XG4gICAgICAgICAgICAvLyBCaXRHbyB0byBVc2VyIChPVkMtMSlcbiAgICAgICAgICAgIDE6IHtcbiAgICAgICAgICAgICAgYml0Z29Ub092Y1NoYXJlOiB7XG4gICAgICAgICAgICAgICAgaTogMSxcbiAgICAgICAgICAgICAgICBqOiAzLFxuICAgICAgICAgICAgICAgIHB1YmxpY1NoYXJlOiBiaXRnb1RvVXNlclNoYXJlLnB1YmxpY1NoYXJlLFxuICAgICAgICAgICAgICAgIHByaXZhdGVTaGFyZTogYml0Z29Ub1VzZXJTaGFyZS5wcml2YXRlU2hhcmUsXG4gICAgICAgICAgICAgICAgcGFpbGxpZXJQdWJsaWNLZXk6IGJpdGdvVG9Vc2VyU2hhcmUucGFpbGxpZXJQdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgdnNzUHJvb2Y6IGJpdGdvVG9Vc2VyU2hhcmUudnNzUHJvb2YsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQml0R28gdG8gQmFja3VwIChPVkMtMilcbiAgICAgICAgICAgIDI6IHtcbiAgICAgICAgICAgICAgYml0Z29Ub092Y1NoYXJlOiB7XG4gICAgICAgICAgICAgICAgaTogMixcbiAgICAgICAgICAgICAgICBqOiAzLFxuICAgICAgICAgICAgICAgIHB1YmxpY1NoYXJlOiBiaXRnb1RvQmFja3VwU2hhcmUucHVibGljU2hhcmUsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZVNoYXJlOiBiaXRnb1RvQmFja3VwU2hhcmUucHJpdmF0ZVNoYXJlLFxuICAgICAgICAgICAgICAgIHBhaWxsaWVyUHVibGljS2V5OiBiaXRnb1RvQmFja3VwU2hhcmUucGFpbGxpZXJQdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgdnNzUHJvb2Y6IGJpdGdvVG9CYWNrdXBTaGFyZS52c3NQcm9vZixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vIE1hcmsgaXQgcmVhZHkgZm9yIG5leHQgb3BlcmF0aW9uLCBzaG91bGQgYmUgMlxuICAgIGJpdGdvVG9PdmNPdXRwdXQud2FsbGV0LnN0YXRlICs9IDE7XG5cbiAgICBjb25zdCBvdXRwdXQ6IEJpdEdvS2V5RnJvbU92Y1NoYXJlcyA9IHtcbiAgICAgIGJpdEdvS2V5SWQ6IGtleS5pZCxcbiAgICAgIGJpdEdvT3V0cHV0SnNvbkZvck92YzogYml0Z29Ub092Y091dHB1dCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlY29kZU9yRWxzZShCaXRHb0tleUZyb21PdmNTaGFyZXMubmFtZSwgQml0R29LZXlGcm9tT3ZjU2hhcmVzLCBvdXRwdXQsIChlcnJvcnMpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcHJvZHVjaW5nIHRoZSBvdXRwdXQ6ICR7ZXJyb3JzfWApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBrZXljaGFpbiBmb3Igb2ZjIHdhbGxldCB1c2luZyB0aGUgcGFzc3dvcmRcbiAgICogQHBhcmFtIHVzZXJQYXNzd29yZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlVXNlcktleWNoYWluKHVzZXJQYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIGNvbnN0IGtleWNoYWlucyA9IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCk7XG4gICAgY29uc3QgbmV3S2V5Y2hhaW4gPSBrZXljaGFpbnMuY3JlYXRlKCk7XG4gICAgY29uc3Qgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlID0gZ2VuZXJhdGVSYW5kb21QYXNzd29yZCg1KTtcblxuICAgIGNvbnN0IGVuY3J5cHRlZFBydiA9IHRoaXMuYml0Z28uZW5jcnlwdCh7XG4gICAgICBwYXNzd29yZDogdXNlclBhc3N3b3JkLFxuICAgICAgaW5wdXQ6IG5ld0tleWNoYWluLnBydixcbiAgICB9KTtcblxuICAgIHJldHVybiBhd2FpdCBrZXljaGFpbnMuYWRkKHtcbiAgICAgIGVuY3J5cHRlZFBydixcbiAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgIHB1YjogbmV3S2V5Y2hhaW4ucHViLFxuICAgICAgc291cmNlOiAndXNlcicsXG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==