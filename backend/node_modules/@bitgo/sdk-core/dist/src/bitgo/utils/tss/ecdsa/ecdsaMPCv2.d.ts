/// <reference types="node" />
import { DklsTypes } from '@bitgo/sdk-lib-mpc';
import { Buffer } from 'buffer';
import { KeychainsTriplet } from '../../../baseCoin';
import { MPCv2BroadcastMessage, MPCv2KeyGenRound1Response, MPCv2KeyGenRound2Response, MPCv2KeyGenRound3Response, MPCv2P2PMessage, MPCv2PartyFromStringOrNumber } from '@bitgo/public-types';
import { Ecdsa } from '../../../../account-lib';
import { Keychain } from '../../../keychain';
import { DecryptedRetrofitPayload } from '../../../keychain/iKeychains';
import { CustomMPCv2SigningRound1GeneratingFunction, CustomMPCv2SigningRound2GeneratingFunction, CustomMPCv2SigningRound3GeneratingFunction, RequestType, SignatureShareRecord, TSSParams, TSSParamsForMessage, TSSParamsForMessageWithPrv, TSSParamsWithPrv, TxRequest } from '../baseTypes';
import { BaseEcdsaUtils } from './base';
export declare class EcdsaMPCv2Utils extends BaseEcdsaUtils {
    /** @inheritdoc */
    createKeychains(params: {
        passphrase: string;
        enterprise: string;
        originalPasscodeEncryptionCode?: string;
        retrofit?: DecryptedRetrofitPayload;
    }): Promise<KeychainsTriplet>;
    createParticipantKeychain(participantIndex: MPCv2PartyFromStringOrNumber, commonKeychain: string, privateMaterial?: Buffer, reducedPrivateMaterial?: Buffer, passphrase?: string, originalPasscodeEncryptionCode?: string): Promise<Keychain>;
    /**
     * Converts user and backup MPCv1 SigningMaterial to RetrofitData needed by MPCv2 DKG.
     *
     * @param {Object} params - MPCv1 decrypted signing material for user and backup as a json.stringify string and bitgo's Big Si.
     * @returns {{ mpcv2UserKeyShare: DklsTypes.RetrofitData; mpcv2BakcupKeyShare: DklsTypes.RetrofitData }} - the retrofit data needed to start an MPCv2 DKG session.
     */
    getMpcV2RetrofitDataFromMpcV1Keys(params: {
        mpcv1UserKeyShare: string;
        mpcv1BackupKeyShare: string;
    }): {
        mpcv2UserKeyShare: DklsTypes.RetrofitData;
        mpcv2BackupKeyShare: DklsTypes.RetrofitData;
    };
    getMpcV2RetrofitDataFromMpcV1Key({ mpcv1PartyKeyShare, mpcv1PartyIndex, xiList, mpc, }: {
        mpcv1PartyKeyShare: string;
        mpcv1PartyIndex: number;
        xiList: number[][];
        mpc: Ecdsa;
    }): DklsTypes.RetrofitData;
    private addUserKeychain;
    private addBackupKeychain;
    private getUserAndBackupSession;
    private addBitgoKeychain;
    private sendKeyGenerationRequest;
    sendKeyGenerationRound1(enterprise: string, userGpgPublicKey: string, backupGpgPublicKey: string, payload: DklsTypes.AuthEncMessages & {
        walletId?: string;
    }): Promise<MPCv2KeyGenRound1Response>;
    sendKeyGenerationRound2(enterprise: string, sessionId: string, payload: DklsTypes.AuthEncMessages): Promise<MPCv2KeyGenRound2Response>;
    sendKeyGenerationRound3(enterprise: string, sessionId: string, payload: DklsTypes.AuthEncMessages): Promise<MPCv2KeyGenRound3Response>;
    /**
     * Signs the transaction associated to the transaction request.
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param {string} params.reqId - request id
     * @param {string} params.mpcv2PartyId - party id for the signer involved in this mpcv2 request (either 0 for user or 1 for backup)
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    signTxRequest(params: TSSParamsWithPrv): Promise<TxRequest>;
    /**
     * Signs the message associated to the transaction request.
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param {string} params.reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    signTxRequestForMessage(params: TSSParamsForMessageWithPrv): Promise<TxRequest>;
    private signRequestBase;
    formatBitgoBroadcastMessage(broadcastMessage: MPCv2BroadcastMessage): {
        from: 0 | 1 | 2;
        payload: {
            message: string;
            signature: string;
        };
    };
    formatP2PMessage(p2pMessage: MPCv2P2PMessage, commitment?: string): {
        payload: {
            encryptedMessage: string;
            signature: string;
        };
        from: 0 | 1 | 2;
        to: 0 | 1 | 2;
        commitment: string | undefined;
    };
    /**
     * Get the hash string and derivation path from the transaction request.
     * @param {TxRequest} txRequest - the transaction request object
     * @param {RequestType} requestType - the request type
     * @returns {{ hashBuffer: Buffer; derivationPath: string }} - the hash string and derivation path
     */
    private getHashStringAndDerivationPath;
    /**
     * Gets the BitGo and user GPG keys from the BitGo public GPG key and the encrypted user GPG private key.
     * @param {string} bitgoPublicGpgKey  - the BitGo public GPG key
     * @param {string} encryptedUserGpgPrvKey  - the encrypted user GPG private key
     * @param {string} walletPassphrase  - the wallet passphrase
     * @returns {Promise<{ bitgoGpgKey: pgp.Key; userGpgKey: pgp.SerializedKeyPair<string> }>} - the BitGo and user GPG keys
     */
    private getBitgoAndUserGpgKeys;
    /**
     * Validates the adata and cyphertext.
     * @param adata string
     * @param cyphertext string
     * @returns void
     * @throws {Error} if the adata or cyphertext is invalid
     */
    private validateAdata;
    /** @inheritdoc */
    signEcdsaMPCv2TssUsingExternalSigner(params: TSSParams | TSSParamsForMessage, externalSignerMPCv2SigningRound1Generator: CustomMPCv2SigningRound1GeneratingFunction, externalSignerMPCv2SigningRound2Generator: CustomMPCv2SigningRound2GeneratingFunction, externalSignerMPCv2SigningRound3Generator: CustomMPCv2SigningRound3GeneratingFunction, requestType?: RequestType): Promise<TxRequest>;
    createOfflineRound1Share(params: {
        txRequest: TxRequest;
        prv: string;
        walletPassphrase: string;
    }): Promise<{
        signatureShareRound1: SignatureShareRecord;
        userGpgPubKey: string;
        encryptedRound1Session: string;
        encryptedUserGpgPrvKey: string;
    }>;
    createOfflineRound2Share(params: {
        txRequest: TxRequest;
        prv: string;
        walletPassphrase: string;
        bitgoPublicGpgKey: string;
        encryptedUserGpgPrvKey: string;
        encryptedRound1Session: string;
    }): Promise<{
        signatureShareRound2: SignatureShareRecord;
        encryptedRound2Session: string;
    }>;
    createOfflineRound3Share(params: {
        txRequest: TxRequest;
        prv: string;
        walletPassphrase: string;
        bitgoPublicGpgKey: string;
        encryptedUserGpgPrvKey: string;
        encryptedRound2Session: string;
    }): Promise<{
        signatureShareRound3: SignatureShareRecord;
    }>;
}
/**
 * Checks if the given key share, when decrypted, contains valid GG18 signing material.
 *
 * @param {string} keyShare - The encrypted key share string.
 * @param {string|undefined} walletPassphrase - The passphrase used to decrypt the key share
 * @returns {boolean} - Returns `true` if the decrypted data contains valid signing material, otherwise `false`.
 */
export declare function isGG18SigningMaterial(keyShare: string, walletPassphrase: string | undefined): boolean;
/**
 * Retrieves the MPC v2 recovery key shares from the provided user and backup key shares.
 *
 * @param {string} userPublicOrPrivateKeyShare
 * @param {string} backupPrivateOrPublicKeyShare
 * @param {string} [walletPassphrase] - The passphrase used to decrypt the key shares
 * @returns {Promise<{ userKeyShare: KeyShare, backupKeyShare: KeyShare, commonKeyChain: string }>}
 *
 * @async
 */
export declare function getMpcV2RecoveryKeyShares(userPublicOrPrivateKeyShare: string, backupPrivateOrPublicKeyShare: string, walletPassphrase?: string): Promise<{
    userKeyShare: Buffer;
    backupKeyShare: Buffer;
    commonKeyChain: string;
}>;
/**
 * Signs a message hash using MPC v2 recovery key shares.
 *
 * @param {Buffer} messageHash
 * @param {Buffer} userKeyShare
 * @param {Buffer} backupKeyShare
 * @param {string} commonKeyChain
 * @returns {Promise<{ recid: number, r: string, s: string, y: string }>}
 *
 * @async
 */
export declare function signRecoveryMpcV2(messageHash: Buffer, userKeyShare: Buffer, backupKeyShare: Buffer, commonKeyChain: string): Promise<{
    recid: number;
    r: string;
    s: string;
    y: string;
}>;
//# sourceMappingURL=ecdsaMPCv2.d.ts.map