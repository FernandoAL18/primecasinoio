"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EcdsaUtils = void 0;
const assert_1 = __importDefault(require("assert"));
const buffer_1 = require("buffer");
const openpgp = __importStar(require("openpgp"));
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const tss_1 = require("../../../../account-lib/mpc/tss");
const ecdsa_1 = __importDefault(require("../../../tss/ecdsa"));
const baseTypes_1 = require("../baseTypes");
const tss_2 = require("../../../tss");
const types_1 = require("../../../tss/ecdsa/types");
const opengpgUtils_1 = require("../../opengpgUtils");
const ecdsa_2 = require("../../../tss/ecdsa/ecdsa");
const ecdh_1 = require("../../../ecdh");
const common_1 = require("../../../tss/common");
const types_2 = require("../../../tss/types");
const base_1 = require("./base");
const encryptNShare = ecdsa_1.default.encryptNShare;
/** @inheritdoc */
class EcdsaUtils extends base_1.BaseEcdsaUtils {
    async finalizeBitgoHeldBackupKeyShare(keyId, commonKeychain, userKeyShare, bitgoKeychain, userGpgKey, thirdPartyBackupPublicGpgKey) {
        var _a;
        const encryptedUserToBackupShare = await encryptNShare(userKeyShare, 2, thirdPartyBackupPublicGpgKey.armor(), userGpgKey);
        const bitgoToBackupKeyShare = (_a = bitgoKeychain.keyShares) === null || _a === void 0 ? void 0 : _a.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === 'backup');
        const userPublicShare = buffer_1.Buffer.concat([
            buffer_1.Buffer.from(userKeyShare.nShares[2].y, 'hex'),
            buffer_1.Buffer.from(userKeyShare.nShares[2].chaincode, 'hex'),
        ]).toString('hex');
        (0, assert_1.default)(bitgoToBackupKeyShare);
        const keyResponse = await this.bitgo
            .put(this.baseCoin.url(`/krs/backupkeys/${keyId}`))
            .send({
            commonKeychain,
            keyShares: [
                {
                    from: 'user',
                    to: 'backup',
                    publicShare: userPublicShare,
                    privateShare: encryptedUserToBackupShare.encryptedPrivateShare,
                    privateShareProof: encryptedUserToBackupShare.privateShareProof,
                    vssProof: encryptedUserToBackupShare.vssProof,
                },
                bitgoToBackupKeyShare,
            ],
        })
            .result();
        if (!keyResponse || !keyResponse.commonKeychain) {
            throw new Error('Failed backup key verification.');
        }
        return {
            id: keyResponse.id,
            keyShares: keyResponse.keyShares,
            commonKeychain: keyResponse.commonKeychain,
        };
    }
    /** @inheritdoc */
    async createKeychains(params) {
        var _a;
        const MPC = new tss_1.Ecdsa();
        const m = 2;
        const n = 3;
        const userKeyShare = await MPC.keyShare(1, m, n);
        const userGpgKey = await (0, opengpgUtils_1.generateGPGKeyPair)('secp256k1');
        const isThirdPartyBackup = this.isValidThirdPartyBackupProvider(params.backupProvider);
        const backupKeyShare = await this.createBackupKeyShares(isThirdPartyBackup, userGpgKey, params.enterprise);
        const backupGpgKey = await this.getBackupGpgPubKey(isThirdPartyBackup);
        // Get the BitGo public key based on user/enterprise feature flags
        // If it doesn't work, use the default public key from the constants
        const bitgoPublicGpgKey = (_a = (await this.getBitgoGpgPubkeyBasedOnFeatureFlags(params.enterprise))) !== null && _a !== void 0 ? _a : this.bitgoPublicGpgKey;
        const bitgoKeychain = await this.createBitgoKeychain({
            userGpgKey,
            backupGpgKey,
            bitgoPublicGpgKey,
            userKeyShare,
            backupKeyShare,
            enterprise: params.enterprise,
            isThirdPartyBackup,
        });
        const userKeychainPromise = this.createUserKeychain({
            userGpgKey,
            backupGpgKey,
            bitgoPublicGpgKey,
            userKeyShare,
            backupKeyShare,
            bitgoKeychain,
            passphrase: params.passphrase,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            isThirdPartyBackup,
        });
        const backupKeychainPromise = this.createBackupKeychain({
            userGpgKey,
            backupGpgKey,
            bitgoPublicGpgKey,
            userKeyShare,
            backupKeyShare,
            bitgoKeychain,
            passphrase: params.passphrase,
            backupProvider: params.backupProvider,
        });
        const [userKeychain, backupKeychain] = await Promise.all([userKeychainPromise, backupKeychainPromise]);
        return {
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
    }
    /**
     * If a third party backup is requested, it will create backup shares from
     * a third party (BitGo as of now), otherwise the key shares will be client generated
     */
    async createBackupKeyShares(isThirdPartyBackup = false, userGpgPubKey, enterprise) {
        let backupKeyShare;
        if (isThirdPartyBackup) {
            const bitgoHeldBackupKeyShares = await this.createBitgoHeldBackupKeyShare(userGpgPubKey, enterprise);
            backupKeyShare = {
                bitGoHeldKeyShares: bitgoHeldBackupKeyShares,
            };
        }
        else {
            const MPC = new tss_1.Ecdsa();
            const m = 2;
            const n = 3;
            backupKeyShare = {
                userHeldKeyShare: await MPC.keyShare(2, m, n),
            };
        }
        return backupKeyShare;
    }
    createUserKeychain({ userGpgKey, backupGpgKey, bitgoPublicGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode, isThirdPartyBackup = false, }) {
        var _a;
        if (!passphrase) {
            throw new Error('Please provide a wallet passphrase');
        }
        if (isThirdPartyBackup && ((_a = backupKeyShare.bitGoHeldKeyShares) === null || _a === void 0 ? void 0 : _a.keyShares)) {
            return this.createUserKeychainFromThirdPartyBackup(userGpgKey, bitgoPublicGpgKey, backupGpgKey, userKeyShare, backupKeyShare.bitGoHeldKeyShares.keyShares, bitgoKeychain, passphrase, originalPasscodeEncryptionCode);
        }
        (0, assert_1.default)(backupKeyShare.userHeldKeyShare);
        return this.createParticipantKeychain(userGpgKey, backupGpgKey, bitgoPublicGpgKey, 1, userKeyShare, backupKeyShare.userHeldKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode);
    }
    async createBackupKeychain({ userGpgKey, userKeyShare, backupGpgKey, backupKeyShare, bitgoKeychain, bitgoPublicGpgKey, passphrase, backupProvider, }) {
        var _a;
        if (this.isValidThirdPartyBackupProvider(backupProvider) && ((_a = backupKeyShare.bitGoHeldKeyShares) === null || _a === void 0 ? void 0 : _a.keyShares)) {
            (0, assert_1.default)(bitgoKeychain.commonKeychain);
            const finalizedBackupKeyShare = await this.finalizeBitgoHeldBackupKeyShare(backupKeyShare.bitGoHeldKeyShares.id, bitgoKeychain.commonKeychain, userKeyShare, bitgoKeychain, userGpgKey, backupGpgKey);
            if (finalizedBackupKeyShare.commonKeychain !== bitgoKeychain.commonKeychain) {
                throw new Error('Failed to create backup keychain - commonKeychains do not match');
            }
            const backupKeyParams = {
                source: 'backup',
                keyType: 'tss',
                commonKeychain: finalizedBackupKeyShare.commonKeychain,
                provider: backupProvider !== null && backupProvider !== void 0 ? backupProvider : 'BitGoTrustAsKrs',
            };
            const backupKeychain = await this.baseCoin.keychains().createBackup(backupKeyParams);
            backupKeychain.keyShares = finalizedBackupKeyShare.keyShares;
            return backupKeychain;
        }
        (0, assert_1.default)(backupKeyShare.userHeldKeyShare);
        (0, assert_1.default)(passphrase);
        return this.createParticipantKeychain(userGpgKey, backupGpgKey, bitgoPublicGpgKey, 2, userKeyShare, backupKeyShare.userHeldKeyShare, bitgoKeychain, passphrase);
    }
    /** @inheritdoc */
    async createBitgoKeychain({ userGpgKey, backupGpgKey, userKeyShare, backupKeyShare, enterprise, bitgoPublicGpgKey, isThirdPartyBackup = false, }) {
        const recipientIndex = 3;
        const userToBitgoShare = await encryptNShare(userKeyShare, recipientIndex, bitgoPublicGpgKey.armor(), userGpgKey);
        const backupToBitgoShare = await this.getBackupEncryptedNShare(backupKeyShare, recipientIndex, bitgoPublicGpgKey.armor(), backupGpgKey, isThirdPartyBackup);
        const createBitGoMPCParams = {
            keyType: 'tss',
            source: 'bitgo',
            keyShares: [
                {
                    from: 'user',
                    to: 'bitgo',
                    publicShare: userToBitgoShare.publicShare,
                    privateShare: userToBitgoShare.encryptedPrivateShare,
                    n: userToBitgoShare.n,
                    vssProof: userToBitgoShare.vssProof,
                    privateShareProof: userToBitgoShare.privateShareProof,
                },
                {
                    from: 'backup',
                    to: 'bitgo',
                    publicShare: backupToBitgoShare.publicShare,
                    privateShare: backupToBitgoShare.encryptedPrivateShare,
                    n: backupToBitgoShare.n,
                    vssProof: backupToBitgoShare.vssProof,
                    privateShareProof: backupToBitgoShare.privateShareProof,
                },
            ],
            userGPGPublicKey: userGpgKey.publicKey,
            backupGPGPublicKey: isThirdPartyBackup
                ? backupGpgKey.armor()
                : backupGpgKey.publicKey,
            enterprise: enterprise,
            algoUsed: 'ecdsa',
        };
        return await this.baseCoin.keychains().add(createBitGoMPCParams);
    }
    /**
     * This builds the relevant backup encryptedNShare based on whether the
     * backup key is user or third party generated
     * @param backupShare can either have key shares from the user or third party
     * @param recipientIndex index of the party receiving the backup shares
     * @param recipientGpgPublicArmor gpg armor of the party receiving the backup shares
     * @param backupGpgKey backup gpg key
     * @param isThirdPartyBackup whether the backup is generated by third party
     */
    async getBackupEncryptedNShare(backupShare, recipientIndex, recipientGpgPublicArmor, backupGpgKey, isThirdPartyBackup = false) {
        let backupToRecipientShare;
        if (isThirdPartyBackup) {
            if (!backupShare.bitGoHeldKeyShares) {
                throw new Error(`Missing third party backup key shares`);
            }
            const backupToRecipientApiShare = backupShare.bitGoHeldKeyShares.keyShares.find((keyShare) => keyShare.from === 'backup' && keyShare.to === (0, ecdsa_2.getParticipantFromIndex)(recipientIndex));
            if (!backupToRecipientApiShare) {
                throw new Error(`Missing backup to ${(0, ecdsa_2.getParticipantFromIndex)(recipientIndex)} key share`);
            }
            // Since backup is from a third party, it is already encrypted
            backupToRecipientShare = await (0, ecdsa_2.buildNShareFromAPIKeyShare)(backupToRecipientApiShare);
        }
        else {
            (0, assert_1.default)(backupShare.userHeldKeyShare);
            backupToRecipientShare = await encryptNShare(backupShare.userHeldKeyShare, recipientIndex, recipientGpgPublicArmor, backupGpgKey);
        }
        return backupToRecipientShare;
    }
    /**
     * This uses the backup key from a third party (bitgo in this case)
     * to create the user keychain via WP.
     */
    async createUserKeychainFromThirdPartyBackup(userGpgKey, bitgoPublicGpgKey, thirdPartyBackupPublicGpgKey, userKeyShare, thirdPartybackupKeyShares, bitgoKeychain, passphrase, originalPasscodeEncryptionCode) {
        const bitgoKeyShares = bitgoKeychain.keyShares;
        if (!bitgoKeyShares) {
            throw new Error('Missing BitGo key shares');
        }
        if (!bitgoKeychain.commonKeychain) {
            throw new Error(`Missing common key chain: ${bitgoKeychain.commonKeychain}`);
        }
        const bitGoToUserShare = bitgoKeyShares.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === 'user');
        if (!bitGoToUserShare) {
            throw new Error('Missing BitGo to User key share');
        }
        const backupToUserShare = thirdPartybackupKeyShares.find((keyShare) => keyShare.from === 'backup' && keyShare.to === 'user');
        if (!backupToUserShare) {
            throw new Error('Missing Backup to User key share');
        }
        const backupToUserNShare = await (0, ecdsa_2.buildNShareFromAPIKeyShare)(backupToUserShare);
        const bitGoToUserNShare = await (0, ecdsa_2.buildNShareFromAPIKeyShare)(bitGoToUserShare);
        const encryptedNShares = [
            {
                nShare: backupToUserNShare,
                recipientPrivateArmor: userGpgKey.privateKey,
                senderPublicArmor: thirdPartyBackupPublicGpgKey.armor(),
                isbs58Encoded: false,
            },
            {
                nShare: bitGoToUserNShare,
                recipientPrivateArmor: userGpgKey.privateKey,
                senderPublicArmor: bitgoPublicGpgKey.armor(),
                isbs58Encoded: false,
            },
        ];
        const userCombinedKey = await ecdsa_1.default.createCombinedKey(userKeyShare, encryptedNShares, bitgoKeychain.commonKeychain);
        if (userCombinedKey.commonKeychain !== bitgoKeychain.commonKeychain) {
            throw new Error('Failed to create user keychain - commonKeychains do not match.');
        }
        const prv = JSON.stringify(userCombinedKey.signingMaterial);
        const userKeychainParams = {
            source: 'user',
            keyType: 'tss',
            commonKeychain: userCombinedKey.commonKeychain,
            prv: prv,
            encryptedPrv: this.bitgo.encrypt({
                input: prv,
                password: passphrase,
            }),
            originalPasscodeEncryptionCode,
        };
        const keychains = this.baseCoin.keychains();
        return await keychains.add(userKeychainParams);
    }
    /** @inheritdoc */
    async createParticipantKeychain(userGpgKey, userLocalBackupGpgKey, bitgoPublicGpgKey, recipientIndex, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode) {
        const bitgoKeyShares = bitgoKeychain.keyShares;
        if (!bitgoKeyShares) {
            throw new Error('Missing BitGo key shares');
        }
        if (!bitgoKeychain.commonKeychain) {
            throw new Error(`Missing common key chain: ${bitgoKeychain.commonKeychain}`);
        }
        let recipient;
        let keyShare;
        let otherShare;
        let recipientGpgKey;
        let senderGpgKey;
        if (recipientIndex === 1) {
            keyShare = userKeyShare;
            otherShare = backupKeyShare;
            recipient = 'user';
            recipientGpgKey = userGpgKey;
            senderGpgKey = userLocalBackupGpgKey;
        }
        else if (recipientIndex === 2) {
            keyShare = backupKeyShare;
            otherShare = userKeyShare;
            recipient = 'backup';
            recipientGpgKey = userLocalBackupGpgKey;
            senderGpgKey = userGpgKey;
        }
        else {
            throw new Error('Invalid user index');
        }
        const bitGoToRecipientShare = bitgoKeyShares.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === recipient);
        if (!bitGoToRecipientShare) {
            throw new Error(`Missing BitGo to ${recipient} key share`);
        }
        const decryptedShare = await this.decryptPrivateShare(bitGoToRecipientShare.privateShare, recipientGpgKey);
        await this.verifyWalletSignatures(userGpgKey.publicKey, userLocalBackupGpgKey.publicKey, bitgoKeychain, decryptedShare, recipientIndex);
        const senderToRecipientShare = await encryptNShare(otherShare, recipientIndex, recipientGpgKey.publicKey, senderGpgKey);
        const encryptedNShares = [
            {
                // userToBackup or backupToUser
                nShare: senderToRecipientShare,
                recipientPrivateArmor: recipientGpgKey.privateKey,
                senderPublicArmor: senderGpgKey.publicKey,
            },
            {
                // bitgoToRecipient
                nShare: {
                    i: recipientIndex,
                    j: 3,
                    publicShare: bitGoToRecipientShare.publicShare,
                    encryptedPrivateShare: bitGoToRecipientShare.privateShare,
                    n: bitGoToRecipientShare.n,
                    vssProof: bitGoToRecipientShare.vssProof,
                    privateShareProof: bitGoToRecipientShare.privateShareProof,
                },
                recipientPrivateArmor: recipientGpgKey.privateKey,
                senderPublicArmor: bitgoPublicGpgKey.armor(),
                isbs58Encoded: false,
            },
        ];
        const recipientCombinedKey = await ecdsa_1.default.createCombinedKey(keyShare, encryptedNShares, bitgoKeychain.commonKeychain);
        const prv = JSON.stringify(recipientCombinedKey.signingMaterial);
        const recipientKeychainParams = {
            source: recipient,
            keyType: 'tss',
            commonKeychain: bitgoKeychain.commonKeychain,
            prv: prv,
            encryptedPrv: this.bitgo.encrypt({
                input: prv,
                password: passphrase,
            }),
            originalPasscodeEncryptionCode,
        };
        const keychains = this.baseCoin.keychains();
        return recipientIndex === 1
            ? await keychains.add(recipientKeychainParams)
            : await keychains.createBackup(recipientKeychainParams);
    }
    async createTssEcdsaStep1SigningMaterial(params) {
        const { challenges, derivationPath, prv } = params;
        const userSigningMaterial = JSON.parse(prv);
        if (userSigningMaterial.pShare.i !== 1) {
            throw new Error('Invalid user key');
        }
        if (!userSigningMaterial.backupNShare) {
            throw new Error('Invalid user key - missing backupNShare');
        }
        const MPC = new tss_1.Ecdsa();
        const signingKey = MPC.keyDerive(userSigningMaterial.pShare, [userSigningMaterial.bitgoNShare, userSigningMaterial.backupNShare], derivationPath);
        const bitgoIndex = types_2.ShareKeyPosition.BITGO;
        const userIndex = userSigningMaterial.pShare.i;
        const { ntilde: ntildea, h1: h1a, h2: h2a, p: pa } = challenges.enterpriseChallenge;
        const { ntilde: ntildeb, h1: h1b, h2: h2b, p: pb, n: nb } = challenges.bitgoChallenge;
        const userXShare = MPC.appendChallenge(signingKey.xShare, { ntilde: ntildea, h1: h1a, h2: h2a }, { p: pa });
        const bitgoYShare = MPC.appendChallenge({
            i: userIndex,
            j: bitgoIndex,
            n: nb,
        }, { ntilde: ntildeb, h1: h1b, h2: h2b }, { p: pb });
        const userSignShare = await ecdsa_1.default.createUserSignShare(userXShare, bitgoYShare);
        const u = signingKey.nShares[bitgoIndex].u;
        let chaincode = userSigningMaterial.bitgoNShare.chaincode;
        while (chaincode.length < 64) {
            chaincode = '0' + chaincode;
        }
        const signerShare = utxo_lib_1.bip32.fromPrivateKey(buffer_1.Buffer.from(u, 'hex'), buffer_1.Buffer.from(chaincode, 'hex')).toBase58();
        const bitgoGpgKey = (await (0, opengpgUtils_1.getBitgoGpgPubKey)(this.bitgo)).mpcV1;
        const encryptedSignerShare = (await openpgp.encrypt({
            message: await openpgp.createMessage({
                text: signerShare,
            }),
            config: {
                rejectCurves: new Set(),
            },
            encryptionKeys: [bitgoGpgKey],
        }));
        const userGpgKey = await (0, opengpgUtils_1.generateGPGKeyPair)('secp256k1');
        const privateShareProof = await (0, opengpgUtils_1.createShareProof)(userGpgKey.privateKey, signingKey.nShares[bitgoIndex].u, 'ecdsa');
        const vssProof = signingKey.nShares[bitgoIndex].v;
        const userPublicGpgKey = userGpgKey.publicKey;
        const publicShare = signingKey.nShares[bitgoIndex].y + signingKey.nShares[bitgoIndex].chaincode;
        return {
            privateShareProof: privateShareProof,
            vssProof: vssProof,
            publicShare: publicShare,
            encryptedSignerOffsetShare: encryptedSignerShare,
            userPublicGpgKey: userPublicGpgKey,
            kShare: userSignShare.kShare,
            wShare: params.walletPassphrase
                ? this.bitgo.encrypt({ input: JSON.stringify(userSignShare.wShare), password: params.walletPassphrase })
                : userSignShare.wShare,
        };
    }
    async createTssEcdsaStep2SigningMaterial(params) {
        // Append the BitGo challenge to the Ashare to be used in subsequent proofs
        const bitgoToUserAShareWithNtilde = {
            ...params.aShareFromBitgo,
            ...params.bitgoChallenge,
        };
        const userGammaAndMuShares = await ecdsa_1.default.createUserGammaAndMuShare(params.wShare, bitgoToUserAShareWithNtilde);
        const userOmicronAndDeltaShare = await ecdsa_1.default.createUserOmicronAndDeltaShare(userGammaAndMuShares.gShare);
        return {
            muDShare: {
                muShare: userGammaAndMuShares.muShare,
                dShare: userOmicronAndDeltaShare.dShare,
                i: userGammaAndMuShares.muShare.i,
            },
            oShare: params.walletPassphrase
                ? this.bitgo.encrypt({
                    input: JSON.stringify(userOmicronAndDeltaShare.oShare),
                    password: params.walletPassphrase,
                })
                : userOmicronAndDeltaShare.oShare,
        };
    }
    getOfflineSignerPaillierModulus(params) {
        (0, assert_1.default)(params.prv, 'Params to get paillier modulus are missing prv.');
        const userSigningMaterial = JSON.parse(params.prv);
        return { userPaillierModulus: userSigningMaterial.pShare.n };
    }
    async createOfflineKShare(params) {
        const { tssParams, prv, requestType, challenges } = params;
        (0, assert_1.default)(typeof tssParams.txRequest !== 'string', 'Invalid txRequest type');
        const txRequest = tssParams.txRequest;
        let derivationPath;
        if (requestType === baseTypes_1.RequestType.tx) {
            (0, assert_1.default)(txRequest.transactions || txRequest.unsignedTxs, 'Unable to find transactions in txRequest');
            const unsignedTx = txRequest.apiVersion === 'full' ? txRequest.transactions[0].unsignedTx : txRequest.unsignedTxs[0];
            derivationPath = unsignedTx.derivationPath;
        }
        else if (requestType === baseTypes_1.RequestType.message) {
            // TODO BG-67299 Message signing with derivation path
            derivationPath = '';
        }
        return this.createTssEcdsaStep1SigningMaterial({
            prv: prv,
            challenges: challenges,
            derivationPath: derivationPath,
            walletPassphrase: params.walletPassphrase,
        });
    }
    async createOfflineMuDeltaShare(params) {
        const decryptedWShare = this.bitgo.decrypt({ input: params.encryptedWShare, password: params.walletPassphrase });
        return await this.createTssEcdsaStep2SigningMaterial({
            aShareFromBitgo: params.aShareFromBitgo,
            bitgoChallenge: params.bitgoChallenge,
            wShare: JSON.parse(decryptedWShare),
            walletPassphrase: params.walletPassphrase,
        });
    }
    async createOfflineSShare(params) {
        const { tssParams, requestType, dShareFromBitgo, encryptedOShare, walletPassphrase } = params;
        (0, assert_1.default)(typeof tssParams.txRequest !== 'string', 'Invalid txRequest type');
        const txRequest = tssParams.txRequest;
        let signablePayload;
        if (requestType === baseTypes_1.RequestType.tx) {
            (0, assert_1.default)(txRequest.transactions || txRequest.unsignedTxs, 'Unable to find transactions in txRequest');
            const unsignedTx = txRequest.apiVersion === 'full' ? txRequest.transactions[0].unsignedTx : txRequest.unsignedTxs[0];
            signablePayload = buffer_1.Buffer.from(unsignedTx.signableHex, 'hex');
        }
        else if (requestType === baseTypes_1.RequestType.message) {
            signablePayload = params.tssParams.bufferToSign;
        }
        let hash;
        try {
            hash = this.baseCoin.getHashFunction();
        }
        catch (err) {
            hash = undefined;
        }
        const decryptedOShare = this.bitgo.decrypt({ input: encryptedOShare, password: walletPassphrase });
        const { i, R, s, y } = await ecdsa_1.default.createUserSignatureShare(JSON.parse(decryptedOShare), dShareFromBitgo, signablePayload, hash);
        // return only required SShare without bigints from VAShare
        return {
            i,
            R,
            s,
            y,
        };
    }
    async signEcdsaTssUsingExternalSigner(params, requestType, externalSignerPaillierModulusGetter, externalSignerKShareGenerator, externalSignerMuDeltaShareGenerator, externalSignerSShareGenerator) {
        var _a;
        const { txRequest } = params;
        const pendingEcdsaTssInitialization = (_a = this.wallet.coinSpecific()) === null || _a === void 0 ? void 0 : _a.pendingEcdsaTssInitialization;
        if (pendingEcdsaTssInitialization) {
            throw new Error('Wallet is not ready for TSS ECDSA signing. Please contact your enterprise admin to finish the enterprise TSS initialization.');
        }
        const txRequestObj = await (0, tss_2.getTxRequest)(this.bitgo, this.wallet.id(), txRequest, params.reqId);
        const { userPaillierModulus } = await externalSignerPaillierModulusGetter({ txRequest: txRequestObj });
        const { enterpriseChallenge, bitgoChallenge } = await this.getEcdsaSigningChallenges(txRequest, requestType, userPaillierModulus, 0, params.reqId);
        const step1SigningMaterial = await externalSignerKShareGenerator({
            tssParams: {
                ...params,
                txRequest: txRequestObj,
            },
            challenges: { enterpriseChallenge, bitgoChallenge },
            requestType: requestType,
        });
        // signing stage one with K share send to bitgo and receives A share
        const bitgoToUserAShare = (await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequestObj.txRequestId, requestType, types_1.SendShareType.KShare, step1SigningMaterial.kShare, step1SigningMaterial.encryptedSignerOffsetShare, step1SigningMaterial.vssProof, step1SigningMaterial.privateShareProof, step1SigningMaterial.publicShare, step1SigningMaterial.userPublicGpgKey, params.reqId)); // WP/HSM does not return the initial challenge
        const step2Return = await externalSignerMuDeltaShareGenerator({
            txRequest: txRequestObj,
            aShareFromBitgo: bitgoToUserAShare,
            bitgoChallenge: bitgoChallenge,
            encryptedWShare: step1SigningMaterial.wShare,
        });
        // signing stage two with muShare and dShare send to bitgo and receives D share
        const bitgoToUserDShare = (await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequestObj.txRequestId, requestType, types_1.SendShareType.MUShare, step2Return.muDShare, undefined, undefined, undefined, undefined, undefined, params.reqId));
        const userSShare = await externalSignerSShareGenerator({
            tssParams: {
                ...params,
                txRequest: txRequestObj,
            },
            dShareFromBitgo: bitgoToUserDShare,
            requestType: requestType,
            encryptedOShare: step2Return.oShare,
        });
        // signing stage three with SShare send to bitgo and receives SShare
        await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequestObj.txRequestId, requestType, types_1.SendShareType.SShare, userSShare, undefined, undefined, undefined, undefined, undefined, params.reqId);
        return await (0, tss_2.getTxRequest)(this.bitgo, this.wallet.id(), txRequestObj.txRequestId, params.reqId);
    }
    /**
     * Gets signing key, txRequestResolved and txRequestId
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param { string} params.reqId - request id
     * @returns {Promise<TxRequest>}
     */
    async signRequestBase(params, requestType) {
        var _a;
        const pendingEcdsaTssInitialization = (_a = this.wallet.coinSpecific()) === null || _a === void 0 ? void 0 : _a.pendingEcdsaTssInitialization;
        if (pendingEcdsaTssInitialization) {
            throw new Error('Wallet is not ready for TSS ECDSA signing. Please contact your enterprise admin to finish the enterprise TSS initialization.');
        }
        const userSigningMaterial = JSON.parse(params.prv);
        if (userSigningMaterial.pShare.i !== 1) {
            throw new Error('Invalid user key');
        }
        if (!userSigningMaterial.backupNShare) {
            throw new Error('Invalid user key - missing backupNShare');
        }
        const txRequest = typeof params.txRequest === 'string'
            ? await (0, tss_2.getTxRequest)(this.bitgo, this.wallet.id(), params.txRequest, params.reqId)
            : params.txRequest;
        let signablePayload = new buffer_1.Buffer('');
        let derivationPath = '';
        if (requestType === baseTypes_1.RequestType.tx) {
            (0, assert_1.default)(txRequest.transactions || txRequest.unsignedTxs, 'Unable to find transactions in txRequest');
            const unsignedTx = txRequest.apiVersion === 'full' ? txRequest.transactions[0].unsignedTx : txRequest.unsignedTxs[0];
            signablePayload = buffer_1.Buffer.from(unsignedTx.signableHex, 'hex');
            derivationPath = unsignedTx.derivationPath;
        }
        else if (requestType === baseTypes_1.RequestType.message) {
            signablePayload = params.bufferToSign;
            // TODO BG-67299 Message signing with derivation path
        }
        const paillierModulus = this.getOfflineSignerPaillierModulus({ prv: params.prv });
        const challenges = await this.getEcdsaSigningChallenges(txRequest.txRequestId, requestType, paillierModulus.userPaillierModulus, 0, params.reqId);
        const step1Return = await this.createTssEcdsaStep1SigningMaterial({
            prv: params.prv,
            challenges: challenges,
            derivationPath: derivationPath,
        });
        // signing stage one with K share send to bitgo and receives A share
        const bitgoToUserAShare = (await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequest.txRequestId, requestType, types_1.SendShareType.KShare, step1Return.kShare, step1Return.encryptedSignerOffsetShare, step1Return.vssProof, step1Return.privateShareProof, step1Return.publicShare, step1Return.userPublicGpgKey, params.reqId)); // WP/HSM does not return the initial challenge
        const step2Return = await this.createTssEcdsaStep2SigningMaterial({
            aShareFromBitgo: bitgoToUserAShare,
            bitgoChallenge: challenges.bitgoChallenge,
            wShare: step1Return.wShare,
        });
        // signing stage two with muShare and dShare send to bitgo and receives D share
        const bitgoToUserDShare = (await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequest.txRequestId, requestType, types_1.SendShareType.MUShare, step2Return.muDShare, undefined, undefined, undefined, undefined, undefined, params.reqId));
        // If only the getHashFunction() is defined for the coin use it otherwise
        // pass undefined hash, default hash will be used in that case.
        let hash;
        try {
            hash = this.baseCoin.getHashFunction();
        }
        catch (err) {
            hash = undefined;
        }
        const userSShare = await ecdsa_1.default.createUserSignatureShare(step2Return.oShare, bitgoToUserDShare, signablePayload, hash);
        // signing stage three with SShare send to bitgo and receives SShare
        await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequest.txRequestId, requestType, types_1.SendShareType.SShare, userSShare, undefined, undefined, undefined, undefined, undefined, params.reqId);
        return await (0, tss_2.getTxRequest)(this.bitgo, this.wallet.id(), txRequest.txRequestId, params.reqId);
    }
    /**
     * Signs the transaction associated to the transaction request.
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param {string} params.reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    async signTxRequest(params) {
        this.bitgo.setRequestTracer(params.reqId);
        return this.signRequestBase(params, baseTypes_1.RequestType.tx);
    }
    /**
     * Signs the message associated to the transaction request.
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param {string} params.reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    async signTxRequestForMessage(params) {
        if (!params.messageRaw) {
            throw new Error('Raw message required to sign message');
        }
        return this.signRequestBase(params, baseTypes_1.RequestType.message);
    }
    /**
     * Get the challenge values for enterprise and BitGo in ECDSA signing
     * Only returns the challenges if they are verified by the user's enterprise admin's ecdh key
     * @param {string} txRequestId - transaction request id
     * @param {RequestType} requestType -  (0 for tx, 1 for message)
     * @param {string} walletPaillierModulus - paillier pubkey $n$
     * @param {number} index - index of the requestType
     * @param {IRequestTracer} reqId - request tracer request id
     */
    async getEcdsaSigningChallenges(txRequestId, requestType, walletPaillierModulus, index = 0, reqId) {
        const enterpriseId = this.wallet.toJSON().enterprise;
        if (!enterpriseId) {
            throw new Error('Wallet must be an enterprise wallet.');
        }
        // create BitGo range proof and paillier proof challenge
        const createBitgoChallengeResponse = await (0, common_1.getTxRequestChallenge)(this.bitgo, this.wallet.id(), txRequestId, index.toString(), requestType, walletPaillierModulus, reqId);
        const bitgoToEnterprisePaillierChallenge = { p: createBitgoChallengeResponse.p };
        const enterpriseToBitgoPaillierChallenge = sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({
            p: await sdk_lib_mpc_1.EcdsaPaillierProof.generateP((0, sdk_lib_mpc_1.hexToBigInt)(createBitgoChallengeResponse.n)),
        });
        // TODO(BG-78764): once the paillier proofs are complete, reduce challenge creation to one API call
        const walletChallenges = await this.wallet.getChallengesForEcdsaSigning();
        const challengeVerifierUserId = walletChallenges.createdBy;
        const adminSigningKeyResponse = await this.bitgo.getSigningKeyForUser(enterpriseId, challengeVerifierUserId);
        const pubkeyOfAdminEcdhKeyHex = adminSigningKeyResponse.derivedPubkey;
        // Verify enterprise's challenge is signed by the respective admins ecdh keychain
        const enterpriseRawChallenge = {
            ntilde: walletChallenges.enterpriseChallenge.ntilde,
            h1: walletChallenges.enterpriseChallenge.h1,
            h2: walletChallenges.enterpriseChallenge.h2,
        };
        const adminSignatureOnEntChallenge = walletChallenges.enterpriseChallenge.verifiers.adminSignature;
        if (!(0, ecdh_1.verifyEcdhSignature)(EcdsaUtils.getMessageToSignFromChallenge(enterpriseRawChallenge), adminSignatureOnEntChallenge, buffer_1.Buffer.from(pubkeyOfAdminEcdhKeyHex, 'hex'))) {
            throw new Error(`Admin signature for enterprise challenge is not valid. Please contact your enterprise admin.`);
        }
        // Verify that the BitGo challenge's ZK proofs have been verified by the admin
        const bitgoChallenge = {
            ntilde: walletChallenges.bitgoChallenge.ntilde,
            h1: walletChallenges.bitgoChallenge.h1,
            h2: walletChallenges.bitgoChallenge.h2,
            p: bitgoToEnterprisePaillierChallenge.p,
            n: createBitgoChallengeResponse.n,
        };
        const adminVerificationSignatureForBitGoChallenge = walletChallenges.bitgoChallenge.verifiers.adminSignature;
        if (!(0, ecdh_1.verifyEcdhSignature)(EcdsaUtils.getMessageToSignFromChallenge(bitgoChallenge), adminVerificationSignatureForBitGoChallenge, buffer_1.Buffer.from(pubkeyOfAdminEcdhKeyHex, 'hex'))) {
            throw new Error(`Admin signature for BitGo's challenge is not valid. Please contact your enterprise admin.`);
        }
        return {
            enterpriseChallenge: {
                ...enterpriseRawChallenge,
                p: enterpriseToBitgoPaillierChallenge.p,
            },
            bitgoChallenge,
        };
    }
    /**
     * Verifies the u-value proofs and GPG keys used in generating a TSS ECDSA wallet.
     * @param userGpgPub The user's public GPG key for encryption between user/server
     * @param backupGpgPub The backup's public GPG key for encryption between backup/server
     * @param bitgoKeychain previously created BitGo keychain; must be compatible with user and backup key shares
     * @param decryptedShare The decrypted bitgo-to-user/backup private share retrieved from the keychain
     * @param verifierIndex The index of the party to verify: 1 = user, 2 = backup
     */
    async verifyWalletSignatures(userGpgPub, backupGpgPub, bitgoKeychain, decryptedShare, verifierIndex) {
        (0, assert_1.default)(bitgoKeychain.commonKeychain);
        (0, assert_1.default)(bitgoKeychain.walletHSMGPGPublicKeySigs);
        const bitgoGpgKey = (await (0, opengpgUtils_1.getBitgoGpgPubKey)(this.bitgo)).mpcV1;
        const userKeyPub = await openpgp.readKey({ armoredKey: userGpgPub });
        const userKeyId = userKeyPub.keyPacket.getFingerprint();
        const backupKeyPub = await openpgp.readKey({ armoredKey: backupGpgPub });
        const backupKeyId = backupKeyPub.keyPacket.getFingerprint();
        const walletSignatures = await openpgp.readKeys({ armoredKeys: bitgoKeychain.walletHSMGPGPublicKeySigs });
        if (walletSignatures.length !== 2) {
            throw new Error('Invalid wallet signatures');
        }
        if (userKeyId !== walletSignatures[0].keyPacket.getFingerprint()) {
            throw new Error(`first wallet signature's fingerprint does not match passed user gpg key's fingerprint`);
        }
        if (backupKeyId !== walletSignatures[1].keyPacket.getFingerprint()) {
            throw new Error(`second wallet signature's fingerprint does not match passed backup gpg key's fingerprint`);
        }
        await (0, ecdsa_2.verifyWalletSignature)({
            walletSignature: walletSignatures[0],
            commonKeychain: bitgoKeychain.commonKeychain,
            userKeyId,
            backupKeyId,
            bitgoPub: bitgoGpgKey,
            decryptedShare,
            verifierIndex,
        });
        await (0, ecdsa_2.verifyWalletSignature)({
            walletSignature: walletSignatures[1],
            commonKeychain: bitgoKeychain.commonKeychain,
            userKeyId,
            backupKeyId,
            bitgoPub: bitgoGpgKey,
            decryptedShare,
            verifierIndex,
        });
    }
    /**
     * Signs a challenge with the provided v1 ecdh key at a derived path
     * @param challenge challenge to sign
     * @param ecdhXprv xprv of the ecdh key
     * @param derivationPath the derived path at which the ecdh key will sign
     */
    static signChallenge(challenge, ecdhXprv, derivationPath) {
        const messageToSign = this.getMessageToSignFromChallenge(challenge);
        return (0, ecdh_1.signMessageWithDerivedEcdhKey)(messageToSign, ecdhXprv, derivationPath);
    }
    /**
     * Converts challenge to a common message format which can be signed.
     * @param challenge
     */
    static getMessageToSignFromChallenge(challenge) {
        return challenge.ntilde.concat(challenge.h1).concat(challenge.h2);
    }
    /**
     Verifies ZK proofs of BitGo's challenges for both nitro and institutional HSMs
     which are fetched from the WP API.
     */
    static async verifyBitGoChallenges(bitgoChallenges) {
        // Verify institutional hsm challenge proof
        const instChallengeVerified = await this.verifyBitGoChallenge({
            ntilde: bitgoChallenges.bitgoInstitutionalHsm.ntilde,
            h1: bitgoChallenges.bitgoInstitutionalHsm.h1,
            h2: bitgoChallenges.bitgoInstitutionalHsm.h2,
            ntildeProof: bitgoChallenges.bitgoInstitutionalHsm.ntildeProof,
        });
        // Verify nitro hsm challenge proof
        const nitroChallengeVerified = await this.verifyBitGoChallenge({
            ntilde: bitgoChallenges.bitgoNitroHsm.ntilde,
            h1: bitgoChallenges.bitgoNitroHsm.h1,
            h2: bitgoChallenges.bitgoNitroHsm.h2,
            ntildeProof: bitgoChallenges.bitgoNitroHsm.ntildeProof,
        });
        return instChallengeVerified && nitroChallengeVerified;
    }
    /**
     * Verifies ZK proof for a single BitGo challenge
     * @param bitgoChallenge
     */
    static async verifyBitGoChallenge(bitgoChallenge) {
        const deserializedInstChallenge = sdk_lib_mpc_1.EcdsaTypes.deserializeNtildeWithProofs(bitgoChallenge);
        const ntildeProofH1WrtH2Verified = await sdk_lib_mpc_1.EcdsaRangeProof.verifyNtildeProof({
            ntilde: deserializedInstChallenge.ntilde,
            h1: deserializedInstChallenge.h1,
            h2: deserializedInstChallenge.h2,
        }, deserializedInstChallenge.ntildeProof.h1WrtH2);
        const ntildeProofH2WrtH1Verified = await sdk_lib_mpc_1.EcdsaRangeProof.verifyNtildeProof({
            ntilde: deserializedInstChallenge.ntilde,
            h1: deserializedInstChallenge.h2,
            h2: deserializedInstChallenge.h1,
        }, deserializedInstChallenge.ntildeProof.h2WrtH1);
        return ntildeProofH1WrtH2Verified && ntildeProofH2WrtH1Verified;
    }
    /**
     * Gets the bitgo challenges for both nitro and institutional HSMs from WP API.
     * @param bitgo
     */
    static async getBitGoChallenges(bitgo) {
        const res = await bitgo.get(bitgo.url('/tss/ecdsa/challenges', 2)).send().result();
        if (!res.bitgoNitroHsm ||
            !res.bitgoNitroHsm.ntilde ||
            !res.bitgoNitroHsm.h1 ||
            !res.bitgoNitroHsm.h2 ||
            !res.bitgoNitroHsm.ntildeProof ||
            !res.bitgoInstitutionalHsm ||
            !res.bitgoInstitutionalHsm.ntilde ||
            !res.bitgoInstitutionalHsm.h1 ||
            !res.bitgoInstitutionalHsm.h2 ||
            !res.bitgoInstitutionalHsm.ntildeProof) {
            throw new Error('Expected BitGo challenge proof to be present. Contact support@bitgo.com.');
        }
        return res;
    }
    /**
     * Gets BitGo's proofs from API and signs them if the proofs are valid.
     * @param bitgo
     * @param enterpriseId
     * @param userPassword
     */
    static async getVerifyAndSignBitGoChallenges(bitgo, enterpriseId, userPassword) {
        // Fetch BitGo's challenge and verify
        const bitgoChallengesWithProofs = await EcdsaUtils.getBitGoChallenges(bitgo);
        if (!(await EcdsaUtils.verifyBitGoChallenges(bitgoChallengesWithProofs))) {
            throw new Error(`Failed to verify BitGo's challenge needed to enable ECDSA signing. Please contact support@bitgo.com`);
        }
        return await EcdsaUtils.signBitgoChallenges(bitgo, enterpriseId, userPassword, bitgoChallengesWithProofs);
    }
    /**
     * Sign Bitgo's proofs, verification of proofs is left to the caller
     * @param bitgo
     * @param enterpriseId
     * @param userPassword
     * @param bitgoChallengesWithProofs Optionally provide Bitgo Challaenge & Proofs instead of fetching from API
     */
    static async signBitgoChallenges(bitgo, enterpriseId, userPassword, bitgoChallengesWithProofs) {
        // fetch challenge & proof if none are provided
        const challengesWithProofs = bitgoChallengesWithProofs
            ? bitgoChallengesWithProofs
            : await EcdsaUtils.getBitGoChallenges(bitgo);
        // Fetch user's ecdh public keychain needed for signing the challenges
        const ecdhKeypair = await bitgo.getEcdhKeypairPrivate(userPassword, enterpriseId);
        const signedBitGoInstChallenge = EcdsaUtils.signChallenge(challengesWithProofs.bitgoInstitutionalHsm, ecdhKeypair.xprv, ecdhKeypair.derivationPath);
        const signedBitGoNitroChallenge = EcdsaUtils.signChallenge(challengesWithProofs.bitgoNitroHsm, ecdhKeypair.xprv, ecdhKeypair.derivationPath);
        return {
            bitgoInstHsmAdminSignature: signedBitGoInstChallenge,
            bitgoNitroHsmAdminSignature: signedBitGoNitroChallenge,
        };
    }
    /**
     * This is needed to enable ecdsa signing on the enterprise.
     * It receives the enterprise challenge and signatures of verified bitgo proofs
     * and uploads them on the enterprise.
     * @param bitgo
     * @param entId - enterprise id to enable ecdsa signing on
     * @param userPassword - enterprise admin's login pw
     * @param bitgoInstChallengeProofSignature - signature on bitgo's institutional HSM challenge after verification
     * @param bitgoNitroChallengeProofSignature - signature on bitgo's nitro HSM challenge after verification
     * @param challenge - optionally use the challenge for enterprise challenge
     */
    static async initiateChallengesForEnterprise(bitgo, entId, userPassword, bitgoInstChallengeProofSignature, bitgoNitroChallengeProofSignature, openSSLBytes, challenge) {
        // Fetch user's ecdh public keychain needed for signing the challenges
        const ecdhKeypair = await bitgo.getEcdhKeypairPrivate(userPassword, entId);
        // Generate and sign enterprise challenge
        const entChallengeWithProof = challenge !== null && challenge !== void 0 ? challenge : (await sdk_lib_mpc_1.EcdsaRangeProof.generateNtilde(openSSLBytes, sdk_lib_mpc_1.minModulusBitLength));
        const serializedEntChallengeWithProof = sdk_lib_mpc_1.EcdsaTypes.serializeNtildeWithProofs(entChallengeWithProof);
        const signedEnterpriseChallenge = EcdsaUtils.signChallenge(serializedEntChallengeWithProof, ecdhKeypair.xprv, ecdhKeypair.derivationPath);
        await this.uploadChallengesToEnterprise(bitgo, entId, serializedEntChallengeWithProof, signedEnterpriseChallenge.toString('hex'), bitgoInstChallengeProofSignature.toString('hex'), bitgoNitroChallengeProofSignature.toString('hex'));
    }
    /**
     * Uploads the signed challenges and their proofs on the enterprise.
     * This initiates ecdsa signing for the enterprise users.
     * @param bitgo
     * @param entId - enterprise to enable ecdsa signing on
     * @param entChallenge - client side generated ent challenge with ZK proofs
     * @param entChallengeSignature - signature on enterprise challenge
     * @param bitgoIntChallengeSignature - signature on BitGo's institutional HSM challenge
     * @param bitgoNitroChallengeSignature - signature on BitGo's nitro HSM challenge
     */
    static async uploadChallengesToEnterprise(bitgo, entId, entChallenge, entChallengeSignature, bitgoIntChallengeSignature, bitgoNitroChallengeSignature) {
        const body = {
            enterprise: {
                ntilde: entChallenge.ntilde,
                h1: entChallenge.h1,
                h2: entChallenge.h2,
                verifiers: {
                    adminSignature: entChallengeSignature,
                },
            },
            bitgoInstitutionalHsm: {
                verifiers: {
                    adminSignature: bitgoIntChallengeSignature,
                },
            },
            bitgoNitroHsm: {
                verifiers: {
                    adminSignature: bitgoNitroChallengeSignature,
                },
            },
        };
        if ('ntildeProof' in entChallenge) {
            body.enterprise['ntildeProof'] = entChallenge.ntildeProof;
        }
        await bitgo
            .put(bitgo.url(`/enterprise/${entId}/tssconfig/ecdsa/challenge`, 2))
            .send(body)
            .result();
    }
}
exports.EcdsaUtils = EcdsaUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNkc2EuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvYml0Z28vdXRpbHMvdHNzL2VjZHNhL2VjZHNhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0RBQTRCO0FBQzVCLG1DQUFnQztBQUNoQyxpREFBbUM7QUFHbkMsb0RBQXVIO0FBQ3ZILDhDQUF3QztBQUV4Qyx5REFBK0Q7QUFFL0QsK0RBQW9FO0FBVXBFLDRDQWFzQjtBQUN0QixzQ0FBNEM7QUFDNUMsb0RBQWtIO0FBQ2xILHFEQUE2RjtBQUc3RixvREFBc0g7QUFDdEgsd0NBQW1GO0FBQ25GLGdEQUE0RDtBQUM1RCw4Q0FLNEI7QUFDNUIsaUNBQXdDO0FBR3hDLE1BQU0sYUFBYSxHQUFHLGVBQVksQ0FBQyxhQUFhLENBQUM7QUFFakQsa0JBQWtCO0FBQ2xCLE1BQWEsVUFBVyxTQUFRLHFCQUFjO0lBQzVDLEtBQUssQ0FBQywrQkFBK0IsQ0FDbkMsS0FBYSxFQUNiLGNBQXNCLEVBQ3RCLFlBQXNCLEVBQ3RCLGFBQXVCLEVBQ3ZCLFVBQXFDLEVBQ3JDLDRCQUFpQzs7UUFFakMsTUFBTSwwQkFBMEIsR0FBRyxNQUFNLGFBQWEsQ0FDcEQsWUFBWSxFQUNaLENBQUMsRUFDRCw0QkFBNEIsQ0FBQyxLQUFLLEVBQUUsRUFDcEMsVUFBVSxDQUNYLENBQUM7UUFDRixNQUFNLHFCQUFxQixHQUFHLE1BQUEsYUFBYSxDQUFDLFNBQVMsMENBQUUsSUFBSSxDQUN6RCxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxPQUFPLElBQUksUUFBUSxDQUFDLEVBQUUsS0FBSyxRQUFRLENBQ3BFLENBQUM7UUFDRixNQUFNLGVBQWUsR0FBRyxlQUFNLENBQUMsTUFBTSxDQUFDO1lBQ3BDLGVBQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FB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RUFBRTtnQkFDbkIsU0FBUyxFQUFFO29CQUNULGNBQWMsRUFBRSxxQkFBcUI7aUJBQ3RDO2FBQ0Y7WUFDRCxxQkFBcUIsRUFBRTtnQkFDckIsU0FBUyxFQUFFO29CQUNULGNBQWMsRUFBRSwwQkFBMEI7aUJBQzNDO2FBQ0Y7WUFDRCxhQUFhLEVBQUU7Z0JBQ2IsU0FBUyxFQUFFO29CQUNULGNBQWMsRUFBRSw0QkFBNEI7aUJBQzdDO2FBQ0Y7U0FDRixDQUFDO1FBQ0YsSUFBSSxhQUFhLElBQUksWUFBWSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQztTQUMzRDtRQUNELE1BQU0sS0FBSzthQUNSLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGVBQWUsS0FBSyw0QkFBNEIsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUNuRSxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsTUFBTSxFQUFFLENBQUM7SUFDZCxDQUFDO0NBQ0Y7QUF6MENELGdDQXkwQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0ICogYXMgb3BlbnBncCBmcm9tICdvcGVucGdwJztcbmltcG9ydCB7IEtleSwgU2VyaWFsaXplZEtleVBhaXIgfSBmcm9tICdvcGVucGdwJztcbmltcG9ydCB7IEhhc2ggfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgRWNkc2FQYWlsbGllclByb29mLCBFY2RzYVJhbmdlUHJvb2YsIEVjZHNhVHlwZXMsIGhleFRvQmlnSW50LCBtaW5Nb2R1bHVzQml0TGVuZ3RoIH0gZnJvbSAnQGJpdGdvL3Nkay1saWItbXBjJztcbmltcG9ydCB7IGJpcDMyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcblxuaW1wb3J0IHsgRUNEU0EsIEVjZHNhIH0gZnJvbSAnLi4vLi4vLi4vLi4vYWNjb3VudC1saWIvbXBjL3Rzcyc7XG5pbXBvcnQgeyBBZGRLZXljaGFpbk9wdGlvbnMsIEFwaUtleVNoYXJlLCBDcmVhdGVCYWNrdXBPcHRpb25zLCBLZXljaGFpbiwgS2V5VHlwZSB9IGZyb20gJy4uLy4uLy4uL2tleWNoYWluJztcbmltcG9ydCBFQ0RTQU1ldGhvZHMsIHsgRUNEU0FNZXRob2RUeXBlcyB9IGZyb20gJy4uLy4uLy4uL3Rzcy9lY2RzYSc7XG5pbXBvcnQgeyBLZXljaGFpbnNUcmlwbGV0IH0gZnJvbSAnLi4vLi4vLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHtcbiAgQml0R29Qcm9vZlNpZ25hdHVyZXMsXG4gIENyZWF0ZUVjZHNhQml0R29LZXljaGFpblBhcmFtcyxcbiAgQ3JlYXRlRWNkc2FLZXljaGFpblBhcmFtcyxcbiAgRGVjcnlwdGFibGVOU2hhcmUsXG4gIEdldEJpdEdvQ2hhbGxlbmdlc0FwaSxcbiAgS2V5U2hhcmUsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgQmFja3VwS2V5U2hhcmUsXG4gIEJpdGdvSGVsZEJhY2t1cEtleVNoYXJlLFxuICBDdXN0b21LU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIEN1c3RvbU11RGVsdGFTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgQ3VzdG9tUGFpbGxpZXJNb2R1bHVzR2V0dGVyRnVuY3Rpb24sXG4gIEN1c3RvbVNTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgUmVxdWVzdFR5cGUsXG4gIFRTU1BhcmFtcyxcbiAgVFNTUGFyYW1zRm9yTWVzc2FnZSxcbiAgVFNTUGFyYW1zRm9yTWVzc2FnZVdpdGhQcnYsXG4gIFRTU1BhcmFtc1dpdGhQcnYsXG4gIFR4UmVxdWVzdCxcbn0gZnJvbSAnLi4vYmFzZVR5cGVzJztcbmltcG9ydCB7IGdldFR4UmVxdWVzdCB9IGZyb20gJy4uLy4uLy4uL3Rzcyc7XG5pbXBvcnQgeyBBU2hhcmUsIERTaGFyZSwgRW5jcnlwdGVkTlNoYXJlLCBTZW5kU2hhcmVUeXBlLCBTU2hhcmUsIFdTaGFyZSwgT1NoYXJlIH0gZnJvbSAnLi4vLi4vLi4vdHNzL2VjZHNhL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZVNoYXJlUHJvb2YsIGdlbmVyYXRlR1BHS2V5UGFpciwgZ2V0Qml0Z29HcGdQdWJLZXkgfSBmcm9tICcuLi8uLi9vcGVuZ3BnVXRpbHMnO1xuaW1wb3J0IHsgQml0R29CYXNlIH0gZnJvbSAnLi4vLi4vLi4vYml0Z29CYXNlJztcbmltcG9ydCB7IEJhY2t1cFByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vLi4vd2FsbGV0JztcbmltcG9ydCB7IGJ1aWxkTlNoYXJlRnJvbUFQSUtleVNoYXJlLCBnZXRQYXJ0aWNpcGFudEZyb21JbmRleCwgdmVyaWZ5V2FsbGV0U2lnbmF0dXJlIH0gZnJvbSAnLi4vLi4vLi4vdHNzL2VjZHNhL2VjZHNhJztcbmltcG9ydCB7IHNpZ25NZXNzYWdlV2l0aERlcml2ZWRFY2RoS2V5LCB2ZXJpZnlFY2RoU2lnbmF0dXJlIH0gZnJvbSAnLi4vLi4vLi4vZWNkaCc7XG5pbXBvcnQgeyBnZXRUeFJlcXVlc3RDaGFsbGVuZ2UgfSBmcm9tICcuLi8uLi8uLi90c3MvY29tbW9uJztcbmltcG9ydCB7XG4gIFNoYXJlS2V5UG9zaXRpb24sXG4gIFRzc0VjZHNhU3RlcDFSZXR1cm5NZXNzYWdlLFxuICBUc3NFY2RzYVN0ZXAyUmV0dXJuTWVzc2FnZSxcbiAgVHhSZXF1ZXN0Q2hhbGxlbmdlUmVzcG9uc2UsXG59IGZyb20gJy4uLy4uLy4uL3Rzcy90eXBlcyc7XG5pbXBvcnQgeyBCYXNlRWNkc2FVdGlscyB9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBJUmVxdWVzdFRyYWNlciB9IGZyb20gJy4uLy4uLy4uLy4uL2FwaSc7XG5cbmNvbnN0IGVuY3J5cHROU2hhcmUgPSBFQ0RTQU1ldGhvZHMuZW5jcnlwdE5TaGFyZTtcblxuLyoqIEBpbmhlcml0ZG9jICovXG5leHBvcnQgY2xhc3MgRWNkc2FVdGlscyBleHRlbmRzIEJhc2VFY2RzYVV0aWxzIHtcbiAgYXN5bmMgZmluYWxpemVCaXRnb0hlbGRCYWNrdXBLZXlTaGFyZShcbiAgICBrZXlJZDogc3RyaW5nLFxuICAgIGNvbW1vbktleWNoYWluOiBzdHJpbmcsXG4gICAgdXNlcktleVNoYXJlOiBLZXlTaGFyZSxcbiAgICBiaXRnb0tleWNoYWluOiBLZXljaGFpbixcbiAgICB1c2VyR3BnS2V5OiBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+LFxuICAgIHRoaXJkUGFydHlCYWNrdXBQdWJsaWNHcGdLZXk6IEtleVxuICApOiBQcm9taXNlPEJpdGdvSGVsZEJhY2t1cEtleVNoYXJlPiB7XG4gICAgY29uc3QgZW5jcnlwdGVkVXNlclRvQmFja3VwU2hhcmUgPSBhd2FpdCBlbmNyeXB0TlNoYXJlKFxuICAgICAgdXNlcktleVNoYXJlLFxuICAgICAgMixcbiAgICAgIHRoaXJkUGFydHlCYWNrdXBQdWJsaWNHcGdLZXkuYXJtb3IoKSxcbiAgICAgIHVzZXJHcGdLZXlcbiAgICApO1xuICAgIGNvbnN0IGJpdGdvVG9CYWNrdXBLZXlTaGFyZSA9IGJpdGdvS2V5Y2hhaW4ua2V5U2hhcmVzPy5maW5kKFxuICAgICAgKGtleVNoYXJlKSA9PiBrZXlTaGFyZS5mcm9tID09PSAnYml0Z28nICYmIGtleVNoYXJlLnRvID09PSAnYmFja3VwJ1xuICAgICk7XG4gICAgY29uc3QgdXNlclB1YmxpY1NoYXJlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbSh1c2VyS2V5U2hhcmUublNoYXJlc1syXS55LCAnaGV4JyksXG4gICAgICBCdWZmZXIuZnJvbSh1c2VyS2V5U2hhcmUublNoYXJlc1syXS5jaGFpbmNvZGUsICdoZXgnKSxcbiAgICBdKS50b1N0cmluZygnaGV4Jyk7XG4gICAgYXNzZXJ0KGJpdGdvVG9CYWNrdXBLZXlTaGFyZSk7XG4gICAgY29uc3Qga2V5UmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAucHV0KHRoaXMuYmFzZUNvaW4udXJsKGAva3JzL2JhY2t1cGtleXMvJHtrZXlJZH1gKSlcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgY29tbW9uS2V5Y2hhaW4sXG4gICAgICAgIGtleVNoYXJlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZyb206ICd1c2VyJyxcbiAgICAgICAgICAgIHRvOiAnYmFja3VwJyxcbiAgICAgICAgICAgIHB1YmxpY1NoYXJlOiB1c2VyUHVibGljU2hhcmUsXG4gICAgICAgICAgICBwcml2YXRlU2hhcmU6IGVuY3J5cHRlZFVzZXJUb0JhY2t1cFNoYXJlLmVuY3J5cHRlZFByaXZhdGVTaGFyZSxcbiAgICAgICAgICAgIHByaXZhdGVTaGFyZVByb29mOiBlbmNyeXB0ZWRVc2VyVG9CYWNrdXBTaGFyZS5wcml2YXRlU2hhcmVQcm9vZixcbiAgICAgICAgICAgIHZzc1Byb29mOiBlbmNyeXB0ZWRVc2VyVG9CYWNrdXBTaGFyZS52c3NQcm9vZixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJpdGdvVG9CYWNrdXBLZXlTaGFyZSxcbiAgICAgICAgXSxcbiAgICAgIH0pXG4gICAgICAucmVzdWx0KCk7XG4gICAgaWYgKCFrZXlSZXNwb25zZSB8fCAha2V5UmVzcG9uc2UuY29tbW9uS2V5Y2hhaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIGJhY2t1cCBrZXkgdmVyaWZpY2F0aW9uLicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGtleVJlc3BvbnNlLmlkLFxuICAgICAga2V5U2hhcmVzOiBrZXlSZXNwb25zZS5rZXlTaGFyZXMsXG4gICAgICBjb21tb25LZXljaGFpbjoga2V5UmVzcG9uc2UuY29tbW9uS2V5Y2hhaW4sXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBhc3luYyBjcmVhdGVLZXljaGFpbnMocGFyYW1zOiB7XG4gICAgcGFzc3BocmFzZTogc3RyaW5nO1xuICAgIGVudGVycHJpc2U/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGJhY2t1cFByb3ZpZGVyPzogQmFja3VwUHJvdmlkZXI7XG4gIH0pOiBQcm9taXNlPEtleWNoYWluc1RyaXBsZXQ+IHtcbiAgICBjb25zdCBNUEMgPSBuZXcgRWNkc2EoKTtcbiAgICBjb25zdCBtID0gMjtcbiAgICBjb25zdCBuID0gMztcblxuICAgIGNvbnN0IHVzZXJLZXlTaGFyZSA9IGF3YWl0IE1QQy5rZXlTaGFyZSgxLCBtLCBuKTtcbiAgICBjb25zdCB1c2VyR3BnS2V5ID0gYXdhaXQgZ2VuZXJhdGVHUEdLZXlQYWlyKCdzZWNwMjU2azEnKTtcbiAgICBjb25zdCBpc1RoaXJkUGFydHlCYWNrdXAgPSB0aGlzLmlzVmFsaWRUaGlyZFBhcnR5QmFja3VwUHJvdmlkZXIocGFyYW1zLmJhY2t1cFByb3ZpZGVyKTtcbiAgICBjb25zdCBiYWNrdXBLZXlTaGFyZSA9IGF3YWl0IHRoaXMuY3JlYXRlQmFja3VwS2V5U2hhcmVzKGlzVGhpcmRQYXJ0eUJhY2t1cCwgdXNlckdwZ0tleSwgcGFyYW1zLmVudGVycHJpc2UpO1xuICAgIGNvbnN0IGJhY2t1cEdwZ0tleSA9IGF3YWl0IHRoaXMuZ2V0QmFja3VwR3BnUHViS2V5KGlzVGhpcmRQYXJ0eUJhY2t1cCk7XG5cbiAgICAvLyBHZXQgdGhlIEJpdEdvIHB1YmxpYyBrZXkgYmFzZWQgb24gdXNlci9lbnRlcnByaXNlIGZlYXR1cmUgZmxhZ3NcbiAgICAvLyBJZiBpdCBkb2Vzbid0IHdvcmssIHVzZSB0aGUgZGVmYXVsdCBwdWJsaWMga2V5IGZyb20gdGhlIGNvbnN0YW50c1xuICAgIGNvbnN0IGJpdGdvUHVibGljR3BnS2V5ID1cbiAgICAgIChhd2FpdCB0aGlzLmdldEJpdGdvR3BnUHVia2V5QmFzZWRPbkZlYXR1cmVGbGFncyhwYXJhbXMuZW50ZXJwcmlzZSkpID8/IHRoaXMuYml0Z29QdWJsaWNHcGdLZXk7XG5cbiAgICBjb25zdCBiaXRnb0tleWNoYWluID0gYXdhaXQgdGhpcy5jcmVhdGVCaXRnb0tleWNoYWluKHtcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgICBiYWNrdXBHcGdLZXksXG4gICAgICBiaXRnb1B1YmxpY0dwZ0tleSxcbiAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgIGJhY2t1cEtleVNoYXJlLFxuICAgICAgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsXG4gICAgICBpc1RoaXJkUGFydHlCYWNrdXAsXG4gICAgfSk7XG4gICAgY29uc3QgdXNlcktleWNoYWluUHJvbWlzZSA9IHRoaXMuY3JlYXRlVXNlcktleWNoYWluKHtcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgICBiYWNrdXBHcGdLZXksXG4gICAgICBiaXRnb1B1YmxpY0dwZ0tleSxcbiAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgIGJhY2t1cEtleVNoYXJlLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgIHBhc3NwaHJhc2U6IHBhcmFtcy5wYXNzcGhyYXNlLFxuICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlOiBwYXJhbXMub3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgaXNUaGlyZFBhcnR5QmFja3VwLFxuICAgIH0pO1xuICAgIGNvbnN0IGJhY2t1cEtleWNoYWluUHJvbWlzZSA9IHRoaXMuY3JlYXRlQmFja3VwS2V5Y2hhaW4oe1xuICAgICAgdXNlckdwZ0tleSxcbiAgICAgIGJhY2t1cEdwZ0tleSxcbiAgICAgIGJpdGdvUHVibGljR3BnS2V5LFxuICAgICAgdXNlcktleVNoYXJlLFxuICAgICAgYmFja3VwS2V5U2hhcmUsXG4gICAgICBiaXRnb0tleWNoYWluLFxuICAgICAgcGFzc3BocmFzZTogcGFyYW1zLnBhc3NwaHJhc2UsXG4gICAgICBiYWNrdXBQcm92aWRlcjogcGFyYW1zLmJhY2t1cFByb3ZpZGVyLFxuICAgIH0pO1xuXG4gICAgY29uc3QgW3VzZXJLZXljaGFpbiwgYmFja3VwS2V5Y2hhaW5dID0gYXdhaXQgUHJvbWlzZS5hbGwoW3VzZXJLZXljaGFpblByb21pc2UsIGJhY2t1cEtleWNoYWluUHJvbWlzZV0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGEgdGhpcmQgcGFydHkgYmFja3VwIGlzIHJlcXVlc3RlZCwgaXQgd2lsbCBjcmVhdGUgYmFja3VwIHNoYXJlcyBmcm9tXG4gICAqIGEgdGhpcmQgcGFydHkgKEJpdEdvIGFzIG9mIG5vdyksIG90aGVyd2lzZSB0aGUga2V5IHNoYXJlcyB3aWxsIGJlIGNsaWVudCBnZW5lcmF0ZWRcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJhY2t1cEtleVNoYXJlcyhcbiAgICBpc1RoaXJkUGFydHlCYWNrdXAgPSBmYWxzZSxcbiAgICB1c2VyR3BnUHViS2V5OiBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+LFxuICAgIGVudGVycHJpc2U6IHN0cmluZyB8IHVuZGVmaW5lZFxuICApOiBQcm9taXNlPEJhY2t1cEtleVNoYXJlPiB7XG4gICAgbGV0IGJhY2t1cEtleVNoYXJlOiBCYWNrdXBLZXlTaGFyZTtcbiAgICBpZiAoaXNUaGlyZFBhcnR5QmFja3VwKSB7XG4gICAgICBjb25zdCBiaXRnb0hlbGRCYWNrdXBLZXlTaGFyZXMgPSBhd2FpdCB0aGlzLmNyZWF0ZUJpdGdvSGVsZEJhY2t1cEtleVNoYXJlKHVzZXJHcGdQdWJLZXksIGVudGVycHJpc2UpO1xuICAgICAgYmFja3VwS2V5U2hhcmUgPSB7XG4gICAgICAgIGJpdEdvSGVsZEtleVNoYXJlczogYml0Z29IZWxkQmFja3VwS2V5U2hhcmVzLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG4gICAgICBjb25zdCBtID0gMjtcbiAgICAgIGNvbnN0IG4gPSAzO1xuICAgICAgYmFja3VwS2V5U2hhcmUgPSB7XG4gICAgICAgIHVzZXJIZWxkS2V5U2hhcmU6IGF3YWl0IE1QQy5rZXlTaGFyZSgyLCBtLCBuKSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBiYWNrdXBLZXlTaGFyZTtcbiAgfVxuXG4gIGNyZWF0ZVVzZXJLZXljaGFpbih7XG4gICAgdXNlckdwZ0tleSxcbiAgICBiYWNrdXBHcGdLZXksXG4gICAgYml0Z29QdWJsaWNHcGdLZXksXG4gICAgdXNlcktleVNoYXJlLFxuICAgIGJhY2t1cEtleVNoYXJlLFxuICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgcGFzc3BocmFzZSxcbiAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgaXNUaGlyZFBhcnR5QmFja3VwID0gZmFsc2UsXG4gIH06IENyZWF0ZUVjZHNhS2V5Y2hhaW5QYXJhbXMpOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgaWYgKCFwYXNzcGhyYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICB9XG4gICAgaWYgKGlzVGhpcmRQYXJ0eUJhY2t1cCAmJiBiYWNrdXBLZXlTaGFyZS5iaXRHb0hlbGRLZXlTaGFyZXM/LmtleVNoYXJlcykge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXNlcktleWNoYWluRnJvbVRoaXJkUGFydHlCYWNrdXAoXG4gICAgICAgIHVzZXJHcGdLZXksXG4gICAgICAgIGJpdGdvUHVibGljR3BnS2V5LFxuICAgICAgICBiYWNrdXBHcGdLZXkgYXMgS2V5LFxuICAgICAgICB1c2VyS2V5U2hhcmUsXG4gICAgICAgIGJhY2t1cEtleVNoYXJlLmJpdEdvSGVsZEtleVNoYXJlcy5rZXlTaGFyZXMsXG4gICAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICAgIHBhc3NwaHJhc2UsXG4gICAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZVxuICAgICAgKTtcbiAgICB9XG4gICAgYXNzZXJ0KGJhY2t1cEtleVNoYXJlLnVzZXJIZWxkS2V5U2hhcmUpO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcnRpY2lwYW50S2V5Y2hhaW4oXG4gICAgICB1c2VyR3BnS2V5LFxuICAgICAgYmFja3VwR3BnS2V5IGFzIFNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz4sXG4gICAgICBiaXRnb1B1YmxpY0dwZ0tleSxcbiAgICAgIDEsXG4gICAgICB1c2VyS2V5U2hhcmUsXG4gICAgICBiYWNrdXBLZXlTaGFyZS51c2VySGVsZEtleVNoYXJlLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgIHBhc3NwaHJhc2UsXG4gICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGVcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQmFja3VwS2V5Y2hhaW4oe1xuICAgIHVzZXJHcGdLZXksXG4gICAgdXNlcktleVNoYXJlLFxuICAgIGJhY2t1cEdwZ0tleSxcbiAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICBiaXRnb0tleWNoYWluLFxuICAgIGJpdGdvUHVibGljR3BnS2V5LFxuICAgIHBhc3NwaHJhc2UsXG4gICAgYmFja3VwUHJvdmlkZXIsXG4gIH06IENyZWF0ZUVjZHNhS2V5Y2hhaW5QYXJhbXMpOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZFRoaXJkUGFydHlCYWNrdXBQcm92aWRlcihiYWNrdXBQcm92aWRlcikgJiYgYmFja3VwS2V5U2hhcmUuYml0R29IZWxkS2V5U2hhcmVzPy5rZXlTaGFyZXMpIHtcbiAgICAgIGFzc2VydChiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluKTtcbiAgICAgIGNvbnN0IGZpbmFsaXplZEJhY2t1cEtleVNoYXJlID0gYXdhaXQgdGhpcy5maW5hbGl6ZUJpdGdvSGVsZEJhY2t1cEtleVNoYXJlKFxuICAgICAgICBiYWNrdXBLZXlTaGFyZS5iaXRHb0hlbGRLZXlTaGFyZXMuaWQsXG4gICAgICAgIGJpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4sXG4gICAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgICAgdXNlckdwZ0tleSxcbiAgICAgICAgYmFja3VwR3BnS2V5IGFzIEtleVxuICAgICAgKTtcbiAgICAgIGlmIChmaW5hbGl6ZWRCYWNrdXBLZXlTaGFyZS5jb21tb25LZXljaGFpbiAhPT0gYml0Z29LZXljaGFpbi5jb21tb25LZXljaGFpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYmFja3VwIGtleWNoYWluIC0gY29tbW9uS2V5Y2hhaW5zIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFja3VwS2V5UGFyYW1zOiBDcmVhdGVCYWNrdXBPcHRpb25zID0ge1xuICAgICAgICBzb3VyY2U6ICdiYWNrdXAnLFxuICAgICAgICBrZXlUeXBlOiAndHNzJyxcbiAgICAgICAgY29tbW9uS2V5Y2hhaW46IGZpbmFsaXplZEJhY2t1cEtleVNoYXJlLmNvbW1vbktleWNoYWluLFxuICAgICAgICBwcm92aWRlcjogYmFja3VwUHJvdmlkZXIgPz8gJ0JpdEdvVHJ1c3RBc0tycycsXG4gICAgICB9O1xuICAgICAgY29uc3QgYmFja3VwS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZUJhY2t1cChiYWNrdXBLZXlQYXJhbXMpO1xuICAgICAgYmFja3VwS2V5Y2hhaW4ua2V5U2hhcmVzID0gZmluYWxpemVkQmFja3VwS2V5U2hhcmUua2V5U2hhcmVzO1xuICAgICAgcmV0dXJuIGJhY2t1cEtleWNoYWluO1xuICAgIH1cbiAgICBhc3NlcnQoYmFja3VwS2V5U2hhcmUudXNlckhlbGRLZXlTaGFyZSk7XG4gICAgYXNzZXJ0KHBhc3NwaHJhc2UpO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcnRpY2lwYW50S2V5Y2hhaW4oXG4gICAgICB1c2VyR3BnS2V5LFxuICAgICAgYmFja3VwR3BnS2V5IGFzIFNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz4sXG4gICAgICBiaXRnb1B1YmxpY0dwZ0tleSxcbiAgICAgIDIsXG4gICAgICB1c2VyS2V5U2hhcmUsXG4gICAgICBiYWNrdXBLZXlTaGFyZS51c2VySGVsZEtleVNoYXJlLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgIHBhc3NwaHJhc2VcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGFzeW5jIGNyZWF0ZUJpdGdvS2V5Y2hhaW4oe1xuICAgIHVzZXJHcGdLZXksXG4gICAgYmFja3VwR3BnS2V5LFxuICAgIHVzZXJLZXlTaGFyZSxcbiAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICBlbnRlcnByaXNlLFxuICAgIGJpdGdvUHVibGljR3BnS2V5LFxuICAgIGlzVGhpcmRQYXJ0eUJhY2t1cCA9IGZhbHNlLFxuICB9OiBDcmVhdGVFY2RzYUJpdEdvS2V5Y2hhaW5QYXJhbXMpOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgY29uc3QgcmVjaXBpZW50SW5kZXggPSAzO1xuICAgIGNvbnN0IHVzZXJUb0JpdGdvU2hhcmUgPSBhd2FpdCBlbmNyeXB0TlNoYXJlKHVzZXJLZXlTaGFyZSwgcmVjaXBpZW50SW5kZXgsIGJpdGdvUHVibGljR3BnS2V5LmFybW9yKCksIHVzZXJHcGdLZXkpO1xuXG4gICAgY29uc3QgYmFja3VwVG9CaXRnb1NoYXJlID0gYXdhaXQgdGhpcy5nZXRCYWNrdXBFbmNyeXB0ZWROU2hhcmUoXG4gICAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICAgIHJlY2lwaWVudEluZGV4LFxuICAgICAgYml0Z29QdWJsaWNHcGdLZXkuYXJtb3IoKSxcbiAgICAgIGJhY2t1cEdwZ0tleSBhcyBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+LFxuICAgICAgaXNUaGlyZFBhcnR5QmFja3VwXG4gICAgKTtcblxuICAgIGNvbnN0IGNyZWF0ZUJpdEdvTVBDUGFyYW1zOiBBZGRLZXljaGFpbk9wdGlvbnMgPSB7XG4gICAgICBrZXlUeXBlOiAndHNzJyBhcyBLZXlUeXBlLFxuICAgICAgc291cmNlOiAnYml0Z28nLFxuICAgICAga2V5U2hhcmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBmcm9tOiAndXNlcicsXG4gICAgICAgICAgdG86ICdiaXRnbycsXG4gICAgICAgICAgcHVibGljU2hhcmU6IHVzZXJUb0JpdGdvU2hhcmUucHVibGljU2hhcmUsXG4gICAgICAgICAgcHJpdmF0ZVNoYXJlOiB1c2VyVG9CaXRnb1NoYXJlLmVuY3J5cHRlZFByaXZhdGVTaGFyZSxcbiAgICAgICAgICBuOiB1c2VyVG9CaXRnb1NoYXJlLm4sXG4gICAgICAgICAgdnNzUHJvb2Y6IHVzZXJUb0JpdGdvU2hhcmUudnNzUHJvb2YsXG4gICAgICAgICAgcHJpdmF0ZVNoYXJlUHJvb2Y6IHVzZXJUb0JpdGdvU2hhcmUucHJpdmF0ZVNoYXJlUHJvb2YsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBmcm9tOiAnYmFja3VwJyxcbiAgICAgICAgICB0bzogJ2JpdGdvJyxcbiAgICAgICAgICBwdWJsaWNTaGFyZTogYmFja3VwVG9CaXRnb1NoYXJlLnB1YmxpY1NoYXJlLFxuICAgICAgICAgIHByaXZhdGVTaGFyZTogYmFja3VwVG9CaXRnb1NoYXJlLmVuY3J5cHRlZFByaXZhdGVTaGFyZSxcbiAgICAgICAgICBuOiBiYWNrdXBUb0JpdGdvU2hhcmUubixcbiAgICAgICAgICB2c3NQcm9vZjogYmFja3VwVG9CaXRnb1NoYXJlLnZzc1Byb29mLFxuICAgICAgICAgIHByaXZhdGVTaGFyZVByb29mOiBiYWNrdXBUb0JpdGdvU2hhcmUucHJpdmF0ZVNoYXJlUHJvb2YsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgdXNlckdQR1B1YmxpY0tleTogdXNlckdwZ0tleS5wdWJsaWNLZXksXG4gICAgICBiYWNrdXBHUEdQdWJsaWNLZXk6IGlzVGhpcmRQYXJ0eUJhY2t1cFxuICAgICAgICA/IChiYWNrdXBHcGdLZXkgYXMgS2V5KS5hcm1vcigpXG4gICAgICAgIDogKGJhY2t1cEdwZ0tleSBhcyBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+KS5wdWJsaWNLZXksXG4gICAgICBlbnRlcnByaXNlOiBlbnRlcnByaXNlLFxuICAgICAgYWxnb1VzZWQ6ICdlY2RzYScsXG4gICAgfTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZChjcmVhdGVCaXRHb01QQ1BhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBidWlsZHMgdGhlIHJlbGV2YW50IGJhY2t1cCBlbmNyeXB0ZWROU2hhcmUgYmFzZWQgb24gd2hldGhlciB0aGVcbiAgICogYmFja3VwIGtleSBpcyB1c2VyIG9yIHRoaXJkIHBhcnR5IGdlbmVyYXRlZFxuICAgKiBAcGFyYW0gYmFja3VwU2hhcmUgY2FuIGVpdGhlciBoYXZlIGtleSBzaGFyZXMgZnJvbSB0aGUgdXNlciBvciB0aGlyZCBwYXJ0eVxuICAgKiBAcGFyYW0gcmVjaXBpZW50SW5kZXggaW5kZXggb2YgdGhlIHBhcnR5IHJlY2VpdmluZyB0aGUgYmFja3VwIHNoYXJlc1xuICAgKiBAcGFyYW0gcmVjaXBpZW50R3BnUHVibGljQXJtb3IgZ3BnIGFybW9yIG9mIHRoZSBwYXJ0eSByZWNlaXZpbmcgdGhlIGJhY2t1cCBzaGFyZXNcbiAgICogQHBhcmFtIGJhY2t1cEdwZ0tleSBiYWNrdXAgZ3BnIGtleVxuICAgKiBAcGFyYW0gaXNUaGlyZFBhcnR5QmFja3VwIHdoZXRoZXIgdGhlIGJhY2t1cCBpcyBnZW5lcmF0ZWQgYnkgdGhpcmQgcGFydHlcbiAgICovXG4gIGFzeW5jIGdldEJhY2t1cEVuY3J5cHRlZE5TaGFyZShcbiAgICBiYWNrdXBTaGFyZTogQmFja3VwS2V5U2hhcmUsXG4gICAgcmVjaXBpZW50SW5kZXg6IG51bWJlcixcbiAgICByZWNpcGllbnRHcGdQdWJsaWNBcm1vcjogc3RyaW5nLFxuICAgIGJhY2t1cEdwZ0tleTogU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPixcbiAgICBpc1RoaXJkUGFydHlCYWNrdXAgPSBmYWxzZVxuICApOiBQcm9taXNlPEVuY3J5cHRlZE5TaGFyZT4ge1xuICAgIGxldCBiYWNrdXBUb1JlY2lwaWVudFNoYXJlOiBFbmNyeXB0ZWROU2hhcmU7XG4gICAgaWYgKGlzVGhpcmRQYXJ0eUJhY2t1cCkge1xuICAgICAgaWYgKCFiYWNrdXBTaGFyZS5iaXRHb0hlbGRLZXlTaGFyZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHRoaXJkIHBhcnR5IGJhY2t1cCBrZXkgc2hhcmVzYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBiYWNrdXBUb1JlY2lwaWVudEFwaVNoYXJlID0gYmFja3VwU2hhcmUuYml0R29IZWxkS2V5U2hhcmVzLmtleVNoYXJlcy5maW5kKFxuICAgICAgICAoa2V5U2hhcmUpID0+IGtleVNoYXJlLmZyb20gPT09ICdiYWNrdXAnICYmIGtleVNoYXJlLnRvID09PSBnZXRQYXJ0aWNpcGFudEZyb21JbmRleChyZWNpcGllbnRJbmRleClcbiAgICAgICk7XG4gICAgICBpZiAoIWJhY2t1cFRvUmVjaXBpZW50QXBpU2hhcmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGJhY2t1cCB0byAke2dldFBhcnRpY2lwYW50RnJvbUluZGV4KHJlY2lwaWVudEluZGV4KX0ga2V5IHNoYXJlYCk7XG4gICAgICB9XG4gICAgICAvLyBTaW5jZSBiYWNrdXAgaXMgZnJvbSBhIHRoaXJkIHBhcnR5LCBpdCBpcyBhbHJlYWR5IGVuY3J5cHRlZFxuICAgICAgYmFja3VwVG9SZWNpcGllbnRTaGFyZSA9IGF3YWl0IGJ1aWxkTlNoYXJlRnJvbUFQSUtleVNoYXJlKGJhY2t1cFRvUmVjaXBpZW50QXBpU2hhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoYmFja3VwU2hhcmUudXNlckhlbGRLZXlTaGFyZSk7XG4gICAgICBiYWNrdXBUb1JlY2lwaWVudFNoYXJlID0gYXdhaXQgZW5jcnlwdE5TaGFyZShcbiAgICAgICAgYmFja3VwU2hhcmUudXNlckhlbGRLZXlTaGFyZSxcbiAgICAgICAgcmVjaXBpZW50SW5kZXgsXG4gICAgICAgIHJlY2lwaWVudEdwZ1B1YmxpY0FybW9yLFxuICAgICAgICBiYWNrdXBHcGdLZXlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBiYWNrdXBUb1JlY2lwaWVudFNoYXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgdXNlcyB0aGUgYmFja3VwIGtleSBmcm9tIGEgdGhpcmQgcGFydHkgKGJpdGdvIGluIHRoaXMgY2FzZSlcbiAgICogdG8gY3JlYXRlIHRoZSB1c2VyIGtleWNoYWluIHZpYSBXUC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVVzZXJLZXljaGFpbkZyb21UaGlyZFBhcnR5QmFja3VwKFxuICAgIHVzZXJHcGdLZXk6IG9wZW5wZ3AuU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPixcbiAgICBiaXRnb1B1YmxpY0dwZ0tleTogS2V5LFxuICAgIHRoaXJkUGFydHlCYWNrdXBQdWJsaWNHcGdLZXk6IEtleSxcbiAgICB1c2VyS2V5U2hhcmU6IEtleVNoYXJlLFxuICAgIHRoaXJkUGFydHliYWNrdXBLZXlTaGFyZXM6IEFwaUtleVNoYXJlW10sXG4gICAgYml0Z29LZXljaGFpbjogS2V5Y2hhaW4sXG4gICAgcGFzc3BocmFzZTogc3RyaW5nLFxuICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZT86IHN0cmluZ1xuICApOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgY29uc3QgYml0Z29LZXlTaGFyZXMgPSBiaXRnb0tleWNoYWluLmtleVNoYXJlcztcbiAgICBpZiAoIWJpdGdvS2V5U2hhcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgQml0R28ga2V5IHNoYXJlcycpO1xuICAgIH1cbiAgICBpZiAoIWJpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBjb21tb24ga2V5IGNoYWluOiAke2JpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW59YCk7XG4gICAgfVxuXG4gICAgY29uc3QgYml0R29Ub1VzZXJTaGFyZSA9IGJpdGdvS2V5U2hhcmVzLmZpbmQoKGtleVNoYXJlKSA9PiBrZXlTaGFyZS5mcm9tID09PSAnYml0Z28nICYmIGtleVNoYXJlLnRvID09PSAndXNlcicpO1xuICAgIGlmICghYml0R29Ub1VzZXJTaGFyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEJpdEdvIHRvIFVzZXIga2V5IHNoYXJlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFja3VwVG9Vc2VyU2hhcmUgPSB0aGlyZFBhcnR5YmFja3VwS2V5U2hhcmVzLmZpbmQoXG4gICAgICAoa2V5U2hhcmUpID0+IGtleVNoYXJlLmZyb20gPT09ICdiYWNrdXAnICYmIGtleVNoYXJlLnRvID09PSAndXNlcidcbiAgICApO1xuICAgIGlmICghYmFja3VwVG9Vc2VyU2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBCYWNrdXAgdG8gVXNlciBrZXkgc2hhcmUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBiYWNrdXBUb1VzZXJOU2hhcmUgPSBhd2FpdCBidWlsZE5TaGFyZUZyb21BUElLZXlTaGFyZShiYWNrdXBUb1VzZXJTaGFyZSk7XG4gICAgY29uc3QgYml0R29Ub1VzZXJOU2hhcmUgPSBhd2FpdCBidWlsZE5TaGFyZUZyb21BUElLZXlTaGFyZShiaXRHb1RvVXNlclNoYXJlKTtcbiAgICBjb25zdCBlbmNyeXB0ZWROU2hhcmVzOiBEZWNyeXB0YWJsZU5TaGFyZVtdID0gW1xuICAgICAge1xuICAgICAgICBuU2hhcmU6IGJhY2t1cFRvVXNlck5TaGFyZSxcbiAgICAgICAgcmVjaXBpZW50UHJpdmF0ZUFybW9yOiB1c2VyR3BnS2V5LnByaXZhdGVLZXksXG4gICAgICAgIHNlbmRlclB1YmxpY0FybW9yOiB0aGlyZFBhcnR5QmFja3VwUHVibGljR3BnS2V5LmFybW9yKCksXG4gICAgICAgIGlzYnM1OEVuY29kZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgblNoYXJlOiBiaXRHb1RvVXNlck5TaGFyZSxcbiAgICAgICAgcmVjaXBpZW50UHJpdmF0ZUFybW9yOiB1c2VyR3BnS2V5LnByaXZhdGVLZXksXG4gICAgICAgIHNlbmRlclB1YmxpY0FybW9yOiBiaXRnb1B1YmxpY0dwZ0tleS5hcm1vcigpLFxuICAgICAgICBpc2JzNThFbmNvZGVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGNvbnN0IHVzZXJDb21iaW5lZEtleSA9IGF3YWl0IEVDRFNBTWV0aG9kcy5jcmVhdGVDb21iaW5lZEtleShcbiAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgIGVuY3J5cHRlZE5TaGFyZXMsXG4gICAgICBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluXG4gICAgKTtcbiAgICBpZiAodXNlckNvbWJpbmVkS2V5LmNvbW1vbktleWNoYWluICE9PSBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgdXNlciBrZXljaGFpbiAtIGNvbW1vbktleWNoYWlucyBkbyBub3QgbWF0Y2guJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJ2ID0gSlNPTi5zdHJpbmdpZnkodXNlckNvbWJpbmVkS2V5LnNpZ25pbmdNYXRlcmlhbCk7XG4gICAgY29uc3QgdXNlcktleWNoYWluUGFyYW1zID0ge1xuICAgICAgc291cmNlOiAndXNlcicsXG4gICAgICBrZXlUeXBlOiAndHNzJyBhcyBLZXlUeXBlLFxuICAgICAgY29tbW9uS2V5Y2hhaW46IHVzZXJDb21iaW5lZEtleS5jb21tb25LZXljaGFpbixcbiAgICAgIHBydjogcHJ2LFxuICAgICAgZW5jcnlwdGVkUHJ2OiB0aGlzLmJpdGdvLmVuY3J5cHQoe1xuICAgICAgICBpbnB1dDogcHJ2LFxuICAgICAgICBwYXNzd29yZDogcGFzc3BocmFzZSxcbiAgICAgIH0pLFxuICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgIH07XG5cbiAgICBjb25zdCBrZXljaGFpbnMgPSB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpO1xuICAgIHJldHVybiBhd2FpdCBrZXljaGFpbnMuYWRkKHVzZXJLZXljaGFpblBhcmFtcyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgYXN5bmMgY3JlYXRlUGFydGljaXBhbnRLZXljaGFpbihcbiAgICB1c2VyR3BnS2V5OiBvcGVucGdwLlNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz4sXG4gICAgdXNlckxvY2FsQmFja3VwR3BnS2V5OiBvcGVucGdwLlNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz4sXG4gICAgYml0Z29QdWJsaWNHcGdLZXk6IEtleSxcbiAgICByZWNpcGllbnRJbmRleDogbnVtYmVyLFxuICAgIHVzZXJLZXlTaGFyZTogS2V5U2hhcmUsXG4gICAgYmFja3VwS2V5U2hhcmU6IEtleVNoYXJlLFxuICAgIGJpdGdvS2V5Y2hhaW46IEtleWNoYWluLFxuICAgIHBhc3NwaHJhc2U6IHN0cmluZyxcbiAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIGNvbnN0IGJpdGdvS2V5U2hhcmVzID0gYml0Z29LZXljaGFpbi5rZXlTaGFyZXM7XG4gICAgaWYgKCFiaXRnb0tleVNoYXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEJpdEdvIGtleSBzaGFyZXMnKTtcbiAgICB9XG4gICAgaWYgKCFiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgY29tbW9uIGtleSBjaGFpbjogJHtiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWlufWApO1xuICAgIH1cblxuICAgIGxldCByZWNpcGllbnQ6IHN0cmluZztcbiAgICBsZXQga2V5U2hhcmU6IEtleVNoYXJlO1xuICAgIGxldCBvdGhlclNoYXJlOiBLZXlTaGFyZTtcbiAgICBsZXQgcmVjaXBpZW50R3BnS2V5OiBvcGVucGdwLlNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz47XG4gICAgbGV0IHNlbmRlckdwZ0tleTogb3BlbnBncC5TZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+O1xuICAgIGlmIChyZWNpcGllbnRJbmRleCA9PT0gMSkge1xuICAgICAga2V5U2hhcmUgPSB1c2VyS2V5U2hhcmU7XG4gICAgICBvdGhlclNoYXJlID0gYmFja3VwS2V5U2hhcmU7XG4gICAgICByZWNpcGllbnQgPSAndXNlcic7XG4gICAgICByZWNpcGllbnRHcGdLZXkgPSB1c2VyR3BnS2V5O1xuICAgICAgc2VuZGVyR3BnS2V5ID0gdXNlckxvY2FsQmFja3VwR3BnS2V5O1xuICAgIH0gZWxzZSBpZiAocmVjaXBpZW50SW5kZXggPT09IDIpIHtcbiAgICAgIGtleVNoYXJlID0gYmFja3VwS2V5U2hhcmU7XG4gICAgICBvdGhlclNoYXJlID0gdXNlcktleVNoYXJlO1xuICAgICAgcmVjaXBpZW50ID0gJ2JhY2t1cCc7XG4gICAgICByZWNpcGllbnRHcGdLZXkgPSB1c2VyTG9jYWxCYWNrdXBHcGdLZXk7XG4gICAgICBzZW5kZXJHcGdLZXkgPSB1c2VyR3BnS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBpbmRleCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdEdvVG9SZWNpcGllbnRTaGFyZSA9IGJpdGdvS2V5U2hhcmVzLmZpbmQoXG4gICAgICAoa2V5U2hhcmUpID0+IGtleVNoYXJlLmZyb20gPT09ICdiaXRnbycgJiYga2V5U2hhcmUudG8gPT09IHJlY2lwaWVudFxuICAgICk7XG4gICAgaWYgKCFiaXRHb1RvUmVjaXBpZW50U2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBCaXRHbyB0byAke3JlY2lwaWVudH0ga2V5IHNoYXJlYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjcnlwdGVkU2hhcmUgPSBhd2FpdCB0aGlzLmRlY3J5cHRQcml2YXRlU2hhcmUoYml0R29Ub1JlY2lwaWVudFNoYXJlLnByaXZhdGVTaGFyZSwgcmVjaXBpZW50R3BnS2V5KTtcblxuICAgIGF3YWl0IHRoaXMudmVyaWZ5V2FsbGV0U2lnbmF0dXJlcyhcbiAgICAgIHVzZXJHcGdLZXkucHVibGljS2V5LFxuICAgICAgdXNlckxvY2FsQmFja3VwR3BnS2V5LnB1YmxpY0tleSxcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICBkZWNyeXB0ZWRTaGFyZSxcbiAgICAgIHJlY2lwaWVudEluZGV4XG4gICAgKTtcblxuICAgIGNvbnN0IHNlbmRlclRvUmVjaXBpZW50U2hhcmUgPSBhd2FpdCBlbmNyeXB0TlNoYXJlKFxuICAgICAgb3RoZXJTaGFyZSxcbiAgICAgIHJlY2lwaWVudEluZGV4LFxuICAgICAgcmVjaXBpZW50R3BnS2V5LnB1YmxpY0tleSxcbiAgICAgIHNlbmRlckdwZ0tleVxuICAgICk7XG4gICAgY29uc3QgZW5jcnlwdGVkTlNoYXJlczogRGVjcnlwdGFibGVOU2hhcmVbXSA9IFtcbiAgICAgIHtcbiAgICAgICAgLy8gdXNlclRvQmFja3VwIG9yIGJhY2t1cFRvVXNlclxuICAgICAgICBuU2hhcmU6IHNlbmRlclRvUmVjaXBpZW50U2hhcmUsXG4gICAgICAgIHJlY2lwaWVudFByaXZhdGVBcm1vcjogcmVjaXBpZW50R3BnS2V5LnByaXZhdGVLZXksXG4gICAgICAgIHNlbmRlclB1YmxpY0FybW9yOiBzZW5kZXJHcGdLZXkucHVibGljS2V5LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gYml0Z29Ub1JlY2lwaWVudFxuICAgICAgICBuU2hhcmU6IHtcbiAgICAgICAgICBpOiByZWNpcGllbnRJbmRleCxcbiAgICAgICAgICBqOiAzLFxuICAgICAgICAgIHB1YmxpY1NoYXJlOiBiaXRHb1RvUmVjaXBpZW50U2hhcmUucHVibGljU2hhcmUsXG4gICAgICAgICAgZW5jcnlwdGVkUHJpdmF0ZVNoYXJlOiBiaXRHb1RvUmVjaXBpZW50U2hhcmUucHJpdmF0ZVNoYXJlLFxuICAgICAgICAgIG46IGJpdEdvVG9SZWNpcGllbnRTaGFyZS5uISxcbiAgICAgICAgICB2c3NQcm9vZjogYml0R29Ub1JlY2lwaWVudFNoYXJlLnZzc1Byb29mLFxuICAgICAgICAgIHByaXZhdGVTaGFyZVByb29mOiBiaXRHb1RvUmVjaXBpZW50U2hhcmUucHJpdmF0ZVNoYXJlUHJvb2YsXG4gICAgICAgIH0sXG4gICAgICAgIHJlY2lwaWVudFByaXZhdGVBcm1vcjogcmVjaXBpZW50R3BnS2V5LnByaXZhdGVLZXksXG4gICAgICAgIHNlbmRlclB1YmxpY0FybW9yOiBiaXRnb1B1YmxpY0dwZ0tleS5hcm1vcigpLFxuICAgICAgICBpc2JzNThFbmNvZGVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGNvbnN0IHJlY2lwaWVudENvbWJpbmVkS2V5ID0gYXdhaXQgRUNEU0FNZXRob2RzLmNyZWF0ZUNvbWJpbmVkS2V5KFxuICAgICAga2V5U2hhcmUsXG4gICAgICBlbmNyeXB0ZWROU2hhcmVzLFxuICAgICAgYml0Z29LZXljaGFpbi5jb21tb25LZXljaGFpblxuICAgICk7XG5cbiAgICBjb25zdCBwcnYgPSBKU09OLnN0cmluZ2lmeShyZWNpcGllbnRDb21iaW5lZEtleS5zaWduaW5nTWF0ZXJpYWwpO1xuICAgIGNvbnN0IHJlY2lwaWVudEtleWNoYWluUGFyYW1zID0ge1xuICAgICAgc291cmNlOiByZWNpcGllbnQsXG4gICAgICBrZXlUeXBlOiAndHNzJyBhcyBLZXlUeXBlLFxuICAgICAgY29tbW9uS2V5Y2hhaW46IGJpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4sXG4gICAgICBwcnY6IHBydixcbiAgICAgIGVuY3J5cHRlZFBydjogdGhpcy5iaXRnby5lbmNyeXB0KHtcbiAgICAgICAgaW5wdXQ6IHBydixcbiAgICAgICAgcGFzc3dvcmQ6IHBhc3NwaHJhc2UsXG4gICAgICB9KSxcbiAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICB9O1xuXG4gICAgY29uc3Qga2V5Y2hhaW5zID0gdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKTtcbiAgICByZXR1cm4gcmVjaXBpZW50SW5kZXggPT09IDFcbiAgICAgID8gYXdhaXQga2V5Y2hhaW5zLmFkZChyZWNpcGllbnRLZXljaGFpblBhcmFtcylcbiAgICAgIDogYXdhaXQga2V5Y2hhaW5zLmNyZWF0ZUJhY2t1cChyZWNpcGllbnRLZXljaGFpblBhcmFtcyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRzc0VjZHNhU3RlcDFTaWduaW5nTWF0ZXJpYWwocGFyYW1zOiB7XG4gICAgY2hhbGxlbmdlczoge1xuICAgICAgZW50ZXJwcmlzZUNoYWxsZW5nZTogRWNkc2FUeXBlcy5TZXJpYWxpemVkRWNkc2FDaGFsbGVuZ2VzO1xuICAgICAgYml0Z29DaGFsbGVuZ2U6IFR4UmVxdWVzdENoYWxsZW5nZVJlc3BvbnNlO1xuICAgIH07XG4gICAgcHJ2OiBzdHJpbmc7XG4gICAgZGVyaXZhdGlvblBhdGg6IHN0cmluZztcbiAgICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxUc3NFY2RzYVN0ZXAxUmV0dXJuTWVzc2FnZT4ge1xuICAgIGNvbnN0IHsgY2hhbGxlbmdlcywgZGVyaXZhdGlvblBhdGgsIHBydiB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHVzZXJTaWduaW5nTWF0ZXJpYWw6IEVDRFNBTWV0aG9kVHlwZXMuU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZShwcnYpO1xuICAgIGlmICh1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZS5pICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXknKTtcbiAgICB9XG4gICAgaWYgKCF1c2VyU2lnbmluZ01hdGVyaWFsLmJhY2t1cE5TaGFyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXIga2V5IC0gbWlzc2luZyBiYWNrdXBOU2hhcmUnKTtcbiAgICB9XG4gICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG4gICAgY29uc3Qgc2lnbmluZ0tleSA9IE1QQy5rZXlEZXJpdmUoXG4gICAgICB1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZSxcbiAgICAgIFt1c2VyU2lnbmluZ01hdGVyaWFsLmJpdGdvTlNoYXJlLCB1c2VyU2lnbmluZ01hdGVyaWFsLmJhY2t1cE5TaGFyZV0sXG4gICAgICBkZXJpdmF0aW9uUGF0aFxuICAgICk7XG5cbiAgICBjb25zdCBiaXRnb0luZGV4ID0gU2hhcmVLZXlQb3NpdGlvbi5CSVRHTztcbiAgICBjb25zdCB1c2VySW5kZXggPSB1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZS5pO1xuXG4gICAgY29uc3QgeyBudGlsZGU6IG50aWxkZWEsIGgxOiBoMWEsIGgyOiBoMmEsIHA6IHBhIH0gPSBjaGFsbGVuZ2VzLmVudGVycHJpc2VDaGFsbGVuZ2U7XG4gICAgY29uc3QgeyBudGlsZGU6IG50aWxkZWIsIGgxOiBoMWIsIGgyOiBoMmIsIHA6IHBiLCBuOiBuYiB9ID0gY2hhbGxlbmdlcy5iaXRnb0NoYWxsZW5nZTtcbiAgICBjb25zdCB1c2VyWFNoYXJlID0gTVBDLmFwcGVuZENoYWxsZW5nZShzaWduaW5nS2V5LnhTaGFyZSwgeyBudGlsZGU6IG50aWxkZWEsIGgxOiBoMWEsIGgyOiBoMmEgfSwgeyBwOiBwYSB9KTtcbiAgICBjb25zdCBiaXRnb1lTaGFyZSA9IE1QQy5hcHBlbmRDaGFsbGVuZ2UoXG4gICAgICB7XG4gICAgICAgIGk6IHVzZXJJbmRleCxcbiAgICAgICAgajogYml0Z29JbmRleCxcbiAgICAgICAgbjogbmIsXG4gICAgICB9LFxuICAgICAgeyBudGlsZGU6IG50aWxkZWIsIGgxOiBoMWIsIGgyOiBoMmIgfSxcbiAgICAgIHsgcDogcGIgfVxuICAgICk7XG5cbiAgICBjb25zdCB1c2VyU2lnblNoYXJlID0gYXdhaXQgRUNEU0FNZXRob2RzLmNyZWF0ZVVzZXJTaWduU2hhcmUodXNlclhTaGFyZSwgYml0Z29ZU2hhcmUpO1xuICAgIGNvbnN0IHUgPSBzaWduaW5nS2V5Lm5TaGFyZXNbYml0Z29JbmRleF0udTtcblxuICAgIGxldCBjaGFpbmNvZGUgPSB1c2VyU2lnbmluZ01hdGVyaWFsLmJpdGdvTlNoYXJlLmNoYWluY29kZTtcbiAgICB3aGlsZSAoY2hhaW5jb2RlLmxlbmd0aCA8IDY0KSB7XG4gICAgICBjaGFpbmNvZGUgPSAnMCcgKyBjaGFpbmNvZGU7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lclNoYXJlID0gYmlwMzIuZnJvbVByaXZhdGVLZXkoQnVmZmVyLmZyb20odSwgJ2hleCcpLCBCdWZmZXIuZnJvbShjaGFpbmNvZGUsICdoZXgnKSkudG9CYXNlNTgoKTtcbiAgICBjb25zdCBiaXRnb0dwZ0tleSA9IChhd2FpdCBnZXRCaXRnb0dwZ1B1YktleSh0aGlzLmJpdGdvKSkubXBjVjE7XG4gICAgY29uc3QgZW5jcnlwdGVkU2lnbmVyU2hhcmUgPSAoYXdhaXQgb3BlbnBncC5lbmNyeXB0KHtcbiAgICAgIG1lc3NhZ2U6IGF3YWl0IG9wZW5wZ3AuY3JlYXRlTWVzc2FnZSh7XG4gICAgICAgIHRleHQ6IHNpZ25lclNoYXJlLFxuICAgICAgfSksXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgcmVqZWN0Q3VydmVzOiBuZXcgU2V0KCksXG4gICAgICB9LFxuICAgICAgZW5jcnlwdGlvbktleXM6IFtiaXRnb0dwZ0tleV0sXG4gICAgfSkpIGFzIHN0cmluZztcbiAgICBjb25zdCB1c2VyR3BnS2V5ID0gYXdhaXQgZ2VuZXJhdGVHUEdLZXlQYWlyKCdzZWNwMjU2azEnKTtcbiAgICBjb25zdCBwcml2YXRlU2hhcmVQcm9vZiA9IGF3YWl0IGNyZWF0ZVNoYXJlUHJvb2YodXNlckdwZ0tleS5wcml2YXRlS2V5LCBzaWduaW5nS2V5Lm5TaGFyZXNbYml0Z29JbmRleF0udSwgJ2VjZHNhJyk7XG4gICAgY29uc3QgdnNzUHJvb2YgPSBzaWduaW5nS2V5Lm5TaGFyZXNbYml0Z29JbmRleF0udjtcbiAgICBjb25zdCB1c2VyUHVibGljR3BnS2V5ID0gdXNlckdwZ0tleS5wdWJsaWNLZXk7XG4gICAgY29uc3QgcHVibGljU2hhcmUgPSBzaWduaW5nS2V5Lm5TaGFyZXNbYml0Z29JbmRleF0ueSArIHNpZ25pbmdLZXkublNoYXJlc1tiaXRnb0luZGV4XS5jaGFpbmNvZGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaXZhdGVTaGFyZVByb29mOiBwcml2YXRlU2hhcmVQcm9vZixcbiAgICAgIHZzc1Byb29mOiB2c3NQcm9vZixcbiAgICAgIHB1YmxpY1NoYXJlOiBwdWJsaWNTaGFyZSxcbiAgICAgIGVuY3J5cHRlZFNpZ25lck9mZnNldFNoYXJlOiBlbmNyeXB0ZWRTaWduZXJTaGFyZSxcbiAgICAgIHVzZXJQdWJsaWNHcGdLZXk6IHVzZXJQdWJsaWNHcGdLZXksXG4gICAgICBrU2hhcmU6IHVzZXJTaWduU2hhcmUua1NoYXJlLFxuICAgICAgd1NoYXJlOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZVxuICAgICAgICA/IHRoaXMuYml0Z28uZW5jcnlwdCh7IGlucHV0OiBKU09OLnN0cmluZ2lmeSh1c2VyU2lnblNoYXJlLndTaGFyZSksIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB9KVxuICAgICAgICA6IHVzZXJTaWduU2hhcmUud1NoYXJlLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRzc0VjZHNhU3RlcDJTaWduaW5nTWF0ZXJpYWwocGFyYW1zOiB7XG4gICAgYml0Z29DaGFsbGVuZ2U6IFR4UmVxdWVzdENoYWxsZW5nZVJlc3BvbnNlO1xuICAgIHdTaGFyZTogV1NoYXJlO1xuICAgIGFTaGFyZUZyb21CaXRnbzogT21pdDxBU2hhcmUsICdoMScgfCAnaDInIHwgJ250aWxkZSc+O1xuICAgIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPFRzc0VjZHNhU3RlcDJSZXR1cm5NZXNzYWdlPiB7XG4gICAgLy8gQXBwZW5kIHRoZSBCaXRHbyBjaGFsbGVuZ2UgdG8gdGhlIEFzaGFyZSB0byBiZSB1c2VkIGluIHN1YnNlcXVlbnQgcHJvb2ZzXG4gICAgY29uc3QgYml0Z29Ub1VzZXJBU2hhcmVXaXRoTnRpbGRlOiBBU2hhcmUgPSB7XG4gICAgICAuLi5wYXJhbXMuYVNoYXJlRnJvbUJpdGdvLFxuICAgICAgLi4ucGFyYW1zLmJpdGdvQ2hhbGxlbmdlLFxuICAgIH07XG4gICAgY29uc3QgdXNlckdhbW1hQW5kTXVTaGFyZXMgPSBhd2FpdCBFQ0RTQU1ldGhvZHMuY3JlYXRlVXNlckdhbW1hQW5kTXVTaGFyZShcbiAgICAgIHBhcmFtcy53U2hhcmUsXG4gICAgICBiaXRnb1RvVXNlckFTaGFyZVdpdGhOdGlsZGVcbiAgICApO1xuICAgIGNvbnN0IHVzZXJPbWljcm9uQW5kRGVsdGFTaGFyZSA9IGF3YWl0IEVDRFNBTWV0aG9kcy5jcmVhdGVVc2VyT21pY3JvbkFuZERlbHRhU2hhcmUoXG4gICAgICB1c2VyR2FtbWFBbmRNdVNoYXJlcy5nU2hhcmUgYXMgRUNEU0EuR1NoYXJlXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgbXVEU2hhcmU6IHtcbiAgICAgICAgbXVTaGFyZTogdXNlckdhbW1hQW5kTXVTaGFyZXMubXVTaGFyZSxcbiAgICAgICAgZFNoYXJlOiB1c2VyT21pY3JvbkFuZERlbHRhU2hhcmUuZFNoYXJlLFxuICAgICAgICBpOiB1c2VyR2FtbWFBbmRNdVNoYXJlcy5tdVNoYXJlLmksXG4gICAgICB9LFxuICAgICAgb1NoYXJlOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZVxuICAgICAgICA/IHRoaXMuYml0Z28uZW5jcnlwdCh7XG4gICAgICAgICAgICBpbnB1dDogSlNPTi5zdHJpbmdpZnkodXNlck9taWNyb25BbmREZWx0YVNoYXJlLm9TaGFyZSksXG4gICAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgICAgfSlcbiAgICAgICAgOiB1c2VyT21pY3JvbkFuZERlbHRhU2hhcmUub1NoYXJlLFxuICAgIH07XG4gIH1cblxuICBnZXRPZmZsaW5lU2lnbmVyUGFpbGxpZXJNb2R1bHVzKHBhcmFtczogeyBwcnY6IHN0cmluZyB9KTogeyB1c2VyUGFpbGxpZXJNb2R1bHVzOiBzdHJpbmcgfSB7XG4gICAgYXNzZXJ0KHBhcmFtcy5wcnYsICdQYXJhbXMgdG8gZ2V0IHBhaWxsaWVyIG1vZHVsdXMgYXJlIG1pc3NpbmcgcHJ2LicpO1xuICAgIGNvbnN0IHVzZXJTaWduaW5nTWF0ZXJpYWw6IEVDRFNBTWV0aG9kVHlwZXMuU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZShwYXJhbXMucHJ2KTtcbiAgICByZXR1cm4geyB1c2VyUGFpbGxpZXJNb2R1bHVzOiB1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZS5uIH07XG4gIH1cblxuICBhc3luYyBjcmVhdGVPZmZsaW5lS1NoYXJlKHBhcmFtczoge1xuICAgIHRzc1BhcmFtczogVFNTUGFyYW1zIHwgVFNTUGFyYW1zRm9yTWVzc2FnZTtcbiAgICBjaGFsbGVuZ2VzOiB7XG4gICAgICBlbnRlcnByaXNlQ2hhbGxlbmdlOiBFY2RzYVR5cGVzLlNlcmlhbGl6ZWRFY2RzYUNoYWxsZW5nZXM7XG4gICAgICBiaXRnb0NoYWxsZW5nZTogVHhSZXF1ZXN0Q2hhbGxlbmdlUmVzcG9uc2U7XG4gICAgfTtcbiAgICByZXF1ZXN0VHlwZTogUmVxdWVzdFR5cGU7XG4gICAgcHJ2OiBzdHJpbmc7XG4gICAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxUc3NFY2RzYVN0ZXAxUmV0dXJuTWVzc2FnZT4ge1xuICAgIGNvbnN0IHsgdHNzUGFyYW1zLCBwcnYsIHJlcXVlc3RUeXBlLCBjaGFsbGVuZ2VzIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHR5cGVvZiB0c3NQYXJhbXMudHhSZXF1ZXN0ICE9PSAnc3RyaW5nJywgJ0ludmFsaWQgdHhSZXF1ZXN0IHR5cGUnKTtcbiAgICBjb25zdCB0eFJlcXVlc3Q6IFR4UmVxdWVzdCA9IHRzc1BhcmFtcy50eFJlcXVlc3Q7XG4gICAgbGV0IGRlcml2YXRpb25QYXRoO1xuXG4gICAgaWYgKHJlcXVlc3RUeXBlID09PSBSZXF1ZXN0VHlwZS50eCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0eFJlcXVlc3QudHJhbnNhY3Rpb25zIHx8ICh0eFJlcXVlc3QgYXMgVHhSZXF1ZXN0KS51bnNpZ25lZFR4cyxcbiAgICAgICAgJ1VuYWJsZSB0byBmaW5kIHRyYW5zYWN0aW9ucyBpbiB0eFJlcXVlc3QnXG4gICAgICApO1xuICAgICAgY29uc3QgdW5zaWduZWRUeCA9XG4gICAgICAgIHR4UmVxdWVzdC5hcGlWZXJzaW9uID09PSAnZnVsbCcgPyB0eFJlcXVlc3QudHJhbnNhY3Rpb25zIVswXS51bnNpZ25lZFR4IDogdHhSZXF1ZXN0LnVuc2lnbmVkVHhzWzBdO1xuICAgICAgZGVyaXZhdGlvblBhdGggPSB1bnNpZ25lZFR4LmRlcml2YXRpb25QYXRoO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdFR5cGUgPT09IFJlcXVlc3RUeXBlLm1lc3NhZ2UpIHtcbiAgICAgIC8vIFRPRE8gQkctNjcyOTkgTWVzc2FnZSBzaWduaW5nIHdpdGggZGVyaXZhdGlvbiBwYXRoXG4gICAgICBkZXJpdmF0aW9uUGF0aCA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUc3NFY2RzYVN0ZXAxU2lnbmluZ01hdGVyaWFsKHtcbiAgICAgIHBydjogcHJ2LFxuICAgICAgY2hhbGxlbmdlczogY2hhbGxlbmdlcyxcbiAgICAgIGRlcml2YXRpb25QYXRoOiBkZXJpdmF0aW9uUGF0aCxcbiAgICAgIHdhbGxldFBhc3NwaHJhc2U6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlT2ZmbGluZU11RGVsdGFTaGFyZShwYXJhbXM6IHtcbiAgICBhU2hhcmVGcm9tQml0Z286IE9taXQ8QVNoYXJlLCAnbnRpbGRlJyB8ICdoMScgfCAnaDInPjtcbiAgICBiaXRnb0NoYWxsZW5nZTogVHhSZXF1ZXN0Q2hhbGxlbmdlUmVzcG9uc2U7XG4gICAgZW5jcnlwdGVkV1NoYXJlOiBzdHJpbmc7XG4gICAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxUc3NFY2RzYVN0ZXAyUmV0dXJuTWVzc2FnZT4ge1xuICAgIGNvbnN0IGRlY3J5cHRlZFdTaGFyZSA9IHRoaXMuYml0Z28uZGVjcnlwdCh7IGlucHV0OiBwYXJhbXMuZW5jcnlwdGVkV1NoYXJlLCBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlVHNzRWNkc2FTdGVwMlNpZ25pbmdNYXRlcmlhbCh7XG4gICAgICBhU2hhcmVGcm9tQml0Z286IHBhcmFtcy5hU2hhcmVGcm9tQml0Z28sXG4gICAgICBiaXRnb0NoYWxsZW5nZTogcGFyYW1zLmJpdGdvQ2hhbGxlbmdlLFxuICAgICAgd1NoYXJlOiBKU09OLnBhcnNlKGRlY3J5cHRlZFdTaGFyZSksXG4gICAgICB3YWxsZXRQYXNzcGhyYXNlOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZU9mZmxpbmVTU2hhcmUocGFyYW1zOiB7XG4gICAgdHNzUGFyYW1zOiBUU1NQYXJhbXMgfCBUU1NQYXJhbXNGb3JNZXNzYWdlO1xuICAgIGRTaGFyZUZyb21CaXRnbzogRFNoYXJlO1xuICAgIHJlcXVlc3RUeXBlOiBSZXF1ZXN0VHlwZTtcbiAgICBlbmNyeXB0ZWRPU2hhcmU6IHN0cmluZztcbiAgICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPFNTaGFyZT4ge1xuICAgIGNvbnN0IHsgdHNzUGFyYW1zLCByZXF1ZXN0VHlwZSwgZFNoYXJlRnJvbUJpdGdvLCBlbmNyeXB0ZWRPU2hhcmUsIHdhbGxldFBhc3NwaHJhc2UgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQodHlwZW9mIHRzc1BhcmFtcy50eFJlcXVlc3QgIT09ICdzdHJpbmcnLCAnSW52YWxpZCB0eFJlcXVlc3QgdHlwZScpO1xuICAgIGNvbnN0IHR4UmVxdWVzdDogVHhSZXF1ZXN0ID0gdHNzUGFyYW1zLnR4UmVxdWVzdDtcbiAgICBsZXQgc2lnbmFibGVQYXlsb2FkO1xuICAgIGlmIChyZXF1ZXN0VHlwZSA9PT0gUmVxdWVzdFR5cGUudHgpIHtcbiAgICAgIGFzc2VydCh0eFJlcXVlc3QudHJhbnNhY3Rpb25zIHx8IHR4UmVxdWVzdC51bnNpZ25lZFR4cywgJ1VuYWJsZSB0byBmaW5kIHRyYW5zYWN0aW9ucyBpbiB0eFJlcXVlc3QnKTtcbiAgICAgIGNvbnN0IHVuc2lnbmVkVHggPVxuICAgICAgICB0eFJlcXVlc3QuYXBpVmVyc2lvbiA9PT0gJ2Z1bGwnID8gdHhSZXF1ZXN0LnRyYW5zYWN0aW9ucyFbMF0udW5zaWduZWRUeCA6IHR4UmVxdWVzdC51bnNpZ25lZFR4c1swXTtcbiAgICAgIHNpZ25hYmxlUGF5bG9hZCA9IEJ1ZmZlci5mcm9tKHVuc2lnbmVkVHguc2lnbmFibGVIZXgsICdoZXgnKTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3RUeXBlID09PSBSZXF1ZXN0VHlwZS5tZXNzYWdlKSB7XG4gICAgICBzaWduYWJsZVBheWxvYWQgPSAocGFyYW1zLnRzc1BhcmFtcyBhcyBUU1NQYXJhbXNGb3JNZXNzYWdlKS5idWZmZXJUb1NpZ247XG4gICAgfVxuICAgIGxldCBoYXNoOiBIYXNoIHwgdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBoYXNoID0gdGhpcy5iYXNlQ29pbi5nZXRIYXNoRnVuY3Rpb24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGhhc2ggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGRlY3J5cHRlZE9TaGFyZSA9IHRoaXMuYml0Z28uZGVjcnlwdCh7IGlucHV0OiBlbmNyeXB0ZWRPU2hhcmUsIHBhc3N3b3JkOiB3YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgIGNvbnN0IHsgaSwgUiwgcywgeSB9ID0gYXdhaXQgRUNEU0FNZXRob2RzLmNyZWF0ZVVzZXJTaWduYXR1cmVTaGFyZShcbiAgICAgIEpTT04ucGFyc2UoZGVjcnlwdGVkT1NoYXJlKSxcbiAgICAgIGRTaGFyZUZyb21CaXRnbyxcbiAgICAgIHNpZ25hYmxlUGF5bG9hZCxcbiAgICAgIGhhc2hcbiAgICApO1xuICAgIC8vIHJldHVybiBvbmx5IHJlcXVpcmVkIFNTaGFyZSB3aXRob3V0IGJpZ2ludHMgZnJvbSBWQVNoYXJlXG4gICAgcmV0dXJuIHtcbiAgICAgIGksXG4gICAgICBSLFxuICAgICAgcyxcbiAgICAgIHksXG4gICAgfTtcbiAgfVxuICBhc3luYyBzaWduRWNkc2FUc3NVc2luZ0V4dGVybmFsU2lnbmVyKFxuICAgIHBhcmFtczogVFNTUGFyYW1zIHwgVFNTUGFyYW1zRm9yTWVzc2FnZSxcbiAgICByZXF1ZXN0VHlwZTogUmVxdWVzdFR5cGUsXG4gICAgZXh0ZXJuYWxTaWduZXJQYWlsbGllck1vZHVsdXNHZXR0ZXI6IEN1c3RvbVBhaWxsaWVyTW9kdWx1c0dldHRlckZ1bmN0aW9uLFxuICAgIGV4dGVybmFsU2lnbmVyS1NoYXJlR2VuZXJhdG9yOiBDdXN0b21LU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gICAgZXh0ZXJuYWxTaWduZXJNdURlbHRhU2hhcmVHZW5lcmF0b3I6IEN1c3RvbU11RGVsdGFTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgICBleHRlcm5hbFNpZ25lclNTaGFyZUdlbmVyYXRvcjogQ3VzdG9tU1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uXG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgY29uc3QgeyB0eFJlcXVlc3QgfSA9IHBhcmFtcztcbiAgICBjb25zdCBwZW5kaW5nRWNkc2FUc3NJbml0aWFsaXphdGlvbiA9IHRoaXMud2FsbGV0LmNvaW5TcGVjaWZpYygpPy5wZW5kaW5nRWNkc2FUc3NJbml0aWFsaXphdGlvbjtcbiAgICBpZiAocGVuZGluZ0VjZHNhVHNzSW5pdGlhbGl6YXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1dhbGxldCBpcyBub3QgcmVhZHkgZm9yIFRTUyBFQ0RTQSBzaWduaW5nLiBQbGVhc2UgY29udGFjdCB5b3VyIGVudGVycHJpc2UgYWRtaW4gdG8gZmluaXNoIHRoZSBlbnRlcnByaXNlIFRTUyBpbml0aWFsaXphdGlvbi4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB0eFJlcXVlc3RPYmo6IFR4UmVxdWVzdCA9IGF3YWl0IGdldFR4UmVxdWVzdCh0aGlzLmJpdGdvLCB0aGlzLndhbGxldC5pZCgpLCB0eFJlcXVlc3QgYXMgc3RyaW5nLCBwYXJhbXMucmVxSWQpO1xuICAgIGNvbnN0IHsgdXNlclBhaWxsaWVyTW9kdWx1cyB9ID0gYXdhaXQgZXh0ZXJuYWxTaWduZXJQYWlsbGllck1vZHVsdXNHZXR0ZXIoeyB0eFJlcXVlc3Q6IHR4UmVxdWVzdE9iaiB9KTtcbiAgICBjb25zdCB7IGVudGVycHJpc2VDaGFsbGVuZ2UsIGJpdGdvQ2hhbGxlbmdlIH0gPSBhd2FpdCB0aGlzLmdldEVjZHNhU2lnbmluZ0NoYWxsZW5nZXMoXG4gICAgICB0eFJlcXVlc3QgYXMgc3RyaW5nLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICB1c2VyUGFpbGxpZXJNb2R1bHVzLFxuICAgICAgMCxcbiAgICAgIHBhcmFtcy5yZXFJZFxuICAgICk7XG4gICAgY29uc3Qgc3RlcDFTaWduaW5nTWF0ZXJpYWwgPSBhd2FpdCBleHRlcm5hbFNpZ25lcktTaGFyZUdlbmVyYXRvcih7XG4gICAgICB0c3NQYXJhbXM6IHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB0eFJlcXVlc3Q6IHR4UmVxdWVzdE9iaixcbiAgICAgIH0sXG4gICAgICBjaGFsbGVuZ2VzOiB7IGVudGVycHJpc2VDaGFsbGVuZ2UsIGJpdGdvQ2hhbGxlbmdlIH0sXG4gICAgICByZXF1ZXN0VHlwZTogcmVxdWVzdFR5cGUsXG4gICAgfSk7XG4gICAgLy8gc2lnbmluZyBzdGFnZSBvbmUgd2l0aCBLIHNoYXJlIHNlbmQgdG8gYml0Z28gYW5kIHJlY2VpdmVzIEEgc2hhcmVcbiAgICBjb25zdCBiaXRnb1RvVXNlckFTaGFyZSA9IChhd2FpdCBFQ0RTQU1ldGhvZHMuc2VuZFNoYXJlVG9CaXRnbyhcbiAgICAgIHRoaXMuYml0Z28sXG4gICAgICB0aGlzLndhbGxldC5pZCgpLFxuICAgICAgdHhSZXF1ZXN0T2JqLnR4UmVxdWVzdElkLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICBTZW5kU2hhcmVUeXBlLktTaGFyZSxcbiAgICAgIHN0ZXAxU2lnbmluZ01hdGVyaWFsLmtTaGFyZSxcbiAgICAgIHN0ZXAxU2lnbmluZ01hdGVyaWFsLmVuY3J5cHRlZFNpZ25lck9mZnNldFNoYXJlLFxuICAgICAgc3RlcDFTaWduaW5nTWF0ZXJpYWwudnNzUHJvb2YsXG4gICAgICBzdGVwMVNpZ25pbmdNYXRlcmlhbC5wcml2YXRlU2hhcmVQcm9vZixcbiAgICAgIHN0ZXAxU2lnbmluZ01hdGVyaWFsLnB1YmxpY1NoYXJlLFxuICAgICAgc3RlcDFTaWduaW5nTWF0ZXJpYWwudXNlclB1YmxpY0dwZ0tleSxcbiAgICAgIHBhcmFtcy5yZXFJZFxuICAgICkpIGFzIE9taXQ8QVNoYXJlLCAnbnRpbGRlJyB8ICdoMScgfCAnaDInPjsgLy8gV1AvSFNNIGRvZXMgbm90IHJldHVybiB0aGUgaW5pdGlhbCBjaGFsbGVuZ2VcbiAgICBjb25zdCBzdGVwMlJldHVybiA9IGF3YWl0IGV4dGVybmFsU2lnbmVyTXVEZWx0YVNoYXJlR2VuZXJhdG9yKHtcbiAgICAgIHR4UmVxdWVzdDogdHhSZXF1ZXN0T2JqLFxuICAgICAgYVNoYXJlRnJvbUJpdGdvOiBiaXRnb1RvVXNlckFTaGFyZSxcbiAgICAgIGJpdGdvQ2hhbGxlbmdlOiBiaXRnb0NoYWxsZW5nZSxcbiAgICAgIGVuY3J5cHRlZFdTaGFyZTogc3RlcDFTaWduaW5nTWF0ZXJpYWwud1NoYXJlIGFzIHN0cmluZyxcbiAgICB9KTtcbiAgICAvLyBzaWduaW5nIHN0YWdlIHR3byB3aXRoIG11U2hhcmUgYW5kIGRTaGFyZSBzZW5kIHRvIGJpdGdvIGFuZCByZWNlaXZlcyBEIHNoYXJlXG4gICAgY29uc3QgYml0Z29Ub1VzZXJEU2hhcmUgPSAoYXdhaXQgRUNEU0FNZXRob2RzLnNlbmRTaGFyZVRvQml0Z28oXG4gICAgICB0aGlzLmJpdGdvLFxuICAgICAgdGhpcy53YWxsZXQuaWQoKSxcbiAgICAgIHR4UmVxdWVzdE9iai50eFJlcXVlc3RJZCxcbiAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgU2VuZFNoYXJlVHlwZS5NVVNoYXJlLFxuICAgICAgc3RlcDJSZXR1cm4ubXVEU2hhcmUsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBwYXJhbXMucmVxSWRcbiAgICApKSBhcyBEU2hhcmU7XG4gICAgY29uc3QgdXNlclNTaGFyZSA9IGF3YWl0IGV4dGVybmFsU2lnbmVyU1NoYXJlR2VuZXJhdG9yKHtcbiAgICAgIHRzc1BhcmFtczoge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHR4UmVxdWVzdDogdHhSZXF1ZXN0T2JqLFxuICAgICAgfSxcbiAgICAgIGRTaGFyZUZyb21CaXRnbzogYml0Z29Ub1VzZXJEU2hhcmUsXG4gICAgICByZXF1ZXN0VHlwZTogcmVxdWVzdFR5cGUsXG4gICAgICBlbmNyeXB0ZWRPU2hhcmU6IHN0ZXAyUmV0dXJuLm9TaGFyZSBhcyBzdHJpbmcsXG4gICAgfSk7XG4gICAgLy8gc2lnbmluZyBzdGFnZSB0aHJlZSB3aXRoIFNTaGFyZSBzZW5kIHRvIGJpdGdvIGFuZCByZWNlaXZlcyBTU2hhcmVcbiAgICBhd2FpdCBFQ0RTQU1ldGhvZHMuc2VuZFNoYXJlVG9CaXRnbyhcbiAgICAgIHRoaXMuYml0Z28sXG4gICAgICB0aGlzLndhbGxldC5pZCgpLFxuICAgICAgdHhSZXF1ZXN0T2JqLnR4UmVxdWVzdElkLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICBTZW5kU2hhcmVUeXBlLlNTaGFyZSxcbiAgICAgIHVzZXJTU2hhcmUsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBwYXJhbXMucmVxSWRcbiAgICApO1xuICAgIHJldHVybiBhd2FpdCBnZXRUeFJlcXVlc3QodGhpcy5iaXRnbywgdGhpcy53YWxsZXQuaWQoKSwgdHhSZXF1ZXN0T2JqLnR4UmVxdWVzdElkLCBwYXJhbXMucmVxSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgc2lnbmluZyBrZXksIHR4UmVxdWVzdFJlc29sdmVkIGFuZCB0eFJlcXVlc3RJZFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFR4UmVxdWVzdH0gcGFyYW1zLnR4UmVxdWVzdCAtIHRyYW5zYWN0aW9uIHJlcXVlc3Qgb2JqZWN0IG9yIGlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucHJ2IC0gZGVjcnlwdGVkIHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSB7IHN0cmluZ30gcGFyYW1zLnJlcUlkIC0gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzaWduUmVxdWVzdEJhc2UoXG4gICAgcGFyYW1zOiBUU1NQYXJhbXNXaXRoUHJ2IHwgVFNTUGFyYW1zRm9yTWVzc2FnZVdpdGhQcnYsXG4gICAgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlXG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgY29uc3QgcGVuZGluZ0VjZHNhVHNzSW5pdGlhbGl6YXRpb24gPSB0aGlzLndhbGxldC5jb2luU3BlY2lmaWMoKT8ucGVuZGluZ0VjZHNhVHNzSW5pdGlhbGl6YXRpb247XG4gICAgaWYgKHBlbmRpbmdFY2RzYVRzc0luaXRpYWxpemF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdXYWxsZXQgaXMgbm90IHJlYWR5IGZvciBUU1MgRUNEU0Egc2lnbmluZy4gUGxlYXNlIGNvbnRhY3QgeW91ciBlbnRlcnByaXNlIGFkbWluIHRvIGZpbmlzaCB0aGUgZW50ZXJwcmlzZSBUU1MgaW5pdGlhbGl6YXRpb24uJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXNlclNpZ25pbmdNYXRlcmlhbDogRUNEU0FNZXRob2RUeXBlcy5TaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKHBhcmFtcy5wcnYpO1xuICAgIGlmICh1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZS5pICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXknKTtcbiAgICB9XG4gICAgaWYgKCF1c2VyU2lnbmluZ01hdGVyaWFsLmJhY2t1cE5TaGFyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXIga2V5IC0gbWlzc2luZyBiYWNrdXBOU2hhcmUnKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eFJlcXVlc3Q6IFR4UmVxdWVzdCA9XG4gICAgICB0eXBlb2YgcGFyYW1zLnR4UmVxdWVzdCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhd2FpdCBnZXRUeFJlcXVlc3QodGhpcy5iaXRnbywgdGhpcy53YWxsZXQuaWQoKSwgcGFyYW1zLnR4UmVxdWVzdCwgcGFyYW1zLnJlcUlkKVxuICAgICAgICA6IHBhcmFtcy50eFJlcXVlc3Q7XG5cbiAgICBsZXQgc2lnbmFibGVQYXlsb2FkID0gbmV3IEJ1ZmZlcignJyk7XG4gICAgbGV0IGRlcml2YXRpb25QYXRoID0gJyc7XG5cbiAgICBpZiAocmVxdWVzdFR5cGUgPT09IFJlcXVlc3RUeXBlLnR4KSB7XG4gICAgICBhc3NlcnQodHhSZXF1ZXN0LnRyYW5zYWN0aW9ucyB8fCB0eFJlcXVlc3QudW5zaWduZWRUeHMsICdVbmFibGUgdG8gZmluZCB0cmFuc2FjdGlvbnMgaW4gdHhSZXF1ZXN0Jyk7XG4gICAgICBjb25zdCB1bnNpZ25lZFR4ID1cbiAgICAgICAgdHhSZXF1ZXN0LmFwaVZlcnNpb24gPT09ICdmdWxsJyA/IHR4UmVxdWVzdC50cmFuc2FjdGlvbnMhWzBdLnVuc2lnbmVkVHggOiB0eFJlcXVlc3QudW5zaWduZWRUeHNbMF07XG4gICAgICBzaWduYWJsZVBheWxvYWQgPSBCdWZmZXIuZnJvbSh1bnNpZ25lZFR4LnNpZ25hYmxlSGV4LCAnaGV4Jyk7XG4gICAgICBkZXJpdmF0aW9uUGF0aCA9IHVuc2lnbmVkVHguZGVyaXZhdGlvblBhdGg7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0VHlwZSA9PT0gUmVxdWVzdFR5cGUubWVzc2FnZSkge1xuICAgICAgc2lnbmFibGVQYXlsb2FkID0gKHBhcmFtcyBhcyBUU1NQYXJhbXNGb3JNZXNzYWdlKS5idWZmZXJUb1NpZ247XG4gICAgICAvLyBUT0RPIEJHLTY3Mjk5IE1lc3NhZ2Ugc2lnbmluZyB3aXRoIGRlcml2YXRpb24gcGF0aFxuICAgIH1cbiAgICBjb25zdCBwYWlsbGllck1vZHVsdXMgPSB0aGlzLmdldE9mZmxpbmVTaWduZXJQYWlsbGllck1vZHVsdXMoeyBwcnY6IHBhcmFtcy5wcnYgfSk7XG4gICAgY29uc3QgY2hhbGxlbmdlcyA9IGF3YWl0IHRoaXMuZ2V0RWNkc2FTaWduaW5nQ2hhbGxlbmdlcyhcbiAgICAgIHR4UmVxdWVzdC50eFJlcXVlc3RJZCxcbiAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgcGFpbGxpZXJNb2R1bHVzLnVzZXJQYWlsbGllck1vZHVsdXMsXG4gICAgICAwLFxuICAgICAgcGFyYW1zLnJlcUlkXG4gICAgKTtcblxuICAgIGNvbnN0IHN0ZXAxUmV0dXJuID0gYXdhaXQgdGhpcy5jcmVhdGVUc3NFY2RzYVN0ZXAxU2lnbmluZ01hdGVyaWFsKHtcbiAgICAgIHBydjogcGFyYW1zLnBydixcbiAgICAgIGNoYWxsZW5nZXM6IGNoYWxsZW5nZXMsXG4gICAgICBkZXJpdmF0aW9uUGF0aDogZGVyaXZhdGlvblBhdGgsXG4gICAgfSk7XG5cbiAgICAvLyBzaWduaW5nIHN0YWdlIG9uZSB3aXRoIEsgc2hhcmUgc2VuZCB0byBiaXRnbyBhbmQgcmVjZWl2ZXMgQSBzaGFyZVxuICAgIGNvbnN0IGJpdGdvVG9Vc2VyQVNoYXJlID0gKGF3YWl0IEVDRFNBTWV0aG9kcy5zZW5kU2hhcmVUb0JpdGdvKFxuICAgICAgdGhpcy5iaXRnbyxcbiAgICAgIHRoaXMud2FsbGV0LmlkKCksXG4gICAgICB0eFJlcXVlc3QudHhSZXF1ZXN0SWQsXG4gICAgICByZXF1ZXN0VHlwZSxcbiAgICAgIFNlbmRTaGFyZVR5cGUuS1NoYXJlLFxuICAgICAgc3RlcDFSZXR1cm4ua1NoYXJlLFxuICAgICAgc3RlcDFSZXR1cm4uZW5jcnlwdGVkU2lnbmVyT2Zmc2V0U2hhcmUsXG4gICAgICBzdGVwMVJldHVybi52c3NQcm9vZixcbiAgICAgIHN0ZXAxUmV0dXJuLnByaXZhdGVTaGFyZVByb29mLFxuICAgICAgc3RlcDFSZXR1cm4ucHVibGljU2hhcmUsXG4gICAgICBzdGVwMVJldHVybi51c2VyUHVibGljR3BnS2V5LFxuICAgICAgcGFyYW1zLnJlcUlkXG4gICAgKSkgYXMgT21pdDxBU2hhcmUsICdudGlsZGUnIHwgJ2gxJyB8ICdoMic+OyAvLyBXUC9IU00gZG9lcyBub3QgcmV0dXJuIHRoZSBpbml0aWFsIGNoYWxsZW5nZVxuXG4gICAgY29uc3Qgc3RlcDJSZXR1cm4gPSBhd2FpdCB0aGlzLmNyZWF0ZVRzc0VjZHNhU3RlcDJTaWduaW5nTWF0ZXJpYWwoe1xuICAgICAgYVNoYXJlRnJvbUJpdGdvOiBiaXRnb1RvVXNlckFTaGFyZSxcbiAgICAgIGJpdGdvQ2hhbGxlbmdlOiBjaGFsbGVuZ2VzLmJpdGdvQ2hhbGxlbmdlLFxuICAgICAgd1NoYXJlOiBzdGVwMVJldHVybi53U2hhcmUgYXMgV1NoYXJlLFxuICAgIH0pO1xuXG4gICAgLy8gc2lnbmluZyBzdGFnZSB0d28gd2l0aCBtdVNoYXJlIGFuZCBkU2hhcmUgc2VuZCB0byBiaXRnbyBhbmQgcmVjZWl2ZXMgRCBzaGFyZVxuICAgIGNvbnN0IGJpdGdvVG9Vc2VyRFNoYXJlID0gKGF3YWl0IEVDRFNBTWV0aG9kcy5zZW5kU2hhcmVUb0JpdGdvKFxuICAgICAgdGhpcy5iaXRnbyxcbiAgICAgIHRoaXMud2FsbGV0LmlkKCksXG4gICAgICB0eFJlcXVlc3QudHhSZXF1ZXN0SWQsXG4gICAgICByZXF1ZXN0VHlwZSxcbiAgICAgIFNlbmRTaGFyZVR5cGUuTVVTaGFyZSxcbiAgICAgIHN0ZXAyUmV0dXJuLm11RFNoYXJlLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgcGFyYW1zLnJlcUlkXG4gICAgKSkgYXMgRFNoYXJlO1xuXG4gICAgLy8gSWYgb25seSB0aGUgZ2V0SGFzaEZ1bmN0aW9uKCkgaXMgZGVmaW5lZCBmb3IgdGhlIGNvaW4gdXNlIGl0IG90aGVyd2lzZVxuICAgIC8vIHBhc3MgdW5kZWZpbmVkIGhhc2gsIGRlZmF1bHQgaGFzaCB3aWxsIGJlIHVzZWQgaW4gdGhhdCBjYXNlLlxuICAgIGxldCBoYXNoOiBIYXNoIHwgdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBoYXNoID0gdGhpcy5iYXNlQ29pbi5nZXRIYXNoRnVuY3Rpb24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGhhc2ggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlclNTaGFyZSA9IGF3YWl0IEVDRFNBTWV0aG9kcy5jcmVhdGVVc2VyU2lnbmF0dXJlU2hhcmUoXG4gICAgICBzdGVwMlJldHVybi5vU2hhcmUgYXMgT1NoYXJlLFxuICAgICAgYml0Z29Ub1VzZXJEU2hhcmUsXG4gICAgICBzaWduYWJsZVBheWxvYWQsXG4gICAgICBoYXNoXG4gICAgKTtcblxuICAgIC8vIHNpZ25pbmcgc3RhZ2UgdGhyZWUgd2l0aCBTU2hhcmUgc2VuZCB0byBiaXRnbyBhbmQgcmVjZWl2ZXMgU1NoYXJlXG4gICAgYXdhaXQgRUNEU0FNZXRob2RzLnNlbmRTaGFyZVRvQml0Z28oXG4gICAgICB0aGlzLmJpdGdvLFxuICAgICAgdGhpcy53YWxsZXQuaWQoKSxcbiAgICAgIHR4UmVxdWVzdC50eFJlcXVlc3RJZCxcbiAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgU2VuZFNoYXJlVHlwZS5TU2hhcmUsXG4gICAgICB1c2VyU1NoYXJlLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgcGFyYW1zLnJlcUlkXG4gICAgKTtcbiAgICByZXR1cm4gYXdhaXQgZ2V0VHhSZXF1ZXN0KHRoaXMuYml0Z28sIHRoaXMud2FsbGV0LmlkKCksIHR4UmVxdWVzdC50eFJlcXVlc3RJZCwgcGFyYW1zLnJlcUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyB0aGUgdHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB0byB0aGUgdHJhbnNhY3Rpb24gcmVxdWVzdC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBUeFJlcXVlc3R9IHBhcmFtcy50eFJlcXVlc3QgLSB0cmFuc2FjdGlvbiByZXF1ZXN0IG9iamVjdCBvciBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBydiAtIGRlY3J5cHRlZCBwcml2YXRlIGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnJlcUlkIC0gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fSBmdWxseSBzaWduZWQgVHhSZXF1ZXN0IG9iamVjdFxuICAgKi9cbiAgYXN5bmMgc2lnblR4UmVxdWVzdChwYXJhbXM6IFRTU1BhcmFtc1dpdGhQcnYpOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQpO1xuICAgIHJldHVybiB0aGlzLnNpZ25SZXF1ZXN0QmFzZShwYXJhbXMsIFJlcXVlc3RUeXBlLnR4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyB0aGUgbWVzc2FnZSBhc3NvY2lhdGVkIHRvIHRoZSB0cmFuc2FjdGlvbiByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFR4UmVxdWVzdH0gcGFyYW1zLnR4UmVxdWVzdCAtIHRyYW5zYWN0aW9uIHJlcXVlc3Qgb2JqZWN0IG9yIGlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucHJ2IC0gZGVjcnlwdGVkIHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucmVxSWQgLSByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFR4UmVxdWVzdD59IGZ1bGx5IHNpZ25lZCBUeFJlcXVlc3Qgb2JqZWN0XG4gICAqL1xuICBhc3luYyBzaWduVHhSZXF1ZXN0Rm9yTWVzc2FnZShwYXJhbXM6IFRTU1BhcmFtc0Zvck1lc3NhZ2VXaXRoUHJ2KTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICBpZiAoIXBhcmFtcy5tZXNzYWdlUmF3KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhdyBtZXNzYWdlIHJlcXVpcmVkIHRvIHNpZ24gbWVzc2FnZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduUmVxdWVzdEJhc2UocGFyYW1zLCBSZXF1ZXN0VHlwZS5tZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNoYWxsZW5nZSB2YWx1ZXMgZm9yIGVudGVycHJpc2UgYW5kIEJpdEdvIGluIEVDRFNBIHNpZ25pbmdcbiAgICogT25seSByZXR1cm5zIHRoZSBjaGFsbGVuZ2VzIGlmIHRoZXkgYXJlIHZlcmlmaWVkIGJ5IHRoZSB1c2VyJ3MgZW50ZXJwcmlzZSBhZG1pbidzIGVjZGgga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eFJlcXVlc3RJZCAtIHRyYW5zYWN0aW9uIHJlcXVlc3QgaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0VHlwZX0gcmVxdWVzdFR5cGUgLSAgKDAgZm9yIHR4LCAxIGZvciBtZXNzYWdlKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0UGFpbGxpZXJNb2R1bHVzIC0gcGFpbGxpZXIgcHVia2V5ICRuJFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiB0aGUgcmVxdWVzdFR5cGVcbiAgICogQHBhcmFtIHtJUmVxdWVzdFRyYWNlcn0gcmVxSWQgLSByZXF1ZXN0IHRyYWNlciByZXF1ZXN0IGlkXG4gICAqL1xuICBhc3luYyBnZXRFY2RzYVNpZ25pbmdDaGFsbGVuZ2VzKFxuICAgIHR4UmVxdWVzdElkOiBzdHJpbmcsXG4gICAgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlLFxuICAgIHdhbGxldFBhaWxsaWVyTW9kdWx1czogc3RyaW5nLFxuICAgIGluZGV4ID0gMCxcbiAgICByZXFJZD86IElSZXF1ZXN0VHJhY2VyXG4gICk6IFByb21pc2U8e1xuICAgIGVudGVycHJpc2VDaGFsbGVuZ2U6IEVjZHNhVHlwZXMuU2VyaWFsaXplZEVjZHNhQ2hhbGxlbmdlcztcbiAgICBiaXRnb0NoYWxsZW5nZTogVHhSZXF1ZXN0Q2hhbGxlbmdlUmVzcG9uc2U7XG4gIH0+IHtcbiAgICBjb25zdCBlbnRlcnByaXNlSWQgPSB0aGlzLndhbGxldC50b0pTT04oKS5lbnRlcnByaXNlO1xuICAgIGlmICghZW50ZXJwcmlzZUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBtdXN0IGJlIGFuIGVudGVycHJpc2Ugd2FsbGV0LicpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBCaXRHbyByYW5nZSBwcm9vZiBhbmQgcGFpbGxpZXIgcHJvb2YgY2hhbGxlbmdlXG4gICAgY29uc3QgY3JlYXRlQml0Z29DaGFsbGVuZ2VSZXNwb25zZSA9IGF3YWl0IGdldFR4UmVxdWVzdENoYWxsZW5nZShcbiAgICAgIHRoaXMuYml0Z28sXG4gICAgICB0aGlzLndhbGxldC5pZCgpLFxuICAgICAgdHhSZXF1ZXN0SWQsXG4gICAgICBpbmRleC50b1N0cmluZygpLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICB3YWxsZXRQYWlsbGllck1vZHVsdXMsXG4gICAgICByZXFJZFxuICAgICk7XG5cbiAgICBjb25zdCBiaXRnb1RvRW50ZXJwcmlzZVBhaWxsaWVyQ2hhbGxlbmdlID0geyBwOiBjcmVhdGVCaXRnb0NoYWxsZW5nZVJlc3BvbnNlLnAgfTtcbiAgICBjb25zdCBlbnRlcnByaXNlVG9CaXRnb1BhaWxsaWVyQ2hhbGxlbmdlID0gRWNkc2FUeXBlcy5zZXJpYWxpemVQYWlsbGllckNoYWxsZW5nZSh7XG4gICAgICBwOiBhd2FpdCBFY2RzYVBhaWxsaWVyUHJvb2YuZ2VuZXJhdGVQKGhleFRvQmlnSW50KGNyZWF0ZUJpdGdvQ2hhbGxlbmdlUmVzcG9uc2UubikpLFxuICAgIH0pO1xuXG4gICAgLy8gVE9ETyhCRy03ODc2NCk6IG9uY2UgdGhlIHBhaWxsaWVyIHByb29mcyBhcmUgY29tcGxldGUsIHJlZHVjZSBjaGFsbGVuZ2UgY3JlYXRpb24gdG8gb25lIEFQSSBjYWxsXG4gICAgY29uc3Qgd2FsbGV0Q2hhbGxlbmdlcyA9IGF3YWl0IHRoaXMud2FsbGV0LmdldENoYWxsZW5nZXNGb3JFY2RzYVNpZ25pbmcoKTtcblxuICAgIGNvbnN0IGNoYWxsZW5nZVZlcmlmaWVyVXNlcklkID0gd2FsbGV0Q2hhbGxlbmdlcy5jcmVhdGVkQnk7XG4gICAgY29uc3QgYWRtaW5TaWduaW5nS2V5UmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpdGdvLmdldFNpZ25pbmdLZXlGb3JVc2VyKGVudGVycHJpc2VJZCwgY2hhbGxlbmdlVmVyaWZpZXJVc2VySWQpO1xuICAgIGNvbnN0IHB1YmtleU9mQWRtaW5FY2RoS2V5SGV4ID0gYWRtaW5TaWduaW5nS2V5UmVzcG9uc2UuZGVyaXZlZFB1YmtleTtcblxuICAgIC8vIFZlcmlmeSBlbnRlcnByaXNlJ3MgY2hhbGxlbmdlIGlzIHNpZ25lZCBieSB0aGUgcmVzcGVjdGl2ZSBhZG1pbnMgZWNkaCBrZXljaGFpblxuICAgIGNvbnN0IGVudGVycHJpc2VSYXdDaGFsbGVuZ2UgPSB7XG4gICAgICBudGlsZGU6IHdhbGxldENoYWxsZW5nZXMuZW50ZXJwcmlzZUNoYWxsZW5nZS5udGlsZGUsXG4gICAgICBoMTogd2FsbGV0Q2hhbGxlbmdlcy5lbnRlcnByaXNlQ2hhbGxlbmdlLmgxLFxuICAgICAgaDI6IHdhbGxldENoYWxsZW5nZXMuZW50ZXJwcmlzZUNoYWxsZW5nZS5oMixcbiAgICB9O1xuICAgIGNvbnN0IGFkbWluU2lnbmF0dXJlT25FbnRDaGFsbGVuZ2U6IHN0cmluZyA9IHdhbGxldENoYWxsZW5nZXMuZW50ZXJwcmlzZUNoYWxsZW5nZS52ZXJpZmllcnMuYWRtaW5TaWduYXR1cmU7XG4gICAgaWYgKFxuICAgICAgIXZlcmlmeUVjZGhTaWduYXR1cmUoXG4gICAgICAgIEVjZHNhVXRpbHMuZ2V0TWVzc2FnZVRvU2lnbkZyb21DaGFsbGVuZ2UoZW50ZXJwcmlzZVJhd0NoYWxsZW5nZSksXG4gICAgICAgIGFkbWluU2lnbmF0dXJlT25FbnRDaGFsbGVuZ2UsXG4gICAgICAgIEJ1ZmZlci5mcm9tKHB1YmtleU9mQWRtaW5FY2RoS2V5SGV4LCAnaGV4JylcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRtaW4gc2lnbmF0dXJlIGZvciBlbnRlcnByaXNlIGNoYWxsZW5nZSBpcyBub3QgdmFsaWQuIFBsZWFzZSBjb250YWN0IHlvdXIgZW50ZXJwcmlzZSBhZG1pbi5gKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgQml0R28gY2hhbGxlbmdlJ3MgWksgcHJvb2ZzIGhhdmUgYmVlbiB2ZXJpZmllZCBieSB0aGUgYWRtaW5cbiAgICBjb25zdCBiaXRnb0NoYWxsZW5nZTogVHhSZXF1ZXN0Q2hhbGxlbmdlUmVzcG9uc2UgPSB7XG4gICAgICBudGlsZGU6IHdhbGxldENoYWxsZW5nZXMuYml0Z29DaGFsbGVuZ2UubnRpbGRlLFxuICAgICAgaDE6IHdhbGxldENoYWxsZW5nZXMuYml0Z29DaGFsbGVuZ2UuaDEsXG4gICAgICBoMjogd2FsbGV0Q2hhbGxlbmdlcy5iaXRnb0NoYWxsZW5nZS5oMixcbiAgICAgIHA6IGJpdGdvVG9FbnRlcnByaXNlUGFpbGxpZXJDaGFsbGVuZ2UucCxcbiAgICAgIG46IGNyZWF0ZUJpdGdvQ2hhbGxlbmdlUmVzcG9uc2UubixcbiAgICB9O1xuICAgIGNvbnN0IGFkbWluVmVyaWZpY2F0aW9uU2lnbmF0dXJlRm9yQml0R29DaGFsbGVuZ2UgPSB3YWxsZXRDaGFsbGVuZ2VzLmJpdGdvQ2hhbGxlbmdlLnZlcmlmaWVycy5hZG1pblNpZ25hdHVyZTtcbiAgICBpZiAoXG4gICAgICAhdmVyaWZ5RWNkaFNpZ25hdHVyZShcbiAgICAgICAgRWNkc2FVdGlscy5nZXRNZXNzYWdlVG9TaWduRnJvbUNoYWxsZW5nZShiaXRnb0NoYWxsZW5nZSksXG4gICAgICAgIGFkbWluVmVyaWZpY2F0aW9uU2lnbmF0dXJlRm9yQml0R29DaGFsbGVuZ2UsXG4gICAgICAgIEJ1ZmZlci5mcm9tKHB1YmtleU9mQWRtaW5FY2RoS2V5SGV4LCAnaGV4JylcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRtaW4gc2lnbmF0dXJlIGZvciBCaXRHbydzIGNoYWxsZW5nZSBpcyBub3QgdmFsaWQuIFBsZWFzZSBjb250YWN0IHlvdXIgZW50ZXJwcmlzZSBhZG1pbi5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW50ZXJwcmlzZUNoYWxsZW5nZToge1xuICAgICAgICAuLi5lbnRlcnByaXNlUmF3Q2hhbGxlbmdlLFxuICAgICAgICBwOiBlbnRlcnByaXNlVG9CaXRnb1BhaWxsaWVyQ2hhbGxlbmdlLnAsXG4gICAgICB9LFxuICAgICAgYml0Z29DaGFsbGVuZ2UsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgdS12YWx1ZSBwcm9vZnMgYW5kIEdQRyBrZXlzIHVzZWQgaW4gZ2VuZXJhdGluZyBhIFRTUyBFQ0RTQSB3YWxsZXQuXG4gICAqIEBwYXJhbSB1c2VyR3BnUHViIFRoZSB1c2VyJ3MgcHVibGljIEdQRyBrZXkgZm9yIGVuY3J5cHRpb24gYmV0d2VlbiB1c2VyL3NlcnZlclxuICAgKiBAcGFyYW0gYmFja3VwR3BnUHViIFRoZSBiYWNrdXAncyBwdWJsaWMgR1BHIGtleSBmb3IgZW5jcnlwdGlvbiBiZXR3ZWVuIGJhY2t1cC9zZXJ2ZXJcbiAgICogQHBhcmFtIGJpdGdvS2V5Y2hhaW4gcHJldmlvdXNseSBjcmVhdGVkIEJpdEdvIGtleWNoYWluOyBtdXN0IGJlIGNvbXBhdGlibGUgd2l0aCB1c2VyIGFuZCBiYWNrdXAga2V5IHNoYXJlc1xuICAgKiBAcGFyYW0gZGVjcnlwdGVkU2hhcmUgVGhlIGRlY3J5cHRlZCBiaXRnby10by11c2VyL2JhY2t1cCBwcml2YXRlIHNoYXJlIHJldHJpZXZlZCBmcm9tIHRoZSBrZXljaGFpblxuICAgKiBAcGFyYW0gdmVyaWZpZXJJbmRleCBUaGUgaW5kZXggb2YgdGhlIHBhcnR5IHRvIHZlcmlmeTogMSA9IHVzZXIsIDIgPSBiYWNrdXBcbiAgICovXG4gIGFzeW5jIHZlcmlmeVdhbGxldFNpZ25hdHVyZXMoXG4gICAgdXNlckdwZ1B1Yjogc3RyaW5nLFxuICAgIGJhY2t1cEdwZ1B1Yjogc3RyaW5nLFxuICAgIGJpdGdvS2V5Y2hhaW46IEtleWNoYWluLFxuICAgIGRlY3J5cHRlZFNoYXJlOiBzdHJpbmcsXG4gICAgdmVyaWZpZXJJbmRleDogMSB8IDJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXNzZXJ0KGJpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4pO1xuICAgIGFzc2VydChiaXRnb0tleWNoYWluLndhbGxldEhTTUdQR1B1YmxpY0tleVNpZ3MpO1xuXG4gICAgY29uc3QgYml0Z29HcGdLZXkgPSAoYXdhaXQgZ2V0Qml0Z29HcGdQdWJLZXkodGhpcy5iaXRnbykpLm1wY1YxO1xuICAgIGNvbnN0IHVzZXJLZXlQdWIgPSBhd2FpdCBvcGVucGdwLnJlYWRLZXkoeyBhcm1vcmVkS2V5OiB1c2VyR3BnUHViIH0pO1xuICAgIGNvbnN0IHVzZXJLZXlJZCA9IHVzZXJLZXlQdWIua2V5UGFja2V0LmdldEZpbmdlcnByaW50KCk7XG4gICAgY29uc3QgYmFja3VwS2V5UHViID0gYXdhaXQgb3BlbnBncC5yZWFkS2V5KHsgYXJtb3JlZEtleTogYmFja3VwR3BnUHViIH0pO1xuICAgIGNvbnN0IGJhY2t1cEtleUlkID0gYmFja3VwS2V5UHViLmtleVBhY2tldC5nZXRGaW5nZXJwcmludCgpO1xuXG4gICAgY29uc3Qgd2FsbGV0U2lnbmF0dXJlcyA9IGF3YWl0IG9wZW5wZ3AucmVhZEtleXMoeyBhcm1vcmVkS2V5czogYml0Z29LZXljaGFpbi53YWxsZXRIU01HUEdQdWJsaWNLZXlTaWdzIH0pO1xuICAgIGlmICh3YWxsZXRTaWduYXR1cmVzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdhbGxldCBzaWduYXR1cmVzJyk7XG4gICAgfVxuICAgIGlmICh1c2VyS2V5SWQgIT09IHdhbGxldFNpZ25hdHVyZXNbMF0ua2V5UGFja2V0LmdldEZpbmdlcnByaW50KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZmlyc3Qgd2FsbGV0IHNpZ25hdHVyZSdzIGZpbmdlcnByaW50IGRvZXMgbm90IG1hdGNoIHBhc3NlZCB1c2VyIGdwZyBrZXkncyBmaW5nZXJwcmludGApO1xuICAgIH1cbiAgICBpZiAoYmFja3VwS2V5SWQgIT09IHdhbGxldFNpZ25hdHVyZXNbMV0ua2V5UGFja2V0LmdldEZpbmdlcnByaW50KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2Vjb25kIHdhbGxldCBzaWduYXR1cmUncyBmaW5nZXJwcmludCBkb2VzIG5vdCBtYXRjaCBwYXNzZWQgYmFja3VwIGdwZyBrZXkncyBmaW5nZXJwcmludGApO1xuICAgIH1cblxuICAgIGF3YWl0IHZlcmlmeVdhbGxldFNpZ25hdHVyZSh7XG4gICAgICB3YWxsZXRTaWduYXR1cmU6IHdhbGxldFNpZ25hdHVyZXNbMF0sXG4gICAgICBjb21tb25LZXljaGFpbjogYml0Z29LZXljaGFpbi5jb21tb25LZXljaGFpbixcbiAgICAgIHVzZXJLZXlJZCxcbiAgICAgIGJhY2t1cEtleUlkLFxuICAgICAgYml0Z29QdWI6IGJpdGdvR3BnS2V5LFxuICAgICAgZGVjcnlwdGVkU2hhcmUsXG4gICAgICB2ZXJpZmllckluZGV4LFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdmVyaWZ5V2FsbGV0U2lnbmF0dXJlKHtcbiAgICAgIHdhbGxldFNpZ25hdHVyZTogd2FsbGV0U2lnbmF0dXJlc1sxXSxcbiAgICAgIGNvbW1vbktleWNoYWluOiBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluLFxuICAgICAgdXNlcktleUlkLFxuICAgICAgYmFja3VwS2V5SWQsXG4gICAgICBiaXRnb1B1YjogYml0Z29HcGdLZXksXG4gICAgICBkZWNyeXB0ZWRTaGFyZSxcbiAgICAgIHZlcmlmaWVySW5kZXgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbnMgYSBjaGFsbGVuZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgdjEgZWNkaCBrZXkgYXQgYSBkZXJpdmVkIHBhdGhcbiAgICogQHBhcmFtIGNoYWxsZW5nZSBjaGFsbGVuZ2UgdG8gc2lnblxuICAgKiBAcGFyYW0gZWNkaFhwcnYgeHBydiBvZiB0aGUgZWNkaCBrZXlcbiAgICogQHBhcmFtIGRlcml2YXRpb25QYXRoIHRoZSBkZXJpdmVkIHBhdGggYXQgd2hpY2ggdGhlIGVjZGgga2V5IHdpbGwgc2lnblxuICAgKi9cbiAgc3RhdGljIHNpZ25DaGFsbGVuZ2UoY2hhbGxlbmdlOiBFY2RzYVR5cGVzLlNlcmlhbGl6ZWROdGlsZGUsIGVjZGhYcHJ2OiBzdHJpbmcsIGRlcml2YXRpb25QYXRoOiBzdHJpbmcpOiBCdWZmZXIge1xuICAgIGNvbnN0IG1lc3NhZ2VUb1NpZ24gPSB0aGlzLmdldE1lc3NhZ2VUb1NpZ25Gcm9tQ2hhbGxlbmdlKGNoYWxsZW5nZSk7XG4gICAgcmV0dXJuIHNpZ25NZXNzYWdlV2l0aERlcml2ZWRFY2RoS2V5KG1lc3NhZ2VUb1NpZ24sIGVjZGhYcHJ2LCBkZXJpdmF0aW9uUGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgY2hhbGxlbmdlIHRvIGEgY29tbW9uIG1lc3NhZ2UgZm9ybWF0IHdoaWNoIGNhbiBiZSBzaWduZWQuXG4gICAqIEBwYXJhbSBjaGFsbGVuZ2VcbiAgICovXG4gIHN0YXRpYyBnZXRNZXNzYWdlVG9TaWduRnJvbUNoYWxsZW5nZShjaGFsbGVuZ2U6IEVjZHNhVHlwZXMuU2VyaWFsaXplZE50aWxkZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNoYWxsZW5nZS5udGlsZGUuY29uY2F0KGNoYWxsZW5nZS5oMSkuY29uY2F0KGNoYWxsZW5nZS5oMik7XG4gIH1cblxuICAvKipcbiAgIFZlcmlmaWVzIFpLIHByb29mcyBvZiBCaXRHbydzIGNoYWxsZW5nZXMgZm9yIGJvdGggbml0cm8gYW5kIGluc3RpdHV0aW9uYWwgSFNNc1xuICAgd2hpY2ggYXJlIGZldGNoZWQgZnJvbSB0aGUgV1AgQVBJLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHZlcmlmeUJpdEdvQ2hhbGxlbmdlcyhiaXRnb0NoYWxsZW5nZXM6IEdldEJpdEdvQ2hhbGxlbmdlc0FwaSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIC8vIFZlcmlmeSBpbnN0aXR1dGlvbmFsIGhzbSBjaGFsbGVuZ2UgcHJvb2ZcbiAgICBjb25zdCBpbnN0Q2hhbGxlbmdlVmVyaWZpZWQgPSBhd2FpdCB0aGlzLnZlcmlmeUJpdEdvQ2hhbGxlbmdlKHtcbiAgICAgIG50aWxkZTogYml0Z29DaGFsbGVuZ2VzLmJpdGdvSW5zdGl0dXRpb25hbEhzbS5udGlsZGUsXG4gICAgICBoMTogYml0Z29DaGFsbGVuZ2VzLmJpdGdvSW5zdGl0dXRpb25hbEhzbS5oMSxcbiAgICAgIGgyOiBiaXRnb0NoYWxsZW5nZXMuYml0Z29JbnN0aXR1dGlvbmFsSHNtLmgyLFxuICAgICAgbnRpbGRlUHJvb2Y6IGJpdGdvQ2hhbGxlbmdlcy5iaXRnb0luc3RpdHV0aW9uYWxIc20ubnRpbGRlUHJvb2YsXG4gICAgfSk7XG5cbiAgICAvLyBWZXJpZnkgbml0cm8gaHNtIGNoYWxsZW5nZSBwcm9vZlxuICAgIGNvbnN0IG5pdHJvQ2hhbGxlbmdlVmVyaWZpZWQgPSBhd2FpdCB0aGlzLnZlcmlmeUJpdEdvQ2hhbGxlbmdlKHtcbiAgICAgIG50aWxkZTogYml0Z29DaGFsbGVuZ2VzLmJpdGdvTml0cm9Ic20ubnRpbGRlLFxuICAgICAgaDE6IGJpdGdvQ2hhbGxlbmdlcy5iaXRnb05pdHJvSHNtLmgxLFxuICAgICAgaDI6IGJpdGdvQ2hhbGxlbmdlcy5iaXRnb05pdHJvSHNtLmgyLFxuICAgICAgbnRpbGRlUHJvb2Y6IGJpdGdvQ2hhbGxlbmdlcy5iaXRnb05pdHJvSHNtLm50aWxkZVByb29mLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluc3RDaGFsbGVuZ2VWZXJpZmllZCAmJiBuaXRyb0NoYWxsZW5nZVZlcmlmaWVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIFpLIHByb29mIGZvciBhIHNpbmdsZSBCaXRHbyBjaGFsbGVuZ2VcbiAgICogQHBhcmFtIGJpdGdvQ2hhbGxlbmdlXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdmVyaWZ5Qml0R29DaGFsbGVuZ2UoYml0Z29DaGFsbGVuZ2U6IEVjZHNhVHlwZXMuU2VyaWFsaXplZE50aWxkZVdpdGhQcm9vZnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBkZXNlcmlhbGl6ZWRJbnN0Q2hhbGxlbmdlID0gRWNkc2FUeXBlcy5kZXNlcmlhbGl6ZU50aWxkZVdpdGhQcm9vZnMoYml0Z29DaGFsbGVuZ2UpO1xuICAgIGNvbnN0IG50aWxkZVByb29mSDFXcnRIMlZlcmlmaWVkID0gYXdhaXQgRWNkc2FSYW5nZVByb29mLnZlcmlmeU50aWxkZVByb29mKFxuICAgICAge1xuICAgICAgICBudGlsZGU6IGRlc2VyaWFsaXplZEluc3RDaGFsbGVuZ2UubnRpbGRlLFxuICAgICAgICBoMTogZGVzZXJpYWxpemVkSW5zdENoYWxsZW5nZS5oMSxcbiAgICAgICAgaDI6IGRlc2VyaWFsaXplZEluc3RDaGFsbGVuZ2UuaDIsXG4gICAgICB9LFxuICAgICAgZGVzZXJpYWxpemVkSW5zdENoYWxsZW5nZS5udGlsZGVQcm9vZi5oMVdydEgyXG4gICAgKTtcbiAgICBjb25zdCBudGlsZGVQcm9vZkgyV3J0SDFWZXJpZmllZCA9IGF3YWl0IEVjZHNhUmFuZ2VQcm9vZi52ZXJpZnlOdGlsZGVQcm9vZihcbiAgICAgIHtcbiAgICAgICAgbnRpbGRlOiBkZXNlcmlhbGl6ZWRJbnN0Q2hhbGxlbmdlLm50aWxkZSxcbiAgICAgICAgaDE6IGRlc2VyaWFsaXplZEluc3RDaGFsbGVuZ2UuaDIsXG4gICAgICAgIGgyOiBkZXNlcmlhbGl6ZWRJbnN0Q2hhbGxlbmdlLmgxLFxuICAgICAgfSxcbiAgICAgIGRlc2VyaWFsaXplZEluc3RDaGFsbGVuZ2UubnRpbGRlUHJvb2YuaDJXcnRIMVxuICAgICk7XG4gICAgcmV0dXJuIG50aWxkZVByb29mSDFXcnRIMlZlcmlmaWVkICYmIG50aWxkZVByb29mSDJXcnRIMVZlcmlmaWVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGJpdGdvIGNoYWxsZW5nZXMgZm9yIGJvdGggbml0cm8gYW5kIGluc3RpdHV0aW9uYWwgSFNNcyBmcm9tIFdQIEFQSS5cbiAgICogQHBhcmFtIGJpdGdvXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0Qml0R29DaGFsbGVuZ2VzKGJpdGdvOiBCaXRHb0Jhc2UpOiBQcm9taXNlPEdldEJpdEdvQ2hhbGxlbmdlc0FwaT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGJpdGdvLmdldChiaXRnby51cmwoJy90c3MvZWNkc2EvY2hhbGxlbmdlcycsIDIpKS5zZW5kKCkucmVzdWx0KCk7XG4gICAgaWYgKFxuICAgICAgIXJlcy5iaXRnb05pdHJvSHNtIHx8XG4gICAgICAhcmVzLmJpdGdvTml0cm9Ic20ubnRpbGRlIHx8XG4gICAgICAhcmVzLmJpdGdvTml0cm9Ic20uaDEgfHxcbiAgICAgICFyZXMuYml0Z29OaXRyb0hzbS5oMiB8fFxuICAgICAgIXJlcy5iaXRnb05pdHJvSHNtLm50aWxkZVByb29mIHx8XG4gICAgICAhcmVzLmJpdGdvSW5zdGl0dXRpb25hbEhzbSB8fFxuICAgICAgIXJlcy5iaXRnb0luc3RpdHV0aW9uYWxIc20ubnRpbGRlIHx8XG4gICAgICAhcmVzLmJpdGdvSW5zdGl0dXRpb25hbEhzbS5oMSB8fFxuICAgICAgIXJlcy5iaXRnb0luc3RpdHV0aW9uYWxIc20uaDIgfHxcbiAgICAgICFyZXMuYml0Z29JbnN0aXR1dGlvbmFsSHNtLm50aWxkZVByb29mXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIEJpdEdvIGNoYWxsZW5nZSBwcm9vZiB0byBiZSBwcmVzZW50LiBDb250YWN0IHN1cHBvcnRAYml0Z28uY29tLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgQml0R28ncyBwcm9vZnMgZnJvbSBBUEkgYW5kIHNpZ25zIHRoZW0gaWYgdGhlIHByb29mcyBhcmUgdmFsaWQuXG4gICAqIEBwYXJhbSBiaXRnb1xuICAgKiBAcGFyYW0gZW50ZXJwcmlzZUlkXG4gICAqIEBwYXJhbSB1c2VyUGFzc3dvcmRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRWZXJpZnlBbmRTaWduQml0R29DaGFsbGVuZ2VzKFxuICAgIGJpdGdvOiBCaXRHb0Jhc2UsXG4gICAgZW50ZXJwcmlzZUlkOiBzdHJpbmcsXG4gICAgdXNlclBhc3N3b3JkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxCaXRHb1Byb29mU2lnbmF0dXJlcz4ge1xuICAgIC8vIEZldGNoIEJpdEdvJ3MgY2hhbGxlbmdlIGFuZCB2ZXJpZnlcbiAgICBjb25zdCBiaXRnb0NoYWxsZW5nZXNXaXRoUHJvb2ZzID0gYXdhaXQgRWNkc2FVdGlscy5nZXRCaXRHb0NoYWxsZW5nZXMoYml0Z28pO1xuICAgIGlmICghKGF3YWl0IEVjZHNhVXRpbHMudmVyaWZ5Qml0R29DaGFsbGVuZ2VzKGJpdGdvQ2hhbGxlbmdlc1dpdGhQcm9vZnMpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHZlcmlmeSBCaXRHbydzIGNoYWxsZW5nZSBuZWVkZWQgdG8gZW5hYmxlIEVDRFNBIHNpZ25pbmcuIFBsZWFzZSBjb250YWN0IHN1cHBvcnRAYml0Z28uY29tYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IEVjZHNhVXRpbHMuc2lnbkJpdGdvQ2hhbGxlbmdlcyhiaXRnbywgZW50ZXJwcmlzZUlkLCB1c2VyUGFzc3dvcmQsIGJpdGdvQ2hhbGxlbmdlc1dpdGhQcm9vZnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gQml0Z28ncyBwcm9vZnMsIHZlcmlmaWNhdGlvbiBvZiBwcm9vZnMgaXMgbGVmdCB0byB0aGUgY2FsbGVyXG4gICAqIEBwYXJhbSBiaXRnb1xuICAgKiBAcGFyYW0gZW50ZXJwcmlzZUlkXG4gICAqIEBwYXJhbSB1c2VyUGFzc3dvcmRcbiAgICogQHBhcmFtIGJpdGdvQ2hhbGxlbmdlc1dpdGhQcm9vZnMgT3B0aW9uYWxseSBwcm92aWRlIEJpdGdvIENoYWxsYWVuZ2UgJiBQcm9vZnMgaW5zdGVhZCBvZiBmZXRjaGluZyBmcm9tIEFQSVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHNpZ25CaXRnb0NoYWxsZW5nZXMoXG4gICAgYml0Z286IEJpdEdvQmFzZSxcbiAgICBlbnRlcnByaXNlSWQ6IHN0cmluZyxcbiAgICB1c2VyUGFzc3dvcmQ6IHN0cmluZyxcbiAgICBiaXRnb0NoYWxsZW5nZXNXaXRoUHJvb2ZzPzogR2V0Qml0R29DaGFsbGVuZ2VzQXBpXG4gICk6IFByb21pc2U8Qml0R29Qcm9vZlNpZ25hdHVyZXM+IHtcbiAgICAvLyBmZXRjaCBjaGFsbGVuZ2UgJiBwcm9vZiBpZiBub25lIGFyZSBwcm92aWRlZFxuICAgIGNvbnN0IGNoYWxsZW5nZXNXaXRoUHJvb2ZzID0gYml0Z29DaGFsbGVuZ2VzV2l0aFByb29mc1xuICAgICAgPyBiaXRnb0NoYWxsZW5nZXNXaXRoUHJvb2ZzXG4gICAgICA6IGF3YWl0IEVjZHNhVXRpbHMuZ2V0Qml0R29DaGFsbGVuZ2VzKGJpdGdvKTtcblxuICAgIC8vIEZldGNoIHVzZXIncyBlY2RoIHB1YmxpYyBrZXljaGFpbiBuZWVkZWQgZm9yIHNpZ25pbmcgdGhlIGNoYWxsZW5nZXNcbiAgICBjb25zdCBlY2RoS2V5cGFpciA9IGF3YWl0IGJpdGdvLmdldEVjZGhLZXlwYWlyUHJpdmF0ZSh1c2VyUGFzc3dvcmQsIGVudGVycHJpc2VJZCk7XG5cbiAgICBjb25zdCBzaWduZWRCaXRHb0luc3RDaGFsbGVuZ2UgPSBFY2RzYVV0aWxzLnNpZ25DaGFsbGVuZ2UoXG4gICAgICBjaGFsbGVuZ2VzV2l0aFByb29mcy5iaXRnb0luc3RpdHV0aW9uYWxIc20sXG4gICAgICBlY2RoS2V5cGFpci54cHJ2LFxuICAgICAgZWNkaEtleXBhaXIuZGVyaXZhdGlvblBhdGhcbiAgICApO1xuICAgIGNvbnN0IHNpZ25lZEJpdEdvTml0cm9DaGFsbGVuZ2UgPSBFY2RzYVV0aWxzLnNpZ25DaGFsbGVuZ2UoXG4gICAgICBjaGFsbGVuZ2VzV2l0aFByb29mcy5iaXRnb05pdHJvSHNtLFxuICAgICAgZWNkaEtleXBhaXIueHBydixcbiAgICAgIGVjZGhLZXlwYWlyLmRlcml2YXRpb25QYXRoXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgYml0Z29JbnN0SHNtQWRtaW5TaWduYXR1cmU6IHNpZ25lZEJpdEdvSW5zdENoYWxsZW5nZSxcbiAgICAgIGJpdGdvTml0cm9Ic21BZG1pblNpZ25hdHVyZTogc2lnbmVkQml0R29OaXRyb0NoYWxsZW5nZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGVuYWJsZSBlY2RzYSBzaWduaW5nIG9uIHRoZSBlbnRlcnByaXNlLlxuICAgKiBJdCByZWNlaXZlcyB0aGUgZW50ZXJwcmlzZSBjaGFsbGVuZ2UgYW5kIHNpZ25hdHVyZXMgb2YgdmVyaWZpZWQgYml0Z28gcHJvb2ZzXG4gICAqIGFuZCB1cGxvYWRzIHRoZW0gb24gdGhlIGVudGVycHJpc2UuXG4gICAqIEBwYXJhbSBiaXRnb1xuICAgKiBAcGFyYW0gZW50SWQgLSBlbnRlcnByaXNlIGlkIHRvIGVuYWJsZSBlY2RzYSBzaWduaW5nIG9uXG4gICAqIEBwYXJhbSB1c2VyUGFzc3dvcmQgLSBlbnRlcnByaXNlIGFkbWluJ3MgbG9naW4gcHdcbiAgICogQHBhcmFtIGJpdGdvSW5zdENoYWxsZW5nZVByb29mU2lnbmF0dXJlIC0gc2lnbmF0dXJlIG9uIGJpdGdvJ3MgaW5zdGl0dXRpb25hbCBIU00gY2hhbGxlbmdlIGFmdGVyIHZlcmlmaWNhdGlvblxuICAgKiBAcGFyYW0gYml0Z29OaXRyb0NoYWxsZW5nZVByb29mU2lnbmF0dXJlIC0gc2lnbmF0dXJlIG9uIGJpdGdvJ3Mgbml0cm8gSFNNIGNoYWxsZW5nZSBhZnRlciB2ZXJpZmljYXRpb25cbiAgICogQHBhcmFtIGNoYWxsZW5nZSAtIG9wdGlvbmFsbHkgdXNlIHRoZSBjaGFsbGVuZ2UgZm9yIGVudGVycHJpc2UgY2hhbGxlbmdlXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgaW5pdGlhdGVDaGFsbGVuZ2VzRm9yRW50ZXJwcmlzZShcbiAgICBiaXRnbzogQml0R29CYXNlLFxuICAgIGVudElkOiBzdHJpbmcsXG4gICAgdXNlclBhc3N3b3JkOiBzdHJpbmcsXG4gICAgYml0Z29JbnN0Q2hhbGxlbmdlUHJvb2ZTaWduYXR1cmU6IEJ1ZmZlcixcbiAgICBiaXRnb05pdHJvQ2hhbGxlbmdlUHJvb2ZTaWduYXR1cmU6IEJ1ZmZlcixcbiAgICBvcGVuU1NMQnl0ZXM6IFVpbnQ4QXJyYXksXG4gICAgY2hhbGxlbmdlPzogRWNkc2FUeXBlcy5EZXNlcmlhbGl6ZWROdGlsZGVXaXRoUHJvb2ZzXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEZldGNoIHVzZXIncyBlY2RoIHB1YmxpYyBrZXljaGFpbiBuZWVkZWQgZm9yIHNpZ25pbmcgdGhlIGNoYWxsZW5nZXNcbiAgICBjb25zdCBlY2RoS2V5cGFpciA9IGF3YWl0IGJpdGdvLmdldEVjZGhLZXlwYWlyUHJpdmF0ZSh1c2VyUGFzc3dvcmQsIGVudElkKTtcblxuICAgIC8vIEdlbmVyYXRlIGFuZCBzaWduIGVudGVycHJpc2UgY2hhbGxlbmdlXG4gICAgY29uc3QgZW50Q2hhbGxlbmdlV2l0aFByb29mID1cbiAgICAgIGNoYWxsZW5nZSA/PyAoYXdhaXQgRWNkc2FSYW5nZVByb29mLmdlbmVyYXRlTnRpbGRlKG9wZW5TU0xCeXRlcywgbWluTW9kdWx1c0JpdExlbmd0aCkpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRFbnRDaGFsbGVuZ2VXaXRoUHJvb2YgPSBFY2RzYVR5cGVzLnNlcmlhbGl6ZU50aWxkZVdpdGhQcm9vZnMoZW50Q2hhbGxlbmdlV2l0aFByb29mKTtcbiAgICBjb25zdCBzaWduZWRFbnRlcnByaXNlQ2hhbGxlbmdlID0gRWNkc2FVdGlscy5zaWduQ2hhbGxlbmdlKFxuICAgICAgc2VyaWFsaXplZEVudENoYWxsZW5nZVdpdGhQcm9vZixcbiAgICAgIGVjZGhLZXlwYWlyLnhwcnYsXG4gICAgICBlY2RoS2V5cGFpci5kZXJpdmF0aW9uUGF0aFxuICAgICk7XG5cbiAgICBhd2FpdCB0aGlzLnVwbG9hZENoYWxsZW5nZXNUb0VudGVycHJpc2UoXG4gICAgICBiaXRnbyxcbiAgICAgIGVudElkLFxuICAgICAgc2VyaWFsaXplZEVudENoYWxsZW5nZVdpdGhQcm9vZixcbiAgICAgIHNpZ25lZEVudGVycHJpc2VDaGFsbGVuZ2UudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgYml0Z29JbnN0Q2hhbGxlbmdlUHJvb2ZTaWduYXR1cmUudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgYml0Z29OaXRyb0NoYWxsZW5nZVByb29mU2lnbmF0dXJlLnRvU3RyaW5nKCdoZXgnKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkcyB0aGUgc2lnbmVkIGNoYWxsZW5nZXMgYW5kIHRoZWlyIHByb29mcyBvbiB0aGUgZW50ZXJwcmlzZS5cbiAgICogVGhpcyBpbml0aWF0ZXMgZWNkc2Egc2lnbmluZyBmb3IgdGhlIGVudGVycHJpc2UgdXNlcnMuXG4gICAqIEBwYXJhbSBiaXRnb1xuICAgKiBAcGFyYW0gZW50SWQgLSBlbnRlcnByaXNlIHRvIGVuYWJsZSBlY2RzYSBzaWduaW5nIG9uXG4gICAqIEBwYXJhbSBlbnRDaGFsbGVuZ2UgLSBjbGllbnQgc2lkZSBnZW5lcmF0ZWQgZW50IGNoYWxsZW5nZSB3aXRoIFpLIHByb29mc1xuICAgKiBAcGFyYW0gZW50Q2hhbGxlbmdlU2lnbmF0dXJlIC0gc2lnbmF0dXJlIG9uIGVudGVycHJpc2UgY2hhbGxlbmdlXG4gICAqIEBwYXJhbSBiaXRnb0ludENoYWxsZW5nZVNpZ25hdHVyZSAtIHNpZ25hdHVyZSBvbiBCaXRHbydzIGluc3RpdHV0aW9uYWwgSFNNIGNoYWxsZW5nZVxuICAgKiBAcGFyYW0gYml0Z29OaXRyb0NoYWxsZW5nZVNpZ25hdHVyZSAtIHNpZ25hdHVyZSBvbiBCaXRHbydzIG5pdHJvIEhTTSBjaGFsbGVuZ2VcbiAgICovXG4gIHN0YXRpYyBhc3luYyB1cGxvYWRDaGFsbGVuZ2VzVG9FbnRlcnByaXNlKFxuICAgIGJpdGdvOiBCaXRHb0Jhc2UsXG4gICAgZW50SWQ6IHN0cmluZyxcbiAgICBlbnRDaGFsbGVuZ2U6IEVjZHNhVHlwZXMuU2VyaWFsaXplZE50aWxkZSB8IEVjZHNhVHlwZXMuU2VyaWFsaXplZE50aWxkZVdpdGhQcm9vZnMsXG4gICAgZW50Q2hhbGxlbmdlU2lnbmF0dXJlOiBzdHJpbmcsXG4gICAgYml0Z29JbnRDaGFsbGVuZ2VTaWduYXR1cmU6IHN0cmluZyxcbiAgICBiaXRnb05pdHJvQ2hhbGxlbmdlU2lnbmF0dXJlOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgIGVudGVycHJpc2U6IHtcbiAgICAgICAgbnRpbGRlOiBlbnRDaGFsbGVuZ2UubnRpbGRlLFxuICAgICAgICBoMTogZW50Q2hhbGxlbmdlLmgxLFxuICAgICAgICBoMjogZW50Q2hhbGxlbmdlLmgyLFxuICAgICAgICB2ZXJpZmllcnM6IHtcbiAgICAgICAgICBhZG1pblNpZ25hdHVyZTogZW50Q2hhbGxlbmdlU2lnbmF0dXJlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGJpdGdvSW5zdGl0dXRpb25hbEhzbToge1xuICAgICAgICB2ZXJpZmllcnM6IHtcbiAgICAgICAgICBhZG1pblNpZ25hdHVyZTogYml0Z29JbnRDaGFsbGVuZ2VTaWduYXR1cmUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgYml0Z29OaXRyb0hzbToge1xuICAgICAgICB2ZXJpZmllcnM6IHtcbiAgICAgICAgICBhZG1pblNpZ25hdHVyZTogYml0Z29OaXRyb0NoYWxsZW5nZVNpZ25hdHVyZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoJ250aWxkZVByb29mJyBpbiBlbnRDaGFsbGVuZ2UpIHtcbiAgICAgIGJvZHkuZW50ZXJwcmlzZVsnbnRpbGRlUHJvb2YnXSA9IGVudENoYWxsZW5nZS5udGlsZGVQcm9vZjtcbiAgICB9XG4gICAgYXdhaXQgYml0Z29cbiAgICAgIC5wdXQoYml0Z28udXJsKGAvZW50ZXJwcmlzZS8ke2VudElkfS90c3Njb25maWcvZWNkc2EvY2hhbGxlbmdlYCwgMikpXG4gICAgICAuc2VuZChib2R5KVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG59XG4iXX0=