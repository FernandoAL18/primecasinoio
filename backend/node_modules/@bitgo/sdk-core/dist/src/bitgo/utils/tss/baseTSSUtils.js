"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const openpgp_1 = require("openpgp");
const tss_1 = require("../../tss");
const mpcUtils_1 = require("../mpcUtils");
const _ = __importStar(require("lodash"));
const util_1 = require("../util");
/**
 * BaseTssUtil class which different signature schemes have to extend
 */
class BaseTssUtils extends mpcUtils_1.MpcUtils {
    constructor(bitgo, baseCoin, wallet) {
        super(bitgo, baseCoin);
        this._wallet = wallet;
    }
    get wallet() {
        if (_.isNil(this._wallet)) {
            throw new Error('Wallet not defined');
        }
        return this._wallet;
    }
    async createBitgoHeldBackupKeyShare(userGpgKey, enterprise) {
        const keyResponse = await this.bitgo
            .post(this.baseCoin.url('/krs/backupkeys'))
            .send({
            enterprise,
            userGPGPublicKey: userGpgKey.publicKey,
        })
            .result();
        if (!keyResponse || !keyResponse.keyShares) {
            throw new Error('Failed to get backup shares from BitGo.');
        }
        return {
            id: keyResponse.id,
            keyShares: keyResponse.keyShares,
        };
    }
    finalizeBitgoHeldBackupKeyShare(keyId, commonKeychain, userKeyShare, bitgoKeychain, userGpgKey, backupGpgKey) {
        throw new Error('Method not implemented.');
    }
    createUserKeychain(params) {
        throw new Error('Method not implemented.');
    }
    createBackupKeychain(params) {
        throw new Error('Method not implemented.');
    }
    createBitgoKeychain(params) {
        throw new Error('Method not implemented.');
    }
    createKeychains(params) {
        throw new Error('Method not implemented.');
    }
    signTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    signTxRequestForMessage(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Signs a transaction using TSS for EdDSA and through utilization of custom share generators
     *
     * @param {string | TxRequest} txRequest - transaction request with unsigned transaction
     * @param {CustomRShareGeneratingFunction} externalSignerRShareGenerator a function that creates R shares in the EdDSA TSS flow
     * @param {CustomGShareGeneratingFunction} externalSignerGShareGenerator a function that creates G shares in the EdDSA TSS flow
     * @returns {Promise<TxRequest>} - a signed tx request
     */
    signEddsaTssUsingExternalSigner(txRequest, externalSignerCommitmentGenerator, externalSignerRShareGenerator, externalSignerGShareGenerator) {
        throw new Error('Method not implemented.');
    }
    /**
     * Signs a transaction using TSS for ECDSA and through utilization of custom share generators
     *
     * @param {params: TSSParams | TSSParamsForMessage} params - params object that represents parameters to sign a transaction or a message.
     * @param {RequestType} requestType - the type of the request to sign (transaction or message).
     * @param {CustomPaillierModulusGetterFunction} externalSignerPaillierModulusGetter a function that creates Paillier Modulus shares in the ECDSA TSS flow.
     * @param {CustomKShareGeneratingFunction} externalSignerKShareGenerator a function that creates K shares in the ECDSA TSS flow.
     * @param {CustomMuDeltaShareGeneratingFunction} externalSignerMuDeltaShareGenerator a function that creates Mu and Delta shares in the ECDSA TSS flow.
     * @param {CustomSShareGeneratingFunction} externalSignerSShareGenerator a function that creates S shares in the ECDSA TSS flow.
     */
    signEcdsaTssUsingExternalSigner(params, requestType, externalSignerPaillierModulusGetter, externalSignerKShareGenerator, externalSignerMuDeltaShareGenerator, externalSignerSShareGenerator) {
        throw new Error('Method not implemented.');
    }
    /**
     * Signs a transaction using TSS MPCv2 for ECDSA and through utilization of custom share generators
     *
     * @param {TSSParams | TSSParamsForMessage} params - params object that represents parameters to sign a transaction or a message.
     * @param {CustomMPCv2SigningRound1GeneratingFunction} externalSignerMPCv2SigningRound1Generator - a function that creates MPCv2 Round 1 shares in the ECDSA TSS MPCv2 flow.
     * @param {CustomMPCv2SigningRound2GeneratingFunction} externalSignerMPCv2SigningRound2Generator - a function that creates MPCv2 Round 2 shares in the ECDSA TSS MPCv2 flow.
     * @param {CustomMPCv2SigningRound3GeneratingFunction} externalSignerMPCv2SigningRound3Generator - a function that creates MPCv2 Round 3 shares in the ECDSA TSS MPCv2 flow.
     * @param {RequestType} requestType - the type of the request to sign (transaction or message).
     * @returns {Promise<TxRequest>} - a signed tx request
     */
    signEcdsaMPCv2TssUsingExternalSigner(params, externalSignerMPCv2SigningRound1Generator, externalSignerMPCv2SigningRound2Generator, externalSignerMPCv2SigningRound3Generator, requestType) {
        throw new Error('Method not implemented.');
    }
    /**
     * Create an Commitment (User to BitGo) share from an unsigned transaction and private user signing material
     * EDDSA only
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {string} params.walletPassphrase - wallet passphrase
     *
     * @returns {Promise<{ userToBitgoCommitment: CommitmentShareRecor, encryptedSignerShare: EncryptedSignerShareRecord }>} - Commitment Share and the Encrypted Signer Share to BitGo
     */
    createCommitmentShareFromTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Create an R (User to BitGo) share from an unsigned transaction and private user signing material
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {string} [params.walletPassphrase] - wallet passphrase
     * @param {EncryptedSignerShareRecord} [params.encryptedUserToBitgoRShare] - encrypted user to bitgo R share generated in the commitment phase
     * @returns {Promise<{ rShare: SignShare }>} - R Share to BitGo
     */
    createRShareFromTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Create a G (User to BitGo) share from an unsigned transaction and private user signing material
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {SignatureShareRecord} params.bitgoToUserRShare - BitGo to User R Share
     * @param {SignShare} params.userToBitgoRShare - User to BitGo R Share
     * @param {CommitmentShareRecord} params.bitgoToUserCommitment - BitGo to User Commitment
     * @returns {Promise<GShare>} - GShare from User to BitGo
     */
    createGShareFromTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Builds a tx request from params and verify it
     *
     * @param {PrebuildTransactionWithIntentOptions} params - parameters to build the tx
     * @param {TxRequestVersion} apiVersion lite or full
     * @param {boolean} preview boolean indicating if this is to preview a tx request, which will not initiate policy checks or pending approvals
     * @returns {Promise<TxRequest>} - a built tx request
     */
    async prebuildTxWithIntent(params, apiVersion = 'lite', preview) {
        const intentOptions = this.populateIntent(this.baseCoin, params);
        const whitelistedParams = {
            intent: {
                ...intentOptions,
            },
            apiVersion: apiVersion,
            preview,
        };
        const reqTracer = params.reqId || new util_1.RequestTracer();
        this.bitgo.setRequestTracer(reqTracer);
        const unsignedTx = (await this.bitgo
            .post(this.bitgo.url('/wallet/' + this.wallet.id() + '/txrequests', 2))
            .send(whitelistedParams)
            .result());
        return unsignedTx;
    }
    /**
     * Create a tx request from params for message signing
     *
     * @param params
     * @param apiVersion
     * @param preview
     */
    async createTxRequestWithIntentForMessageSigning(params, apiVersion = 'full', preview) {
        var _a, _b;
        const intentOptions = {
            custodianMessageId: params.custodianMessageId,
            intentType: params.intentType,
            sequenceId: params.sequenceId,
            comment: params.comment,
            memo: (_a = params.memo) === null || _a === void 0 ? void 0 : _a.value,
            isTss: params.isTss,
            messageRaw: params.messageRaw,
            messageEncoded: (_b = params.messageEncoded) !== null && _b !== void 0 ? _b : '',
        };
        return this.createTxRequestBase(intentOptions, apiVersion, preview, params.reqId);
    }
    /**
     * Create a tx request from params for type data signing
     *
     * @param params
     * @param apiVersion
     * @param preview
     */
    async createTxRequestWithIntentForTypedDataSigning(params, apiVersion = 'full', preview) {
        var _a, _b;
        const intentOptions = {
            custodianMessageId: params.custodianMessageId,
            intentType: params.intentType,
            sequenceId: params.sequenceId,
            comment: params.comment,
            memo: (_a = params.memo) === null || _a === void 0 ? void 0 : _a.value,
            isTss: params.isTss,
            messageRaw: params.typedDataRaw,
            messageEncoded: (_b = params.typedDataEncoded) !== null && _b !== void 0 ? _b : '',
        };
        return this.createTxRequestBase(intentOptions, apiVersion, preview, params.reqId);
    }
    /**
     * Calls Bitgo API to create tx request.
     *
     * @private
     */
    async createTxRequestBase(intentOptions, apiVersion, preview, reqId) {
        const whitelistedParams = {
            intent: {
                ...intentOptions,
            },
            apiVersion,
            preview,
        };
        const reqTracer = reqId || new util_1.RequestTracer();
        this.bitgo.setRequestTracer(reqTracer);
        return this.bitgo
            .post(this.bitgo.url(`/wallet/${this.wallet.id()}/txrequests`, 2))
            .send(whitelistedParams)
            .result();
    }
    /**
     * Call delete signature shares for a txRequest, the endpoint delete the signatures and return them
     *
     * @param {string} txRequestId tx id reference to delete signature shares
     * @param {IRequestTracer} reqId - the request tracer request id
     * @returns {SignatureShareRecord[]}
     */
    async deleteSignatureShares(txRequestId, reqId) {
        const reqTracer = reqId || new util_1.RequestTracer();
        this.bitgo.setRequestTracer(reqTracer);
        return this.bitgo
            .del(this.bitgo.url(`/wallet/${this.wallet.id()}/txrequests/${txRequestId}/signatureshares`, 2))
            .send()
            .result();
    }
    /**
     * Initialize the send procedure once Bitgo has the User To Bitgo GShare
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {IRequestTracer} reqId - the request tracer request id
     * @returns {Promise<any>}
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async sendTxRequest(txRequestId, reqId) {
        const reqTracer = reqId || new util_1.RequestTracer();
        this.bitgo.setRequestTracer(reqTracer);
        return this.bitgo
            .post(this.baseCoin.url('/wallet/' + this.wallet.id() + '/tx/send'))
            .send({ txRequestId })
            .result();
    }
    /**
     * Delete signature shares, get the tx request without them from the db and sign it to finally send it.
     *
     * Note : This can be performed in order to reach latest network conditions required on pending approval flow.
     *
     * @param {String} txRequestId - the txRequest Id to make the requests.
     * @param {String} decryptedPrv - decrypted prv to sign the tx request.
     * @param {RequestTracer} reqId id tracer.
     * @returns {Promise<any>}
     */
    async recreateTxRequest(txRequestId, decryptedPrv, reqId) {
        await this.deleteSignatureShares(txRequestId, reqId);
        // after delete signatures shares get the tx without them
        const txRequest = await (0, tss_1.getTxRequest)(this.bitgo, this.wallet.id(), txRequestId, reqId);
        return await this.signTxRequest({ txRequest, prv: decryptedPrv, reqId });
    }
    /**
     * Gets the latest Tx Request by id
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {IRequestTracer} reqId - request tracer request id
     * @returns {Promise<TxRequest>}
     */
    async getTxRequest(txRequestId, reqId) {
        return (0, tss_1.getTxRequest)(this.bitgo, this.wallet.id(), txRequestId, reqId);
    }
    /**
     * Checks whether the third party backup provider is valid/supported
     * @param backupProvider - the backup provider client selected
     */
    isValidThirdPartyBackupProvider(backupProvider) {
        // As of now, BitGo is the only supported KRS provider for TSS
        return !!(backupProvider && backupProvider === 'BitGoTrustAsKrs');
    }
    /**
     * It gets the appropriate BitGo GPG public key for key creation based on a
     * combination of coin and the feature flags on the user and their enterprise if set.
     * @param enterpriseId - enterprise under which user wants to create the wallet
     * @param isMPCv2 - true to get the MPCv2 GPG public key, defaults to false
     * @param reqId - request tracer request id
     */
    async getBitgoGpgPubkeyBasedOnFeatureFlags(enterpriseId, isMPCv2 = false, reqId) {
        const reqTracer = reqId || new util_1.RequestTracer();
        this.bitgo.setRequestTracer(reqTracer);
        const response = await this.bitgo
            .get(this.baseCoin.url('/tss/pubkey'))
            .query({ enterpriseId })
            .retry(3)
            .result();
        const bitgoPublicKeyStr = isMPCv2 ? response.mpcv2PublicKey : response.publicKey;
        return (0, openpgp_1.readKey)({ armoredKey: bitgoPublicKeyStr });
    }
    /**
     * Returns supported TxRequest versions for this wallet
     */
    supportedTxRequestVersions() {
        var _a, _b, _c, _d;
        const walletType = (_a = this._wallet) === null || _a === void 0 ? void 0 : _a.type();
        const supportedWalletTypes = ['custodial', 'cold', 'hot'];
        if (!walletType || ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.multisigType()) !== 'tss' || !supportedWalletTypes.includes(walletType)) {
            return [];
        }
        else if (((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.baseCoin.getMPCAlgorithm()) === 'ecdsa') {
            return ['full'];
        }
        else if (walletType === 'custodial' || walletType === 'cold') {
            return ['full'];
        }
        else if (((_d = this._wallet) === null || _d === void 0 ? void 0 : _d.baseCoin.getMPCAlgorithm()) === 'eddsa' && walletType === 'hot') {
            return ['lite', 'full'];
        }
        return [];
    }
    /**
     * Returns true if the txRequest is using apiVersion == full and is pending approval
     * @param txRequest
     * @returns boolean
     */
    isPendingApprovalTxRequestFull(txRequest) {
        const { apiVersion, state } = txRequest;
        return apiVersion === 'full' && 'pendingApproval' === state;
    }
}
exports.default = BaseTssUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZVRTU1V0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3V0aWxzL3Rzcy9iYXNlVFNTVXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLHFDQUEwRDtBQUkxRCxtQ0FBeUM7QUFFekMsMENBQXVDO0FBQ3ZDLDBDQUE0QjtBQWlDNUIsa0NBQXdDO0FBRXhDOztHQUVHO0FBQ0gsTUFBcUIsWUFBdUIsU0FBUSxtQkFBUTtJQUcxRCxZQUFZLEtBQWdCLEVBQUUsUUFBbUIsRUFBRSxNQUFnQjtRQUNqRSxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0lBQ3hCLENBQUM7SUFFRCxJQUFJLE1BQU07UUFDUixJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztTQUN2QztRQUNELE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0lBRUQsS0FBSyxDQUFDLDZCQUE2QixDQUNqQyxVQUFxQyxFQUNyQyxVQUE4QjtRQUU5QixNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxLQUFLO2FBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2FBQzFDLElBQUksQ0FBQztZQUNKLFVBQVU7WUFDVixnQkFBZ0IsRUFBRSxVQUFVLENBQUMsU0FBUztTQUN2QyxDQUFDO2FBQ0QsTUFBTSxFQUFFLENBQUM7UUFDWixJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRTtZQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7U0FDNUQ7UUFDRCxPQUFPO1lBQ0wsRUFBRSxFQUFFLFdBQVcsQ0FBQyxFQUFFO1lBQ2xCLFNBQVMsRUFBRSxXQUFXLENBQUMsU0FBUztTQUNqQyxDQUFDO0lBQ0osQ0FBQztJQUVNLCtCQUErQixDQUNwQyxLQUFhLEVBQ2IsY0FBc0IsRUFDdEIsWUFBc0IsRUFDdEIsYUFBdUIsRUFDdkIsVUFBcUMsRUFDckMsWUFBaUI7UUFFakIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRCxrQkFBa0IsQ0FBQyxNQUFnQztRQUNqRCxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELG9CQUFvQixDQUFDLE1BQWdDO1FBQ25ELE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQsbUJBQW1CLENBQUMsTUFBcUM7UUFDdkQsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRCxlQUFlLENBQUMsTUFNZjtRQUNDLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQsYUFBYSxDQUFDLE1BQXdCO1FBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQsdUJBQXVCLENBQUMsTUFBMkI7UUFDakQsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsK0JBQStCLENBQzdCLFNBQTZCLEVBQzdCLGlDQUFxRSxFQUNyRSw2QkFBNkQsRUFDN0QsNkJBQTZEO1FBRTdELE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsK0JBQStCLENBQzdCLE1BQXVDLEVBQ3ZDLFdBQXdCLEVBQ3hCLG1DQUF3RSxFQUN4RSw2QkFBNkQsRUFDN0QsbUNBQXlFLEVBQ3pFLDZCQUE2RDtRQUU3RCxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILG9DQUFvQyxDQUNsQyxNQUF1QyxFQUN2Qyx5Q0FBcUYsRUFDckYseUNBQXFGLEVBQ3JGLHlDQUFxRixFQUNyRixXQUF5QjtRQUV6QixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxrQ0FBa0MsQ0FBQyxNQUF1RTtRQUt4RyxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILHlCQUF5QixDQUFDLE1BSXpCO1FBQ0MsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gseUJBQXlCLENBQUMsTUFNekI7UUFDQyxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsb0JBQW9CLENBQ3hCLE1BQTRDLEVBQzVDLGFBQStCLE1BQU0sRUFDckMsT0FBaUI7UUFFakIsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRWpFLE1BQU0saUJBQWlCLEdBQUc7WUFDeEIsTUFBTSxFQUFFO2dCQUNOLEdBQUcsYUFBYTthQUNqQjtZQUNELFVBQVUsRUFBRSxVQUFVO1lBQ3RCLE9BQU87U0FDUixDQUFDO1FBRUYsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLEtBQUssSUFBSSxJQUFJLG9CQUFhLEVBQUUsQ0FBQztRQUN0RCxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZDLE1BQU0sVUFBVSxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsS0FBSzthQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEdBQUcsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ3RFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQzthQUN2QixNQUFNLEVBQUUsQ0FBYyxDQUFDO1FBRTFCLE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFLLENBQUMsMENBQTBDLENBQzlDLE1BQStCLEVBQy9CLGFBQStCLE1BQU0sRUFDckMsT0FBaUI7O1FBRWpCLE1BQU0sYUFBYSxHQUFxQztZQUN0RCxrQkFBa0IsRUFBRSxNQUFNLENBQUMsa0JBQWtCO1lBQzdDLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVTtZQUM3QixVQUFVLEVBQUUsTUFBTSxDQUFDLFVBQVU7WUFDN0IsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPO1lBQ3ZCLElBQUksRUFBRSxNQUFBLE1BQU0sQ0FBQyxJQUFJLDBDQUFFLEtBQUs7WUFDeEIsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLO1lBQ25CLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVTtZQUM3QixjQUFjLEVBQUUsTUFBQSxNQUFNLENBQUMsY0FBYyxtQ0FBSSxFQUFFO1NBQzVDLENBQUM7UUFFRixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxhQUFhLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEYsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyw0Q0FBNEMsQ0FDaEQsTUFBaUMsRUFDakMsYUFBK0IsTUFBTSxFQUNyQyxPQUFpQjs7UUFFakIsTUFBTSxhQUFhLEdBQXVDO1lBQ3hELGtCQUFrQixFQUFFLE1BQU0sQ0FBQyxrQkFBa0I7WUFDN0MsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVO1lBQzdCLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVTtZQUM3QixPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU87WUFDdkIsSUFBSSxFQUFFLE1BQUEsTUFBTSxDQUFDLElBQUksMENBQUUsS0FBSztZQUN4QixLQUFLLEVBQUUsTUFBTSxDQUFDLEtBQUs7WUFDbkIsVUFBVSxFQUFFLE1BQU0sQ0FBQyxZQUFZO1lBQy9CLGNBQWMsRUFBRSxNQUFBLE1BQU0sQ0FBQyxnQkFBZ0IsbUNBQUksRUFBRTtTQUM5QyxDQUFDO1FBRUYsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3BGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssS0FBSyxDQUFDLG1CQUFtQixDQUMvQixhQUFvRixFQUNwRixVQUE0QixFQUM1QixPQUFpQixFQUNqQixLQUFzQjtRQUV0QixNQUFNLGlCQUFpQixHQUFHO1lBQ3hCLE1BQU0sRUFBRTtnQkFDTixHQUFHLGFBQWE7YUFDakI7WUFDRCxVQUFVO1lBQ1YsT0FBTztTQUNSLENBQUM7UUFFRixNQUFNLFNBQVMsR0FBRyxLQUFLLElBQUksSUFBSSxvQkFBYSxFQUFFLENBQUM7UUFDL0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN2QyxPQUFPLElBQUksQ0FBQyxLQUFLO2FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ2pFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQzthQUN2QixNQUFNLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFLLENBQUMscUJBQXFCLENBQUMsV0FBbUIsRUFBRSxLQUFzQjtRQUNyRSxNQUFNLFNBQVMsR0FBRyxLQUFLLElBQUksSUFBSSxvQkFBYSxFQUFFLENBQUM7UUFDL0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN2QyxPQUFPLElBQUksQ0FBQyxLQUFLO2FBQ2QsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsZUFBZSxXQUFXLGtCQUFrQixFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQy9GLElBQUksRUFBRTthQUNOLE1BQU0sRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILDhEQUE4RDtJQUM5RCxLQUFLLENBQUMsYUFBYSxDQUFDLFdBQW1CLEVBQUUsS0FBc0I7UUFDN0QsTUFBTSxTQUFTLEdBQUcsS0FBSyxJQUFJLElBQUksb0JBQWEsRUFBRSxDQUFDO1FBQy9DLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdkMsT0FBTyxJQUFJLENBQUMsS0FBSzthQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsR0FBRyxVQUFVLENBQUMsQ0FBQzthQUNuRSxJQUFJLENBQUMsRUFBRSxXQUFXLEVBQUUsQ0FBQzthQUNyQixNQUFNLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxLQUFLLENBQUMsaUJBQWlCLENBQUMsV0FBbUIsRUFBRSxZQUFvQixFQUFFLEtBQXFCO1FBQ3RGLE1BQU0sSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNyRCx5REFBeUQ7UUFDekQsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFBLGtCQUFZLEVBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2RixPQUFPLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyxZQUFZLENBQUMsV0FBbUIsRUFBRSxLQUFzQjtRQUM1RCxPQUFPLElBQUEsa0JBQVksRUFBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRDs7O09BR0c7SUFDSCwrQkFBK0IsQ0FDN0IsY0FBbUQ7UUFFbkQsOERBQThEO1FBQzlELE9BQU8sQ0FBQyxDQUFDLENBQUMsY0FBYyxJQUFJLGNBQWMsS0FBSyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxLQUFLLENBQUMsb0NBQW9DLENBQy9DLFlBQWdDLEVBQ2hDLE9BQU8sR0FBRyxLQUFLLEVBQ2YsS0FBc0I7UUFFdEIsTUFBTSxTQUFTLEdBQUcsS0FBSyxJQUFJLElBQUksb0JBQWEsRUFBRSxDQUFDO1FBQy9DLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdkMsTUFBTSxRQUFRLEdBQXNCLE1BQU0sSUFBSSxDQUFDLEtBQUs7YUFDakQsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ3JDLEtBQUssQ0FBQyxFQUFFLFlBQVksRUFBRSxDQUFDO2FBQ3ZCLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFDUixNQUFNLEVBQUUsQ0FBQztRQUNaLE1BQU0saUJBQWlCLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO1FBQ2pGLE9BQU8sSUFBQSxpQkFBTyxFQUFDLEVBQUUsVUFBVSxFQUFFLGlCQUEyQixFQUFFLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRUQ7O09BRUc7SUFDSSwwQkFBMEI7O1FBQy9CLE1BQU0sVUFBVSxHQUFHLE1BQUEsSUFBSSxDQUFDLE9BQU8sMENBQUUsSUFBSSxFQUFFLENBQUM7UUFDeEMsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDMUQsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFBLE1BQUEsSUFBSSxDQUFDLE9BQU8sMENBQUUsWUFBWSxFQUFFLE1BQUssS0FBSyxJQUFJLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3ZHLE9BQU8sRUFBRSxDQUFDO1NBQ1g7YUFBTSxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsT0FBTywwQ0FBRSxRQUFRLENBQUMsZUFBZSxFQUFFLE1BQUssT0FBTyxFQUFFO1lBQy9ELE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQjthQUFNLElBQUksVUFBVSxLQUFLLFdBQVcsSUFBSSxVQUFVLEtBQUssTUFBTSxFQUFFO1lBQzlELE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQjthQUFNLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxPQUFPLDBDQUFFLFFBQVEsQ0FBQyxlQUFlLEVBQUUsTUFBSyxPQUFPLElBQUksVUFBVSxLQUFLLEtBQUssRUFBRTtZQUN2RixPQUFPLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3pCO1FBQ0QsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDhCQUE4QixDQUFDLFNBQW9CO1FBQ2pELE1BQU0sRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLEdBQUcsU0FBUyxDQUFDO1FBQ3hDLE9BQU8sVUFBVSxLQUFLLE1BQU0sSUFBSSxpQkFBaUIsS0FBSyxLQUFLLENBQUM7SUFDOUQsQ0FBQztDQUNGO0FBMWFELCtCQTBhQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi4vLi4vLi4vYXBpJztcbmltcG9ydCB7IEtleSwgcmVhZEtleSwgU2VyaWFsaXplZEtleVBhaXIgfSBmcm9tICdvcGVucGdwJztcbmltcG9ydCB7IElCYXNlQ29pbiwgS2V5Y2hhaW5zVHJpcGxldCB9IGZyb20gJy4uLy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uLy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgeyBLZXljaGFpbiB9IGZyb20gJy4uLy4uL2tleWNoYWluJztcbmltcG9ydCB7IGdldFR4UmVxdWVzdCB9IGZyb20gJy4uLy4uL3Rzcyc7XG5pbXBvcnQgeyBJV2FsbGV0LCBCYWNrdXBQcm92aWRlciB9IGZyb20gJy4uLy4uL3dhbGxldCc7XG5pbXBvcnQgeyBNcGNVdGlscyB9IGZyb20gJy4uL21wY1V0aWxzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7XG4gIEJpdGdvR1BHUHVibGljS2V5LFxuICBCaXRnb0hlbGRCYWNrdXBLZXlTaGFyZSxcbiAgQ3VzdG9tR1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICBDdXN0b21SU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIElUc3NVdGlscyxcbiAgUHJlYnVpbGRUcmFuc2FjdGlvbldpdGhJbnRlbnRPcHRpb25zLFxuICBTaWduYXR1cmVTaGFyZVJlY29yZCxcbiAgVFNTUGFyYW1zLFxuICBUeFJlcXVlc3QsXG4gIFR4UmVxdWVzdFZlcnNpb24sXG4gIENyZWF0ZUtleWNoYWluUGFyYW1zQmFzZSxcbiAgSW50ZW50T3B0aW9uc0Zvck1lc3NhZ2UsXG4gIFBvcHVsYXRlZEludGVudEZvck1lc3NhZ2VTaWduaW5nLFxuICBJbnRlbnRPcHRpb25zRm9yVHlwZWREYXRhLFxuICBQb3B1bGF0ZWRJbnRlbnRGb3JUeXBlZERhdGFTaWduaW5nLFxuICBDcmVhdGVCaXRHb0tleWNoYWluUGFyYW1zQmFzZSxcbiAgQ29tbWl0bWVudFNoYXJlUmVjb3JkLFxuICBFbmNyeXB0ZWRTaWduZXJTaGFyZVJlY29yZCxcbiAgQ3VzdG9tQ29tbWl0bWVudEdlbmVyYXRpbmdGdW5jdGlvbixcbiAgVFNTUGFyYW1zRm9yTWVzc2FnZSxcbiAgUmVxdWVzdFR5cGUsXG4gIEN1c3RvbVBhaWxsaWVyTW9kdWx1c0dldHRlckZ1bmN0aW9uLFxuICBDdXN0b21LU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIEN1c3RvbU11RGVsdGFTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgQ3VzdG9tU1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICBDdXN0b21NUEN2MlNpZ25pbmdSb3VuZDFHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIEN1c3RvbU1QQ3YyU2lnbmluZ1JvdW5kMkdlbmVyYXRpbmdGdW5jdGlvbixcbiAgQ3VzdG9tTVBDdjJTaWduaW5nUm91bmQzR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICBUU1NQYXJhbXNXaXRoUHJ2LFxufSBmcm9tICcuL2Jhc2VUeXBlcyc7XG5pbXBvcnQgeyBHU2hhcmUsIFNpZ25TaGFyZSB9IGZyb20gJy4uLy4uLy4uL2FjY291bnQtbGliL21wYy90c3MnO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4uL3V0aWwnO1xuXG4vKipcbiAqIEJhc2VUc3NVdGlsIGNsYXNzIHdoaWNoIGRpZmZlcmVudCBzaWduYXR1cmUgc2NoZW1lcyBoYXZlIHRvIGV4dGVuZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlVHNzVXRpbHM8S2V5U2hhcmU+IGV4dGVuZHMgTXBjVXRpbHMgaW1wbGVtZW50cyBJVHNzVXRpbHM8S2V5U2hhcmU+IHtcbiAgcHJpdmF0ZSBfd2FsbGV0PzogSVdhbGxldDtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBiYXNlQ29pbjogSUJhc2VDb2luLCB3YWxsZXQ/OiBJV2FsbGV0KSB7XG4gICAgc3VwZXIoYml0Z28sIGJhc2VDb2luKTtcbiAgICB0aGlzLl93YWxsZXQgPSB3YWxsZXQ7XG4gIH1cblxuICBnZXQgd2FsbGV0KCk6IElXYWxsZXQge1xuICAgIGlmIChfLmlzTmlsKHRoaXMuX3dhbGxldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93YWxsZXQ7XG4gIH1cblxuICBhc3luYyBjcmVhdGVCaXRnb0hlbGRCYWNrdXBLZXlTaGFyZShcbiAgICB1c2VyR3BnS2V5OiBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+LFxuICAgIGVudGVycHJpc2U6IHN0cmluZyB8IHVuZGVmaW5lZFxuICApOiBQcm9taXNlPEJpdGdvSGVsZEJhY2t1cEtleVNoYXJlPiB7XG4gICAgY29uc3Qga2V5UmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL2tycy9iYWNrdXBrZXlzJykpXG4gICAgICAuc2VuZCh7XG4gICAgICAgIGVudGVycHJpc2UsXG4gICAgICAgIHVzZXJHUEdQdWJsaWNLZXk6IHVzZXJHcGdLZXkucHVibGljS2V5LFxuICAgICAgfSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgICBpZiAoIWtleVJlc3BvbnNlIHx8ICFrZXlSZXNwb25zZS5rZXlTaGFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBiYWNrdXAgc2hhcmVzIGZyb20gQml0R28uJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpZDoga2V5UmVzcG9uc2UuaWQsXG4gICAgICBrZXlTaGFyZXM6IGtleVJlc3BvbnNlLmtleVNoYXJlcyxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGZpbmFsaXplQml0Z29IZWxkQmFja3VwS2V5U2hhcmUoXG4gICAga2V5SWQ6IHN0cmluZyxcbiAgICBjb21tb25LZXljaGFpbjogc3RyaW5nLFxuICAgIHVzZXJLZXlTaGFyZTogS2V5U2hhcmUsXG4gICAgYml0Z29LZXljaGFpbjogS2V5Y2hhaW4sXG4gICAgdXNlckdwZ0tleTogU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPixcbiAgICBiYWNrdXBHcGdLZXk6IEtleVxuICApOiBQcm9taXNlPEJpdGdvSGVsZEJhY2t1cEtleVNoYXJlPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgY3JlYXRlVXNlcktleWNoYWluKHBhcmFtczogQ3JlYXRlS2V5Y2hhaW5QYXJhbXNCYXNlKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGNyZWF0ZUJhY2t1cEtleWNoYWluKHBhcmFtczogQ3JlYXRlS2V5Y2hhaW5QYXJhbXNCYXNlKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGNyZWF0ZUJpdGdvS2V5Y2hhaW4ocGFyYW1zOiBDcmVhdGVCaXRHb0tleWNoYWluUGFyYW1zQmFzZSk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBjcmVhdGVLZXljaGFpbnMocGFyYW1zOiB7XG4gICAgcGFzc3BocmFzZTogc3RyaW5nO1xuICAgIGVudGVycHJpc2U/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlzVGhpcmRQYXJ0eUJhY2t1cD86IGJvb2xlYW47XG4gICAgYmFja3VwUHJvdmlkZXI/OiBCYWNrdXBQcm92aWRlcjtcbiAgfSk6IFByb21pc2U8S2V5Y2hhaW5zVHJpcGxldD4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIHNpZ25UeFJlcXVlc3QocGFyYW1zOiBUU1NQYXJhbXNXaXRoUHJ2KTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBzaWduVHhSZXF1ZXN0Rm9yTWVzc2FnZShwYXJhbXM6IFRTU1BhcmFtc0Zvck1lc3NhZ2UpOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBhIHRyYW5zYWN0aW9uIHVzaW5nIFRTUyBmb3IgRWREU0EgYW5kIHRocm91Z2ggdXRpbGl6YXRpb24gb2YgY3VzdG9tIHNoYXJlIGdlbmVyYXRvcnNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBUeFJlcXVlc3R9IHR4UmVxdWVzdCAtIHRyYW5zYWN0aW9uIHJlcXVlc3Qgd2l0aCB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0N1c3RvbVJTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbn0gZXh0ZXJuYWxTaWduZXJSU2hhcmVHZW5lcmF0b3IgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgUiBzaGFyZXMgaW4gdGhlIEVkRFNBIFRTUyBmbG93XG4gICAqIEBwYXJhbSB7Q3VzdG9tR1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9ufSBleHRlcm5hbFNpZ25lckdTaGFyZUdlbmVyYXRvciBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBHIHNoYXJlcyBpbiB0aGUgRWREU0EgVFNTIGZsb3dcbiAgICogQHJldHVybnMge1Byb21pc2U8VHhSZXF1ZXN0Pn0gLSBhIHNpZ25lZCB0eCByZXF1ZXN0XG4gICAqL1xuICBzaWduRWRkc2FUc3NVc2luZ0V4dGVybmFsU2lnbmVyKFxuICAgIHR4UmVxdWVzdDogc3RyaW5nIHwgVHhSZXF1ZXN0LFxuICAgIGV4dGVybmFsU2lnbmVyQ29tbWl0bWVudEdlbmVyYXRvcjogQ3VzdG9tQ29tbWl0bWVudEdlbmVyYXRpbmdGdW5jdGlvbixcbiAgICBleHRlcm5hbFNpZ25lclJTaGFyZUdlbmVyYXRvcjogQ3VzdG9tUlNoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICAgIGV4dGVybmFsU2lnbmVyR1NoYXJlR2VuZXJhdG9yOiBDdXN0b21HU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb25cbiAgKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbnMgYSB0cmFuc2FjdGlvbiB1c2luZyBUU1MgZm9yIEVDRFNBIGFuZCB0aHJvdWdoIHV0aWxpemF0aW9uIG9mIGN1c3RvbSBzaGFyZSBnZW5lcmF0b3JzXG4gICAqXG4gICAqIEBwYXJhbSB7cGFyYW1zOiBUU1NQYXJhbXMgfCBUU1NQYXJhbXNGb3JNZXNzYWdlfSBwYXJhbXMgLSBwYXJhbXMgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBwYXJhbWV0ZXJzIHRvIHNpZ24gYSB0cmFuc2FjdGlvbiBvciBhIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7UmVxdWVzdFR5cGV9IHJlcXVlc3RUeXBlIC0gdGhlIHR5cGUgb2YgdGhlIHJlcXVlc3QgdG8gc2lnbiAodHJhbnNhY3Rpb24gb3IgbWVzc2FnZSkuXG4gICAqIEBwYXJhbSB7Q3VzdG9tUGFpbGxpZXJNb2R1bHVzR2V0dGVyRnVuY3Rpb259IGV4dGVybmFsU2lnbmVyUGFpbGxpZXJNb2R1bHVzR2V0dGVyIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIFBhaWxsaWVyIE1vZHVsdXMgc2hhcmVzIGluIHRoZSBFQ0RTQSBUU1MgZmxvdy5cbiAgICogQHBhcmFtIHtDdXN0b21LU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb259IGV4dGVybmFsU2lnbmVyS1NoYXJlR2VuZXJhdG9yIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIEsgc2hhcmVzIGluIHRoZSBFQ0RTQSBUU1MgZmxvdy5cbiAgICogQHBhcmFtIHtDdXN0b21NdURlbHRhU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb259IGV4dGVybmFsU2lnbmVyTXVEZWx0YVNoYXJlR2VuZXJhdG9yIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIE11IGFuZCBEZWx0YSBzaGFyZXMgaW4gdGhlIEVDRFNBIFRTUyBmbG93LlxuICAgKiBAcGFyYW0ge0N1c3RvbVNTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbn0gZXh0ZXJuYWxTaWduZXJTU2hhcmVHZW5lcmF0b3IgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgUyBzaGFyZXMgaW4gdGhlIEVDRFNBIFRTUyBmbG93LlxuICAgKi9cbiAgc2lnbkVjZHNhVHNzVXNpbmdFeHRlcm5hbFNpZ25lcihcbiAgICBwYXJhbXM6IFRTU1BhcmFtcyB8IFRTU1BhcmFtc0Zvck1lc3NhZ2UsXG4gICAgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlLFxuICAgIGV4dGVybmFsU2lnbmVyUGFpbGxpZXJNb2R1bHVzR2V0dGVyOiBDdXN0b21QYWlsbGllck1vZHVsdXNHZXR0ZXJGdW5jdGlvbixcbiAgICBleHRlcm5hbFNpZ25lcktTaGFyZUdlbmVyYXRvcjogQ3VzdG9tS1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICAgIGV4dGVybmFsU2lnbmVyTXVEZWx0YVNoYXJlR2VuZXJhdG9yOiBDdXN0b21NdURlbHRhU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gICAgZXh0ZXJuYWxTaWduZXJTU2hhcmVHZW5lcmF0b3I6IEN1c3RvbVNTaGFyZUdlbmVyYXRpbmdGdW5jdGlvblxuICApOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBhIHRyYW5zYWN0aW9uIHVzaW5nIFRTUyBNUEN2MiBmb3IgRUNEU0EgYW5kIHRocm91Z2ggdXRpbGl6YXRpb24gb2YgY3VzdG9tIHNoYXJlIGdlbmVyYXRvcnNcbiAgICpcbiAgICogQHBhcmFtIHtUU1NQYXJhbXMgfCBUU1NQYXJhbXNGb3JNZXNzYWdlfSBwYXJhbXMgLSBwYXJhbXMgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBwYXJhbWV0ZXJzIHRvIHNpZ24gYSB0cmFuc2FjdGlvbiBvciBhIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7Q3VzdG9tTVBDdjJTaWduaW5nUm91bmQxR2VuZXJhdGluZ0Z1bmN0aW9ufSBleHRlcm5hbFNpZ25lck1QQ3YyU2lnbmluZ1JvdW5kMUdlbmVyYXRvciAtIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIE1QQ3YyIFJvdW5kIDEgc2hhcmVzIGluIHRoZSBFQ0RTQSBUU1MgTVBDdjIgZmxvdy5cbiAgICogQHBhcmFtIHtDdXN0b21NUEN2MlNpZ25pbmdSb3VuZDJHZW5lcmF0aW5nRnVuY3Rpb259IGV4dGVybmFsU2lnbmVyTVBDdjJTaWduaW5nUm91bmQyR2VuZXJhdG9yIC0gYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgTVBDdjIgUm91bmQgMiBzaGFyZXMgaW4gdGhlIEVDRFNBIFRTUyBNUEN2MiBmbG93LlxuICAgKiBAcGFyYW0ge0N1c3RvbU1QQ3YyU2lnbmluZ1JvdW5kM0dlbmVyYXRpbmdGdW5jdGlvbn0gZXh0ZXJuYWxTaWduZXJNUEN2MlNpZ25pbmdSb3VuZDNHZW5lcmF0b3IgLSBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBNUEN2MiBSb3VuZCAzIHNoYXJlcyBpbiB0aGUgRUNEU0EgVFNTIE1QQ3YyIGZsb3cuXG4gICAqIEBwYXJhbSB7UmVxdWVzdFR5cGV9IHJlcXVlc3RUeXBlIC0gdGhlIHR5cGUgb2YgdGhlIHJlcXVlc3QgdG8gc2lnbiAodHJhbnNhY3Rpb24gb3IgbWVzc2FnZSkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFR4UmVxdWVzdD59IC0gYSBzaWduZWQgdHggcmVxdWVzdFxuICAgKi9cbiAgc2lnbkVjZHNhTVBDdjJUc3NVc2luZ0V4dGVybmFsU2lnbmVyKFxuICAgIHBhcmFtczogVFNTUGFyYW1zIHwgVFNTUGFyYW1zRm9yTWVzc2FnZSxcbiAgICBleHRlcm5hbFNpZ25lck1QQ3YyU2lnbmluZ1JvdW5kMUdlbmVyYXRvcjogQ3VzdG9tTVBDdjJTaWduaW5nUm91bmQxR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICAgIGV4dGVybmFsU2lnbmVyTVBDdjJTaWduaW5nUm91bmQyR2VuZXJhdG9yOiBDdXN0b21NUEN2MlNpZ25pbmdSb3VuZDJHZW5lcmF0aW5nRnVuY3Rpb24sXG4gICAgZXh0ZXJuYWxTaWduZXJNUEN2MlNpZ25pbmdSb3VuZDNHZW5lcmF0b3I6IEN1c3RvbU1QQ3YyU2lnbmluZ1JvdW5kM0dlbmVyYXRpbmdGdW5jdGlvbixcbiAgICByZXF1ZXN0VHlwZT86IFJlcXVlc3RUeXBlXG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBDb21taXRtZW50IChVc2VyIHRvIEJpdEdvKSBzaGFyZSBmcm9tIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGFuZCBwcml2YXRlIHVzZXIgc2lnbmluZyBtYXRlcmlhbFxuICAgKiBFRERTQSBvbmx5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbXMgb2JqZWN0XG4gICAqIEBwYXJhbSB7VHhSZXF1ZXN0fSBwYXJhbXMudHhSZXF1ZXN0IC0gdHJhbnNhY3Rpb24gcmVxdWVzdCB3aXRoIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucHJ2IC0gdXNlciBzaWduaW5nIG1hdGVyaWFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAtIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgdXNlclRvQml0Z29Db21taXRtZW50OiBDb21taXRtZW50U2hhcmVSZWNvciwgZW5jcnlwdGVkU2lnbmVyU2hhcmU6IEVuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkIH0+fSAtIENvbW1pdG1lbnQgU2hhcmUgYW5kIHRoZSBFbmNyeXB0ZWQgU2lnbmVyIFNoYXJlIHRvIEJpdEdvXG4gICAqL1xuICBjcmVhdGVDb21taXRtZW50U2hhcmVGcm9tVHhSZXF1ZXN0KHBhcmFtczogeyB0eFJlcXVlc3Q6IFR4UmVxdWVzdDsgcHJ2OiBzdHJpbmc7IHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZyB9KTogUHJvbWlzZTx7XG4gICAgdXNlclRvQml0Z29Db21taXRtZW50OiBDb21taXRtZW50U2hhcmVSZWNvcmQ7XG4gICAgZW5jcnlwdGVkU2lnbmVyU2hhcmU6IEVuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkO1xuICAgIGVuY3J5cHRlZFVzZXJUb0JpdGdvUlNoYXJlOiBFbmNyeXB0ZWRTaWduZXJTaGFyZVJlY29yZDtcbiAgfT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gUiAoVXNlciB0byBCaXRHbykgc2hhcmUgZnJvbSBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiBhbmQgcHJpdmF0ZSB1c2VyIHNpZ25pbmcgbWF0ZXJpYWxcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtcyBvYmplY3RcbiAgICogQHBhcmFtIHtUeFJlcXVlc3R9IHBhcmFtcy50eFJlcXVlc3QgLSB0cmFuc2FjdGlvbiByZXF1ZXN0IHdpdGggdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wcnYgLSB1c2VyIHNpZ25pbmcgbWF0ZXJpYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMud2FsbGV0UGFzc3BocmFzZV0gLSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0ge0VuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkfSBbcGFyYW1zLmVuY3J5cHRlZFVzZXJUb0JpdGdvUlNoYXJlXSAtIGVuY3J5cHRlZCB1c2VyIHRvIGJpdGdvIFIgc2hhcmUgZ2VuZXJhdGVkIGluIHRoZSBjb21taXRtZW50IHBoYXNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgclNoYXJlOiBTaWduU2hhcmUgfT59IC0gUiBTaGFyZSB0byBCaXRHb1xuICAgKi9cbiAgY3JlYXRlUlNoYXJlRnJvbVR4UmVxdWVzdChwYXJhbXM6IHtcbiAgICB0eFJlcXVlc3Q6IFR4UmVxdWVzdDtcbiAgICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG4gICAgZW5jcnlwdGVkVXNlclRvQml0Z29SU2hhcmU6IEVuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkO1xuICB9KTogUHJvbWlzZTx7IHJTaGFyZTogU2lnblNoYXJlIH0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRyAoVXNlciB0byBCaXRHbykgc2hhcmUgZnJvbSBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiBhbmQgcHJpdmF0ZSB1c2VyIHNpZ25pbmcgbWF0ZXJpYWxcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtcyBvYmplY3RcbiAgICogQHBhcmFtIHtUeFJlcXVlc3R9IHBhcmFtcy50eFJlcXVlc3QgLSB0cmFuc2FjdGlvbiByZXF1ZXN0IHdpdGggdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wcnYgLSB1c2VyIHNpZ25pbmcgbWF0ZXJpYWxcbiAgICogQHBhcmFtIHtTaWduYXR1cmVTaGFyZVJlY29yZH0gcGFyYW1zLmJpdGdvVG9Vc2VyUlNoYXJlIC0gQml0R28gdG8gVXNlciBSIFNoYXJlXG4gICAqIEBwYXJhbSB7U2lnblNoYXJlfSBwYXJhbXMudXNlclRvQml0Z29SU2hhcmUgLSBVc2VyIHRvIEJpdEdvIFIgU2hhcmVcbiAgICogQHBhcmFtIHtDb21taXRtZW50U2hhcmVSZWNvcmR9IHBhcmFtcy5iaXRnb1RvVXNlckNvbW1pdG1lbnQgLSBCaXRHbyB0byBVc2VyIENvbW1pdG1lbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8R1NoYXJlPn0gLSBHU2hhcmUgZnJvbSBVc2VyIHRvIEJpdEdvXG4gICAqL1xuICBjcmVhdGVHU2hhcmVGcm9tVHhSZXF1ZXN0KHBhcmFtczoge1xuICAgIHR4UmVxdWVzdDogVHhSZXF1ZXN0O1xuICAgIHBydjogc3RyaW5nO1xuICAgIGJpdGdvVG9Vc2VyUlNoYXJlOiBTaWduYXR1cmVTaGFyZVJlY29yZDtcbiAgICB1c2VyVG9CaXRnb1JTaGFyZTogU2lnblNoYXJlO1xuICAgIGJpdGdvVG9Vc2VyQ29tbWl0bWVudDogQ29tbWl0bWVudFNoYXJlUmVjb3JkO1xuICB9KTogUHJvbWlzZTxHU2hhcmU+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgdHggcmVxdWVzdCBmcm9tIHBhcmFtcyBhbmQgdmVyaWZ5IGl0XG4gICAqXG4gICAqIEBwYXJhbSB7UHJlYnVpbGRUcmFuc2FjdGlvbldpdGhJbnRlbnRPcHRpb25zfSBwYXJhbXMgLSBwYXJhbWV0ZXJzIHRvIGJ1aWxkIHRoZSB0eFxuICAgKiBAcGFyYW0ge1R4UmVxdWVzdFZlcnNpb259IGFwaVZlcnNpb24gbGl0ZSBvciBmdWxsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlldyBib29sZWFuIGluZGljYXRpbmcgaWYgdGhpcyBpcyB0byBwcmV2aWV3IGEgdHggcmVxdWVzdCwgd2hpY2ggd2lsbCBub3QgaW5pdGlhdGUgcG9saWN5IGNoZWNrcyBvciBwZW5kaW5nIGFwcHJvdmFsc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fSAtIGEgYnVpbHQgdHggcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgcHJlYnVpbGRUeFdpdGhJbnRlbnQoXG4gICAgcGFyYW1zOiBQcmVidWlsZFRyYW5zYWN0aW9uV2l0aEludGVudE9wdGlvbnMsXG4gICAgYXBpVmVyc2lvbjogVHhSZXF1ZXN0VmVyc2lvbiA9ICdsaXRlJyxcbiAgICBwcmV2aWV3PzogYm9vbGVhblxuICApOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIGNvbnN0IGludGVudE9wdGlvbnMgPSB0aGlzLnBvcHVsYXRlSW50ZW50KHRoaXMuYmFzZUNvaW4sIHBhcmFtcyk7XG5cbiAgICBjb25zdCB3aGl0ZWxpc3RlZFBhcmFtcyA9IHtcbiAgICAgIGludGVudDoge1xuICAgICAgICAuLi5pbnRlbnRPcHRpb25zLFxuICAgICAgfSxcbiAgICAgIGFwaVZlcnNpb246IGFwaVZlcnNpb24sXG4gICAgICBwcmV2aWV3LFxuICAgIH07XG5cbiAgICBjb25zdCByZXFUcmFjZXIgPSBwYXJhbXMucmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxVHJhY2VyKTtcbiAgICBjb25zdCB1bnNpZ25lZFR4ID0gKGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYml0Z28udXJsKCcvd2FsbGV0LycgKyB0aGlzLndhbGxldC5pZCgpICsgJy90eHJlcXVlc3RzJywgMikpXG4gICAgICAuc2VuZCh3aGl0ZWxpc3RlZFBhcmFtcylcbiAgICAgIC5yZXN1bHQoKSkgYXMgVHhSZXF1ZXN0O1xuXG4gICAgcmV0dXJuIHVuc2lnbmVkVHg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdHggcmVxdWVzdCBmcm9tIHBhcmFtcyBmb3IgbWVzc2FnZSBzaWduaW5nXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGFwaVZlcnNpb25cbiAgICogQHBhcmFtIHByZXZpZXdcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVR4UmVxdWVzdFdpdGhJbnRlbnRGb3JNZXNzYWdlU2lnbmluZyhcbiAgICBwYXJhbXM6IEludGVudE9wdGlvbnNGb3JNZXNzYWdlLFxuICAgIGFwaVZlcnNpb246IFR4UmVxdWVzdFZlcnNpb24gPSAnZnVsbCcsXG4gICAgcHJldmlldz86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICBjb25zdCBpbnRlbnRPcHRpb25zOiBQb3B1bGF0ZWRJbnRlbnRGb3JNZXNzYWdlU2lnbmluZyA9IHtcbiAgICAgIGN1c3RvZGlhbk1lc3NhZ2VJZDogcGFyYW1zLmN1c3RvZGlhbk1lc3NhZ2VJZCxcbiAgICAgIGludGVudFR5cGU6IHBhcmFtcy5pbnRlbnRUeXBlLFxuICAgICAgc2VxdWVuY2VJZDogcGFyYW1zLnNlcXVlbmNlSWQsXG4gICAgICBjb21tZW50OiBwYXJhbXMuY29tbWVudCxcbiAgICAgIG1lbW86IHBhcmFtcy5tZW1vPy52YWx1ZSxcbiAgICAgIGlzVHNzOiBwYXJhbXMuaXNUc3MsXG4gICAgICBtZXNzYWdlUmF3OiBwYXJhbXMubWVzc2FnZVJhdyxcbiAgICAgIG1lc3NhZ2VFbmNvZGVkOiBwYXJhbXMubWVzc2FnZUVuY29kZWQgPz8gJycsXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVR4UmVxdWVzdEJhc2UoaW50ZW50T3B0aW9ucywgYXBpVmVyc2lvbiwgcHJldmlldywgcGFyYW1zLnJlcUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0eCByZXF1ZXN0IGZyb20gcGFyYW1zIGZvciB0eXBlIGRhdGEgc2lnbmluZ1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBhcGlWZXJzaW9uXG4gICAqIEBwYXJhbSBwcmV2aWV3XG4gICAqL1xuICBhc3luYyBjcmVhdGVUeFJlcXVlc3RXaXRoSW50ZW50Rm9yVHlwZWREYXRhU2lnbmluZyhcbiAgICBwYXJhbXM6IEludGVudE9wdGlvbnNGb3JUeXBlZERhdGEsXG4gICAgYXBpVmVyc2lvbjogVHhSZXF1ZXN0VmVyc2lvbiA9ICdmdWxsJyxcbiAgICBwcmV2aWV3PzogYm9vbGVhblxuICApOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIGNvbnN0IGludGVudE9wdGlvbnM6IFBvcHVsYXRlZEludGVudEZvclR5cGVkRGF0YVNpZ25pbmcgPSB7XG4gICAgICBjdXN0b2RpYW5NZXNzYWdlSWQ6IHBhcmFtcy5jdXN0b2RpYW5NZXNzYWdlSWQsXG4gICAgICBpbnRlbnRUeXBlOiBwYXJhbXMuaW50ZW50VHlwZSxcbiAgICAgIHNlcXVlbmNlSWQ6IHBhcmFtcy5zZXF1ZW5jZUlkLFxuICAgICAgY29tbWVudDogcGFyYW1zLmNvbW1lbnQsXG4gICAgICBtZW1vOiBwYXJhbXMubWVtbz8udmFsdWUsXG4gICAgICBpc1RzczogcGFyYW1zLmlzVHNzLFxuICAgICAgbWVzc2FnZVJhdzogcGFyYW1zLnR5cGVkRGF0YVJhdyxcbiAgICAgIG1lc3NhZ2VFbmNvZGVkOiBwYXJhbXMudHlwZWREYXRhRW5jb2RlZCA/PyAnJyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlVHhSZXF1ZXN0QmFzZShpbnRlbnRPcHRpb25zLCBhcGlWZXJzaW9uLCBwcmV2aWV3LCBwYXJhbXMucmVxSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIEJpdGdvIEFQSSB0byBjcmVhdGUgdHggcmVxdWVzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlVHhSZXF1ZXN0QmFzZShcbiAgICBpbnRlbnRPcHRpb25zOiBQb3B1bGF0ZWRJbnRlbnRGb3JUeXBlZERhdGFTaWduaW5nIHwgUG9wdWxhdGVkSW50ZW50Rm9yTWVzc2FnZVNpZ25pbmcsXG4gICAgYXBpVmVyc2lvbjogVHhSZXF1ZXN0VmVyc2lvbixcbiAgICBwcmV2aWV3PzogYm9vbGVhbixcbiAgICByZXFJZD86IElSZXF1ZXN0VHJhY2VyXG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgY29uc3Qgd2hpdGVsaXN0ZWRQYXJhbXMgPSB7XG4gICAgICBpbnRlbnQ6IHtcbiAgICAgICAgLi4uaW50ZW50T3B0aW9ucyxcbiAgICAgIH0sXG4gICAgICBhcGlWZXJzaW9uLFxuICAgICAgcHJldmlldyxcbiAgICB9O1xuXG4gICAgY29uc3QgcmVxVHJhY2VyID0gcmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxVHJhY2VyKTtcbiAgICByZXR1cm4gdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iaXRnby51cmwoYC93YWxsZXQvJHt0aGlzLndhbGxldC5pZCgpfS90eHJlcXVlc3RzYCwgMikpXG4gICAgICAuc2VuZCh3aGl0ZWxpc3RlZFBhcmFtcylcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGRlbGV0ZSBzaWduYXR1cmUgc2hhcmVzIGZvciBhIHR4UmVxdWVzdCwgdGhlIGVuZHBvaW50IGRlbGV0ZSB0aGUgc2lnbmF0dXJlcyBhbmQgcmV0dXJuIHRoZW1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR4UmVxdWVzdElkIHR4IGlkIHJlZmVyZW5jZSB0byBkZWxldGUgc2lnbmF0dXJlIHNoYXJlc1xuICAgKiBAcGFyYW0ge0lSZXF1ZXN0VHJhY2VyfSByZXFJZCAtIHRoZSByZXF1ZXN0IHRyYWNlciByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm5zIHtTaWduYXR1cmVTaGFyZVJlY29yZFtdfVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlU2lnbmF0dXJlU2hhcmVzKHR4UmVxdWVzdElkOiBzdHJpbmcsIHJlcUlkPzogSVJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPFNpZ25hdHVyZVNoYXJlUmVjb3JkW10+IHtcbiAgICBjb25zdCByZXFUcmFjZXIgPSByZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFUcmFjZXIpO1xuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAuZGVsKHRoaXMuYml0Z28udXJsKGAvd2FsbGV0LyR7dGhpcy53YWxsZXQuaWQoKX0vdHhyZXF1ZXN0cy8ke3R4UmVxdWVzdElkfS9zaWduYXR1cmVzaGFyZXNgLCAyKSlcbiAgICAgIC5zZW5kKClcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBzZW5kIHByb2NlZHVyZSBvbmNlIEJpdGdvIGhhcyB0aGUgVXNlciBUbyBCaXRnbyBHU2hhcmVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICAgKiBAcGFyYW0ge0lSZXF1ZXN0VHJhY2VyfSByZXFJZCAtIHRoZSByZXF1ZXN0IHRyYWNlciByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBhc3luYyBzZW5kVHhSZXF1ZXN0KHR4UmVxdWVzdElkOiBzdHJpbmcsIHJlcUlkPzogSVJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHJlcVRyYWNlciA9IHJlcUlkIHx8IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG4gICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcVRyYWNlcik7XG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyB0aGlzLndhbGxldC5pZCgpICsgJy90eC9zZW5kJykpXG4gICAgICAuc2VuZCh7IHR4UmVxdWVzdElkIH0pXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIHNpZ25hdHVyZSBzaGFyZXMsIGdldCB0aGUgdHggcmVxdWVzdCB3aXRob3V0IHRoZW0gZnJvbSB0aGUgZGIgYW5kIHNpZ24gaXQgdG8gZmluYWxseSBzZW5kIGl0LlxuICAgKlxuICAgKiBOb3RlIDogVGhpcyBjYW4gYmUgcGVyZm9ybWVkIGluIG9yZGVyIHRvIHJlYWNoIGxhdGVzdCBuZXR3b3JrIGNvbmRpdGlvbnMgcmVxdWlyZWQgb24gcGVuZGluZyBhcHByb3ZhbCBmbG93LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHhSZXF1ZXN0SWQgLSB0aGUgdHhSZXF1ZXN0IElkIHRvIG1ha2UgdGhlIHJlcXVlc3RzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjcnlwdGVkUHJ2IC0gZGVjcnlwdGVkIHBydiB0byBzaWduIHRoZSB0eCByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge1JlcXVlc3RUcmFjZXJ9IHJlcUlkIGlkIHRyYWNlci5cbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICovXG4gIGFzeW5jIHJlY3JlYXRlVHhSZXF1ZXN0KHR4UmVxdWVzdElkOiBzdHJpbmcsIGRlY3J5cHRlZFBydjogc3RyaW5nLCByZXFJZDogSVJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIGF3YWl0IHRoaXMuZGVsZXRlU2lnbmF0dXJlU2hhcmVzKHR4UmVxdWVzdElkLCByZXFJZCk7XG4gICAgLy8gYWZ0ZXIgZGVsZXRlIHNpZ25hdHVyZXMgc2hhcmVzIGdldCB0aGUgdHggd2l0aG91dCB0aGVtXG4gICAgY29uc3QgdHhSZXF1ZXN0ID0gYXdhaXQgZ2V0VHhSZXF1ZXN0KHRoaXMuYml0Z28sIHRoaXMud2FsbGV0LmlkKCksIHR4UmVxdWVzdElkLCByZXFJZCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnblR4UmVxdWVzdCh7IHR4UmVxdWVzdCwgcHJ2OiBkZWNyeXB0ZWRQcnYsIHJlcUlkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxhdGVzdCBUeCBSZXF1ZXN0IGJ5IGlkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eFJlcXVlc3RJZCAtIHRoZSB0eFJlcXVlc3QgSWRcbiAgICogQHBhcmFtIHtJUmVxdWVzdFRyYWNlcn0gcmVxSWQgLSByZXF1ZXN0IHRyYWNlciByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFR4UmVxdWVzdD59XG4gICAqL1xuICBhc3luYyBnZXRUeFJlcXVlc3QodHhSZXF1ZXN0SWQ6IHN0cmluZywgcmVxSWQ/OiBJUmVxdWVzdFRyYWNlcik6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgcmV0dXJuIGdldFR4UmVxdWVzdCh0aGlzLmJpdGdvLCB0aGlzLndhbGxldC5pZCgpLCB0eFJlcXVlc3RJZCwgcmVxSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB0aGlyZCBwYXJ0eSBiYWNrdXAgcHJvdmlkZXIgaXMgdmFsaWQvc3VwcG9ydGVkXG4gICAqIEBwYXJhbSBiYWNrdXBQcm92aWRlciAtIHRoZSBiYWNrdXAgcHJvdmlkZXIgY2xpZW50IHNlbGVjdGVkXG4gICAqL1xuICBpc1ZhbGlkVGhpcmRQYXJ0eUJhY2t1cFByb3ZpZGVyKFxuICAgIGJhY2t1cFByb3ZpZGVyOiBCYWNrdXBQcm92aWRlciB8IHN0cmluZyB8IHVuZGVmaW5lZFxuICApOiBiYWNrdXBQcm92aWRlciBpcyBCYWNrdXBQcm92aWRlciB7XG4gICAgLy8gQXMgb2Ygbm93LCBCaXRHbyBpcyB0aGUgb25seSBzdXBwb3J0ZWQgS1JTIHByb3ZpZGVyIGZvciBUU1NcbiAgICByZXR1cm4gISEoYmFja3VwUHJvdmlkZXIgJiYgYmFja3VwUHJvdmlkZXIgPT09ICdCaXRHb1RydXN0QXNLcnMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCBnZXRzIHRoZSBhcHByb3ByaWF0ZSBCaXRHbyBHUEcgcHVibGljIGtleSBmb3Iga2V5IGNyZWF0aW9uIGJhc2VkIG9uIGFcbiAgICogY29tYmluYXRpb24gb2YgY29pbiBhbmQgdGhlIGZlYXR1cmUgZmxhZ3Mgb24gdGhlIHVzZXIgYW5kIHRoZWlyIGVudGVycHJpc2UgaWYgc2V0LlxuICAgKiBAcGFyYW0gZW50ZXJwcmlzZUlkIC0gZW50ZXJwcmlzZSB1bmRlciB3aGljaCB1c2VyIHdhbnRzIHRvIGNyZWF0ZSB0aGUgd2FsbGV0XG4gICAqIEBwYXJhbSBpc01QQ3YyIC0gdHJ1ZSB0byBnZXQgdGhlIE1QQ3YyIEdQRyBwdWJsaWMga2V5LCBkZWZhdWx0cyB0byBmYWxzZVxuICAgKiBAcGFyYW0gcmVxSWQgLSByZXF1ZXN0IHRyYWNlciByZXF1ZXN0IGlkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0Qml0Z29HcGdQdWJrZXlCYXNlZE9uRmVhdHVyZUZsYWdzKFxuICAgIGVudGVycHJpc2VJZDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGlzTVBDdjIgPSBmYWxzZSxcbiAgICByZXFJZD86IElSZXF1ZXN0VHJhY2VyXG4gICk6IFByb21pc2U8S2V5PiB7XG4gICAgY29uc3QgcmVxVHJhY2VyID0gcmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxVHJhY2VyKTtcbiAgICBjb25zdCByZXNwb25zZTogQml0Z29HUEdQdWJsaWNLZXkgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAuZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvdHNzL3B1YmtleScpKVxuICAgICAgLnF1ZXJ5KHsgZW50ZXJwcmlzZUlkIH0pXG4gICAgICAucmV0cnkoMylcbiAgICAgIC5yZXN1bHQoKTtcbiAgICBjb25zdCBiaXRnb1B1YmxpY0tleVN0ciA9IGlzTVBDdjIgPyByZXNwb25zZS5tcGN2MlB1YmxpY0tleSA6IHJlc3BvbnNlLnB1YmxpY0tleTtcbiAgICByZXR1cm4gcmVhZEtleSh7IGFybW9yZWRLZXk6IGJpdGdvUHVibGljS2V5U3RyIGFzIHN0cmluZyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN1cHBvcnRlZCBUeFJlcXVlc3QgdmVyc2lvbnMgZm9yIHRoaXMgd2FsbGV0XG4gICAqL1xuICBwdWJsaWMgc3VwcG9ydGVkVHhSZXF1ZXN0VmVyc2lvbnMoKTogVHhSZXF1ZXN0VmVyc2lvbltdIHtcbiAgICBjb25zdCB3YWxsZXRUeXBlID0gdGhpcy5fd2FsbGV0Py50eXBlKCk7XG4gICAgY29uc3Qgc3VwcG9ydGVkV2FsbGV0VHlwZXMgPSBbJ2N1c3RvZGlhbCcsICdjb2xkJywgJ2hvdCddO1xuICAgIGlmICghd2FsbGV0VHlwZSB8fCB0aGlzLl93YWxsZXQ/Lm11bHRpc2lnVHlwZSgpICE9PSAndHNzJyB8fCAhc3VwcG9ydGVkV2FsbGV0VHlwZXMuaW5jbHVkZXMod2FsbGV0VHlwZSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbGxldD8uYmFzZUNvaW4uZ2V0TVBDQWxnb3JpdGhtKCkgPT09ICdlY2RzYScpIHtcbiAgICAgIHJldHVybiBbJ2Z1bGwnXTtcbiAgICB9IGVsc2UgaWYgKHdhbGxldFR5cGUgPT09ICdjdXN0b2RpYWwnIHx8IHdhbGxldFR5cGUgPT09ICdjb2xkJykge1xuICAgICAgcmV0dXJuIFsnZnVsbCddO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fd2FsbGV0Py5iYXNlQ29pbi5nZXRNUENBbGdvcml0aG0oKSA9PT0gJ2VkZHNhJyAmJiB3YWxsZXRUeXBlID09PSAnaG90Jykge1xuICAgICAgcmV0dXJuIFsnbGl0ZScsICdmdWxsJ107XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR4UmVxdWVzdCBpcyB1c2luZyBhcGlWZXJzaW9uID09IGZ1bGwgYW5kIGlzIHBlbmRpbmcgYXBwcm92YWxcbiAgICogQHBhcmFtIHR4UmVxdWVzdFxuICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAqL1xuICBpc1BlbmRpbmdBcHByb3ZhbFR4UmVxdWVzdEZ1bGwodHhSZXF1ZXN0OiBUeFJlcXVlc3QpOiBib29sZWFuIHtcbiAgICBjb25zdCB7IGFwaVZlcnNpb24sIHN0YXRlIH0gPSB0eFJlcXVlc3Q7XG4gICAgcmV0dXJuIGFwaVZlcnNpb24gPT09ICdmdWxsJyAmJiAncGVuZGluZ0FwcHJvdmFsJyA9PT0gc3RhdGU7XG4gIH1cbn1cbiJdfQ==