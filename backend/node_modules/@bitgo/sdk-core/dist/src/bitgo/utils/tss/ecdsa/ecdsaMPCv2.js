"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signRecoveryMpcV2 = exports.getMpcV2RecoveryKeyShares = exports.isGG18SigningMaterial = exports.EcdsaMPCv2Utils = void 0;
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const sjcl = __importStar(require("@bitgo/sjcl"));
const assert_1 = __importDefault(require("assert"));
const buffer_1 = require("buffer");
const io_ts_types_1 = require("io-ts-types");
const keccak_1 = __importDefault(require("keccak"));
const pgp = __importStar(require("openpgp"));
const public_types_1 = require("@bitgo/public-types");
const account_lib_1 = require("../../../../account-lib");
const tss_1 = require("../../../tss");
const common_1 = require("../../../tss/common");
const typesMPCv2_1 = require("./typesMPCv2");
const ecdsaMPCv2_1 = require("../../../tss/ecdsa/ecdsaMPCv2");
const opengpgUtils_1 = require("../../opengpgUtils");
const baseTypes_1 = require("../baseTypes");
const base_1 = require("./base");
class EcdsaMPCv2Utils extends base_1.BaseEcdsaUtils {
    /** @inheritdoc */
    async createKeychains(params) {
        var _a, _b;
        const { userSession, backupSession } = this.getUserAndBackupSession(2, 3, params.retrofit);
        const userGpgKey = await (0, opengpgUtils_1.generateGPGKeyPair)('secp256k1');
        const backupGpgKey = await (0, opengpgUtils_1.generateGPGKeyPair)('secp256k1');
        // Get the BitGo public key based on user/enterprise feature flags
        // If it doesn't work, use the default public key from the constants
        const bitgoPublicGpgKey = ((_a = (await this.getBitgoGpgPubkeyBasedOnFeatureFlags(params.enterprise, true))) !== null && _a !== void 0 ? _a : this.bitgoMPCv2PublicGpgKey).armor();
        const userGpgPrvKey = {
            partyId: typesMPCv2_1.MPCv2PartiesEnum.USER,
            gpgKey: userGpgKey.privateKey,
        };
        const backupGpgPrvKey = {
            partyId: typesMPCv2_1.MPCv2PartiesEnum.BACKUP,
            gpgKey: backupGpgKey.privateKey,
        };
        const bitgoGpgPubKey = {
            partyId: typesMPCv2_1.MPCv2PartiesEnum.BITGO,
            gpgKey: bitgoPublicGpgKey,
        };
        // #region round 1
        const userRound1BroadcastMsg = await userSession.initDkg();
        const backupRound1BroadcastMsg = await backupSession.initDkg();
        const round1SerializedMessages = sdk_lib_mpc_1.DklsTypes.serializeMessages({
            broadcastMessages: [userRound1BroadcastMsg, backupRound1BroadcastMsg],
            p2pMessages: [],
        });
        const round1Messages = await sdk_lib_mpc_1.DklsComms.encryptAndAuthOutgoingMessages(round1SerializedMessages, [bitgoGpgPubKey], [userGpgPrvKey, backupGpgPrvKey]);
        const { sessionId, bitgoMsg1, bitgoToBackupMsg2, bitgoToUserMsg2 } = await this.sendKeyGenerationRound1(params.enterprise, userGpgKey.publicKey, backupGpgKey.publicKey, ((_b = params.retrofit) === null || _b === void 0 ? void 0 : _b.walletId)
            ? {
                ...round1Messages,
                walletId: params.retrofit.walletId,
            }
            : round1Messages);
        // #endregion
        // #region round 2
        const bitgoRound1BroadcastMessages = await sdk_lib_mpc_1.DklsComms.decryptAndVerifyIncomingMessages({ p2pMessages: [], broadcastMessages: [this.formatBitgoBroadcastMessage(bitgoMsg1)] }, [bitgoGpgPubKey], [userGpgPrvKey, backupGpgPrvKey]);
        const bitgoRound1BroadcastMsg = bitgoRound1BroadcastMessages.broadcastMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BITGO);
        (0, assert_1.default)(bitgoRound1BroadcastMsg, 'BitGo message 1 not found in broadcast messages');
        const userRound2P2PMessages = userSession.handleIncomingMessages({
            p2pMessages: [],
            broadcastMessages: [sdk_lib_mpc_1.DklsTypes.deserializeBroadcastMessage(bitgoRound1BroadcastMsg), backupRound1BroadcastMsg],
        });
        const userToBitgoMsg2 = userRound2P2PMessages.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.USER && m.to === typesMPCv2_1.MPCv2PartiesEnum.BITGO);
        (0, assert_1.default)(userToBitgoMsg2, 'User message 2 not found in P2P messages');
        const serializedUserToBitgoMsg2 = sdk_lib_mpc_1.DklsTypes.serializeP2PMessage(userToBitgoMsg2);
        const backupRound2P2PMessages = backupSession.handleIncomingMessages({
            p2pMessages: [],
            broadcastMessages: [userRound1BroadcastMsg, sdk_lib_mpc_1.DklsTypes.deserializeBroadcastMessage(bitgoRound1BroadcastMsg)],
        });
        const serializedBackupToBitgoMsg2 = sdk_lib_mpc_1.DklsTypes.serializeMessages(backupRound2P2PMessages).p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BACKUP && m.to === typesMPCv2_1.MPCv2PartiesEnum.BITGO);
        (0, assert_1.default)(serializedBackupToBitgoMsg2, 'Backup message 2 not found in P2P messages');
        const round2Messages = await sdk_lib_mpc_1.DklsComms.encryptAndAuthOutgoingMessages({ p2pMessages: [serializedUserToBitgoMsg2, serializedBackupToBitgoMsg2], broadcastMessages: [] }, [bitgoGpgPubKey], [userGpgPrvKey, backupGpgPrvKey]);
        const { sessionId: sessionIdRound2, bitgoCommitment2, bitgoToUserMsg3, bitgoToBackupMsg3, } = await this.sendKeyGenerationRound2(params.enterprise, sessionId, round2Messages);
        // #endregion
        // #region round 3
        assert_1.default.equal(sessionId, sessionIdRound2, 'Round 1 and 2 Session IDs do not match');
        const decryptedBitgoToUserRound2Msgs = await sdk_lib_mpc_1.DklsComms.decryptAndVerifyIncomingMessages({ p2pMessages: [this.formatP2PMessage(bitgoToUserMsg2)], broadcastMessages: [] }, [bitgoGpgPubKey], [userGpgPrvKey]);
        const serializedBitgoToUserRound2Msg = decryptedBitgoToUserRound2Msgs.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BITGO && m.to === typesMPCv2_1.MPCv2PartiesEnum.USER);
        (0, assert_1.default)(serializedBitgoToUserRound2Msg, 'BitGo to User message 2 not found in P2P messages');
        const bitgoToUserRound2Msg = sdk_lib_mpc_1.DklsTypes.deserializeP2PMessage(serializedBitgoToUserRound2Msg);
        const decryptedBitgoToBackupRound2Msg = await sdk_lib_mpc_1.DklsComms.decryptAndVerifyIncomingMessages({ p2pMessages: [this.formatP2PMessage(bitgoToBackupMsg2)], broadcastMessages: [] }, [bitgoGpgPubKey], [backupGpgPrvKey]);
        const serializedBitgoToBackupRound2Msg = decryptedBitgoToBackupRound2Msg.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BITGO && m.to === typesMPCv2_1.MPCv2PartiesEnum.BACKUP);
        (0, assert_1.default)(serializedBitgoToBackupRound2Msg, 'BitGo to Backup message 2 not found in P2P messages');
        const bitgoToBackupRound2Msg = sdk_lib_mpc_1.DklsTypes.deserializeP2PMessage(serializedBitgoToBackupRound2Msg);
        const userToBackupMsg2 = userRound2P2PMessages.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.USER && m.to === typesMPCv2_1.MPCv2PartiesEnum.BACKUP);
        (0, assert_1.default)(userToBackupMsg2, 'User to Backup message 2 not found in P2P messages');
        const backupToUserMsg2 = backupRound2P2PMessages.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BACKUP && m.to === typesMPCv2_1.MPCv2PartiesEnum.USER);
        (0, assert_1.default)(backupToUserMsg2, 'Backup to User message 2 not found in P2P messages');
        const userRound3Messages = userSession.handleIncomingMessages({
            broadcastMessages: [],
            p2pMessages: [bitgoToUserRound2Msg, backupToUserMsg2],
        });
        const userToBackupMsg3 = userRound3Messages.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.USER && m.to === typesMPCv2_1.MPCv2PartiesEnum.BACKUP);
        (0, assert_1.default)(userToBackupMsg3, 'User to Backup message 3 not found in P2P messages');
        const userToBitgoMsg3 = userRound3Messages.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.USER && m.to === typesMPCv2_1.MPCv2PartiesEnum.BITGO);
        (0, assert_1.default)(userToBitgoMsg3, 'User to Bitgo message 3 not found in P2P messages');
        const serializedUserToBitgoMsg3 = sdk_lib_mpc_1.DklsTypes.serializeP2PMessage(userToBitgoMsg3);
        const backupRound3Messages = backupSession.handleIncomingMessages({
            broadcastMessages: [],
            p2pMessages: [bitgoToBackupRound2Msg, userToBackupMsg2],
        });
        const backupToUserMsg3 = backupRound3Messages.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BACKUP && m.to === typesMPCv2_1.MPCv2PartiesEnum.USER);
        (0, assert_1.default)(backupToUserMsg3, 'Backup to User message 3 not found in P2P messages');
        const backupToBitgoMsg3 = backupRound3Messages.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BACKUP && m.to === typesMPCv2_1.MPCv2PartiesEnum.BITGO);
        (0, assert_1.default)(backupToBitgoMsg3, 'Backup to Bitgo message 3 not found in P2P messages');
        const serializedBackupToBitgoMsg3 = sdk_lib_mpc_1.DklsTypes.serializeP2PMessage(backupToBitgoMsg3);
        const decryptedBitgoToUserRound3Messages = await sdk_lib_mpc_1.DklsComms.decryptAndVerifyIncomingMessages({ broadcastMessages: [], p2pMessages: [this.formatP2PMessage(bitgoToUserMsg3, bitgoCommitment2)] }, [bitgoGpgPubKey], [userGpgPrvKey]);
        const serializedBitgoToUserRound3Msg = decryptedBitgoToUserRound3Messages.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BITGO && m.to === typesMPCv2_1.MPCv2PartiesEnum.USER);
        (0, assert_1.default)(serializedBitgoToUserRound3Msg, 'BitGo to User message 3 not found in P2P messages');
        const bitgoToUserRound3Msg = sdk_lib_mpc_1.DklsTypes.deserializeP2PMessage(serializedBitgoToUserRound3Msg);
        const decryptedBitgoToBackupRound3Messages = await sdk_lib_mpc_1.DklsComms.decryptAndVerifyIncomingMessages({ broadcastMessages: [], p2pMessages: [this.formatP2PMessage(bitgoToBackupMsg3, bitgoCommitment2)] }, [bitgoGpgPubKey], [backupGpgPrvKey]);
        const serializedBitgoToBackupRound3Msg = decryptedBitgoToBackupRound3Messages.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BITGO && m.to === typesMPCv2_1.MPCv2PartiesEnum.BACKUP);
        (0, assert_1.default)(serializedBitgoToBackupRound3Msg, 'BitGo to Backup message 3 not found in P2P messages');
        const bitgoToBackupRound3Msg = sdk_lib_mpc_1.DklsTypes.deserializeP2PMessage(serializedBitgoToBackupRound3Msg);
        const userRound4Messages = userSession.handleIncomingMessages({
            p2pMessages: [backupToUserMsg3, bitgoToUserRound3Msg],
            broadcastMessages: [],
        });
        const userRound4BroadcastMsg = userRound4Messages.broadcastMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.USER);
        (0, assert_1.default)(userRound4BroadcastMsg, 'User message 4 not found in broadcast messages');
        const serializedUserRound4BroadcastMsg = sdk_lib_mpc_1.DklsTypes.serializeBroadcastMessage(userRound4BroadcastMsg);
        const backupRound4Messages = backupSession.handleIncomingMessages({
            p2pMessages: [userToBackupMsg3, bitgoToBackupRound3Msg],
            broadcastMessages: [],
        });
        const backupRound4BroadcastMsg = backupRound4Messages.broadcastMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BACKUP);
        (0, assert_1.default)(backupRound4BroadcastMsg, 'Backup message 4 not found in broadcast messages');
        const serializedBackupRound4BroadcastMsg = sdk_lib_mpc_1.DklsTypes.serializeBroadcastMessage(backupRound4BroadcastMsg);
        const round3Messages = await sdk_lib_mpc_1.DklsComms.encryptAndAuthOutgoingMessages({
            p2pMessages: [serializedUserToBitgoMsg3, serializedBackupToBitgoMsg3],
            broadcastMessages: [serializedUserRound4BroadcastMsg, serializedBackupRound4BroadcastMsg],
        }, [bitgoGpgPubKey], [userGpgPrvKey, backupGpgPrvKey]);
        const { sessionId: sessionIdRound3, bitgoMsg4, commonKeychain: bitgoCommonKeychain, } = await this.sendKeyGenerationRound3(params.enterprise, sessionId, round3Messages);
        // #endregion
        // #region keychain creation
        assert_1.default.equal(sessionId, sessionIdRound3, 'Round 1 and 3 Session IDs do not match');
        const bitgoRound4BroadcastMessages = sdk_lib_mpc_1.DklsTypes.deserializeMessages(await sdk_lib_mpc_1.DklsComms.decryptAndVerifyIncomingMessages({ p2pMessages: [], broadcastMessages: [this.formatBitgoBroadcastMessage(bitgoMsg4)] }, [bitgoGpgPubKey], [])).broadcastMessages;
        const bitgoRound4BroadcastMsg = bitgoRound4BroadcastMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BITGO);
        (0, assert_1.default)(bitgoRound4BroadcastMsg, 'BitGo message 4 not found in broadcast messages');
        userSession.handleIncomingMessages({
            p2pMessages: [],
            broadcastMessages: [bitgoRound4BroadcastMsg, backupRound4BroadcastMsg],
        });
        backupSession.handleIncomingMessages({
            p2pMessages: [],
            broadcastMessages: [bitgoRound4BroadcastMsg, userRound4BroadcastMsg],
        });
        const userPrivateMaterial = userSession.getKeyShare();
        const backupPrivateMaterial = backupSession.getKeyShare();
        const userReducedPrivateMaterial = userSession.getReducedKeyShare();
        const backupReducedPrivateMaterial = backupSession.getReducedKeyShare();
        const userCommonKeychain = sdk_lib_mpc_1.DklsTypes.getCommonKeychain(userPrivateMaterial);
        const backupCommonKeychain = sdk_lib_mpc_1.DklsTypes.getCommonKeychain(backupPrivateMaterial);
        assert_1.default.equal(bitgoCommonKeychain, userCommonKeychain, 'User and Bitgo Common keychains do not match');
        assert_1.default.equal(bitgoCommonKeychain, backupCommonKeychain, 'Backup and Bitgo Common keychains do not match');
        const userKeychainPromise = this.addUserKeychain(bitgoCommonKeychain, userPrivateMaterial, userReducedPrivateMaterial, params.passphrase, params.originalPasscodeEncryptionCode);
        const backupKeychainPromise = this.addBackupKeychain(bitgoCommonKeychain, userPrivateMaterial, backupReducedPrivateMaterial, params.passphrase, params.originalPasscodeEncryptionCode);
        const bitgoKeychainPromise = this.addBitgoKeychain(bitgoCommonKeychain);
        const [userKeychain, backupKeychain, bitgoKeychain] = await Promise.all([
            userKeychainPromise,
            backupKeychainPromise,
            bitgoKeychainPromise,
        ]);
        // #endregion
        return {
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
    }
    // #region keychain utils
    async createParticipantKeychain(participantIndex, commonKeychain, privateMaterial, reducedPrivateMaterial, passphrase, originalPasscodeEncryptionCode) {
        let source;
        let encryptedPrv = undefined;
        let reducedEncryptedPrv = undefined;
        switch (participantIndex) {
            case typesMPCv2_1.MPCv2PartiesEnum.USER:
            case typesMPCv2_1.MPCv2PartiesEnum.BACKUP:
                source = participantIndex === typesMPCv2_1.MPCv2PartiesEnum.USER ? 'user' : 'backup';
                (0, assert_1.default)(privateMaterial, `Private material is required for ${source} keychain`);
                (0, assert_1.default)(reducedPrivateMaterial, `Reduced private material is required for ${source} keychain`);
                (0, assert_1.default)(passphrase, `Passphrase is required for ${source} keychain`);
                encryptedPrv = this.bitgo.encrypt({
                    input: privateMaterial.toString('base64'),
                    password: passphrase,
                });
                reducedEncryptedPrv = this.bitgo.encrypt({
                    // Buffer.toString('base64') can not be used here as it does not work on the browser.
                    // The browser deals with a Buffer as Uint8Array, therefore in the browser .toString('base64') just creates a comma seperated string of the array values.
                    input: btoa(String.fromCharCode.apply(null, Array.from(new Uint8Array(reducedPrivateMaterial)))),
                    password: passphrase,
                });
                break;
            case typesMPCv2_1.MPCv2PartiesEnum.BITGO:
                source = 'bitgo';
                break;
            default:
                throw new Error('Invalid participant index');
        }
        const recipientKeychainParams = {
            source,
            keyType: 'tss',
            commonKeychain,
            encryptedPrv,
            originalPasscodeEncryptionCode,
            isMPCv2: true,
        };
        const keychains = this.baseCoin.keychains();
        return { ...(await keychains.add(recipientKeychainParams)), reducedEncryptedPrv: reducedEncryptedPrv };
    }
    /**
     * Converts user and backup MPCv1 SigningMaterial to RetrofitData needed by MPCv2 DKG.
     *
     * @param {Object} params - MPCv1 decrypted signing material for user and backup as a json.stringify string and bitgo's Big Si.
     * @returns {{ mpcv2UserKeyShare: DklsTypes.RetrofitData; mpcv2BakcupKeyShare: DklsTypes.RetrofitData }} - the retrofit data needed to start an MPCv2 DKG session.
     */
    getMpcV2RetrofitDataFromMpcV1Keys(params) {
        const mpc = new account_lib_1.Ecdsa();
        const xiList = [
            Array.from((0, sdk_lib_mpc_1.bigIntToBufferBE)(BigInt(1), 32)),
            Array.from((0, sdk_lib_mpc_1.bigIntToBufferBE)(BigInt(2), 32)),
            Array.from((0, sdk_lib_mpc_1.bigIntToBufferBE)(BigInt(3), 32)),
        ];
        return {
            mpcv2UserKeyShare: this.getMpcV2RetrofitDataFromMpcV1Key({
                mpcv1PartyKeyShare: params.mpcv1UserKeyShare,
                mpcv1PartyIndex: 1,
                xiList,
                mpc,
            }),
            mpcv2BackupKeyShare: this.getMpcV2RetrofitDataFromMpcV1Key({
                mpcv1PartyKeyShare: params.mpcv1BackupKeyShare,
                mpcv1PartyIndex: 2,
                xiList,
                mpc,
            }),
        };
    }
    getMpcV2RetrofitDataFromMpcV1Key({ mpcv1PartyKeyShare, mpcv1PartyIndex, xiList, mpc, }) {
        const signingMaterial = JSON.parse(mpcv1PartyKeyShare);
        let keyCombined = undefined;
        switch (mpcv1PartyIndex) {
            case 1:
                (0, assert_1.default)(signingMaterial.backupNShare, 'User MPCv1 key material should have backup NShare.');
                (0, assert_1.default)(signingMaterial.bitgoNShare, 'BitGo MPCv1 key material should have user NShare.');
                keyCombined = mpc.keyCombine(signingMaterial.pShare, [
                    signingMaterial.backupNShare,
                    signingMaterial.bitgoNShare,
                ]);
                break;
            case 2:
                (0, assert_1.default)(signingMaterial.userNShare, 'User MPCv1 key material should have backup NShare.');
                (0, assert_1.default)(signingMaterial.bitgoNShare, 'BitGo MPCv1 key material should have user NShare.');
                keyCombined = mpc.keyCombine(signingMaterial.pShare, [signingMaterial.userNShare, signingMaterial.bitgoNShare]);
                break;
            case 3:
                (0, assert_1.default)(signingMaterial.userNShare, 'User MPCv1 key material should have backup NShare.');
                (0, assert_1.default)(signingMaterial.backupNShare, 'Backup MPCv1 key material should have user NShare.');
                keyCombined = mpc.keyCombine(signingMaterial.pShare, [
                    signingMaterial.userNShare,
                    signingMaterial.backupNShare,
                ]);
                break;
            default:
                throw new Error('Invalid participant index');
        }
        return {
            xShare: keyCombined.xShare,
            xiList: xiList,
        };
    }
    async addUserKeychain(commonKeychain, privateMaterial, reducedPrivateMaterial, passphrase, originalPasscodeEncryptionCode) {
        return this.createParticipantKeychain(typesMPCv2_1.MPCv2PartiesEnum.USER, commonKeychain, privateMaterial, reducedPrivateMaterial, passphrase, originalPasscodeEncryptionCode);
    }
    async addBackupKeychain(commonKeychain, privateMaterial, reducedPrivateMaterial, passphrase, originalPasscodeEncryptionCode) {
        return this.createParticipantKeychain(typesMPCv2_1.MPCv2PartiesEnum.BACKUP, commonKeychain, privateMaterial, reducedPrivateMaterial, passphrase, originalPasscodeEncryptionCode);
    }
    getUserAndBackupSession(m, n, retrofit) {
        if (retrofit) {
            const retrofitData = this.getMpcV2RetrofitDataFromMpcV1Keys({
                mpcv1UserKeyShare: retrofit.decryptedUserKey,
                mpcv1BackupKeyShare: retrofit.decryptedBackupKey,
            });
            const userSession = new sdk_lib_mpc_1.DklsDkg.Dkg(n, m, typesMPCv2_1.MPCv2PartiesEnum.USER, undefined, retrofitData.mpcv2UserKeyShare);
            const backupSession = new sdk_lib_mpc_1.DklsDkg.Dkg(n, m, typesMPCv2_1.MPCv2PartiesEnum.BACKUP, undefined, retrofitData.mpcv2BackupKeyShare);
            return { userSession, backupSession };
        }
        const userSession = new sdk_lib_mpc_1.DklsDkg.Dkg(n, m, typesMPCv2_1.MPCv2PartiesEnum.USER);
        const backupSession = new sdk_lib_mpc_1.DklsDkg.Dkg(n, m, typesMPCv2_1.MPCv2PartiesEnum.BACKUP);
        return { userSession, backupSession };
    }
    async addBitgoKeychain(commonKeychain) {
        return this.createParticipantKeychain(typesMPCv2_1.MPCv2PartiesEnum.BITGO, commonKeychain);
    }
    // #endregion
    // #region generate key request utils
    async sendKeyGenerationRequest(enterprise, round, payload) {
        return this.bitgo
            .post(this.bitgo.url('/mpc/generatekey', 2))
            .send({ enterprise, type: public_types_1.KeyGenTypeEnum.MPCv2, round, payload })
            .result();
    }
    async sendKeyGenerationRound1(enterprise, userGpgPublicKey, backupGpgPublicKey, payload) {
        var _a, _b;
        (0, assert_1.default)(io_ts_types_1.NonEmptyString.is(userGpgPublicKey), 'User GPG public key is required');
        (0, assert_1.default)(io_ts_types_1.NonEmptyString.is(backupGpgPublicKey), 'Backup GPG public key is required');
        const userMsg1 = (_a = payload.broadcastMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.USER)) === null || _a === void 0 ? void 0 : _a.payload;
        (0, assert_1.default)(userMsg1, 'User message 1 not found in broadcast messages');
        const backupMsg1 = (_b = payload.broadcastMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BACKUP)) === null || _b === void 0 ? void 0 : _b.payload;
        (0, assert_1.default)(backupMsg1, 'Backup message 1 not found in broadcast messages');
        return this.sendKeyGenerationRequest(enterprise, public_types_1.MPCv2KeyGenStateEnum['MPCv2-R1'], {
            userGpgPublicKey,
            backupGpgPublicKey,
            userMsg1: { from: 0, ...userMsg1 },
            backupMsg1: { from: 1, ...backupMsg1 },
            walletId: payload.walletId,
        });
    }
    async sendKeyGenerationRound2(enterprise, sessionId, payload) {
        (0, assert_1.default)(io_ts_types_1.NonEmptyString.is(sessionId), 'Session ID is required');
        const userMsg2 = payload.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.USER && m.to === typesMPCv2_1.MPCv2PartiesEnum.BITGO);
        (0, assert_1.default)(userMsg2, 'User to Bitgo message 2 not found in P2P messages');
        (0, assert_1.default)(userMsg2.commitment, 'User to Bitgo commitment not found in P2P messages');
        (0, assert_1.default)(io_ts_types_1.NonEmptyString.is(userMsg2.commitment), 'User to Bitgo commitment is required');
        const backupMsg2 = payload.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BACKUP && m.to === typesMPCv2_1.MPCv2PartiesEnum.BITGO);
        (0, assert_1.default)(backupMsg2, 'Backup to Bitgo message 2 not found in P2P messages');
        (0, assert_1.default)(backupMsg2.commitment, 'Backup to Bitgo commitment not found in P2P messages');
        (0, assert_1.default)(io_ts_types_1.NonEmptyString.is(backupMsg2.commitment), 'Backup to Bitgo commitment is required');
        return this.sendKeyGenerationRequest(enterprise, public_types_1.MPCv2KeyGenStateEnum['MPCv2-R2'], {
            sessionId,
            userMsg2: {
                from: typesMPCv2_1.MPCv2PartiesEnum.USER,
                to: typesMPCv2_1.MPCv2PartiesEnum.BITGO,
                signature: userMsg2.payload.signature,
                encryptedMessage: userMsg2.payload.encryptedMessage,
            },
            userCommitment2: userMsg2.commitment,
            backupMsg2: {
                from: typesMPCv2_1.MPCv2PartiesEnum.BACKUP,
                to: typesMPCv2_1.MPCv2PartiesEnum.BITGO,
                signature: backupMsg2.payload.signature,
                encryptedMessage: backupMsg2.payload.encryptedMessage,
            },
            backupCommitment2: backupMsg2.commitment,
        });
    }
    async sendKeyGenerationRound3(enterprise, sessionId, payload) {
        var _a, _b, _c, _d;
        (0, assert_1.default)(io_ts_types_1.NonEmptyString.is(sessionId), 'Session ID is required');
        const userMsg3 = (_a = payload.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.USER && m.to === typesMPCv2_1.MPCv2PartiesEnum.BITGO)) === null || _a === void 0 ? void 0 : _a.payload;
        (0, assert_1.default)(userMsg3, 'User to Bitgo message 3 not found in P2P messages');
        const backupMsg3 = (_b = payload.p2pMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BACKUP && m.to === typesMPCv2_1.MPCv2PartiesEnum.BITGO)) === null || _b === void 0 ? void 0 : _b.payload;
        (0, assert_1.default)(backupMsg3, 'Backup to Bitgo message 3 not found in P2P messages');
        const userMsg4 = (_c = payload.broadcastMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.USER)) === null || _c === void 0 ? void 0 : _c.payload;
        (0, assert_1.default)(userMsg4, 'User message 1 not found in broadcast messages');
        const backupMsg4 = (_d = payload.broadcastMessages.find((m) => m.from === typesMPCv2_1.MPCv2PartiesEnum.BACKUP)) === null || _d === void 0 ? void 0 : _d.payload;
        (0, assert_1.default)(backupMsg4, 'Backup message 1 not found in broadcast messages');
        return this.sendKeyGenerationRequest(enterprise, public_types_1.MPCv2KeyGenStateEnum['MPCv2-R3'], {
            sessionId,
            userMsg3: { from: 0, to: 2, ...userMsg3 },
            backupMsg3: { from: 1, to: 2, ...backupMsg3 },
            userMsg4: { from: 0, ...userMsg4 },
            backupMsg4: { from: 1, ...backupMsg4 },
        });
    }
    // #endregion
    // #region sign tx request
    /**
     * Signs the transaction associated to the transaction request.
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param {string} params.reqId - request id
     * @param {string} params.mpcv2PartyId - party id for the signer involved in this mpcv2 request (either 0 for user or 1 for backup)
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    async signTxRequest(params) {
        this.bitgo.setRequestTracer(params.reqId);
        return this.signRequestBase(params, baseTypes_1.RequestType.tx);
    }
    /**
     * Signs the message associated to the transaction request.
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param {string} params.reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    async signTxRequestForMessage(params) {
        this.bitgo.setRequestTracer(params.reqId);
        return this.signRequestBase(params, baseTypes_1.RequestType.message);
    }
    async signRequestBase(params, requestType) {
        const userKeyShare = buffer_1.Buffer.from(params.prv, 'base64');
        const txRequest = typeof params.txRequest === 'string'
            ? await (0, tss_1.getTxRequest)(this.bitgo, this.wallet.id(), params.txRequest, params.reqId)
            : params.txRequest;
        let txOrMessageToSign;
        let derivationPath;
        let bufferContent;
        const [userGpgKey, bitgoGpgPubKey] = await Promise.all([
            (0, opengpgUtils_1.generateGPGKeyPair)('secp256k1'),
            this.getBitgoGpgPubkeyBasedOnFeatureFlags(txRequest.enterpriseId, true, params.reqId).then((pubKey) => pubKey !== null && pubKey !== void 0 ? pubKey : this.bitgoMPCv2PublicGpgKey),
        ]);
        if (!bitgoGpgPubKey) {
            throw new Error('Missing BitGo GPG key for MPCv2');
        }
        if (requestType === baseTypes_1.RequestType.tx) {
            (0, assert_1.default)(txRequest.transactions || txRequest.unsignedTxs, 'Unable to find transactions in txRequest');
            const unsignedTx = txRequest.apiVersion === 'full' ? txRequest.transactions[0].unsignedTx : txRequest.unsignedTxs[0];
            txOrMessageToSign = unsignedTx.signableHex;
            derivationPath = unsignedTx.derivationPath;
            bufferContent = buffer_1.Buffer.from(txOrMessageToSign, 'hex');
        }
        else if (requestType === baseTypes_1.RequestType.message) {
            txOrMessageToSign = txRequest.messages[0].messageEncoded;
            derivationPath = txRequest.messages[0].derivationPath || 'm/0';
            bufferContent = buffer_1.Buffer.from(txOrMessageToSign);
        }
        else {
            throw new Error('Invalid request type');
        }
        let hash;
        try {
            hash = this.baseCoin.getHashFunction();
        }
        catch (err) {
            hash = (0, keccak_1.default)('keccak256');
        }
        // check what the encoding is supposed to be for message
        const hashBuffer = hash.update(bufferContent).digest();
        const otherSigner = new sdk_lib_mpc_1.DklsDsg.Dsg(userKeyShare, params.mpcv2PartyId ? params.mpcv2PartyId : 0, derivationPath, hashBuffer);
        const userSignerBroadcastMsg1 = await otherSigner.init();
        const signatureShareRound1 = await (0, ecdsaMPCv2_1.getSignatureShareRoundOne)(userSignerBroadcastMsg1, userGpgKey, params.mpcv2PartyId);
        let latestTxRequest = await (0, common_1.sendSignatureShareV2)(this.bitgo, txRequest.walletId, txRequest.txRequestId, [signatureShareRound1], requestType, this.baseCoin.getMPCAlgorithm(), userGpgKey.publicKey, undefined, this.wallet.multisigTypeVersion(), params.reqId);
        (0, assert_1.default)(latestTxRequest.transactions || latestTxRequest.messages, 'Invalid txRequest Object');
        let bitgoToUserMessages1And2;
        if (requestType === baseTypes_1.RequestType.tx) {
            bitgoToUserMessages1And2 = latestTxRequest.transactions[0].signatureShares;
        }
        else {
            bitgoToUserMessages1And2 = latestTxRequest.messages[0].signatureShares;
        }
        // TODO: Use codec for parsing
        const parsedBitGoToUserSigShareRoundOne = JSON.parse(bitgoToUserMessages1And2[bitgoToUserMessages1And2.length - 1].share);
        if (parsedBitGoToUserSigShareRoundOne.type !== 'round1Output') {
            throw new Error('Unexpected signature share response. Unable to parse data.');
        }
        const serializedBitGoToUserMessagesRound1And2 = await (0, ecdsaMPCv2_1.verifyBitGoMessagesAndSignaturesRoundOne)(parsedBitGoToUserSigShareRoundOne, userGpgKey, bitgoGpgPubKey, params.mpcv2PartyId);
        /** Round 2 **/
        const deserializedMessages = sdk_lib_mpc_1.DklsTypes.deserializeMessages(serializedBitGoToUserMessagesRound1And2);
        const userToBitGoMessagesRound2 = otherSigner.handleIncomingMessages({
            p2pMessages: [],
            broadcastMessages: deserializedMessages.broadcastMessages,
        });
        const userToBitGoMessagesRound3 = otherSigner.handleIncomingMessages({
            p2pMessages: deserializedMessages.p2pMessages,
            broadcastMessages: [],
        });
        const signatureShareRoundTwo = await (0, ecdsaMPCv2_1.getSignatureShareRoundTwo)(userToBitGoMessagesRound2, userToBitGoMessagesRound3, userGpgKey, bitgoGpgPubKey, params.mpcv2PartyId);
        latestTxRequest = await (0, common_1.sendSignatureShareV2)(this.bitgo, txRequest.walletId, txRequest.txRequestId, [signatureShareRoundTwo], requestType, this.baseCoin.getMPCAlgorithm(), userGpgKey.publicKey, undefined, this.wallet.multisigTypeVersion(), params.reqId);
        (0, assert_1.default)(latestTxRequest.transactions || latestTxRequest.messages, 'Invalid txRequest Object');
        const txRequestSignatureShares = requestType === baseTypes_1.RequestType.tx
            ? latestTxRequest.transactions[0].signatureShares
            : latestTxRequest.messages[0].signatureShares;
        // TODO: Use codec for parsing
        const parsedBitGoToUserSigShareRoundTwo = JSON.parse(txRequestSignatureShares[txRequestSignatureShares.length - 1].share);
        if (parsedBitGoToUserSigShareRoundTwo.type !== 'round2Output') {
            throw new Error('Unexpected signature share response. Unable to parse data.');
        }
        const serializedBitGoToUserMessagesRound3 = await (0, ecdsaMPCv2_1.verifyBitGoMessagesAndSignaturesRoundTwo)(parsedBitGoToUserSigShareRoundTwo, userGpgKey, bitgoGpgPubKey, params.mpcv2PartyId);
        /** Round 3 **/
        const deserializedBitGoToUserMessagesRound3 = sdk_lib_mpc_1.DklsTypes.deserializeMessages({
            p2pMessages: serializedBitGoToUserMessagesRound3.p2pMessages,
            broadcastMessages: [],
        });
        const userToBitGoMessagesRound4 = otherSigner.handleIncomingMessages({
            p2pMessages: deserializedBitGoToUserMessagesRound3.p2pMessages,
            broadcastMessages: [],
        });
        const signatureShareRoundThree = await (0, ecdsaMPCv2_1.getSignatureShareRoundThree)(userToBitGoMessagesRound4, userGpgKey, bitgoGpgPubKey, params.mpcv2PartyId);
        // Submit for final signature share combine
        await (0, common_1.sendSignatureShareV2)(this.bitgo, txRequest.walletId, txRequest.txRequestId, [signatureShareRoundThree], requestType, this.baseCoin.getMPCAlgorithm(), userGpgKey.publicKey, undefined, this.wallet.multisigTypeVersion(), params.reqId);
        return (0, common_1.sendTxRequest)(this.bitgo, txRequest.walletId, txRequest.txRequestId, requestType, params.reqId);
    }
    // #endregion
    // #region formatting utils
    formatBitgoBroadcastMessage(broadcastMessage) {
        return {
            from: broadcastMessage.from,
            payload: { message: broadcastMessage.message, signature: broadcastMessage.signature },
        };
    }
    formatP2PMessage(p2pMessage, commitment) {
        return {
            payload: { encryptedMessage: p2pMessage.encryptedMessage, signature: p2pMessage.signature },
            from: p2pMessage.from,
            to: p2pMessage.to,
            commitment,
        };
    }
    // #endregion
    // #region private utils
    /**
     * Get the hash string and derivation path from the transaction request.
     * @param {TxRequest} txRequest - the transaction request object
     * @param {RequestType} requestType - the request type
     * @returns {{ hashBuffer: Buffer; derivationPath: string }} - the hash string and derivation path
     */
    getHashStringAndDerivationPath(txRequest, requestType = baseTypes_1.RequestType.tx) {
        let txToSign;
        let derivationPath;
        if (requestType === baseTypes_1.RequestType.tx) {
            (0, assert_1.default)(txRequest.transactions && txRequest.transactions.length === 1, 'Unable to find transactions in txRequest');
            txToSign = txRequest.transactions[0].unsignedTx.signableHex;
            derivationPath = txRequest.transactions[0].unsignedTx.derivationPath;
        }
        else if (requestType === baseTypes_1.RequestType.message) {
            // TODO(WP-2176): Add support for message signing
            throw new Error('MPCv2 message signing not supported yet.');
        }
        else {
            throw new Error('Invalid request type, got: ' + requestType);
        }
        let hash;
        try {
            hash = this.baseCoin.getHashFunction();
        }
        catch (err) {
            hash = (0, keccak_1.default)('keccak256');
        }
        const hashBuffer = hash.update(buffer_1.Buffer.from(txToSign, 'hex')).digest();
        return { hashBuffer, derivationPath };
    }
    /**
     * Gets the BitGo and user GPG keys from the BitGo public GPG key and the encrypted user GPG private key.
     * @param {string} bitgoPublicGpgKey  - the BitGo public GPG key
     * @param {string} encryptedUserGpgPrvKey  - the encrypted user GPG private key
     * @param {string} walletPassphrase  - the wallet passphrase
     * @returns {Promise<{ bitgoGpgKey: pgp.Key; userGpgKey: pgp.SerializedKeyPair<string> }>} - the BitGo and user GPG keys
     */
    async getBitgoAndUserGpgKeys(bitgoPublicGpgKey, encryptedUserGpgPrvKey, walletPassphrase) {
        const bitgoGpgKey = await pgp.readKey({ armoredKey: bitgoPublicGpgKey });
        const userDecryptedKey = await pgp.readKey({
            armoredKey: this.bitgo.decrypt({ input: encryptedUserGpgPrvKey, password: walletPassphrase }),
        });
        const userGpgKey = {
            privateKey: userDecryptedKey.armor(),
            publicKey: userDecryptedKey.toPublic().armor(),
        };
        return {
            bitgoGpgKey,
            userGpgKey,
        };
    }
    /**
     * Validates the adata and cyphertext.
     * @param adata string
     * @param cyphertext string
     * @returns void
     * @throws {Error} if the adata or cyphertext is invalid
     */
    validateAdata(adata, cyphertext) {
        let cypherJson;
        try {
            cypherJson = JSON.parse(cyphertext);
        }
        catch (e) {
            throw new Error('Failed to parse cyphertext to JSON, got: ' + cyphertext);
        }
        // using decodeURIComponent to handle special characters
        if (decodeURIComponent(cypherJson.adata) !== decodeURIComponent(adata)) {
            throw new Error('Adata does not match cyphertext adata');
        }
    }
    // #endregion
    // #region external signer
    /** @inheritdoc */
    async signEcdsaMPCv2TssUsingExternalSigner(params, externalSignerMPCv2SigningRound1Generator, externalSignerMPCv2SigningRound2Generator, externalSignerMPCv2SigningRound3Generator, requestType = baseTypes_1.RequestType.tx) {
        var _a;
        const { txRequest, reqId } = params;
        let txRequestResolved;
        // TODO(WP-2176): Add support for message signing
        (0, assert_1.default)(requestType === baseTypes_1.RequestType.tx, 'Only transaction signing is supported for external signer, got: ' + requestType);
        if (typeof txRequest === 'string') {
            txRequestResolved = await (0, tss_1.getTxRequest)(this.bitgo, this.wallet.id(), txRequest, reqId);
        }
        else {
            txRequestResolved = txRequest;
        }
        const bitgoPublicGpgKey = (_a = (await this.getBitgoGpgPubkeyBasedOnFeatureFlags(txRequestResolved.enterpriseId, true, reqId))) !== null && _a !== void 0 ? _a : this.bitgoMPCv2PublicGpgKey;
        if (!bitgoPublicGpgKey) {
            throw new Error('Missing BitGo GPG key for MPCv2');
        }
        // round 1
        const { signatureShareRound1, userGpgPubKey, encryptedRound1Session, encryptedUserGpgPrvKey } = await externalSignerMPCv2SigningRound1Generator({ txRequest: txRequestResolved });
        const round1TxRequest = await (0, common_1.sendSignatureShareV2)(this.bitgo, txRequestResolved.walletId, txRequestResolved.txRequestId, [signatureShareRound1], requestType, this.baseCoin.getMPCAlgorithm(), userGpgPubKey, undefined, this.wallet.multisigTypeVersion(), reqId);
        // round 2
        const { signatureShareRound2, encryptedRound2Session } = await externalSignerMPCv2SigningRound2Generator({
            txRequest: round1TxRequest,
            encryptedRound1Session,
            encryptedUserGpgPrvKey,
            bitgoPublicGpgKey: bitgoPublicGpgKey.armor(),
        });
        const round2TxRequest = await (0, common_1.sendSignatureShareV2)(this.bitgo, txRequestResolved.walletId, txRequestResolved.txRequestId, [signatureShareRound2], requestType, this.baseCoin.getMPCAlgorithm(), userGpgPubKey, undefined, this.wallet.multisigTypeVersion(), reqId);
        (0, assert_1.default)(round2TxRequest.transactions && round2TxRequest.transactions[0].signatureShares, 'Missing signature shares in round 2 txRequest');
        // round 3
        const { signatureShareRound3 } = await externalSignerMPCv2SigningRound3Generator({
            txRequest: round2TxRequest,
            encryptedRound2Session,
            encryptedUserGpgPrvKey,
            bitgoPublicGpgKey: bitgoPublicGpgKey.armor(),
        });
        await (0, common_1.sendSignatureShareV2)(this.bitgo, txRequestResolved.walletId, txRequestResolved.txRequestId, [signatureShareRound3], requestType, this.baseCoin.getMPCAlgorithm(), userGpgPubKey, undefined, this.wallet.multisigTypeVersion(), reqId);
        return (0, common_1.sendTxRequest)(this.bitgo, txRequestResolved.walletId, txRequestResolved.txRequestId, requestType, reqId);
    }
    async createOfflineRound1Share(params) {
        const { prv, walletPassphrase, txRequest } = params;
        const { hashBuffer, derivationPath } = this.getHashStringAndDerivationPath(txRequest);
        const adata = `${hashBuffer.toString('hex')}:${derivationPath}`;
        const userKeyShare = buffer_1.Buffer.from(prv, 'base64');
        const userGpgKey = await (0, opengpgUtils_1.generateGPGKeyPair)('secp256k1');
        const userSigner = new sdk_lib_mpc_1.DklsDsg.Dsg(userKeyShare, 0, derivationPath, hashBuffer);
        const userSignerBroadcastMsg1 = await userSigner.init();
        const signatureShareRound1 = await (0, ecdsaMPCv2_1.getSignatureShareRoundOne)(userSignerBroadcastMsg1, userGpgKey);
        const session = userSigner.getSession();
        const encryptedRound1Session = this.bitgo.encrypt({ input: session, password: walletPassphrase, adata });
        const userGpgPubKey = userGpgKey.publicKey;
        const encryptedUserGpgPrvKey = this.bitgo.encrypt({
            input: userGpgKey.privateKey,
            password: walletPassphrase,
            adata,
        });
        return { signatureShareRound1, userGpgPubKey, encryptedRound1Session, encryptedUserGpgPrvKey };
    }
    async createOfflineRound2Share(params) {
        var _a;
        const { prv, walletPassphrase, encryptedUserGpgPrvKey, encryptedRound1Session, bitgoPublicGpgKey, txRequest } = params;
        const { hashBuffer, derivationPath } = this.getHashStringAndDerivationPath(txRequest);
        const adata = `${hashBuffer.toString('hex')}:${derivationPath}`;
        const { bitgoGpgKey, userGpgKey } = await this.getBitgoAndUserGpgKeys(bitgoPublicGpgKey, encryptedUserGpgPrvKey, walletPassphrase);
        const signatureShares = (_a = txRequest.transactions) === null || _a === void 0 ? void 0 : _a[0].signatureShares;
        (0, assert_1.default)(signatureShares, 'Missing signature shares in round 1 txRequest');
        const parsedBitGoToUserSigShareRoundOne = JSON.parse(signatureShares[signatureShares.length - 1].share);
        if (parsedBitGoToUserSigShareRoundOne.type !== 'round1Output') {
            throw new Error('Unexpected signature share response. Unable to parse data.');
        }
        const serializedBitGoToUserMessagesRound1 = await (0, ecdsaMPCv2_1.verifyBitGoMessagesAndSignaturesRoundOne)(parsedBitGoToUserSigShareRoundOne, userGpgKey, bitgoGpgKey);
        const round1Session = this.bitgo.decrypt({ input: encryptedRound1Session, password: walletPassphrase });
        this.validateAdata(adata, encryptedRound1Session);
        const userKeyShare = buffer_1.Buffer.from(prv, 'base64');
        const userSigner = new sdk_lib_mpc_1.DklsDsg.Dsg(userKeyShare, 0, derivationPath, hashBuffer);
        await userSigner.setSession(round1Session);
        const deserializedMessages = sdk_lib_mpc_1.DklsTypes.deserializeMessages(serializedBitGoToUserMessagesRound1);
        const userToBitGoMessagesRound2 = userSigner.handleIncomingMessages({
            p2pMessages: [],
            broadcastMessages: deserializedMessages.broadcastMessages,
        });
        const userToBitGoMessagesRound3 = userSigner.handleIncomingMessages({
            p2pMessages: deserializedMessages.p2pMessages,
            broadcastMessages: [],
        });
        const signatureShareRound2 = await (0, ecdsaMPCv2_1.getSignatureShareRoundTwo)(userToBitGoMessagesRound2, userToBitGoMessagesRound3, userGpgKey, bitgoGpgKey);
        const session = userSigner.getSession();
        const encryptedRound2Session = this.bitgo.encrypt({ input: session, password: walletPassphrase, adata });
        return {
            signatureShareRound2,
            encryptedRound2Session,
        };
    }
    async createOfflineRound3Share(params) {
        var _a;
        const { prv, walletPassphrase, encryptedUserGpgPrvKey, encryptedRound2Session, bitgoPublicGpgKey, txRequest } = params;
        (0, assert_1.default)(txRequest.transactions && txRequest.transactions.length === 1, 'Unable to find transactions in txRequest');
        const { hashBuffer, derivationPath } = this.getHashStringAndDerivationPath(txRequest);
        const adata = `${hashBuffer.toString('hex')}:${derivationPath}`;
        const { bitgoGpgKey, userGpgKey } = await this.getBitgoAndUserGpgKeys(bitgoPublicGpgKey, encryptedUserGpgPrvKey, walletPassphrase);
        const signatureShares = (_a = txRequest.transactions) === null || _a === void 0 ? void 0 : _a[0].signatureShares;
        (0, assert_1.default)(signatureShares, 'Missing signature shares in round 2 txRequest');
        const parsedBitGoToUserSigShareRoundTwo = JSON.parse(signatureShares[signatureShares.length - 1].share);
        if (parsedBitGoToUserSigShareRoundTwo.type !== 'round2Output') {
            throw new Error('Unexpected signature share response. Unable to parse data.');
        }
        const serializedBitGoToUserMessagesRound3 = await (0, ecdsaMPCv2_1.verifyBitGoMessagesAndSignaturesRoundTwo)(parsedBitGoToUserSigShareRoundTwo, userGpgKey, bitgoGpgKey);
        const deserializedBitGoToUserMessagesRound3 = sdk_lib_mpc_1.DklsTypes.deserializeMessages({
            p2pMessages: serializedBitGoToUserMessagesRound3.p2pMessages,
            broadcastMessages: [],
        });
        const round2Session = this.bitgo.decrypt({ input: encryptedRound2Session, password: walletPassphrase });
        this.validateAdata(adata, encryptedRound2Session);
        const userKeyShare = buffer_1.Buffer.from(prv, 'base64');
        const userSigner = new sdk_lib_mpc_1.DklsDsg.Dsg(userKeyShare, 0, derivationPath, hashBuffer);
        await userSigner.setSession(round2Session);
        const userToBitGoMessagesRound4 = userSigner.handleIncomingMessages({
            p2pMessages: deserializedBitGoToUserMessagesRound3.p2pMessages,
            broadcastMessages: [],
        });
        const signatureShareRound3 = await (0, ecdsaMPCv2_1.getSignatureShareRoundThree)(userToBitGoMessagesRound4, userGpgKey, bitgoGpgKey);
        return { signatureShareRound3 };
    }
}
exports.EcdsaMPCv2Utils = EcdsaMPCv2Utils;
/**
 * Checks if the given key share, when decrypted, contains valid GG18 signing material.
 *
 * @param {string} keyShare - The encrypted key share string.
 * @param {string|undefined} walletPassphrase - The passphrase used to decrypt the key share
 * @returns {boolean} - Returns `true` if the decrypted data contains valid signing material, otherwise `false`.
 */
function isGG18SigningMaterial(keyShare, walletPassphrase) {
    const prv = sjcl.decrypt(walletPassphrase, keyShare);
    try {
        const signingMaterial = JSON.parse(prv);
        return (signingMaterial.pShare &&
            signingMaterial.bitgoNShare &&
            (signingMaterial.userNShare || signingMaterial.backupNShare));
    }
    catch (error) {
        return false;
    }
}
exports.isGG18SigningMaterial = isGG18SigningMaterial;
/**
 * Retrieves the MPC v2 recovery key shares from the provided user and backup key shares.
 *
 * @param {string} userPublicOrPrivateKeyShare
 * @param {string} backupPrivateOrPublicKeyShare
 * @param {string} [walletPassphrase] - The passphrase used to decrypt the key shares
 * @returns {Promise<{ userKeyShare: KeyShare, backupKeyShare: KeyShare, commonKeyChain: string }>}
 *
 * @async
 */
async function getMpcV2RecoveryKeyShares(userPublicOrPrivateKeyShare, backupPrivateOrPublicKeyShare, walletPassphrase) {
    const userCompressedPrv = buffer_1.Buffer.from(sjcl.decrypt(walletPassphrase, userPublicOrPrivateKeyShare), 'base64');
    const bakcupCompressedPrv = buffer_1.Buffer.from(sjcl.decrypt(walletPassphrase, backupPrivateOrPublicKeyShare), 'base64');
    const userPrvJSON = sdk_lib_mpc_1.DklsTypes.getDecodedReducedKeyShare(userCompressedPrv);
    const backupPrvJSON = sdk_lib_mpc_1.DklsTypes.getDecodedReducedKeyShare(bakcupCompressedPrv);
    const userKeyRetrofit = {
        xShare: {
            x: buffer_1.Buffer.from(userPrvJSON.prv).toString('hex'),
            y: buffer_1.Buffer.from(userPrvJSON.pub).toString('hex'),
            chaincode: buffer_1.Buffer.from(userPrvJSON.rootChainCode).toString('hex'),
        },
        xiList: userPrvJSON.xList.slice(0, 2),
    };
    const backupKeyRetrofit = {
        xShare: {
            x: buffer_1.Buffer.from(backupPrvJSON.prv).toString('hex'),
            y: buffer_1.Buffer.from(backupPrvJSON.pub).toString('hex'),
            chaincode: buffer_1.Buffer.from(backupPrvJSON.rootChainCode).toString('hex'),
        },
        xiList: backupPrvJSON.xList.slice(0, 2),
    };
    const [user, backup] = await sdk_lib_mpc_1.DklsUtils.generate2of2KeyShares(userKeyRetrofit, backupKeyRetrofit);
    const userKeyShare = user.getKeyShare();
    const backupKeyShare = backup.getKeyShare();
    const commonKeyChain = sdk_lib_mpc_1.DklsTypes.getCommonKeychain(userKeyShare);
    return { userKeyShare, backupKeyShare, commonKeyChain };
}
exports.getMpcV2RecoveryKeyShares = getMpcV2RecoveryKeyShares;
/**
 * Signs a message hash using MPC v2 recovery key shares.
 *
 * @param {Buffer} messageHash
 * @param {Buffer} userKeyShare
 * @param {Buffer} backupKeyShare
 * @param {string} commonKeyChain
 * @returns {Promise<{ recid: number, r: string, s: string, y: string }>}
 *
 * @async
 */
async function signRecoveryMpcV2(messageHash, userKeyShare, backupKeyShare, commonKeyChain) {
    const userDsg = new sdk_lib_mpc_1.DklsDsg.Dsg(userKeyShare, 0, 'm/0', messageHash);
    const backupDsg = new sdk_lib_mpc_1.DklsDsg.Dsg(backupKeyShare, 1, 'm/0', messageHash);
    const signatureString = sdk_lib_mpc_1.DklsUtils.verifyAndConvertDklsSignature(messageHash, (await sdk_lib_mpc_1.DklsUtils.executeTillRound(5, userDsg, backupDsg)), commonKeyChain, 'm/0', undefined, false);
    const sigParts = signatureString.split(':');
    return {
        recid: parseInt(sigParts[0], 10),
        r: sigParts[1],
        s: sigParts[2],
        y: sigParts[3],
    };
}
exports.signRecoveryMpcV2 = signRecoveryMpcV2;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNkc2FNUEN2Mi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9iaXRnby91dGlscy90c3MvZWNkc2EvZWNkc2FNUEN2Mi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9EQUF5RztBQUN6RyxrREFBb0M7QUFDcEMsb0RBQTRCO0FBQzVCLG1DQUFnQztBQUVoQyw2Q0FBNkM7QUFDN0Msb0RBQXNDO0FBQ3RDLDZDQUErQjtBQUUvQixzREFZNkI7QUFFN0IseURBQWdEO0FBR2hELHNDQUE4RDtBQUM5RCxnREFBMEU7QUFDMUUsNkNBQThHO0FBQzlHLDhEQU11QztBQUV2QyxxREFBd0Q7QUFDeEQsNENBV3NCO0FBQ3RCLGlDQUF3QztBQUV4QyxNQUFhLGVBQWdCLFNBQVEscUJBQWM7SUFDakQsa0JBQWtCO0lBQ2xCLEtBQUssQ0FBQyxlQUFlLENBQUMsTUFLckI7O1FBQ0MsTUFBTSxFQUFFLFdBQVcsRUFBRSxhQUFhLEVBQUUsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0YsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFBLGlDQUFrQixFQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sWUFBWSxHQUFHLE1BQU0sSUFBQSxpQ0FBa0IsRUFBQyxXQUFXLENBQUMsQ0FBQztRQUUzRCxrRUFBa0U7UUFDbEUsb0VBQW9FO1FBQ3BFLE1BQU0saUJBQWlCLEdBQUcsQ0FDeEIsTUFBQSxDQUFDLE1BQU0sSUFBSSxDQUFDLG9DQUFvQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUMsbUNBQUksSUFBSSxDQUFDLHNCQUFzQixDQUMxRyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBRVYsTUFBTSxhQUFhLEdBQTBCO1lBQzNDLE9BQU8sRUFBRSw2QkFBZ0Is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LEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztJQUV6RSxNQUFNLGVBQWUsR0FBRyx1QkFBUyxDQUFDLDZCQUE2QixDQUM3RCxXQUFXLEVBQ1gsQ0FBQyxNQUFNLHVCQUFTLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBd0MsRUFDaEcsY0FBYyxFQUNkLEtBQUssRUFDTCxTQUFTLEVBQ1QsS0FBSyxDQUNOLENBQUM7SUFDRixNQUFNLFFBQVEsR0FBRyxlQUFlLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRTVDLE9BQU87UUFDTCxLQUFLLEVBQUUsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDaEMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDZCxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNkLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO0tBQ2YsQ0FBQztBQUNKLENBQUM7QUF6QkQsOENBeUJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmlnSW50VG9CdWZmZXJCRSwgRGtsc0NvbW1zLCBEa2xzRGtnLCBEa2xzRHNnLCBEa2xzVHlwZXMsIERrbHNVdGlscyB9IGZyb20gJ0BiaXRnby9zZGstbGliLW1wYyc7XG5pbXBvcnQgKiBhcyBzamNsIGZyb20gJ0BiaXRnby9zamNsJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgeyBIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IE5vbkVtcHR5U3RyaW5nIH0gZnJvbSAnaW8tdHMtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUtlY2Nha0hhc2ggZnJvbSAna2VjY2FrJztcbmltcG9ydCAqIGFzIHBncCBmcm9tICdvcGVucGdwJztcbmltcG9ydCB7IEtleWNoYWluc1RyaXBsZXQgfSBmcm9tICcuLi8uLi8uLi9iYXNlQ29pbic7XG5pbXBvcnQge1xuICBLZXlHZW5UeXBlRW51bSxcbiAgTVBDdjJCcm9hZGNhc3RNZXNzYWdlLFxuICBNUEN2MktleUdlblJvdW5kMVJlc3BvbnNlLFxuICBNUEN2MktleUdlblJvdW5kMlJlc3BvbnNlLFxuICBNUEN2MktleUdlblJvdW5kM1Jlc3BvbnNlLFxuICBNUEN2MktleUdlblN0YXRlLFxuICBNUEN2MktleUdlblN0YXRlRW51bSxcbiAgTVBDdjJQMlBNZXNzYWdlLFxuICBNUEN2MlBhcnR5RnJvbVN0cmluZ09yTnVtYmVyLFxuICBNUEN2MlNpZ25hdHVyZVNoYXJlUm91bmQxT3V0cHV0LFxuICBNUEN2MlNpZ25hdHVyZVNoYXJlUm91bmQyT3V0cHV0LFxufSBmcm9tICdAYml0Z28vcHVibGljLXR5cGVzJztcblxuaW1wb3J0IHsgRWNkc2EgfSBmcm9tICcuLi8uLi8uLi8uLi9hY2NvdW50LWxpYic7XG5pbXBvcnQgeyBBZGRLZXljaGFpbk9wdGlvbnMsIEtleWNoYWluLCBLZXlUeXBlIH0gZnJvbSAnLi4vLi4vLi4va2V5Y2hhaW4nO1xuaW1wb3J0IHsgRGVjcnlwdGVkUmV0cm9maXRQYXlsb2FkIH0gZnJvbSAnLi4vLi4vLi4va2V5Y2hhaW4vaUtleWNoYWlucyc7XG5pbXBvcnQgeyBFQ0RTQU1ldGhvZFR5cGVzLCBnZXRUeFJlcXVlc3QgfSBmcm9tICcuLi8uLi8uLi90c3MnO1xuaW1wb3J0IHsgc2VuZFNpZ25hdHVyZVNoYXJlVjIsIHNlbmRUeFJlcXVlc3QgfSBmcm9tICcuLi8uLi8uLi90c3MvY29tbW9uJztcbmltcG9ydCB7IEdlbmVyYXRlTVBDdjJLZXlSZXF1ZXN0Qm9keSwgR2VuZXJhdGVNUEN2MktleVJlcXVlc3RSZXNwb25zZSwgTVBDdjJQYXJ0aWVzRW51bSB9IGZyb20gJy4vdHlwZXNNUEN2Mic7XG5pbXBvcnQge1xuICBnZXRTaWduYXR1cmVTaGFyZVJvdW5kT25lLFxuICBnZXRTaWduYXR1cmVTaGFyZVJvdW5kVGhyZWUsXG4gIGdldFNpZ25hdHVyZVNoYXJlUm91bmRUd28sXG4gIHZlcmlmeUJpdEdvTWVzc2FnZXNBbmRTaWduYXR1cmVzUm91bmRPbmUsXG4gIHZlcmlmeUJpdEdvTWVzc2FnZXNBbmRTaWduYXR1cmVzUm91bmRUd28sXG59IGZyb20gJy4uLy4uLy4uL3Rzcy9lY2RzYS9lY2RzYU1QQ3YyJztcbmltcG9ydCB7IEtleUNvbWJpbmVkIH0gZnJvbSAnLi4vLi4vLi4vdHNzL2VjZHNhL3R5cGVzJztcbmltcG9ydCB7IGdlbmVyYXRlR1BHS2V5UGFpciB9IGZyb20gJy4uLy4uL29wZW5ncGdVdGlscyc7XG5pbXBvcnQge1xuICBDdXN0b21NUEN2MlNpZ25pbmdSb3VuZDFHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIEN1c3RvbU1QQ3YyU2lnbmluZ1JvdW5kMkdlbmVyYXRpbmdGdW5jdGlvbixcbiAgQ3VzdG9tTVBDdjJTaWduaW5nUm91bmQzR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICBSZXF1ZXN0VHlwZSxcbiAgU2lnbmF0dXJlU2hhcmVSZWNvcmQsXG4gIFRTU1BhcmFtcyxcbiAgVFNTUGFyYW1zRm9yTWVzc2FnZSxcbiAgVFNTUGFyYW1zRm9yTWVzc2FnZVdpdGhQcnYsXG4gIFRTU1BhcmFtc1dpdGhQcnYsXG4gIFR4UmVxdWVzdCxcbn0gZnJvbSAnLi4vYmFzZVR5cGVzJztcbmltcG9ydCB7IEJhc2VFY2RzYVV0aWxzIH0gZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNsYXNzIEVjZHNhTVBDdjJVdGlscyBleHRlbmRzIEJhc2VFY2RzYVV0aWxzIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGFzeW5jIGNyZWF0ZUtleWNoYWlucyhwYXJhbXM6IHtcbiAgICBwYXNzcGhyYXNlOiBzdHJpbmc7XG4gICAgZW50ZXJwcmlzZTogc3RyaW5nO1xuICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZT86IHN0cmluZztcbiAgICByZXRyb2ZpdD86IERlY3J5cHRlZFJldHJvZml0UGF5bG9hZDtcbiAgfSk6IFByb21pc2U8S2V5Y2hhaW5zVHJpcGxldD4ge1xuICAgIGNvbnN0IHsgdXNlclNlc3Npb24sIGJhY2t1cFNlc3Npb24gfSA9IHRoaXMuZ2V0VXNlckFuZEJhY2t1cFNlc3Npb24oMiwgMywgcGFyYW1zLnJldHJvZml0KTtcbiAgICBjb25zdCB1c2VyR3BnS2V5ID0gYXdhaXQgZ2VuZXJhdGVHUEdLZXlQYWlyKCdzZWNwMjU2azEnKTtcbiAgICBjb25zdCBiYWNrdXBHcGdLZXkgPSBhd2FpdCBnZW5lcmF0ZUdQR0tleVBhaXIoJ3NlY3AyNTZrMScpO1xuXG4gICAgLy8gR2V0IHRoZSBCaXRHbyBwdWJsaWMga2V5IGJhc2VkIG9uIHVzZXIvZW50ZXJwcmlzZSBmZWF0dXJlIGZsYWdzXG4gICAgLy8gSWYgaXQgZG9lc24ndCB3b3JrLCB1c2UgdGhlIGRlZmF1bHQgcHVibGljIGtleSBmcm9tIHRoZSBjb25zdGFudHNcbiAgICBjb25zdCBiaXRnb1B1YmxpY0dwZ0tleSA9IChcbiAgICAgIChhd2FpdCB0aGlzLmdldEJpdGdvR3BnUHVia2V5QmFzZWRPbkZlYXR1cmVGbGFncyhwYXJhbXMuZW50ZXJwcmlzZSwgdHJ1ZSkpID8/IHRoaXMuYml0Z29NUEN2MlB1YmxpY0dwZ0tleVxuICAgICkuYXJtb3IoKTtcblxuICAgIGNvbnN0IHVzZXJHcGdQcnZLZXk6IERrbHNUeXBlcy5QYXJ0eUdwZ0tleSA9IHtcbiAgICAgIHBhcnR5SWQ6IE1QQ3YyUGFydGllc0VudW0uVVNFUixcbiAgICAgIGdwZ0tleTogdXNlckdwZ0tleS5wcml2YXRlS2V5LFxuICAgIH07XG4gICAgY29uc3QgYmFja3VwR3BnUHJ2S2V5OiBEa2xzVHlwZXMuUGFydHlHcGdLZXkgPSB7XG4gICAgICBwYXJ0eUlkOiBNUEN2MlBhcnRpZXNFbnVtLkJBQ0tVUCxcbiAgICAgIGdwZ0tleTogYmFja3VwR3BnS2V5LnByaXZhdGVLZXksXG4gICAgfTtcbiAgICBjb25zdCBiaXRnb0dwZ1B1YktleTogRGtsc1R5cGVzLlBhcnR5R3BnS2V5ID0ge1xuICAgICAgcGFydHlJZDogTVBDdjJQYXJ0aWVzRW51bS5CSVRHTyxcbiAgICAgIGdwZ0tleTogYml0Z29QdWJsaWNHcGdLZXksXG4gICAgfTtcblxuICAgIC8vICNyZWdpb24gcm91bmQgMVxuICAgIGNvbnN0IHVzZXJSb3VuZDFCcm9hZGNhc3RNc2cgPSBhd2FpdCB1c2VyU2Vzc2lvbi5pbml0RGtnKCk7XG4gICAgY29uc3QgYmFja3VwUm91bmQxQnJvYWRjYXN0TXNnID0gYXdhaXQgYmFja3VwU2Vzc2lvbi5pbml0RGtnKCk7XG5cbiAgICBjb25zdCByb3VuZDFTZXJpYWxpemVkTWVzc2FnZXMgPSBEa2xzVHlwZXMuc2VyaWFsaXplTWVzc2FnZXMoe1xuICAgICAgYnJvYWRjYXN0TWVzc2FnZXM6IFt1c2VyUm91bmQxQnJvYWRjYXN0TXNnLCBiYWNrdXBSb3VuZDFCcm9hZGNhc3RNc2ddLFxuICAgICAgcDJwTWVzc2FnZXM6IFtdLFxuICAgIH0pO1xuICAgIGNvbnN0IHJvdW5kMU1lc3NhZ2VzID0gYXdhaXQgRGtsc0NvbW1zLmVuY3J5cHRBbmRBdXRoT3V0Z29pbmdNZXNzYWdlcyhcbiAgICAgIHJvdW5kMVNlcmlhbGl6ZWRNZXNzYWdlcyxcbiAgICAgIFtiaXRnb0dwZ1B1YktleV0sXG4gICAgICBbdXNlckdwZ1BydktleSwgYmFja3VwR3BnUHJ2S2V5XVxuICAgICk7XG5cbiAgICBjb25zdCB7IHNlc3Npb25JZCwgYml0Z29Nc2cxLCBiaXRnb1RvQmFja3VwTXNnMiwgYml0Z29Ub1VzZXJNc2cyIH0gPSBhd2FpdCB0aGlzLnNlbmRLZXlHZW5lcmF0aW9uUm91bmQxKFxuICAgICAgcGFyYW1zLmVudGVycHJpc2UsXG4gICAgICB1c2VyR3BnS2V5LnB1YmxpY0tleSxcbiAgICAgIGJhY2t1cEdwZ0tleS5wdWJsaWNLZXksXG4gICAgICBwYXJhbXMucmV0cm9maXQ/LndhbGxldElkXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4ucm91bmQxTWVzc2FnZXMsXG4gICAgICAgICAgICB3YWxsZXRJZDogcGFyYW1zLnJldHJvZml0LndhbGxldElkLFxuICAgICAgICAgIH1cbiAgICAgICAgOiByb3VuZDFNZXNzYWdlc1xuICAgICk7XG4gICAgLy8gI2VuZHJlZ2lvblxuXG4gICAgLy8gI3JlZ2lvbiByb3VuZCAyXG4gICAgY29uc3QgYml0Z29Sb3VuZDFCcm9hZGNhc3RNZXNzYWdlcyA9IGF3YWl0IERrbHNDb21tcy5kZWNyeXB0QW5kVmVyaWZ5SW5jb21pbmdNZXNzYWdlcyhcbiAgICAgIHsgcDJwTWVzc2FnZXM6IFtdLCBicm9hZGNhc3RNZXNzYWdlczogW3RoaXMuZm9ybWF0Qml0Z29Ccm9hZGNhc3RNZXNzYWdlKGJpdGdvTXNnMSldIH0sXG4gICAgICBbYml0Z29HcGdQdWJLZXldLFxuICAgICAgW3VzZXJHcGdQcnZLZXksIGJhY2t1cEdwZ1BydktleV1cbiAgICApO1xuICAgIGNvbnN0IGJpdGdvUm91bmQxQnJvYWRjYXN0TXNnID0gYml0Z29Sb3VuZDFCcm9hZGNhc3RNZXNzYWdlcy5icm9hZGNhc3RNZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uZnJvbSA9PT0gTVBDdjJQYXJ0aWVzRW51bS5CSVRHT1xuICAgICk7XG4gICAgYXNzZXJ0KGJpdGdvUm91bmQxQnJvYWRjYXN0TXNnLCAnQml0R28gbWVzc2FnZSAxIG5vdCBmb3VuZCBpbiBicm9hZGNhc3QgbWVzc2FnZXMnKTtcblxuICAgIGNvbnN0IHVzZXJSb3VuZDJQMlBNZXNzYWdlcyA9IHVzZXJTZXNzaW9uLmhhbmRsZUluY29taW5nTWVzc2FnZXMoe1xuICAgICAgcDJwTWVzc2FnZXM6IFtdLFxuICAgICAgYnJvYWRjYXN0TWVzc2FnZXM6IFtEa2xzVHlwZXMuZGVzZXJpYWxpemVCcm9hZGNhc3RNZXNzYWdlKGJpdGdvUm91bmQxQnJvYWRjYXN0TXNnKSwgYmFja3VwUm91bmQxQnJvYWRjYXN0TXNnXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZXJUb0JpdGdvTXNnMiA9IHVzZXJSb3VuZDJQMlBNZXNzYWdlcy5wMnBNZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uZnJvbSA9PT0gTVBDdjJQYXJ0aWVzRW51bS5VU0VSICYmIG0udG8gPT09IE1QQ3YyUGFydGllc0VudW0uQklUR09cbiAgICApO1xuICAgIGFzc2VydCh1c2VyVG9CaXRnb01zZzIsICdVc2VyIG1lc3NhZ2UgMiBub3QgZm91bmQgaW4gUDJQIG1lc3NhZ2VzJyk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFVzZXJUb0JpdGdvTXNnMiA9IERrbHNUeXBlcy5zZXJpYWxpemVQMlBNZXNzYWdlKHVzZXJUb0JpdGdvTXNnMik7XG5cbiAgICBjb25zdCBiYWNrdXBSb3VuZDJQMlBNZXNzYWdlcyA9IGJhY2t1cFNlc3Npb24uaGFuZGxlSW5jb21pbmdNZXNzYWdlcyh7XG4gICAgICBwMnBNZXNzYWdlczogW10sXG4gICAgICBicm9hZGNhc3RNZXNzYWdlczogW3VzZXJSb3VuZDFCcm9hZGNhc3RNc2csIERrbHNUeXBlcy5kZXNlcmlhbGl6ZUJyb2FkY2FzdE1lc3NhZ2UoYml0Z29Sb3VuZDFCcm9hZGNhc3RNc2cpXSxcbiAgICB9KTtcbiAgICBjb25zdCBzZXJpYWxpemVkQmFja3VwVG9CaXRnb01zZzIgPSBEa2xzVHlwZXMuc2VyaWFsaXplTWVzc2FnZXMoYmFja3VwUm91bmQyUDJQTWVzc2FnZXMpLnAycE1lc3NhZ2VzLmZpbmQoXG4gICAgICAobSkgPT4gbS5mcm9tID09PSBNUEN2MlBhcnRpZXNFbnVtLkJBQ0tVUCAmJiBtLnRvID09PSBNUEN2MlBhcnRpZXNFbnVtLkJJVEdPXG4gICAgKTtcbiAgICBhc3NlcnQoc2VyaWFsaXplZEJhY2t1cFRvQml0Z29Nc2cyLCAnQmFja3VwIG1lc3NhZ2UgMiBub3QgZm91bmQgaW4gUDJQIG1lc3NhZ2VzJyk7XG5cbiAgICBjb25zdCByb3VuZDJNZXNzYWdlcyA9IGF3YWl0IERrbHNDb21tcy5lbmNyeXB0QW5kQXV0aE91dGdvaW5nTWVzc2FnZXMoXG4gICAgICB7IHAycE1lc3NhZ2VzOiBbc2VyaWFsaXplZFVzZXJUb0JpdGdvTXNnMiwgc2VyaWFsaXplZEJhY2t1cFRvQml0Z29Nc2cyXSwgYnJvYWRjYXN0TWVzc2FnZXM6IFtdIH0sXG4gICAgICBbYml0Z29HcGdQdWJLZXldLFxuICAgICAgW3VzZXJHcGdQcnZLZXksIGJhY2t1cEdwZ1BydktleV1cbiAgICApO1xuXG4gICAgY29uc3Qge1xuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWRSb3VuZDIsXG4gICAgICBiaXRnb0NvbW1pdG1lbnQyLFxuICAgICAgYml0Z29Ub1VzZXJNc2czLFxuICAgICAgYml0Z29Ub0JhY2t1cE1zZzMsXG4gICAgfSA9IGF3YWl0IHRoaXMuc2VuZEtleUdlbmVyYXRpb25Sb3VuZDIocGFyYW1zLmVudGVycHJpc2UsIHNlc3Npb25JZCwgcm91bmQyTWVzc2FnZXMpO1xuICAgIC8vICNlbmRyZWdpb25cblxuICAgIC8vICNyZWdpb24gcm91bmQgM1xuICAgIGFzc2VydC5lcXVhbChzZXNzaW9uSWQsIHNlc3Npb25JZFJvdW5kMiwgJ1JvdW5kIDEgYW5kIDIgU2Vzc2lvbiBJRHMgZG8gbm90IG1hdGNoJyk7XG4gICAgY29uc3QgZGVjcnlwdGVkQml0Z29Ub1VzZXJSb3VuZDJNc2dzID0gYXdhaXQgRGtsc0NvbW1zLmRlY3J5cHRBbmRWZXJpZnlJbmNvbWluZ01lc3NhZ2VzKFxuICAgICAgeyBwMnBNZXNzYWdlczogW3RoaXMuZm9ybWF0UDJQTWVzc2FnZShiaXRnb1RvVXNlck1zZzIpXSwgYnJvYWRjYXN0TWVzc2FnZXM6IFtdIH0sXG4gICAgICBbYml0Z29HcGdQdWJLZXldLFxuICAgICAgW3VzZXJHcGdQcnZLZXldXG4gICAgKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQml0Z29Ub1VzZXJSb3VuZDJNc2cgPSBkZWNyeXB0ZWRCaXRnb1RvVXNlclJvdW5kMk1zZ3MucDJwTWVzc2FnZXMuZmluZChcbiAgICAgIChtKSA9PiBtLmZyb20gPT09IE1QQ3YyUGFydGllc0VudW0uQklUR08gJiYgbS50byA9PT0gTVBDdjJQYXJ0aWVzRW51bS5VU0VSXG4gICAgKTtcbiAgICBhc3NlcnQoc2VyaWFsaXplZEJpdGdvVG9Vc2VyUm91bmQyTXNnLCAnQml0R28gdG8gVXNlciBtZXNzYWdlIDIgbm90IGZvdW5kIGluIFAyUCBtZXNzYWdlcycpO1xuICAgIGNvbnN0IGJpdGdvVG9Vc2VyUm91bmQyTXNnID0gRGtsc1R5cGVzLmRlc2VyaWFsaXplUDJQTWVzc2FnZShzZXJpYWxpemVkQml0Z29Ub1VzZXJSb3VuZDJNc2cpO1xuXG4gICAgY29uc3QgZGVjcnlwdGVkQml0Z29Ub0JhY2t1cFJvdW5kMk1zZyA9IGF3YWl0IERrbHNDb21tcy5kZWNyeXB0QW5kVmVyaWZ5SW5jb21pbmdNZXNzYWdlcyhcbiAgICAgIHsgcDJwTWVzc2FnZXM6IFt0aGlzLmZvcm1hdFAyUE1lc3NhZ2UoYml0Z29Ub0JhY2t1cE1zZzIpXSwgYnJvYWRjYXN0TWVzc2FnZXM6IFtdIH0sXG4gICAgICBbYml0Z29HcGdQdWJLZXldLFxuICAgICAgW2JhY2t1cEdwZ1BydktleV1cbiAgICApO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRCaXRnb1RvQmFja3VwUm91bmQyTXNnID0gZGVjcnlwdGVkQml0Z29Ub0JhY2t1cFJvdW5kMk1zZy5wMnBNZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uZnJvbSA9PT0gTVBDdjJQYXJ0aWVzRW51bS5CSVRHTyAmJiBtLnRvID09PSBNUEN2MlBhcnRpZXNFbnVtLkJBQ0tVUFxuICAgICk7XG4gICAgYXNzZXJ0KHNlcmlhbGl6ZWRCaXRnb1RvQmFja3VwUm91bmQyTXNnLCAnQml0R28gdG8gQmFja3VwIG1lc3NhZ2UgMiBub3QgZm91bmQgaW4gUDJQIG1lc3NhZ2VzJyk7XG4gICAgY29uc3QgYml0Z29Ub0JhY2t1cFJvdW5kMk1zZyA9IERrbHNUeXBlcy5kZXNlcmlhbGl6ZVAyUE1lc3NhZ2Uoc2VyaWFsaXplZEJpdGdvVG9CYWNrdXBSb3VuZDJNc2cpO1xuXG4gICAgY29uc3QgdXNlclRvQmFja3VwTXNnMiA9IHVzZXJSb3VuZDJQMlBNZXNzYWdlcy5wMnBNZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uZnJvbSA9PT0gTVBDdjJQYXJ0aWVzRW51bS5VU0VSICYmIG0udG8gPT09IE1QQ3YyUGFydGllc0VudW0uQkFDS1VQXG4gICAgKTtcbiAgICBhc3NlcnQodXNlclRvQmFja3VwTXNnMiwgJ1VzZXIgdG8gQmFja3VwIG1lc3NhZ2UgMiBub3QgZm91bmQgaW4gUDJQIG1lc3NhZ2VzJyk7XG5cbiAgICBjb25zdCBiYWNrdXBUb1VzZXJNc2cyID0gYmFja3VwUm91bmQyUDJQTWVzc2FnZXMucDJwTWVzc2FnZXMuZmluZChcbiAgICAgIChtKSA9PiBtLmZyb20gPT09IE1QQ3YyUGFydGllc0VudW0uQkFDS1VQICYmIG0udG8gPT09IE1QQ3YyUGFydGllc0VudW0uVVNFUlxuICAgICk7XG4gICAgYXNzZXJ0KGJhY2t1cFRvVXNlck1zZzIsICdCYWNrdXAgdG8gVXNlciBtZXNzYWdlIDIgbm90IGZvdW5kIGluIFAyUCBtZXNzYWdlcycpO1xuXG4gICAgY29uc3QgdXNlclJvdW5kM01lc3NhZ2VzID0gdXNlclNlc3Npb24uaGFuZGxlSW5jb21pbmdNZXNzYWdlcyh7XG4gICAgICBicm9hZGNhc3RNZXNzYWdlczogW10sXG4gICAgICBwMnBNZXNzYWdlczogW2JpdGdvVG9Vc2VyUm91bmQyTXNnLCBiYWNrdXBUb1VzZXJNc2cyXSxcbiAgICB9KTtcbiAgICBjb25zdCB1c2VyVG9CYWNrdXBNc2czID0gdXNlclJvdW5kM01lc3NhZ2VzLnAycE1lc3NhZ2VzLmZpbmQoXG4gICAgICAobSkgPT4gbS5mcm9tID09PSBNUEN2MlBhcnRpZXNFbnVtLlVTRVIgJiYgbS50byA9PT0gTVBDdjJQYXJ0aWVzRW51bS5CQUNLVVBcbiAgICApO1xuICAgIGFzc2VydCh1c2VyVG9CYWNrdXBNc2czLCAnVXNlciB0byBCYWNrdXAgbWVzc2FnZSAzIG5vdCBmb3VuZCBpbiBQMlAgbWVzc2FnZXMnKTtcbiAgICBjb25zdCB1c2VyVG9CaXRnb01zZzMgPSB1c2VyUm91bmQzTWVzc2FnZXMucDJwTWVzc2FnZXMuZmluZChcbiAgICAgIChtKSA9PiBtLmZyb20gPT09IE1QQ3YyUGFydGllc0VudW0uVVNFUiAmJiBtLnRvID09PSBNUEN2MlBhcnRpZXNFbnVtLkJJVEdPXG4gICAgKTtcbiAgICBhc3NlcnQodXNlclRvQml0Z29Nc2czLCAnVXNlciB0byBCaXRnbyBtZXNzYWdlIDMgbm90IGZvdW5kIGluIFAyUCBtZXNzYWdlcycpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRVc2VyVG9CaXRnb01zZzMgPSBEa2xzVHlwZXMuc2VyaWFsaXplUDJQTWVzc2FnZSh1c2VyVG9CaXRnb01zZzMpO1xuXG4gICAgY29uc3QgYmFja3VwUm91bmQzTWVzc2FnZXMgPSBiYWNrdXBTZXNzaW9uLmhhbmRsZUluY29taW5nTWVzc2FnZXMoe1xuICAgICAgYnJvYWRjYXN0TWVzc2FnZXM6IFtdLFxuICAgICAgcDJwTWVzc2FnZXM6IFtiaXRnb1RvQmFja3VwUm91bmQyTXNnLCB1c2VyVG9CYWNrdXBNc2cyXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGJhY2t1cFRvVXNlck1zZzMgPSBiYWNrdXBSb3VuZDNNZXNzYWdlcy5wMnBNZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uZnJvbSA9PT0gTVBDdjJQYXJ0aWVzRW51bS5CQUNLVVAgJiYgbS50byA9PT0gTVBDdjJQYXJ0aWVzRW51bS5VU0VSXG4gICAgKTtcbiAgICBhc3NlcnQoYmFja3VwVG9Vc2VyTXNnMywgJ0JhY2t1cCB0byBVc2VyIG1lc3NhZ2UgMyBub3QgZm91bmQgaW4gUDJQIG1lc3NhZ2VzJyk7XG4gICAgY29uc3QgYmFja3VwVG9CaXRnb01zZzMgPSBiYWNrdXBSb3VuZDNNZXNzYWdlcy5wMnBNZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uZnJvbSA9PT0gTVBDdjJQYXJ0aWVzRW51bS5CQUNLVVAgJiYgbS50byA9PT0gTVBDdjJQYXJ0aWVzRW51bS5CSVRHT1xuICAgICk7XG4gICAgYXNzZXJ0KGJhY2t1cFRvQml0Z29Nc2czLCAnQmFja3VwIHRvIEJpdGdvIG1lc3NhZ2UgMyBub3QgZm91bmQgaW4gUDJQIG1lc3NhZ2VzJyk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEJhY2t1cFRvQml0Z29Nc2czID0gRGtsc1R5cGVzLnNlcmlhbGl6ZVAyUE1lc3NhZ2UoYmFja3VwVG9CaXRnb01zZzMpO1xuXG4gICAgY29uc3QgZGVjcnlwdGVkQml0Z29Ub1VzZXJSb3VuZDNNZXNzYWdlcyA9IGF3YWl0IERrbHNDb21tcy5kZWNyeXB0QW5kVmVyaWZ5SW5jb21pbmdNZXNzYWdlcyhcbiAgICAgIHsgYnJvYWRjYXN0TWVzc2FnZXM6IFtdLCBwMnBNZXNzYWdlczogW3RoaXMuZm9ybWF0UDJQTWVzc2FnZShiaXRnb1RvVXNlck1zZzMsIGJpdGdvQ29tbWl0bWVudDIpXSB9LFxuICAgICAgW2JpdGdvR3BnUHViS2V5XSxcbiAgICAgIFt1c2VyR3BnUHJ2S2V5XVxuICAgICk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEJpdGdvVG9Vc2VyUm91bmQzTXNnID0gZGVjcnlwdGVkQml0Z29Ub1VzZXJSb3VuZDNNZXNzYWdlcy5wMnBNZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uZnJvbSA9PT0gTVBDdjJQYXJ0aWVzRW51bS5CSVRHTyAmJiBtLnRvID09PSBNUEN2MlBhcnRpZXNFbnVtLlVTRVJcbiAgICApO1xuICAgIGFzc2VydChzZXJpYWxpemVkQml0Z29Ub1VzZXJSb3VuZDNNc2csICdCaXRHbyB0byBVc2VyIG1lc3NhZ2UgMyBub3QgZm91bmQgaW4gUDJQIG1lc3NhZ2VzJyk7XG4gICAgY29uc3QgYml0Z29Ub1VzZXJSb3VuZDNNc2cgPSBEa2xzVHlwZXMuZGVzZXJpYWxpemVQMlBNZXNzYWdlKHNlcmlhbGl6ZWRCaXRnb1RvVXNlclJvdW5kM01zZyk7XG5cbiAgICBjb25zdCBkZWNyeXB0ZWRCaXRnb1RvQmFja3VwUm91bmQzTWVzc2FnZXMgPSBhd2FpdCBEa2xzQ29tbXMuZGVjcnlwdEFuZFZlcmlmeUluY29taW5nTWVzc2FnZXMoXG4gICAgICB7IGJyb2FkY2FzdE1lc3NhZ2VzOiBbXSwgcDJwTWVzc2FnZXM6IFt0aGlzLmZvcm1hdFAyUE1lc3NhZ2UoYml0Z29Ub0JhY2t1cE1zZzMsIGJpdGdvQ29tbWl0bWVudDIpXSB9LFxuICAgICAgW2JpdGdvR3BnUHViS2V5XSxcbiAgICAgIFtiYWNrdXBHcGdQcnZLZXldXG4gICAgKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQml0Z29Ub0JhY2t1cFJvdW5kM01zZyA9IGRlY3J5cHRlZEJpdGdvVG9CYWNrdXBSb3VuZDNNZXNzYWdlcy5wMnBNZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uZnJvbSA9PT0gTVBDdjJQYXJ0aWVzRW51bS5CSVRHTyAmJiBtLnRvID09PSBNUEN2MlBhcnRpZXNFbnVtLkJBQ0tVUFxuICAgICk7XG4gICAgYXNzZXJ0KHNlcmlhbGl6ZWRCaXRnb1RvQmFja3VwUm91bmQzTXNnLCAnQml0R28gdG8gQmFja3VwIG1lc3NhZ2UgMyBub3QgZm91bmQgaW4gUDJQIG1lc3NhZ2VzJyk7XG4gICAgY29uc3QgYml0Z29Ub0JhY2t1cFJvdW5kM01zZyA9IERrbHNUeXBlcy5kZXNlcmlhbGl6ZVAyUE1lc3NhZ2Uoc2VyaWFsaXplZEJpdGdvVG9CYWNrdXBSb3VuZDNNc2cpO1xuXG4gICAgY29uc3QgdXNlclJvdW5kNE1lc3NhZ2VzID0gdXNlclNlc3Npb24uaGFuZGxlSW5jb21pbmdNZXNzYWdlcyh7XG4gICAgICBwMnBNZXNzYWdlczogW2JhY2t1cFRvVXNlck1zZzMsIGJpdGdvVG9Vc2VyUm91bmQzTXNnXSxcbiAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzOiBbXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZXJSb3VuZDRCcm9hZGNhc3RNc2cgPSB1c2VyUm91bmQ0TWVzc2FnZXMuYnJvYWRjYXN0TWVzc2FnZXMuZmluZCgobSkgPT4gbS5mcm9tID09PSBNUEN2MlBhcnRpZXNFbnVtLlVTRVIpO1xuICAgIGFzc2VydCh1c2VyUm91bmQ0QnJvYWRjYXN0TXNnLCAnVXNlciBtZXNzYWdlIDQgbm90IGZvdW5kIGluIGJyb2FkY2FzdCBtZXNzYWdlcycpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRVc2VyUm91bmQ0QnJvYWRjYXN0TXNnID0gRGtsc1R5cGVzLnNlcmlhbGl6ZUJyb2FkY2FzdE1lc3NhZ2UodXNlclJvdW5kNEJyb2FkY2FzdE1zZyk7XG5cbiAgICBjb25zdCBiYWNrdXBSb3VuZDRNZXNzYWdlcyA9IGJhY2t1cFNlc3Npb24uaGFuZGxlSW5jb21pbmdNZXNzYWdlcyh7XG4gICAgICBwMnBNZXNzYWdlczogW3VzZXJUb0JhY2t1cE1zZzMsIGJpdGdvVG9CYWNrdXBSb3VuZDNNc2ddLFxuICAgICAgYnJvYWRjYXN0TWVzc2FnZXM6IFtdLFxuICAgIH0pO1xuICAgIGNvbnN0IGJhY2t1cFJvdW5kNEJyb2FkY2FzdE1zZyA9IGJhY2t1cFJvdW5kNE1lc3NhZ2VzLmJyb2FkY2FzdE1lc3NhZ2VzLmZpbmQoXG4gICAgICAobSkgPT4gbS5mcm9tID09PSBNUEN2MlBhcnRpZXNFbnVtLkJBQ0tVUFxuICAgICk7XG4gICAgYXNzZXJ0KGJhY2t1cFJvdW5kNEJyb2FkY2FzdE1zZywgJ0JhY2t1cCBtZXNzYWdlIDQgbm90IGZvdW5kIGluIGJyb2FkY2FzdCBtZXNzYWdlcycpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRCYWNrdXBSb3VuZDRCcm9hZGNhc3RNc2cgPSBEa2xzVHlwZXMuc2VyaWFsaXplQnJvYWRjYXN0TWVzc2FnZShiYWNrdXBSb3VuZDRCcm9hZGNhc3RNc2cpO1xuXG4gICAgY29uc3Qgcm91bmQzTWVzc2FnZXMgPSBhd2FpdCBEa2xzQ29tbXMuZW5jcnlwdEFuZEF1dGhPdXRnb2luZ01lc3NhZ2VzKFxuICAgICAge1xuICAgICAgICBwMnBNZXNzYWdlczogW3NlcmlhbGl6ZWRVc2VyVG9CaXRnb01zZzMsIHNlcmlhbGl6ZWRCYWNrdXBUb0JpdGdvTXNnM10sXG4gICAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzOiBbc2VyaWFsaXplZFVzZXJSb3VuZDRCcm9hZGNhc3RNc2csIHNlcmlhbGl6ZWRCYWNrdXBSb3VuZDRCcm9hZGNhc3RNc2ddLFxuICAgICAgfSxcbiAgICAgIFtiaXRnb0dwZ1B1YktleV0sXG4gICAgICBbdXNlckdwZ1BydktleSwgYmFja3VwR3BnUHJ2S2V5XVxuICAgICk7XG5cbiAgICBjb25zdCB7XG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZFJvdW5kMyxcbiAgICAgIGJpdGdvTXNnNCxcbiAgICAgIGNvbW1vbktleWNoYWluOiBiaXRnb0NvbW1vbktleWNoYWluLFxuICAgIH0gPSBhd2FpdCB0aGlzLnNlbmRLZXlHZW5lcmF0aW9uUm91bmQzKHBhcmFtcy5lbnRlcnByaXNlLCBzZXNzaW9uSWQsIHJvdW5kM01lc3NhZ2VzKTtcblxuICAgIC8vICNlbmRyZWdpb25cblxuICAgIC8vICNyZWdpb24ga2V5Y2hhaW4gY3JlYXRpb25cbiAgICBhc3NlcnQuZXF1YWwoc2Vzc2lvbklkLCBzZXNzaW9uSWRSb3VuZDMsICdSb3VuZCAxIGFuZCAzIFNlc3Npb24gSURzIGRvIG5vdCBtYXRjaCcpO1xuICAgIGNvbnN0IGJpdGdvUm91bmQ0QnJvYWRjYXN0TWVzc2FnZXMgPSBEa2xzVHlwZXMuZGVzZXJpYWxpemVNZXNzYWdlcyhcbiAgICAgIGF3YWl0IERrbHNDb21tcy5kZWNyeXB0QW5kVmVyaWZ5SW5jb21pbmdNZXNzYWdlcyhcbiAgICAgICAgeyBwMnBNZXNzYWdlczogW10sIGJyb2FkY2FzdE1lc3NhZ2VzOiBbdGhpcy5mb3JtYXRCaXRnb0Jyb2FkY2FzdE1lc3NhZ2UoYml0Z29Nc2c0KV0gfSxcbiAgICAgICAgW2JpdGdvR3BnUHViS2V5XSxcbiAgICAgICAgW11cbiAgICAgIClcbiAgICApLmJyb2FkY2FzdE1lc3NhZ2VzO1xuICAgIGNvbnN0IGJpdGdvUm91bmQ0QnJvYWRjYXN0TXNnID0gYml0Z29Sb3VuZDRCcm9hZGNhc3RNZXNzYWdlcy5maW5kKChtKSA9PiBtLmZyb20gPT09IE1QQ3YyUGFydGllc0VudW0uQklUR08pO1xuXG4gICAgYXNzZXJ0KGJpdGdvUm91bmQ0QnJvYWRjYXN0TXNnLCAnQml0R28gbWVzc2FnZSA0IG5vdCBmb3VuZCBpbiBicm9hZGNhc3QgbWVzc2FnZXMnKTtcbiAgICB1c2VyU2Vzc2lvbi5oYW5kbGVJbmNvbWluZ01lc3NhZ2VzKHtcbiAgICAgIHAycE1lc3NhZ2VzOiBbXSxcbiAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzOiBbYml0Z29Sb3VuZDRCcm9hZGNhc3RNc2csIGJhY2t1cFJvdW5kNEJyb2FkY2FzdE1zZ10sXG4gICAgfSk7XG5cbiAgICBiYWNrdXBTZXNzaW9uLmhhbmRsZUluY29taW5nTWVzc2FnZXMoe1xuICAgICAgcDJwTWVzc2FnZXM6IFtdLFxuICAgICAgYnJvYWRjYXN0TWVzc2FnZXM6IFtiaXRnb1JvdW5kNEJyb2FkY2FzdE1zZywgdXNlclJvdW5kNEJyb2FkY2FzdE1zZ10sXG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VyUHJpdmF0ZU1hdGVyaWFsID0gdXNlclNlc3Npb24uZ2V0S2V5U2hhcmUoKTtcbiAgICBjb25zdCBiYWNrdXBQcml2YXRlTWF0ZXJpYWwgPSBiYWNrdXBTZXNzaW9uLmdldEtleVNoYXJlKCk7XG4gICAgY29uc3QgdXNlclJlZHVjZWRQcml2YXRlTWF0ZXJpYWwgPSB1c2VyU2Vzc2lvbi5nZXRSZWR1Y2VkS2V5U2hhcmUoKTtcbiAgICBjb25zdCBiYWNrdXBSZWR1Y2VkUHJpdmF0ZU1hdGVyaWFsID0gYmFja3VwU2Vzc2lvbi5nZXRSZWR1Y2VkS2V5U2hhcmUoKTtcblxuICAgIGNvbnN0IHVzZXJDb21tb25LZXljaGFpbiA9IERrbHNUeXBlcy5nZXRDb21tb25LZXljaGFpbih1c2VyUHJpdmF0ZU1hdGVyaWFsKTtcbiAgICBjb25zdCBiYWNrdXBDb21tb25LZXljaGFpbiA9IERrbHNUeXBlcy5nZXRDb21tb25LZXljaGFpbihiYWNrdXBQcml2YXRlTWF0ZXJpYWwpO1xuXG4gICAgYXNzZXJ0LmVxdWFsKGJpdGdvQ29tbW9uS2V5Y2hhaW4sIHVzZXJDb21tb25LZXljaGFpbiwgJ1VzZXIgYW5kIEJpdGdvIENvbW1vbiBrZXljaGFpbnMgZG8gbm90IG1hdGNoJyk7XG4gICAgYXNzZXJ0LmVxdWFsKGJpdGdvQ29tbW9uS2V5Y2hhaW4sIGJhY2t1cENvbW1vbktleWNoYWluLCAnQmFja3VwIGFuZCBCaXRnbyBDb21tb24ga2V5Y2hhaW5zIGRvIG5vdCBtYXRjaCcpO1xuXG4gICAgY29uc3QgdXNlcktleWNoYWluUHJvbWlzZSA9IHRoaXMuYWRkVXNlcktleWNoYWluKFxuICAgICAgYml0Z29Db21tb25LZXljaGFpbixcbiAgICAgIHVzZXJQcml2YXRlTWF0ZXJpYWwsXG4gICAgICB1c2VyUmVkdWNlZFByaXZhdGVNYXRlcmlhbCxcbiAgICAgIHBhcmFtcy5wYXNzcGhyYXNlLFxuICAgICAgcGFyYW1zLm9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZVxuICAgICk7XG4gICAgY29uc3QgYmFja3VwS2V5Y2hhaW5Qcm9taXNlID0gdGhpcy5hZGRCYWNrdXBLZXljaGFpbihcbiAgICAgIGJpdGdvQ29tbW9uS2V5Y2hhaW4sXG4gICAgICB1c2VyUHJpdmF0ZU1hdGVyaWFsLFxuICAgICAgYmFja3VwUmVkdWNlZFByaXZhdGVNYXRlcmlhbCxcbiAgICAgIHBhcmFtcy5wYXNzcGhyYXNlLFxuICAgICAgcGFyYW1zLm9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZVxuICAgICk7XG4gICAgY29uc3QgYml0Z29LZXljaGFpblByb21pc2UgPSB0aGlzLmFkZEJpdGdvS2V5Y2hhaW4oYml0Z29Db21tb25LZXljaGFpbik7XG5cbiAgICBjb25zdCBbdXNlcktleWNoYWluLCBiYWNrdXBLZXljaGFpbiwgYml0Z29LZXljaGFpbl0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB1c2VyS2V5Y2hhaW5Qcm9taXNlLFxuICAgICAgYmFja3VwS2V5Y2hhaW5Qcm9taXNlLFxuICAgICAgYml0Z29LZXljaGFpblByb21pc2UsXG4gICAgXSk7XG4gICAgLy8gI2VuZHJlZ2lvblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICB9O1xuICB9XG5cbiAgLy8gI3JlZ2lvbiBrZXljaGFpbiB1dGlsc1xuICBhc3luYyBjcmVhdGVQYXJ0aWNpcGFudEtleWNoYWluKFxuICAgIHBhcnRpY2lwYW50SW5kZXg6IE1QQ3YyUGFydHlGcm9tU3RyaW5nT3JOdW1iZXIsXG4gICAgY29tbW9uS2V5Y2hhaW46IHN0cmluZyxcbiAgICBwcml2YXRlTWF0ZXJpYWw/OiBCdWZmZXIsXG4gICAgcmVkdWNlZFByaXZhdGVNYXRlcmlhbD86IEJ1ZmZlcixcbiAgICBwYXNzcGhyYXNlPzogc3RyaW5nLFxuICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZT86IHN0cmluZ1xuICApOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgbGV0IHNvdXJjZTogc3RyaW5nO1xuICAgIGxldCBlbmNyeXB0ZWRQcnY6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgcmVkdWNlZEVuY3J5cHRlZFBydjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIHN3aXRjaCAocGFydGljaXBhbnRJbmRleCkge1xuICAgICAgY2FzZSBNUEN2MlBhcnRpZXNFbnVtLlVTRVI6XG4gICAgICBjYXNlIE1QQ3YyUGFydGllc0VudW0uQkFDS1VQOlxuICAgICAgICBzb3VyY2UgPSBwYXJ0aWNpcGFudEluZGV4ID09PSBNUEN2MlBhcnRpZXNFbnVtLlVTRVIgPyAndXNlcicgOiAnYmFja3VwJztcbiAgICAgICAgYXNzZXJ0KHByaXZhdGVNYXRlcmlhbCwgYFByaXZhdGUgbWF0ZXJpYWwgaXMgcmVxdWlyZWQgZm9yICR7c291cmNlfSBrZXljaGFpbmApO1xuICAgICAgICBhc3NlcnQocmVkdWNlZFByaXZhdGVNYXRlcmlhbCwgYFJlZHVjZWQgcHJpdmF0ZSBtYXRlcmlhbCBpcyByZXF1aXJlZCBmb3IgJHtzb3VyY2V9IGtleWNoYWluYCk7XG4gICAgICAgIGFzc2VydChwYXNzcGhyYXNlLCBgUGFzc3BocmFzZSBpcyByZXF1aXJlZCBmb3IgJHtzb3VyY2V9IGtleWNoYWluYCk7XG4gICAgICAgIGVuY3J5cHRlZFBydiA9IHRoaXMuYml0Z28uZW5jcnlwdCh7XG4gICAgICAgICAgaW5wdXQ6IHByaXZhdGVNYXRlcmlhbC50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgcGFzc3dvcmQ6IHBhc3NwaHJhc2UsXG4gICAgICAgIH0pO1xuICAgICAgICByZWR1Y2VkRW5jcnlwdGVkUHJ2ID0gdGhpcy5iaXRnby5lbmNyeXB0KHtcbiAgICAgICAgICAvLyBCdWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpIGNhbiBub3QgYmUgdXNlZCBoZXJlIGFzIGl0IGRvZXMgbm90IHdvcmsgb24gdGhlIGJyb3dzZXIuXG4gICAgICAgICAgLy8gVGhlIGJyb3dzZXIgZGVhbHMgd2l0aCBhIEJ1ZmZlciBhcyBVaW50OEFycmF5LCB0aGVyZWZvcmUgaW4gdGhlIGJyb3dzZXIgLnRvU3RyaW5nKCdiYXNlNjQnKSBqdXN0IGNyZWF0ZXMgYSBjb21tYSBzZXBlcmF0ZWQgc3RyaW5nIG9mIHRoZSBhcnJheSB2YWx1ZXMuXG4gICAgICAgICAgaW5wdXQ6IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KHJlZHVjZWRQcml2YXRlTWF0ZXJpYWwpKSkpLFxuICAgICAgICAgIHBhc3N3b3JkOiBwYXNzcGhyYXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1QQ3YyUGFydGllc0VudW0uQklUR086XG4gICAgICAgIHNvdXJjZSA9ICdiaXRnbyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcnRpY2lwYW50IGluZGV4Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjaXBpZW50S2V5Y2hhaW5QYXJhbXM6IEFkZEtleWNoYWluT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIGtleVR5cGU6ICd0c3MnIGFzIEtleVR5cGUsXG4gICAgICBjb21tb25LZXljaGFpbixcbiAgICAgIGVuY3J5cHRlZFBydixcbiAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgIGlzTVBDdjI6IHRydWUsXG4gICAgfTtcblxuICAgIGNvbnN0IGtleWNoYWlucyA9IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCk7XG4gICAgcmV0dXJuIHsgLi4uKGF3YWl0IGtleWNoYWlucy5hZGQocmVjaXBpZW50S2V5Y2hhaW5QYXJhbXMpKSwgcmVkdWNlZEVuY3J5cHRlZFBydjogcmVkdWNlZEVuY3J5cHRlZFBydiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHVzZXIgYW5kIGJhY2t1cCBNUEN2MSBTaWduaW5nTWF0ZXJpYWwgdG8gUmV0cm9maXREYXRhIG5lZWRlZCBieSBNUEN2MiBES0cuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBNUEN2MSBkZWNyeXB0ZWQgc2lnbmluZyBtYXRlcmlhbCBmb3IgdXNlciBhbmQgYmFja3VwIGFzIGEganNvbi5zdHJpbmdpZnkgc3RyaW5nIGFuZCBiaXRnbydzIEJpZyBTaS5cbiAgICogQHJldHVybnMge3sgbXBjdjJVc2VyS2V5U2hhcmU6IERrbHNUeXBlcy5SZXRyb2ZpdERhdGE7IG1wY3YyQmFrY3VwS2V5U2hhcmU6IERrbHNUeXBlcy5SZXRyb2ZpdERhdGEgfX0gLSB0aGUgcmV0cm9maXQgZGF0YSBuZWVkZWQgdG8gc3RhcnQgYW4gTVBDdjIgREtHIHNlc3Npb24uXG4gICAqL1xuICBnZXRNcGNWMlJldHJvZml0RGF0YUZyb21NcGNWMUtleXMocGFyYW1zOiB7IG1wY3YxVXNlcktleVNoYXJlOiBzdHJpbmc7IG1wY3YxQmFja3VwS2V5U2hhcmU6IHN0cmluZyB9KToge1xuICAgIG1wY3YyVXNlcktleVNoYXJlOiBEa2xzVHlwZXMuUmV0cm9maXREYXRhO1xuICAgIG1wY3YyQmFja3VwS2V5U2hhcmU6IERrbHNUeXBlcy5SZXRyb2ZpdERhdGE7XG4gIH0ge1xuICAgIGNvbnN0IG1wYyA9IG5ldyBFY2RzYSgpO1xuICAgIGNvbnN0IHhpTGlzdCA9IFtcbiAgICAgIEFycmF5LmZyb20oYmlnSW50VG9CdWZmZXJCRShCaWdJbnQoMSksIDMyKSksXG4gICAgICBBcnJheS5mcm9tKGJpZ0ludFRvQnVmZmVyQkUoQmlnSW50KDIpLCAzMikpLFxuICAgICAgQXJyYXkuZnJvbShiaWdJbnRUb0J1ZmZlckJFKEJpZ0ludCgzKSwgMzIpKSxcbiAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICBtcGN2MlVzZXJLZXlTaGFyZTogdGhpcy5nZXRNcGNWMlJldHJvZml0RGF0YUZyb21NcGNWMUtleSh7XG4gICAgICAgIG1wY3YxUGFydHlLZXlTaGFyZTogcGFyYW1zLm1wY3YxVXNlcktleVNoYXJlLFxuICAgICAgICBtcGN2MVBhcnR5SW5kZXg6IDEsXG4gICAgICAgIHhpTGlzdCxcbiAgICAgICAgbXBjLFxuICAgICAgfSksXG4gICAgICBtcGN2MkJhY2t1cEtleVNoYXJlOiB0aGlzLmdldE1wY1YyUmV0cm9maXREYXRhRnJvbU1wY1YxS2V5KHtcbiAgICAgICAgbXBjdjFQYXJ0eUtleVNoYXJlOiBwYXJhbXMubXBjdjFCYWNrdXBLZXlTaGFyZSxcbiAgICAgICAgbXBjdjFQYXJ0eUluZGV4OiAyLFxuICAgICAgICB4aUxpc3QsXG4gICAgICAgIG1wYyxcbiAgICAgIH0pLFxuICAgIH07XG4gIH1cblxuICBnZXRNcGNWMlJldHJvZml0RGF0YUZyb21NcGNWMUtleSh7XG4gICAgbXBjdjFQYXJ0eUtleVNoYXJlLFxuICAgIG1wY3YxUGFydHlJbmRleCxcbiAgICB4aUxpc3QsXG4gICAgbXBjLFxuICB9OiB7XG4gICAgbXBjdjFQYXJ0eUtleVNoYXJlOiBzdHJpbmc7XG4gICAgbXBjdjFQYXJ0eUluZGV4OiBudW1iZXI7XG4gICAgeGlMaXN0OiBudW1iZXJbXVtdO1xuICAgIG1wYzogRWNkc2E7XG4gIH0pOiBEa2xzVHlwZXMuUmV0cm9maXREYXRhIHtcbiAgICBjb25zdCBzaWduaW5nTWF0ZXJpYWw6IEVDRFNBTWV0aG9kVHlwZXMuU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZShtcGN2MVBhcnR5S2V5U2hhcmUpO1xuICAgIGxldCBrZXlDb21iaW5lZDogS2V5Q29tYmluZWQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgc3dpdGNoIChtcGN2MVBhcnR5SW5kZXgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYXNzZXJ0KHNpZ25pbmdNYXRlcmlhbC5iYWNrdXBOU2hhcmUsICdVc2VyIE1QQ3YxIGtleSBtYXRlcmlhbCBzaG91bGQgaGF2ZSBiYWNrdXAgTlNoYXJlLicpO1xuICAgICAgICBhc3NlcnQoc2lnbmluZ01hdGVyaWFsLmJpdGdvTlNoYXJlLCAnQml0R28gTVBDdjEga2V5IG1hdGVyaWFsIHNob3VsZCBoYXZlIHVzZXIgTlNoYXJlLicpO1xuICAgICAgICBrZXlDb21iaW5lZCA9IG1wYy5rZXlDb21iaW5lKHNpZ25pbmdNYXRlcmlhbC5wU2hhcmUsIFtcbiAgICAgICAgICBzaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlLFxuICAgICAgICAgIHNpZ25pbmdNYXRlcmlhbC5iaXRnb05TaGFyZSxcbiAgICAgICAgXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBhc3NlcnQoc2lnbmluZ01hdGVyaWFsLnVzZXJOU2hhcmUsICdVc2VyIE1QQ3YxIGtleSBtYXRlcmlhbCBzaG91bGQgaGF2ZSBiYWNrdXAgTlNoYXJlLicpO1xuICAgICAgICBhc3NlcnQoc2lnbmluZ01hdGVyaWFsLmJpdGdvTlNoYXJlLCAnQml0R28gTVBDdjEga2V5IG1hdGVyaWFsIHNob3VsZCBoYXZlIHVzZXIgTlNoYXJlLicpO1xuICAgICAgICBrZXlDb21iaW5lZCA9IG1wYy5rZXlDb21iaW5lKHNpZ25pbmdNYXRlcmlhbC5wU2hhcmUsIFtzaWduaW5nTWF0ZXJpYWwudXNlck5TaGFyZSwgc2lnbmluZ01hdGVyaWFsLmJpdGdvTlNoYXJlXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBhc3NlcnQoc2lnbmluZ01hdGVyaWFsLnVzZXJOU2hhcmUsICdVc2VyIE1QQ3YxIGtleSBtYXRlcmlhbCBzaG91bGQgaGF2ZSBiYWNrdXAgTlNoYXJlLicpO1xuICAgICAgICBhc3NlcnQoc2lnbmluZ01hdGVyaWFsLmJhY2t1cE5TaGFyZSwgJ0JhY2t1cCBNUEN2MSBrZXkgbWF0ZXJpYWwgc2hvdWxkIGhhdmUgdXNlciBOU2hhcmUuJyk7XG4gICAgICAgIGtleUNvbWJpbmVkID0gbXBjLmtleUNvbWJpbmUoc2lnbmluZ01hdGVyaWFsLnBTaGFyZSwgW1xuICAgICAgICAgIHNpZ25pbmdNYXRlcmlhbC51c2VyTlNoYXJlLFxuICAgICAgICAgIHNpZ25pbmdNYXRlcmlhbC5iYWNrdXBOU2hhcmUsXG4gICAgICAgIF0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJ0aWNpcGFudCBpbmRleCcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeFNoYXJlOiBrZXlDb21iaW5lZC54U2hhcmUsXG4gICAgICB4aUxpc3Q6IHhpTGlzdCxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBhZGRVc2VyS2V5Y2hhaW4oXG4gICAgY29tbW9uS2V5Y2hhaW46IHN0cmluZyxcbiAgICBwcml2YXRlTWF0ZXJpYWw6IEJ1ZmZlcixcbiAgICByZWR1Y2VkUHJpdmF0ZU1hdGVyaWFsOiBCdWZmZXIsXG4gICAgcGFzc3BocmFzZTogc3RyaW5nLFxuICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZT86IHN0cmluZ1xuICApOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFydGljaXBhbnRLZXljaGFpbihcbiAgICAgIE1QQ3YyUGFydGllc0VudW0uVVNFUixcbiAgICAgIGNvbW1vbktleWNoYWluLFxuICAgICAgcHJpdmF0ZU1hdGVyaWFsLFxuICAgICAgcmVkdWNlZFByaXZhdGVNYXRlcmlhbCxcbiAgICAgIHBhc3NwaHJhc2UsXG4gICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGVcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBhZGRCYWNrdXBLZXljaGFpbihcbiAgICBjb21tb25LZXljaGFpbjogc3RyaW5nLFxuICAgIHByaXZhdGVNYXRlcmlhbDogQnVmZmVyLFxuICAgIHJlZHVjZWRQcml2YXRlTWF0ZXJpYWw6IEJ1ZmZlcixcbiAgICBwYXNzcGhyYXNlOiBzdHJpbmcsXG4gICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlPzogc3RyaW5nXG4gICk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJ0aWNpcGFudEtleWNoYWluKFxuICAgICAgTVBDdjJQYXJ0aWVzRW51bS5CQUNLVVAsXG4gICAgICBjb21tb25LZXljaGFpbixcbiAgICAgIHByaXZhdGVNYXRlcmlhbCxcbiAgICAgIHJlZHVjZWRQcml2YXRlTWF0ZXJpYWwsXG4gICAgICBwYXNzcGhyYXNlLFxuICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VXNlckFuZEJhY2t1cFNlc3Npb24obTogbnVtYmVyLCBuOiBudW1iZXIsIHJldHJvZml0PzogRGVjcnlwdGVkUmV0cm9maXRQYXlsb2FkKSB7XG4gICAgaWYgKHJldHJvZml0KSB7XG4gICAgICBjb25zdCByZXRyb2ZpdERhdGEgPSB0aGlzLmdldE1wY1YyUmV0cm9maXREYXRhRnJvbU1wY1YxS2V5cyh7XG4gICAgICAgIG1wY3YxVXNlcktleVNoYXJlOiByZXRyb2ZpdC5kZWNyeXB0ZWRVc2VyS2V5LFxuICAgICAgICBtcGN2MUJhY2t1cEtleVNoYXJlOiByZXRyb2ZpdC5kZWNyeXB0ZWRCYWNrdXBLZXksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdXNlclNlc3Npb24gPSBuZXcgRGtsc0RrZy5Ea2cobiwgbSwgTVBDdjJQYXJ0aWVzRW51bS5VU0VSLCB1bmRlZmluZWQsIHJldHJvZml0RGF0YS5tcGN2MlVzZXJLZXlTaGFyZSk7XG4gICAgICBjb25zdCBiYWNrdXBTZXNzaW9uID0gbmV3IERrbHNEa2cuRGtnKG4sIG0sIE1QQ3YyUGFydGllc0VudW0uQkFDS1VQLCB1bmRlZmluZWQsIHJldHJvZml0RGF0YS5tcGN2MkJhY2t1cEtleVNoYXJlKTtcblxuICAgICAgcmV0dXJuIHsgdXNlclNlc3Npb24sIGJhY2t1cFNlc3Npb24gfTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyU2Vzc2lvbiA9IG5ldyBEa2xzRGtnLkRrZyhuLCBtLCBNUEN2MlBhcnRpZXNFbnVtLlVTRVIpO1xuICAgIGNvbnN0IGJhY2t1cFNlc3Npb24gPSBuZXcgRGtsc0RrZy5Ea2cobiwgbSwgTVBDdjJQYXJ0aWVzRW51bS5CQUNLVVApO1xuXG4gICAgcmV0dXJuIHsgdXNlclNlc3Npb24sIGJhY2t1cFNlc3Npb24gfTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgYWRkQml0Z29LZXljaGFpbihjb21tb25LZXljaGFpbjogc3RyaW5nKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcnRpY2lwYW50S2V5Y2hhaW4oTVBDdjJQYXJ0aWVzRW51bS5CSVRHTywgY29tbW9uS2V5Y2hhaW4pO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGdlbmVyYXRlIGtleSByZXF1ZXN0IHV0aWxzXG4gIHByaXZhdGUgYXN5bmMgc2VuZEtleUdlbmVyYXRpb25SZXF1ZXN0PFQgZXh0ZW5kcyBHZW5lcmF0ZU1QQ3YyS2V5UmVxdWVzdFJlc3BvbnNlPihcbiAgICBlbnRlcnByaXNlOiBzdHJpbmcsXG4gICAgcm91bmQ6IE1QQ3YyS2V5R2VuU3RhdGUsXG4gICAgcGF5bG9hZDogR2VuZXJhdGVNUEN2MktleVJlcXVlc3RCb2R5ICYgeyB3YWxsZXRJZD86IHN0cmluZyB9XG4gICk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJpdGdvLnVybCgnL21wYy9nZW5lcmF0ZWtleScsIDIpKVxuICAgICAgLnNlbmQoeyBlbnRlcnByaXNlLCB0eXBlOiBLZXlHZW5UeXBlRW51bS5NUEN2Miwgcm91bmQsIHBheWxvYWQgfSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRLZXlHZW5lcmF0aW9uUm91bmQxKFxuICAgIGVudGVycHJpc2U6IHN0cmluZyxcbiAgICB1c2VyR3BnUHVibGljS2V5OiBzdHJpbmcsXG4gICAgYmFja3VwR3BnUHVibGljS2V5OiBzdHJpbmcsXG4gICAgcGF5bG9hZDogRGtsc1R5cGVzLkF1dGhFbmNNZXNzYWdlcyAmIHsgd2FsbGV0SWQ/OiBzdHJpbmcgfVxuICApOiBQcm9taXNlPE1QQ3YyS2V5R2VuUm91bmQxUmVzcG9uc2U+IHtcbiAgICBhc3NlcnQoTm9uRW1wdHlTdHJpbmcuaXModXNlckdwZ1B1YmxpY0tleSksICdVc2VyIEdQRyBwdWJsaWMga2V5IGlzIHJlcXVpcmVkJyk7XG4gICAgYXNzZXJ0KE5vbkVtcHR5U3RyaW5nLmlzKGJhY2t1cEdwZ1B1YmxpY0tleSksICdCYWNrdXAgR1BHIHB1YmxpYyBrZXkgaXMgcmVxdWlyZWQnKTtcbiAgICBjb25zdCB1c2VyTXNnMSA9IHBheWxvYWQuYnJvYWRjYXN0TWVzc2FnZXMuZmluZCgobSkgPT4gbS5mcm9tID09PSBNUEN2MlBhcnRpZXNFbnVtLlVTRVIpPy5wYXlsb2FkO1xuICAgIGFzc2VydCh1c2VyTXNnMSwgJ1VzZXIgbWVzc2FnZSAxIG5vdCBmb3VuZCBpbiBicm9hZGNhc3QgbWVzc2FnZXMnKTtcbiAgICBjb25zdCBiYWNrdXBNc2cxID0gcGF5bG9hZC5icm9hZGNhc3RNZXNzYWdlcy5maW5kKChtKSA9PiBtLmZyb20gPT09IE1QQ3YyUGFydGllc0VudW0uQkFDS1VQKT8ucGF5bG9hZDtcbiAgICBhc3NlcnQoYmFja3VwTXNnMSwgJ0JhY2t1cCBtZXNzYWdlIDEgbm90IGZvdW5kIGluIGJyb2FkY2FzdCBtZXNzYWdlcycpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2VuZEtleUdlbmVyYXRpb25SZXF1ZXN0PE1QQ3YyS2V5R2VuUm91bmQxUmVzcG9uc2U+KGVudGVycHJpc2UsIE1QQ3YyS2V5R2VuU3RhdGVFbnVtWydNUEN2Mi1SMSddLCB7XG4gICAgICB1c2VyR3BnUHVibGljS2V5LFxuICAgICAgYmFja3VwR3BnUHVibGljS2V5LFxuICAgICAgdXNlck1zZzE6IHsgZnJvbTogMCwgLi4udXNlck1zZzEgfSxcbiAgICAgIGJhY2t1cE1zZzE6IHsgZnJvbTogMSwgLi4uYmFja3VwTXNnMSB9LFxuICAgICAgd2FsbGV0SWQ6IHBheWxvYWQud2FsbGV0SWQsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBzZW5kS2V5R2VuZXJhdGlvblJvdW5kMihcbiAgICBlbnRlcnByaXNlOiBzdHJpbmcsXG4gICAgc2Vzc2lvbklkOiBzdHJpbmcsXG4gICAgcGF5bG9hZDogRGtsc1R5cGVzLkF1dGhFbmNNZXNzYWdlc1xuICApOiBQcm9taXNlPE1QQ3YyS2V5R2VuUm91bmQyUmVzcG9uc2U+IHtcbiAgICBhc3NlcnQoTm9uRW1wdHlTdHJpbmcuaXMoc2Vzc2lvbklkKSwgJ1Nlc3Npb24gSUQgaXMgcmVxdWlyZWQnKTtcbiAgICBjb25zdCB1c2VyTXNnMiA9IHBheWxvYWQucDJwTWVzc2FnZXMuZmluZChcbiAgICAgIChtKSA9PiBtLmZyb20gPT09IE1QQ3YyUGFydGllc0VudW0uVVNFUiAmJiBtLnRvID09PSBNUEN2MlBhcnRpZXNFbnVtLkJJVEdPXG4gICAgKTtcbiAgICBhc3NlcnQodXNlck1zZzIsICdVc2VyIHRvIEJpdGdvIG1lc3NhZ2UgMiBub3QgZm91bmQgaW4gUDJQIG1lc3NhZ2VzJyk7XG4gICAgYXNzZXJ0KHVzZXJNc2cyLmNvbW1pdG1lbnQsICdVc2VyIHRvIEJpdGdvIGNvbW1pdG1lbnQgbm90IGZvdW5kIGluIFAyUCBtZXNzYWdlcycpO1xuICAgIGFzc2VydChOb25FbXB0eVN0cmluZy5pcyh1c2VyTXNnMi5jb21taXRtZW50KSwgJ1VzZXIgdG8gQml0Z28gY29tbWl0bWVudCBpcyByZXF1aXJlZCcpO1xuICAgIGNvbnN0IGJhY2t1cE1zZzIgPSBwYXlsb2FkLnAycE1lc3NhZ2VzLmZpbmQoXG4gICAgICAobSkgPT4gbS5mcm9tID09PSBNUEN2MlBhcnRpZXNFbnVtLkJBQ0tVUCAmJiBtLnRvID09PSBNUEN2MlBhcnRpZXNFbnVtLkJJVEdPXG4gICAgKTtcbiAgICBhc3NlcnQoYmFja3VwTXNnMiwgJ0JhY2t1cCB0byBCaXRnbyBtZXNzYWdlIDIgbm90IGZvdW5kIGluIFAyUCBtZXNzYWdlcycpO1xuICAgIGFzc2VydChiYWNrdXBNc2cyLmNvbW1pdG1lbnQsICdCYWNrdXAgdG8gQml0Z28gY29tbWl0bWVudCBub3QgZm91bmQgaW4gUDJQIG1lc3NhZ2VzJyk7XG4gICAgYXNzZXJ0KE5vbkVtcHR5U3RyaW5nLmlzKGJhY2t1cE1zZzIuY29tbWl0bWVudCksICdCYWNrdXAgdG8gQml0Z28gY29tbWl0bWVudCBpcyByZXF1aXJlZCcpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2VuZEtleUdlbmVyYXRpb25SZXF1ZXN0PE1QQ3YyS2V5R2VuUm91bmQyUmVzcG9uc2U+KGVudGVycHJpc2UsIE1QQ3YyS2V5R2VuU3RhdGVFbnVtWydNUEN2Mi1SMiddLCB7XG4gICAgICBzZXNzaW9uSWQsXG4gICAgICB1c2VyTXNnMjoge1xuICAgICAgICBmcm9tOiBNUEN2MlBhcnRpZXNFbnVtLlVTRVIsXG4gICAgICAgIHRvOiBNUEN2MlBhcnRpZXNFbnVtLkJJVEdPLFxuICAgICAgICBzaWduYXR1cmU6IHVzZXJNc2cyLnBheWxvYWQuc2lnbmF0dXJlLFxuICAgICAgICBlbmNyeXB0ZWRNZXNzYWdlOiB1c2VyTXNnMi5wYXlsb2FkLmVuY3J5cHRlZE1lc3NhZ2UsXG4gICAgICB9LFxuICAgICAgdXNlckNvbW1pdG1lbnQyOiB1c2VyTXNnMi5jb21taXRtZW50LFxuICAgICAgYmFja3VwTXNnMjoge1xuICAgICAgICBmcm9tOiBNUEN2MlBhcnRpZXNFbnVtLkJBQ0tVUCxcbiAgICAgICAgdG86IE1QQ3YyUGFydGllc0VudW0uQklUR08sXG4gICAgICAgIHNpZ25hdHVyZTogYmFja3VwTXNnMi5wYXlsb2FkLnNpZ25hdHVyZSxcbiAgICAgICAgZW5jcnlwdGVkTWVzc2FnZTogYmFja3VwTXNnMi5wYXlsb2FkLmVuY3J5cHRlZE1lc3NhZ2UsXG4gICAgICB9LFxuICAgICAgYmFja3VwQ29tbWl0bWVudDI6IGJhY2t1cE1zZzIuY29tbWl0bWVudCxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRLZXlHZW5lcmF0aW9uUm91bmQzKFxuICAgIGVudGVycHJpc2U6IHN0cmluZyxcbiAgICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgICBwYXlsb2FkOiBEa2xzVHlwZXMuQXV0aEVuY01lc3NhZ2VzXG4gICk6IFByb21pc2U8TVBDdjJLZXlHZW5Sb3VuZDNSZXNwb25zZT4ge1xuICAgIGFzc2VydChOb25FbXB0eVN0cmluZy5pcyhzZXNzaW9uSWQpLCAnU2Vzc2lvbiBJRCBpcyByZXF1aXJlZCcpO1xuICAgIGNvbnN0IHVzZXJNc2czID0gcGF5bG9hZC5wMnBNZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uZnJvbSA9PT0gTVBDdjJQYXJ0aWVzRW51bS5VU0VSICYmIG0udG8gPT09IE1QQ3YyUGFydGllc0VudW0uQklUR09cbiAgICApPy5wYXlsb2FkO1xuICAgIGFzc2VydCh1c2VyTXNnMywgJ1VzZXIgdG8gQml0Z28gbWVzc2FnZSAzIG5vdCBmb3VuZCBpbiBQMlAgbWVzc2FnZXMnKTtcbiAgICBjb25zdCBiYWNrdXBNc2czID0gcGF5bG9hZC5wMnBNZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uZnJvbSA9PT0gTVBDdjJQYXJ0aWVzRW51bS5CQUNLVVAgJiYgbS50byA9PT0gTVBDdjJQYXJ0aWVzRW51bS5CSVRHT1xuICAgICk/LnBheWxvYWQ7XG4gICAgYXNzZXJ0KGJhY2t1cE1zZzMsICdCYWNrdXAgdG8gQml0Z28gbWVzc2FnZSAzIG5vdCBmb3VuZCBpbiBQMlAgbWVzc2FnZXMnKTtcbiAgICBjb25zdCB1c2VyTXNnNCA9IHBheWxvYWQuYnJvYWRjYXN0TWVzc2FnZXMuZmluZCgobSkgPT4gbS5mcm9tID09PSBNUEN2MlBhcnRpZXNFbnVtLlVTRVIpPy5wYXlsb2FkO1xuICAgIGFzc2VydCh1c2VyTXNnNCwgJ1VzZXIgbWVzc2FnZSAxIG5vdCBmb3VuZCBpbiBicm9hZGNhc3QgbWVzc2FnZXMnKTtcbiAgICBjb25zdCBiYWNrdXBNc2c0ID0gcGF5bG9hZC5icm9hZGNhc3RNZXNzYWdlcy5maW5kKChtKSA9PiBtLmZyb20gPT09IE1QQ3YyUGFydGllc0VudW0uQkFDS1VQKT8ucGF5bG9hZDtcbiAgICBhc3NlcnQoYmFja3VwTXNnNCwgJ0JhY2t1cCBtZXNzYWdlIDEgbm90IGZvdW5kIGluIGJyb2FkY2FzdCBtZXNzYWdlcycpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2VuZEtleUdlbmVyYXRpb25SZXF1ZXN0PE1QQ3YyS2V5R2VuUm91bmQzUmVzcG9uc2U+KGVudGVycHJpc2UsIE1QQ3YyS2V5R2VuU3RhdGVFbnVtWydNUEN2Mi1SMyddLCB7XG4gICAgICBzZXNzaW9uSWQsXG4gICAgICB1c2VyTXNnMzogeyBmcm9tOiAwLCB0bzogMiwgLi4udXNlck1zZzMgfSxcbiAgICAgIGJhY2t1cE1zZzM6IHsgZnJvbTogMSwgdG86IDIsIC4uLmJhY2t1cE1zZzMgfSxcbiAgICAgIHVzZXJNc2c0OiB7IGZyb206IDAsIC4uLnVzZXJNc2c0IH0sXG4gICAgICBiYWNrdXBNc2c0OiB7IGZyb206IDEsIC4uLmJhY2t1cE1zZzQgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHNpZ24gdHggcmVxdWVzdFxuXG4gIC8qKlxuICAgKiBTaWducyB0aGUgdHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB0byB0aGUgdHJhbnNhY3Rpb24gcmVxdWVzdC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBUeFJlcXVlc3R9IHBhcmFtcy50eFJlcXVlc3QgLSB0cmFuc2FjdGlvbiByZXF1ZXN0IG9iamVjdCBvciBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBydiAtIGRlY3J5cHRlZCBwcml2YXRlIGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnJlcUlkIC0gcmVxdWVzdCBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm1wY3YyUGFydHlJZCAtIHBhcnR5IGlkIGZvciB0aGUgc2lnbmVyIGludm9sdmVkIGluIHRoaXMgbXBjdjIgcmVxdWVzdCAoZWl0aGVyIDAgZm9yIHVzZXIgb3IgMSBmb3IgYmFja3VwKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fSBmdWxseSBzaWduZWQgVHhSZXF1ZXN0IG9iamVjdFxuICAgKi9cblxuICBhc3luYyBzaWduVHhSZXF1ZXN0KHBhcmFtczogVFNTUGFyYW1zV2l0aFBydik6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCk7XG4gICAgcmV0dXJuIHRoaXMuc2lnblJlcXVlc3RCYXNlKHBhcmFtcywgUmVxdWVzdFR5cGUudHgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBtZXNzYWdlIGFzc29jaWF0ZWQgdG8gdGhlIHRyYW5zYWN0aW9uIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVHhSZXF1ZXN0fSBwYXJhbXMudHhSZXF1ZXN0IC0gdHJhbnNhY3Rpb24gcmVxdWVzdCBvYmplY3Qgb3IgaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wcnYgLSBkZWNyeXB0ZWQgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5yZXFJZCAtIHJlcXVlc3QgaWRcbiAgICogQHJldHVybnMge1Byb21pc2U8VHhSZXF1ZXN0Pn0gZnVsbHkgc2lnbmVkIFR4UmVxdWVzdCBvYmplY3RcbiAgICovXG4gIGFzeW5jIHNpZ25UeFJlcXVlc3RGb3JNZXNzYWdlKHBhcmFtczogVFNTUGFyYW1zRm9yTWVzc2FnZVdpdGhQcnYpOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQpO1xuICAgIHJldHVybiB0aGlzLnNpZ25SZXF1ZXN0QmFzZShwYXJhbXMsIFJlcXVlc3RUeXBlLm1lc3NhZ2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzaWduUmVxdWVzdEJhc2UoXG4gICAgcGFyYW1zOiBUU1NQYXJhbXNXaXRoUHJ2IHwgVFNTUGFyYW1zRm9yTWVzc2FnZVdpdGhQcnYsXG4gICAgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlXG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgY29uc3QgdXNlcktleVNoYXJlID0gQnVmZmVyLmZyb20ocGFyYW1zLnBydiwgJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IHR4UmVxdWVzdDogVHhSZXF1ZXN0ID1cbiAgICAgIHR5cGVvZiBwYXJhbXMudHhSZXF1ZXN0ID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGF3YWl0IGdldFR4UmVxdWVzdCh0aGlzLmJpdGdvLCB0aGlzLndhbGxldC5pZCgpLCBwYXJhbXMudHhSZXF1ZXN0LCBwYXJhbXMucmVxSWQpXG4gICAgICAgIDogcGFyYW1zLnR4UmVxdWVzdDtcblxuICAgIGxldCB0eE9yTWVzc2FnZVRvU2lnbjtcbiAgICBsZXQgZGVyaXZhdGlvblBhdGg7XG4gICAgbGV0IGJ1ZmZlckNvbnRlbnQ7XG4gICAgY29uc3QgW3VzZXJHcGdLZXksIGJpdGdvR3BnUHViS2V5XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGdlbmVyYXRlR1BHS2V5UGFpcignc2VjcDI1NmsxJyksXG4gICAgICB0aGlzLmdldEJpdGdvR3BnUHVia2V5QmFzZWRPbkZlYXR1cmVGbGFncyh0eFJlcXVlc3QuZW50ZXJwcmlzZUlkLCB0cnVlLCBwYXJhbXMucmVxSWQpLnRoZW4oXG4gICAgICAgIChwdWJLZXkpID0+IHB1YktleSA/PyB0aGlzLmJpdGdvTVBDdjJQdWJsaWNHcGdLZXlcbiAgICAgICksXG4gICAgXSk7XG4gICAgaWYgKCFiaXRnb0dwZ1B1YktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEJpdEdvIEdQRyBrZXkgZm9yIE1QQ3YyJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3RUeXBlID09PSBSZXF1ZXN0VHlwZS50eCkge1xuICAgICAgYXNzZXJ0KHR4UmVxdWVzdC50cmFuc2FjdGlvbnMgfHwgdHhSZXF1ZXN0LnVuc2lnbmVkVHhzLCAnVW5hYmxlIHRvIGZpbmQgdHJhbnNhY3Rpb25zIGluIHR4UmVxdWVzdCcpO1xuICAgICAgY29uc3QgdW5zaWduZWRUeCA9XG4gICAgICAgIHR4UmVxdWVzdC5hcGlWZXJzaW9uID09PSAnZnVsbCcgPyB0eFJlcXVlc3QudHJhbnNhY3Rpb25zIVswXS51bnNpZ25lZFR4IDogdHhSZXF1ZXN0LnVuc2lnbmVkVHhzWzBdO1xuICAgICAgdHhPck1lc3NhZ2VUb1NpZ24gPSB1bnNpZ25lZFR4LnNpZ25hYmxlSGV4O1xuICAgICAgZGVyaXZhdGlvblBhdGggPSB1bnNpZ25lZFR4LmRlcml2YXRpb25QYXRoO1xuICAgICAgYnVmZmVyQ29udGVudCA9IEJ1ZmZlci5mcm9tKHR4T3JNZXNzYWdlVG9TaWduLCAnaGV4Jyk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0VHlwZSA9PT0gUmVxdWVzdFR5cGUubWVzc2FnZSkge1xuICAgICAgdHhPck1lc3NhZ2VUb1NpZ24gPSB0eFJlcXVlc3QubWVzc2FnZXMhWzBdLm1lc3NhZ2VFbmNvZGVkO1xuICAgICAgZGVyaXZhdGlvblBhdGggPSB0eFJlcXVlc3QubWVzc2FnZXMhWzBdLmRlcml2YXRpb25QYXRoIHx8ICdtLzAnO1xuICAgICAgYnVmZmVyQ29udGVudCA9IEJ1ZmZlci5mcm9tKHR4T3JNZXNzYWdlVG9TaWduKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlcXVlc3QgdHlwZScpO1xuICAgIH1cblxuICAgIGxldCBoYXNoOiBIYXNoO1xuICAgIHRyeSB7XG4gICAgICBoYXNoID0gdGhpcy5iYXNlQ29pbi5nZXRIYXNoRnVuY3Rpb24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGhhc2ggPSBjcmVhdGVLZWNjYWtIYXNoKCdrZWNjYWsyNTYnKSBhcyBIYXNoO1xuICAgIH1cbiAgICAvLyBjaGVjayB3aGF0IHRoZSBlbmNvZGluZyBpcyBzdXBwb3NlZCB0byBiZSBmb3IgbWVzc2FnZVxuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSBoYXNoLnVwZGF0ZShidWZmZXJDb250ZW50KS5kaWdlc3QoKTtcbiAgICBjb25zdCBvdGhlclNpZ25lciA9IG5ldyBEa2xzRHNnLkRzZyhcbiAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgIHBhcmFtcy5tcGN2MlBhcnR5SWQgPyBwYXJhbXMubXBjdjJQYXJ0eUlkIDogMCxcbiAgICAgIGRlcml2YXRpb25QYXRoLFxuICAgICAgaGFzaEJ1ZmZlclxuICAgICk7XG4gICAgY29uc3QgdXNlclNpZ25lckJyb2FkY2FzdE1zZzEgPSBhd2FpdCBvdGhlclNpZ25lci5pbml0KCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlU2hhcmVSb3VuZDEgPSBhd2FpdCBnZXRTaWduYXR1cmVTaGFyZVJvdW5kT25lKFxuICAgICAgdXNlclNpZ25lckJyb2FkY2FzdE1zZzEsXG4gICAgICB1c2VyR3BnS2V5LFxuICAgICAgcGFyYW1zLm1wY3YyUGFydHlJZFxuICAgICk7XG5cbiAgICBsZXQgbGF0ZXN0VHhSZXF1ZXN0ID0gYXdhaXQgc2VuZFNpZ25hdHVyZVNoYXJlVjIoXG4gICAgICB0aGlzLmJpdGdvLFxuICAgICAgdHhSZXF1ZXN0LndhbGxldElkLFxuICAgICAgdHhSZXF1ZXN0LnR4UmVxdWVzdElkLFxuICAgICAgW3NpZ25hdHVyZVNoYXJlUm91bmQxXSxcbiAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgdGhpcy5iYXNlQ29pbi5nZXRNUENBbGdvcml0aG0oKSxcbiAgICAgIHVzZXJHcGdLZXkucHVibGljS2V5LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy53YWxsZXQubXVsdGlzaWdUeXBlVmVyc2lvbigpLFxuICAgICAgcGFyYW1zLnJlcUlkXG4gICAgKTtcblxuICAgIGFzc2VydChsYXRlc3RUeFJlcXVlc3QudHJhbnNhY3Rpb25zIHx8IGxhdGVzdFR4UmVxdWVzdC5tZXNzYWdlcywgJ0ludmFsaWQgdHhSZXF1ZXN0IE9iamVjdCcpO1xuXG4gICAgbGV0IGJpdGdvVG9Vc2VyTWVzc2FnZXMxQW5kMjogYW55O1xuICAgIGlmIChyZXF1ZXN0VHlwZSA9PT0gUmVxdWVzdFR5cGUudHgpIHtcbiAgICAgIGJpdGdvVG9Vc2VyTWVzc2FnZXMxQW5kMiA9IGxhdGVzdFR4UmVxdWVzdC50cmFuc2FjdGlvbnMhWzBdLnNpZ25hdHVyZVNoYXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgYml0Z29Ub1VzZXJNZXNzYWdlczFBbmQyID0gbGF0ZXN0VHhSZXF1ZXN0Lm1lc3NhZ2VzIVswXS5zaWduYXR1cmVTaGFyZXM7XG4gICAgfVxuICAgIC8vIFRPRE86IFVzZSBjb2RlYyBmb3IgcGFyc2luZ1xuICAgIGNvbnN0IHBhcnNlZEJpdEdvVG9Vc2VyU2lnU2hhcmVSb3VuZE9uZSA9IEpTT04ucGFyc2UoXG4gICAgICBiaXRnb1RvVXNlck1lc3NhZ2VzMUFuZDJbYml0Z29Ub1VzZXJNZXNzYWdlczFBbmQyLmxlbmd0aCAtIDFdLnNoYXJlXG4gICAgKSBhcyBNUEN2MlNpZ25hdHVyZVNoYXJlUm91bmQxT3V0cHV0O1xuICAgIGlmIChwYXJzZWRCaXRHb1RvVXNlclNpZ1NoYXJlUm91bmRPbmUudHlwZSAhPT0gJ3JvdW5kMU91dHB1dCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzaWduYXR1cmUgc2hhcmUgcmVzcG9uc2UuIFVuYWJsZSB0byBwYXJzZSBkYXRhLicpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkQml0R29Ub1VzZXJNZXNzYWdlc1JvdW5kMUFuZDIgPSBhd2FpdCB2ZXJpZnlCaXRHb01lc3NhZ2VzQW5kU2lnbmF0dXJlc1JvdW5kT25lKFxuICAgICAgcGFyc2VkQml0R29Ub1VzZXJTaWdTaGFyZVJvdW5kT25lLFxuICAgICAgdXNlckdwZ0tleSxcbiAgICAgIGJpdGdvR3BnUHViS2V5LFxuICAgICAgcGFyYW1zLm1wY3YyUGFydHlJZFxuICAgICk7XG5cbiAgICAvKiogUm91bmQgMiAqKi9cbiAgICBjb25zdCBkZXNlcmlhbGl6ZWRNZXNzYWdlcyA9IERrbHNUeXBlcy5kZXNlcmlhbGl6ZU1lc3NhZ2VzKHNlcmlhbGl6ZWRCaXRHb1RvVXNlck1lc3NhZ2VzUm91bmQxQW5kMik7XG4gICAgY29uc3QgdXNlclRvQml0R29NZXNzYWdlc1JvdW5kMiA9IG90aGVyU2lnbmVyLmhhbmRsZUluY29taW5nTWVzc2FnZXMoe1xuICAgICAgcDJwTWVzc2FnZXM6IFtdLFxuICAgICAgYnJvYWRjYXN0TWVzc2FnZXM6IGRlc2VyaWFsaXplZE1lc3NhZ2VzLmJyb2FkY2FzdE1lc3NhZ2VzLFxuICAgIH0pO1xuICAgIGNvbnN0IHVzZXJUb0JpdEdvTWVzc2FnZXNSb3VuZDMgPSBvdGhlclNpZ25lci5oYW5kbGVJbmNvbWluZ01lc3NhZ2VzKHtcbiAgICAgIHAycE1lc3NhZ2VzOiBkZXNlcmlhbGl6ZWRNZXNzYWdlcy5wMnBNZXNzYWdlcyxcbiAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzOiBbXSxcbiAgICB9KTtcbiAgICBjb25zdCBzaWduYXR1cmVTaGFyZVJvdW5kVHdvID0gYXdhaXQgZ2V0U2lnbmF0dXJlU2hhcmVSb3VuZFR3byhcbiAgICAgIHVzZXJUb0JpdEdvTWVzc2FnZXNSb3VuZDIsXG4gICAgICB1c2VyVG9CaXRHb01lc3NhZ2VzUm91bmQzLFxuICAgICAgdXNlckdwZ0tleSxcbiAgICAgIGJpdGdvR3BnUHViS2V5LFxuICAgICAgcGFyYW1zLm1wY3YyUGFydHlJZFxuICAgICk7XG4gICAgbGF0ZXN0VHhSZXF1ZXN0ID0gYXdhaXQgc2VuZFNpZ25hdHVyZVNoYXJlVjIoXG4gICAgICB0aGlzLmJpdGdvLFxuICAgICAgdHhSZXF1ZXN0LndhbGxldElkLFxuICAgICAgdHhSZXF1ZXN0LnR4UmVxdWVzdElkLFxuICAgICAgW3NpZ25hdHVyZVNoYXJlUm91bmRUd29dLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICB0aGlzLmJhc2VDb2luLmdldE1QQ0FsZ29yaXRobSgpLFxuICAgICAgdXNlckdwZ0tleS5wdWJsaWNLZXksXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLndhbGxldC5tdWx0aXNpZ1R5cGVWZXJzaW9uKCksXG4gICAgICBwYXJhbXMucmVxSWRcbiAgICApO1xuICAgIGFzc2VydChsYXRlc3RUeFJlcXVlc3QudHJhbnNhY3Rpb25zIHx8IGxhdGVzdFR4UmVxdWVzdC5tZXNzYWdlcywgJ0ludmFsaWQgdHhSZXF1ZXN0IE9iamVjdCcpO1xuXG4gICAgY29uc3QgdHhSZXF1ZXN0U2lnbmF0dXJlU2hhcmVzID1cbiAgICAgIHJlcXVlc3RUeXBlID09PSBSZXF1ZXN0VHlwZS50eFxuICAgICAgICA/IGxhdGVzdFR4UmVxdWVzdC50cmFuc2FjdGlvbnMhWzBdLnNpZ25hdHVyZVNoYXJlc1xuICAgICAgICA6IGxhdGVzdFR4UmVxdWVzdC5tZXNzYWdlcyFbMF0uc2lnbmF0dXJlU2hhcmVzO1xuICAgIC8vIFRPRE86IFVzZSBjb2RlYyBmb3IgcGFyc2luZ1xuICAgIGNvbnN0IHBhcnNlZEJpdEdvVG9Vc2VyU2lnU2hhcmVSb3VuZFR3byA9IEpTT04ucGFyc2UoXG4gICAgICB0eFJlcXVlc3RTaWduYXR1cmVTaGFyZXNbdHhSZXF1ZXN0U2lnbmF0dXJlU2hhcmVzLmxlbmd0aCAtIDFdLnNoYXJlXG4gICAgKSBhcyBNUEN2MlNpZ25hdHVyZVNoYXJlUm91bmQyT3V0cHV0O1xuICAgIGlmIChwYXJzZWRCaXRHb1RvVXNlclNpZ1NoYXJlUm91bmRUd28udHlwZSAhPT0gJ3JvdW5kMk91dHB1dCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzaWduYXR1cmUgc2hhcmUgcmVzcG9uc2UuIFVuYWJsZSB0byBwYXJzZSBkYXRhLicpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkQml0R29Ub1VzZXJNZXNzYWdlc1JvdW5kMyA9IGF3YWl0IHZlcmlmeUJpdEdvTWVzc2FnZXNBbmRTaWduYXR1cmVzUm91bmRUd28oXG4gICAgICBwYXJzZWRCaXRHb1RvVXNlclNpZ1NoYXJlUm91bmRUd28sXG4gICAgICB1c2VyR3BnS2V5LFxuICAgICAgYml0Z29HcGdQdWJLZXksXG4gICAgICBwYXJhbXMubXBjdjJQYXJ0eUlkXG4gICAgKTtcblxuICAgIC8qKiBSb3VuZCAzICoqL1xuICAgIGNvbnN0IGRlc2VyaWFsaXplZEJpdEdvVG9Vc2VyTWVzc2FnZXNSb3VuZDMgPSBEa2xzVHlwZXMuZGVzZXJpYWxpemVNZXNzYWdlcyh7XG4gICAgICBwMnBNZXNzYWdlczogc2VyaWFsaXplZEJpdEdvVG9Vc2VyTWVzc2FnZXNSb3VuZDMucDJwTWVzc2FnZXMsXG4gICAgICBicm9hZGNhc3RNZXNzYWdlczogW10sXG4gICAgfSk7XG4gICAgY29uc3QgdXNlclRvQml0R29NZXNzYWdlc1JvdW5kNCA9IG90aGVyU2lnbmVyLmhhbmRsZUluY29taW5nTWVzc2FnZXMoe1xuICAgICAgcDJwTWVzc2FnZXM6IGRlc2VyaWFsaXplZEJpdEdvVG9Vc2VyTWVzc2FnZXNSb3VuZDMucDJwTWVzc2FnZXMsXG4gICAgICBicm9hZGNhc3RNZXNzYWdlczogW10sXG4gICAgfSk7XG5cbiAgICBjb25zdCBzaWduYXR1cmVTaGFyZVJvdW5kVGhyZWUgPSBhd2FpdCBnZXRTaWduYXR1cmVTaGFyZVJvdW5kVGhyZWUoXG4gICAgICB1c2VyVG9CaXRHb01lc3NhZ2VzUm91bmQ0LFxuICAgICAgdXNlckdwZ0tleSxcbiAgICAgIGJpdGdvR3BnUHViS2V5LFxuICAgICAgcGFyYW1zLm1wY3YyUGFydHlJZFxuICAgICk7XG4gICAgLy8gU3VibWl0IGZvciBmaW5hbCBzaWduYXR1cmUgc2hhcmUgY29tYmluZVxuICAgIGF3YWl0IHNlbmRTaWduYXR1cmVTaGFyZVYyKFxuICAgICAgdGhpcy5iaXRnbyxcbiAgICAgIHR4UmVxdWVzdC53YWxsZXRJZCxcbiAgICAgIHR4UmVxdWVzdC50eFJlcXVlc3RJZCxcbiAgICAgIFtzaWduYXR1cmVTaGFyZVJvdW5kVGhyZWVdLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICB0aGlzLmJhc2VDb2luLmdldE1QQ0FsZ29yaXRobSgpLFxuICAgICAgdXNlckdwZ0tleS5wdWJsaWNLZXksXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLndhbGxldC5tdWx0aXNpZ1R5cGVWZXJzaW9uKCksXG4gICAgICBwYXJhbXMucmVxSWRcbiAgICApO1xuXG4gICAgcmV0dXJuIHNlbmRUeFJlcXVlc3QodGhpcy5iaXRnbywgdHhSZXF1ZXN0LndhbGxldElkLCB0eFJlcXVlc3QudHhSZXF1ZXN0SWQsIHJlcXVlc3RUeXBlLCBwYXJhbXMucmVxSWQpO1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gZm9ybWF0dGluZyB1dGlsc1xuICBmb3JtYXRCaXRnb0Jyb2FkY2FzdE1lc3NhZ2UoYnJvYWRjYXN0TWVzc2FnZTogTVBDdjJCcm9hZGNhc3RNZXNzYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IGJyb2FkY2FzdE1lc3NhZ2UuZnJvbSxcbiAgICAgIHBheWxvYWQ6IHsgbWVzc2FnZTogYnJvYWRjYXN0TWVzc2FnZS5tZXNzYWdlLCBzaWduYXR1cmU6IGJyb2FkY2FzdE1lc3NhZ2Uuc2lnbmF0dXJlIH0sXG4gICAgfTtcbiAgfVxuXG4gIGZvcm1hdFAyUE1lc3NhZ2UocDJwTWVzc2FnZTogTVBDdjJQMlBNZXNzYWdlLCBjb21taXRtZW50Pzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBheWxvYWQ6IHsgZW5jcnlwdGVkTWVzc2FnZTogcDJwTWVzc2FnZS5lbmNyeXB0ZWRNZXNzYWdlLCBzaWduYXR1cmU6IHAycE1lc3NhZ2Uuc2lnbmF0dXJlIH0sXG4gICAgICBmcm9tOiBwMnBNZXNzYWdlLmZyb20sXG4gICAgICB0bzogcDJwTWVzc2FnZS50byxcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgfTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwcml2YXRlIHV0aWxzXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhhc2ggc3RyaW5nIGFuZCBkZXJpdmF0aW9uIHBhdGggZnJvbSB0aGUgdHJhbnNhY3Rpb24gcmVxdWVzdC5cbiAgICogQHBhcmFtIHtUeFJlcXVlc3R9IHR4UmVxdWVzdCAtIHRoZSB0cmFuc2FjdGlvbiByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge1JlcXVlc3RUeXBlfSByZXF1ZXN0VHlwZSAtIHRoZSByZXF1ZXN0IHR5cGVcbiAgICogQHJldHVybnMge3sgaGFzaEJ1ZmZlcjogQnVmZmVyOyBkZXJpdmF0aW9uUGF0aDogc3RyaW5nIH19IC0gdGhlIGhhc2ggc3RyaW5nIGFuZCBkZXJpdmF0aW9uIHBhdGhcbiAgICovXG4gIHByaXZhdGUgZ2V0SGFzaFN0cmluZ0FuZERlcml2YXRpb25QYXRoKFxuICAgIHR4UmVxdWVzdDogVHhSZXF1ZXN0LFxuICAgIHJlcXVlc3RUeXBlOiBSZXF1ZXN0VHlwZSA9IFJlcXVlc3RUeXBlLnR4XG4gICk6IHsgaGFzaEJ1ZmZlcjogQnVmZmVyOyBkZXJpdmF0aW9uUGF0aDogc3RyaW5nIH0ge1xuICAgIGxldCB0eFRvU2lnbjogc3RyaW5nO1xuICAgIGxldCBkZXJpdmF0aW9uUGF0aDogc3RyaW5nO1xuICAgIGlmIChyZXF1ZXN0VHlwZSA9PT0gUmVxdWVzdFR5cGUudHgpIHtcbiAgICAgIGFzc2VydCh0eFJlcXVlc3QudHJhbnNhY3Rpb25zICYmIHR4UmVxdWVzdC50cmFuc2FjdGlvbnMubGVuZ3RoID09PSAxLCAnVW5hYmxlIHRvIGZpbmQgdHJhbnNhY3Rpb25zIGluIHR4UmVxdWVzdCcpO1xuICAgICAgdHhUb1NpZ24gPSB0eFJlcXVlc3QudHJhbnNhY3Rpb25zWzBdLnVuc2lnbmVkVHguc2lnbmFibGVIZXg7XG4gICAgICBkZXJpdmF0aW9uUGF0aCA9IHR4UmVxdWVzdC50cmFuc2FjdGlvbnNbMF0udW5zaWduZWRUeC5kZXJpdmF0aW9uUGF0aDtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3RUeXBlID09PSBSZXF1ZXN0VHlwZS5tZXNzYWdlKSB7XG4gICAgICAvLyBUT0RPKFdQLTIxNzYpOiBBZGQgc3VwcG9ydCBmb3IgbWVzc2FnZSBzaWduaW5nXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01QQ3YyIG1lc3NhZ2Ugc2lnbmluZyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlcXVlc3QgdHlwZSwgZ290OiAnICsgcmVxdWVzdFR5cGUpO1xuICAgIH1cblxuICAgIGxldCBoYXNoOiBIYXNoO1xuICAgIHRyeSB7XG4gICAgICBoYXNoID0gdGhpcy5iYXNlQ29pbi5nZXRIYXNoRnVuY3Rpb24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGhhc2ggPSBjcmVhdGVLZWNjYWtIYXNoKCdrZWNjYWsyNTYnKSBhcyBIYXNoO1xuICAgIH1cbiAgICBjb25zdCBoYXNoQnVmZmVyID0gaGFzaC51cGRhdGUoQnVmZmVyLmZyb20odHhUb1NpZ24sICdoZXgnKSkuZGlnZXN0KCk7XG5cbiAgICByZXR1cm4geyBoYXNoQnVmZmVyLCBkZXJpdmF0aW9uUGF0aCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIEJpdEdvIGFuZCB1c2VyIEdQRyBrZXlzIGZyb20gdGhlIEJpdEdvIHB1YmxpYyBHUEcga2V5IGFuZCB0aGUgZW5jcnlwdGVkIHVzZXIgR1BHIHByaXZhdGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYml0Z29QdWJsaWNHcGdLZXkgIC0gdGhlIEJpdEdvIHB1YmxpYyBHUEcga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNyeXB0ZWRVc2VyR3BnUHJ2S2V5ICAtIHRoZSBlbmNyeXB0ZWQgdXNlciBHUEcgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldFBhc3NwaHJhc2UgIC0gdGhlIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgYml0Z29HcGdLZXk6IHBncC5LZXk7IHVzZXJHcGdLZXk6IHBncC5TZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+IH0+fSAtIHRoZSBCaXRHbyBhbmQgdXNlciBHUEcga2V5c1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRCaXRnb0FuZFVzZXJHcGdLZXlzKFxuICAgIGJpdGdvUHVibGljR3BnS2V5OiBzdHJpbmcsXG4gICAgZW5jcnlwdGVkVXNlckdwZ1BydktleTogc3RyaW5nLFxuICAgIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZ1xuICApOiBQcm9taXNlPHtcbiAgICBiaXRnb0dwZ0tleTogcGdwLktleTtcbiAgICB1c2VyR3BnS2V5OiBwZ3AuU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPjtcbiAgfT4ge1xuICAgIGNvbnN0IGJpdGdvR3BnS2V5ID0gYXdhaXQgcGdwLnJlYWRLZXkoeyBhcm1vcmVkS2V5OiBiaXRnb1B1YmxpY0dwZ0tleSB9KTtcbiAgICBjb25zdCB1c2VyRGVjcnlwdGVkS2V5ID0gYXdhaXQgcGdwLnJlYWRLZXkoe1xuICAgICAgYXJtb3JlZEtleTogdGhpcy5iaXRnby5kZWNyeXB0KHsgaW5wdXQ6IGVuY3J5cHRlZFVzZXJHcGdQcnZLZXksIHBhc3N3b3JkOiB3YWxsZXRQYXNzcGhyYXNlIH0pLFxuICAgIH0pO1xuICAgIGNvbnN0IHVzZXJHcGdLZXk6IHBncC5TZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+ID0ge1xuICAgICAgcHJpdmF0ZUtleTogdXNlckRlY3J5cHRlZEtleS5hcm1vcigpLFxuICAgICAgcHVibGljS2V5OiB1c2VyRGVjcnlwdGVkS2V5LnRvUHVibGljKCkuYXJtb3IoKSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBiaXRnb0dwZ0tleSxcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGFkYXRhIGFuZCBjeXBoZXJ0ZXh0LlxuICAgKiBAcGFyYW0gYWRhdGEgc3RyaW5nXG4gICAqIEBwYXJhbSBjeXBoZXJ0ZXh0IHN0cmluZ1xuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgYWRhdGEgb3IgY3lwaGVydGV4dCBpcyBpbnZhbGlkXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlQWRhdGEoYWRhdGE6IHN0cmluZywgY3lwaGVydGV4dDogc3RyaW5nKTogdm9pZCB7XG4gICAgbGV0IGN5cGhlckpzb247XG4gICAgdHJ5IHtcbiAgICAgIGN5cGhlckpzb24gPSBKU09OLnBhcnNlKGN5cGhlcnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIGN5cGhlcnRleHQgdG8gSlNPTiwgZ290OiAnICsgY3lwaGVydGV4dCk7XG4gICAgfVxuICAgIC8vIHVzaW5nIGRlY29kZVVSSUNvbXBvbmVudCB0byBoYW5kbGUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGRlY29kZVVSSUNvbXBvbmVudChjeXBoZXJKc29uLmFkYXRhKSAhPT0gZGVjb2RlVVJJQ29tcG9uZW50KGFkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGF0YSBkb2VzIG5vdCBtYXRjaCBjeXBoZXJ0ZXh0IGFkYXRhJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gZXh0ZXJuYWwgc2lnbmVyXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBhc3luYyBzaWduRWNkc2FNUEN2MlRzc1VzaW5nRXh0ZXJuYWxTaWduZXIoXG4gICAgcGFyYW1zOiBUU1NQYXJhbXMgfCBUU1NQYXJhbXNGb3JNZXNzYWdlLFxuICAgIGV4dGVybmFsU2lnbmVyTVBDdjJTaWduaW5nUm91bmQxR2VuZXJhdG9yOiBDdXN0b21NUEN2MlNpZ25pbmdSb3VuZDFHZW5lcmF0aW5nRnVuY3Rpb24sXG4gICAgZXh0ZXJuYWxTaWduZXJNUEN2MlNpZ25pbmdSb3VuZDJHZW5lcmF0b3I6IEN1c3RvbU1QQ3YyU2lnbmluZ1JvdW5kMkdlbmVyYXRpbmdGdW5jdGlvbixcbiAgICBleHRlcm5hbFNpZ25lck1QQ3YyU2lnbmluZ1JvdW5kM0dlbmVyYXRvcjogQ3VzdG9tTVBDdjJTaWduaW5nUm91bmQzR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICAgIHJlcXVlc3RUeXBlOiBSZXF1ZXN0VHlwZSA9IFJlcXVlc3RUeXBlLnR4XG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgY29uc3QgeyB0eFJlcXVlc3QsIHJlcUlkIH0gPSBwYXJhbXM7XG4gICAgbGV0IHR4UmVxdWVzdFJlc29sdmVkOiBUeFJlcXVlc3Q7XG5cbiAgICAvLyBUT0RPKFdQLTIxNzYpOiBBZGQgc3VwcG9ydCBmb3IgbWVzc2FnZSBzaWduaW5nXG4gICAgYXNzZXJ0KFxuICAgICAgcmVxdWVzdFR5cGUgPT09IFJlcXVlc3RUeXBlLnR4LFxuICAgICAgJ09ubHkgdHJhbnNhY3Rpb24gc2lnbmluZyBpcyBzdXBwb3J0ZWQgZm9yIGV4dGVybmFsIHNpZ25lciwgZ290OiAnICsgcmVxdWVzdFR5cGVcbiAgICApO1xuXG4gICAgaWYgKHR5cGVvZiB0eFJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0eFJlcXVlc3RSZXNvbHZlZCA9IGF3YWl0IGdldFR4UmVxdWVzdCh0aGlzLmJpdGdvLCB0aGlzLndhbGxldC5pZCgpLCB0eFJlcXVlc3QsIHJlcUlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHhSZXF1ZXN0UmVzb2x2ZWQgPSB0eFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgY29uc3QgYml0Z29QdWJsaWNHcGdLZXkgPVxuICAgICAgKGF3YWl0IHRoaXMuZ2V0Qml0Z29HcGdQdWJrZXlCYXNlZE9uRmVhdHVyZUZsYWdzKHR4UmVxdWVzdFJlc29sdmVkLmVudGVycHJpc2VJZCwgdHJ1ZSwgcmVxSWQpKSA/P1xuICAgICAgdGhpcy5iaXRnb01QQ3YyUHVibGljR3BnS2V5O1xuICAgIGlmICghYml0Z29QdWJsaWNHcGdLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBCaXRHbyBHUEcga2V5IGZvciBNUEN2MicpO1xuICAgIH1cblxuICAgIC8vIHJvdW5kIDFcbiAgICBjb25zdCB7IHNpZ25hdHVyZVNoYXJlUm91bmQxLCB1c2VyR3BnUHViS2V5LCBlbmNyeXB0ZWRSb3VuZDFTZXNzaW9uLCBlbmNyeXB0ZWRVc2VyR3BnUHJ2S2V5IH0gPVxuICAgICAgYXdhaXQgZXh0ZXJuYWxTaWduZXJNUEN2MlNpZ25pbmdSb3VuZDFHZW5lcmF0b3IoeyB0eFJlcXVlc3Q6IHR4UmVxdWVzdFJlc29sdmVkIH0pO1xuICAgIGNvbnN0IHJvdW5kMVR4UmVxdWVzdCA9IGF3YWl0IHNlbmRTaWduYXR1cmVTaGFyZVYyKFxuICAgICAgdGhpcy5iaXRnbyxcbiAgICAgIHR4UmVxdWVzdFJlc29sdmVkLndhbGxldElkLFxuICAgICAgdHhSZXF1ZXN0UmVzb2x2ZWQudHhSZXF1ZXN0SWQsXG4gICAgICBbc2lnbmF0dXJlU2hhcmVSb3VuZDFdLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICB0aGlzLmJhc2VDb2luLmdldE1QQ0FsZ29yaXRobSgpLFxuICAgICAgdXNlckdwZ1B1YktleSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMud2FsbGV0Lm11bHRpc2lnVHlwZVZlcnNpb24oKSxcbiAgICAgIHJlcUlkXG4gICAgKTtcblxuICAgIC8vIHJvdW5kIDJcbiAgICBjb25zdCB7IHNpZ25hdHVyZVNoYXJlUm91bmQyLCBlbmNyeXB0ZWRSb3VuZDJTZXNzaW9uIH0gPSBhd2FpdCBleHRlcm5hbFNpZ25lck1QQ3YyU2lnbmluZ1JvdW5kMkdlbmVyYXRvcih7XG4gICAgICB0eFJlcXVlc3Q6IHJvdW5kMVR4UmVxdWVzdCxcbiAgICAgIGVuY3J5cHRlZFJvdW5kMVNlc3Npb24sXG4gICAgICBlbmNyeXB0ZWRVc2VyR3BnUHJ2S2V5LFxuICAgICAgYml0Z29QdWJsaWNHcGdLZXk6IGJpdGdvUHVibGljR3BnS2V5LmFybW9yKCksXG4gICAgfSk7XG4gICAgY29uc3Qgcm91bmQyVHhSZXF1ZXN0ID0gYXdhaXQgc2VuZFNpZ25hdHVyZVNoYXJlVjIoXG4gICAgICB0aGlzLmJpdGdvLFxuICAgICAgdHhSZXF1ZXN0UmVzb2x2ZWQud2FsbGV0SWQsXG4gICAgICB0eFJlcXVlc3RSZXNvbHZlZC50eFJlcXVlc3RJZCxcbiAgICAgIFtzaWduYXR1cmVTaGFyZVJvdW5kMl0sXG4gICAgICByZXF1ZXN0VHlwZSxcbiAgICAgIHRoaXMuYmFzZUNvaW4uZ2V0TVBDQWxnb3JpdGhtKCksXG4gICAgICB1c2VyR3BnUHViS2V5LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy53YWxsZXQubXVsdGlzaWdUeXBlVmVyc2lvbigpLFxuICAgICAgcmVxSWRcbiAgICApO1xuICAgIGFzc2VydChcbiAgICAgIHJvdW5kMlR4UmVxdWVzdC50cmFuc2FjdGlvbnMgJiYgcm91bmQyVHhSZXF1ZXN0LnRyYW5zYWN0aW9uc1swXS5zaWduYXR1cmVTaGFyZXMsXG4gICAgICAnTWlzc2luZyBzaWduYXR1cmUgc2hhcmVzIGluIHJvdW5kIDIgdHhSZXF1ZXN0J1xuICAgICk7XG5cbiAgICAvLyByb3VuZCAzXG4gICAgY29uc3QgeyBzaWduYXR1cmVTaGFyZVJvdW5kMyB9ID0gYXdhaXQgZXh0ZXJuYWxTaWduZXJNUEN2MlNpZ25pbmdSb3VuZDNHZW5lcmF0b3Ioe1xuICAgICAgdHhSZXF1ZXN0OiByb3VuZDJUeFJlcXVlc3QsXG4gICAgICBlbmNyeXB0ZWRSb3VuZDJTZXNzaW9uLFxuICAgICAgZW5jcnlwdGVkVXNlckdwZ1BydktleSxcbiAgICAgIGJpdGdvUHVibGljR3BnS2V5OiBiaXRnb1B1YmxpY0dwZ0tleS5hcm1vcigpLFxuICAgIH0pO1xuICAgIGF3YWl0IHNlbmRTaWduYXR1cmVTaGFyZVYyKFxuICAgICAgdGhpcy5iaXRnbyxcbiAgICAgIHR4UmVxdWVzdFJlc29sdmVkLndhbGxldElkLFxuICAgICAgdHhSZXF1ZXN0UmVzb2x2ZWQudHhSZXF1ZXN0SWQsXG4gICAgICBbc2lnbmF0dXJlU2hhcmVSb3VuZDNdLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICB0aGlzLmJhc2VDb2luLmdldE1QQ0FsZ29yaXRobSgpLFxuICAgICAgdXNlckdwZ1B1YktleSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMud2FsbGV0Lm11bHRpc2lnVHlwZVZlcnNpb24oKSxcbiAgICAgIHJlcUlkXG4gICAgKTtcblxuICAgIHJldHVybiBzZW5kVHhSZXF1ZXN0KHRoaXMuYml0Z28sIHR4UmVxdWVzdFJlc29sdmVkLndhbGxldElkLCB0eFJlcXVlc3RSZXNvbHZlZC50eFJlcXVlc3RJZCwgcmVxdWVzdFR5cGUsIHJlcUlkKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZU9mZmxpbmVSb3VuZDFTaGFyZShwYXJhbXM6IHsgdHhSZXF1ZXN0OiBUeFJlcXVlc3Q7IHBydjogc3RyaW5nOyB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmcgfSk6IFByb21pc2U8e1xuICAgIHNpZ25hdHVyZVNoYXJlUm91bmQxOiBTaWduYXR1cmVTaGFyZVJlY29yZDtcbiAgICB1c2VyR3BnUHViS2V5OiBzdHJpbmc7XG4gICAgZW5jcnlwdGVkUm91bmQxU2Vzc2lvbjogc3RyaW5nO1xuICAgIGVuY3J5cHRlZFVzZXJHcGdQcnZLZXk6IHN0cmluZztcbiAgfT4ge1xuICAgIGNvbnN0IHsgcHJ2LCB3YWxsZXRQYXNzcGhyYXNlLCB0eFJlcXVlc3QgfSA9IHBhcmFtcztcbiAgICBjb25zdCB7IGhhc2hCdWZmZXIsIGRlcml2YXRpb25QYXRoIH0gPSB0aGlzLmdldEhhc2hTdHJpbmdBbmREZXJpdmF0aW9uUGF0aCh0eFJlcXVlc3QpO1xuICAgIGNvbnN0IGFkYXRhID0gYCR7aGFzaEJ1ZmZlci50b1N0cmluZygnaGV4Jyl9OiR7ZGVyaXZhdGlvblBhdGh9YDtcblxuICAgIGNvbnN0IHVzZXJLZXlTaGFyZSA9IEJ1ZmZlci5mcm9tKHBydiwgJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IHVzZXJHcGdLZXkgPSBhd2FpdCBnZW5lcmF0ZUdQR0tleVBhaXIoJ3NlY3AyNTZrMScpO1xuXG4gICAgY29uc3QgdXNlclNpZ25lciA9IG5ldyBEa2xzRHNnLkRzZyh1c2VyS2V5U2hhcmUsIDAsIGRlcml2YXRpb25QYXRoLCBoYXNoQnVmZmVyKTtcbiAgICBjb25zdCB1c2VyU2lnbmVyQnJvYWRjYXN0TXNnMSA9IGF3YWl0IHVzZXJTaWduZXIuaW5pdCgpO1xuICAgIGNvbnN0IHNpZ25hdHVyZVNoYXJlUm91bmQxID0gYXdhaXQgZ2V0U2lnbmF0dXJlU2hhcmVSb3VuZE9uZSh1c2VyU2lnbmVyQnJvYWRjYXN0TXNnMSwgdXNlckdwZ0tleSk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHVzZXJTaWduZXIuZ2V0U2Vzc2lvbigpO1xuICAgIGNvbnN0IGVuY3J5cHRlZFJvdW5kMVNlc3Npb24gPSB0aGlzLmJpdGdvLmVuY3J5cHQoeyBpbnB1dDogc2Vzc2lvbiwgcGFzc3dvcmQ6IHdhbGxldFBhc3NwaHJhc2UsIGFkYXRhIH0pO1xuXG4gICAgY29uc3QgdXNlckdwZ1B1YktleSA9IHVzZXJHcGdLZXkucHVibGljS2V5O1xuICAgIGNvbnN0IGVuY3J5cHRlZFVzZXJHcGdQcnZLZXkgPSB0aGlzLmJpdGdvLmVuY3J5cHQoe1xuICAgICAgaW5wdXQ6IHVzZXJHcGdLZXkucHJpdmF0ZUtleSxcbiAgICAgIHBhc3N3b3JkOiB3YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgYWRhdGEsXG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBzaWduYXR1cmVTaGFyZVJvdW5kMSwgdXNlckdwZ1B1YktleSwgZW5jcnlwdGVkUm91bmQxU2Vzc2lvbiwgZW5jcnlwdGVkVXNlckdwZ1BydktleSB9O1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlT2ZmbGluZVJvdW5kMlNoYXJlKHBhcmFtczoge1xuICAgIHR4UmVxdWVzdDogVHhSZXF1ZXN0O1xuICAgIHBydjogc3RyaW5nO1xuICAgIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZztcbiAgICBiaXRnb1B1YmxpY0dwZ0tleTogc3RyaW5nO1xuICAgIGVuY3J5cHRlZFVzZXJHcGdQcnZLZXk6IHN0cmluZztcbiAgICBlbmNyeXB0ZWRSb3VuZDFTZXNzaW9uOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPHtcbiAgICBzaWduYXR1cmVTaGFyZVJvdW5kMjogU2lnbmF0dXJlU2hhcmVSZWNvcmQ7XG4gICAgZW5jcnlwdGVkUm91bmQyU2Vzc2lvbjogc3RyaW5nO1xuICB9PiB7XG4gICAgY29uc3QgeyBwcnYsIHdhbGxldFBhc3NwaHJhc2UsIGVuY3J5cHRlZFVzZXJHcGdQcnZLZXksIGVuY3J5cHRlZFJvdW5kMVNlc3Npb24sIGJpdGdvUHVibGljR3BnS2V5LCB0eFJlcXVlc3QgfSA9XG4gICAgICBwYXJhbXM7XG5cbiAgICBjb25zdCB7IGhhc2hCdWZmZXIsIGRlcml2YXRpb25QYXRoIH0gPSB0aGlzLmdldEhhc2hTdHJpbmdBbmREZXJpdmF0aW9uUGF0aCh0eFJlcXVlc3QpO1xuICAgIGNvbnN0IGFkYXRhID0gYCR7aGFzaEJ1ZmZlci50b1N0cmluZygnaGV4Jyl9OiR7ZGVyaXZhdGlvblBhdGh9YDtcbiAgICBjb25zdCB7IGJpdGdvR3BnS2V5LCB1c2VyR3BnS2V5IH0gPSBhd2FpdCB0aGlzLmdldEJpdGdvQW5kVXNlckdwZ0tleXMoXG4gICAgICBiaXRnb1B1YmxpY0dwZ0tleSxcbiAgICAgIGVuY3J5cHRlZFVzZXJHcGdQcnZLZXksXG4gICAgICB3YWxsZXRQYXNzcGhyYXNlXG4gICAgKTtcblxuICAgIGNvbnN0IHNpZ25hdHVyZVNoYXJlcyA9IHR4UmVxdWVzdC50cmFuc2FjdGlvbnM/LlswXS5zaWduYXR1cmVTaGFyZXM7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZVNoYXJlcywgJ01pc3Npbmcgc2lnbmF0dXJlIHNoYXJlcyBpbiByb3VuZCAxIHR4UmVxdWVzdCcpO1xuICAgIGNvbnN0IHBhcnNlZEJpdEdvVG9Vc2VyU2lnU2hhcmVSb3VuZE9uZSA9IEpTT04ucGFyc2UoXG4gICAgICBzaWduYXR1cmVTaGFyZXNbc2lnbmF0dXJlU2hhcmVzLmxlbmd0aCAtIDFdLnNoYXJlXG4gICAgKSBhcyBNUEN2MlNpZ25hdHVyZVNoYXJlUm91bmQxT3V0cHV0O1xuICAgIGlmIChwYXJzZWRCaXRHb1RvVXNlclNpZ1NoYXJlUm91bmRPbmUudHlwZSAhPT0gJ3JvdW5kMU91dHB1dCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzaWduYXR1cmUgc2hhcmUgcmVzcG9uc2UuIFVuYWJsZSB0byBwYXJzZSBkYXRhLicpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkQml0R29Ub1VzZXJNZXNzYWdlc1JvdW5kMSA9IGF3YWl0IHZlcmlmeUJpdEdvTWVzc2FnZXNBbmRTaWduYXR1cmVzUm91bmRPbmUoXG4gICAgICBwYXJzZWRCaXRHb1RvVXNlclNpZ1NoYXJlUm91bmRPbmUsXG4gICAgICB1c2VyR3BnS2V5LFxuICAgICAgYml0Z29HcGdLZXlcbiAgICApO1xuXG4gICAgY29uc3Qgcm91bmQxU2Vzc2lvbiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7IGlucHV0OiBlbmNyeXB0ZWRSb3VuZDFTZXNzaW9uLCBwYXNzd29yZDogd2FsbGV0UGFzc3BocmFzZSB9KTtcblxuICAgIHRoaXMudmFsaWRhdGVBZGF0YShhZGF0YSwgZW5jcnlwdGVkUm91bmQxU2Vzc2lvbik7XG4gICAgY29uc3QgdXNlcktleVNoYXJlID0gQnVmZmVyLmZyb20ocHJ2LCAnYmFzZTY0Jyk7XG4gICAgY29uc3QgdXNlclNpZ25lciA9IG5ldyBEa2xzRHNnLkRzZyh1c2VyS2V5U2hhcmUsIDAsIGRlcml2YXRpb25QYXRoLCBoYXNoQnVmZmVyKTtcbiAgICBhd2FpdCB1c2VyU2lnbmVyLnNldFNlc3Npb24ocm91bmQxU2Vzc2lvbik7XG5cbiAgICBjb25zdCBkZXNlcmlhbGl6ZWRNZXNzYWdlcyA9IERrbHNUeXBlcy5kZXNlcmlhbGl6ZU1lc3NhZ2VzKHNlcmlhbGl6ZWRCaXRHb1RvVXNlck1lc3NhZ2VzUm91bmQxKTtcbiAgICBjb25zdCB1c2VyVG9CaXRHb01lc3NhZ2VzUm91bmQyID0gdXNlclNpZ25lci5oYW5kbGVJbmNvbWluZ01lc3NhZ2VzKHtcbiAgICAgIHAycE1lc3NhZ2VzOiBbXSxcbiAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzOiBkZXNlcmlhbGl6ZWRNZXNzYWdlcy5icm9hZGNhc3RNZXNzYWdlcyxcbiAgICB9KTtcbiAgICBjb25zdCB1c2VyVG9CaXRHb01lc3NhZ2VzUm91bmQzID0gdXNlclNpZ25lci5oYW5kbGVJbmNvbWluZ01lc3NhZ2VzKHtcbiAgICAgIHAycE1lc3NhZ2VzOiBkZXNlcmlhbGl6ZWRNZXNzYWdlcy5wMnBNZXNzYWdlcyxcbiAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzOiBbXSxcbiAgICB9KTtcbiAgICBjb25zdCBzaWduYXR1cmVTaGFyZVJvdW5kMiA9IGF3YWl0IGdldFNpZ25hdHVyZVNoYXJlUm91bmRUd28oXG4gICAgICB1c2VyVG9CaXRHb01lc3NhZ2VzUm91bmQyLFxuICAgICAgdXNlclRvQml0R29NZXNzYWdlc1JvdW5kMyxcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgICBiaXRnb0dwZ0tleVxuICAgICk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHVzZXJTaWduZXIuZ2V0U2Vzc2lvbigpO1xuICAgIGNvbnN0IGVuY3J5cHRlZFJvdW5kMlNlc3Npb24gPSB0aGlzLmJpdGdvLmVuY3J5cHQoeyBpbnB1dDogc2Vzc2lvbiwgcGFzc3dvcmQ6IHdhbGxldFBhc3NwaHJhc2UsIGFkYXRhIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ25hdHVyZVNoYXJlUm91bmQyLFxuICAgICAgZW5jcnlwdGVkUm91bmQyU2Vzc2lvbixcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlT2ZmbGluZVJvdW5kM1NoYXJlKHBhcmFtczoge1xuICAgIHR4UmVxdWVzdDogVHhSZXF1ZXN0O1xuICAgIHBydjogc3RyaW5nO1xuICAgIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZztcbiAgICBiaXRnb1B1YmxpY0dwZ0tleTogc3RyaW5nO1xuICAgIGVuY3J5cHRlZFVzZXJHcGdQcnZLZXk6IHN0cmluZztcbiAgICBlbmNyeXB0ZWRSb3VuZDJTZXNzaW9uOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPHtcbiAgICBzaWduYXR1cmVTaGFyZVJvdW5kMzogU2lnbmF0dXJlU2hhcmVSZWNvcmQ7XG4gIH0+IHtcbiAgICBjb25zdCB7IHBydiwgd2FsbGV0UGFzc3BocmFzZSwgZW5jcnlwdGVkVXNlckdwZ1BydktleSwgZW5jcnlwdGVkUm91bmQyU2Vzc2lvbiwgYml0Z29QdWJsaWNHcGdLZXksIHR4UmVxdWVzdCB9ID1cbiAgICAgIHBhcmFtcztcblxuICAgIGFzc2VydCh0eFJlcXVlc3QudHJhbnNhY3Rpb25zICYmIHR4UmVxdWVzdC50cmFuc2FjdGlvbnMubGVuZ3RoID09PSAxLCAnVW5hYmxlIHRvIGZpbmQgdHJhbnNhY3Rpb25zIGluIHR4UmVxdWVzdCcpO1xuICAgIGNvbnN0IHsgaGFzaEJ1ZmZlciwgZGVyaXZhdGlvblBhdGggfSA9IHRoaXMuZ2V0SGFzaFN0cmluZ0FuZERlcml2YXRpb25QYXRoKHR4UmVxdWVzdCk7XG4gICAgY29uc3QgYWRhdGEgPSBgJHtoYXNoQnVmZmVyLnRvU3RyaW5nKCdoZXgnKX06JHtkZXJpdmF0aW9uUGF0aH1gO1xuXG4gICAgY29uc3QgeyBiaXRnb0dwZ0tleSwgdXNlckdwZ0tleSB9ID0gYXdhaXQgdGhpcy5nZXRCaXRnb0FuZFVzZXJHcGdLZXlzKFxuICAgICAgYml0Z29QdWJsaWNHcGdLZXksXG4gICAgICBlbmNyeXB0ZWRVc2VyR3BnUHJ2S2V5LFxuICAgICAgd2FsbGV0UGFzc3BocmFzZVxuICAgICk7XG5cbiAgICBjb25zdCBzaWduYXR1cmVTaGFyZXMgPSB0eFJlcXVlc3QudHJhbnNhY3Rpb25zPy5bMF0uc2lnbmF0dXJlU2hhcmVzO1xuICAgIGFzc2VydChzaWduYXR1cmVTaGFyZXMsICdNaXNzaW5nIHNpZ25hdHVyZSBzaGFyZXMgaW4gcm91bmQgMiB0eFJlcXVlc3QnKTtcbiAgICBjb25zdCBwYXJzZWRCaXRHb1RvVXNlclNpZ1NoYXJlUm91bmRUd28gPSBKU09OLnBhcnNlKFxuICAgICAgc2lnbmF0dXJlU2hhcmVzW3NpZ25hdHVyZVNoYXJlcy5sZW5ndGggLSAxXS5zaGFyZVxuICAgICkgYXMgTVBDdjJTaWduYXR1cmVTaGFyZVJvdW5kMk91dHB1dDtcbiAgICBpZiAocGFyc2VkQml0R29Ub1VzZXJTaWdTaGFyZVJvdW5kVHdvLnR5cGUgIT09ICdyb3VuZDJPdXRwdXQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2lnbmF0dXJlIHNoYXJlIHJlc3BvbnNlLiBVbmFibGUgdG8gcGFyc2UgZGF0YS4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZEJpdEdvVG9Vc2VyTWVzc2FnZXNSb3VuZDMgPSBhd2FpdCB2ZXJpZnlCaXRHb01lc3NhZ2VzQW5kU2lnbmF0dXJlc1JvdW5kVHdvKFxuICAgICAgcGFyc2VkQml0R29Ub1VzZXJTaWdTaGFyZVJvdW5kVHdvLFxuICAgICAgdXNlckdwZ0tleSxcbiAgICAgIGJpdGdvR3BnS2V5XG4gICAgKTtcblxuICAgIGNvbnN0IGRlc2VyaWFsaXplZEJpdEdvVG9Vc2VyTWVzc2FnZXNSb3VuZDMgPSBEa2xzVHlwZXMuZGVzZXJpYWxpemVNZXNzYWdlcyh7XG4gICAgICBwMnBNZXNzYWdlczogc2VyaWFsaXplZEJpdEdvVG9Vc2VyTWVzc2FnZXNSb3VuZDMucDJwTWVzc2FnZXMsXG4gICAgICBicm9hZGNhc3RNZXNzYWdlczogW10sXG4gICAgfSk7XG5cbiAgICBjb25zdCByb3VuZDJTZXNzaW9uID0gdGhpcy5iaXRnby5kZWNyeXB0KHsgaW5wdXQ6IGVuY3J5cHRlZFJvdW5kMlNlc3Npb24sIHBhc3N3b3JkOiB3YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgIHRoaXMudmFsaWRhdGVBZGF0YShhZGF0YSwgZW5jcnlwdGVkUm91bmQyU2Vzc2lvbik7XG4gICAgY29uc3QgdXNlcktleVNoYXJlID0gQnVmZmVyLmZyb20ocHJ2LCAnYmFzZTY0Jyk7XG4gICAgY29uc3QgdXNlclNpZ25lciA9IG5ldyBEa2xzRHNnLkRzZyh1c2VyS2V5U2hhcmUsIDAsIGRlcml2YXRpb25QYXRoLCBoYXNoQnVmZmVyKTtcbiAgICBhd2FpdCB1c2VyU2lnbmVyLnNldFNlc3Npb24ocm91bmQyU2Vzc2lvbik7XG5cbiAgICBjb25zdCB1c2VyVG9CaXRHb01lc3NhZ2VzUm91bmQ0ID0gdXNlclNpZ25lci5oYW5kbGVJbmNvbWluZ01lc3NhZ2VzKHtcbiAgICAgIHAycE1lc3NhZ2VzOiBkZXNlcmlhbGl6ZWRCaXRHb1RvVXNlck1lc3NhZ2VzUm91bmQzLnAycE1lc3NhZ2VzLFxuICAgICAgYnJvYWRjYXN0TWVzc2FnZXM6IFtdLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2lnbmF0dXJlU2hhcmVSb3VuZDMgPSBhd2FpdCBnZXRTaWduYXR1cmVTaGFyZVJvdW5kVGhyZWUodXNlclRvQml0R29NZXNzYWdlc1JvdW5kNCwgdXNlckdwZ0tleSwgYml0Z29HcGdLZXkpO1xuXG4gICAgcmV0dXJuIHsgc2lnbmF0dXJlU2hhcmVSb3VuZDMgfTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBrZXkgc2hhcmUsIHdoZW4gZGVjcnlwdGVkLCBjb250YWlucyB2YWxpZCBHRzE4IHNpZ25pbmcgbWF0ZXJpYWwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVNoYXJlIC0gVGhlIGVuY3J5cHRlZCBrZXkgc2hhcmUgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB3YWxsZXRQYXNzcGhyYXNlIC0gVGhlIHBhc3NwaHJhc2UgdXNlZCB0byBkZWNyeXB0IHRoZSBrZXkgc2hhcmVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgYHRydWVgIGlmIHRoZSBkZWNyeXB0ZWQgZGF0YSBjb250YWlucyB2YWxpZCBzaWduaW5nIG1hdGVyaWFsLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzR0cxOFNpZ25pbmdNYXRlcmlhbChrZXlTaGFyZTogc3RyaW5nLCB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgY29uc3QgcHJ2ID0gc2pjbC5kZWNyeXB0KHdhbGxldFBhc3NwaHJhc2UsIGtleVNoYXJlKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKHBydik7XG4gICAgcmV0dXJuIChcbiAgICAgIHNpZ25pbmdNYXRlcmlhbC5wU2hhcmUgJiZcbiAgICAgIHNpZ25pbmdNYXRlcmlhbC5iaXRnb05TaGFyZSAmJlxuICAgICAgKHNpZ25pbmdNYXRlcmlhbC51c2VyTlNoYXJlIHx8IHNpZ25pbmdNYXRlcmlhbC5iYWNrdXBOU2hhcmUpXG4gICAgKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIE1QQyB2MiByZWNvdmVyeSBrZXkgc2hhcmVzIGZyb20gdGhlIHByb3ZpZGVkIHVzZXIgYW5kIGJhY2t1cCBrZXkgc2hhcmVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyUHVibGljT3JQcml2YXRlS2V5U2hhcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYWNrdXBQcml2YXRlT3JQdWJsaWNLZXlTaGFyZVxuICogQHBhcmFtIHtzdHJpbmd9IFt3YWxsZXRQYXNzcGhyYXNlXSAtIFRoZSBwYXNzcGhyYXNlIHVzZWQgdG8gZGVjcnlwdCB0aGUga2V5IHNoYXJlc1xuICogQHJldHVybnMge1Byb21pc2U8eyB1c2VyS2V5U2hhcmU6IEtleVNoYXJlLCBiYWNrdXBLZXlTaGFyZTogS2V5U2hhcmUsIGNvbW1vbktleUNoYWluOiBzdHJpbmcgfT59XG4gKlxuICogQGFzeW5jXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNcGNWMlJlY292ZXJ5S2V5U2hhcmVzKFxuICB1c2VyUHVibGljT3JQcml2YXRlS2V5U2hhcmU6IHN0cmluZyxcbiAgYmFja3VwUHJpdmF0ZU9yUHVibGljS2V5U2hhcmU6IHN0cmluZyxcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZ1xuKSB7XG4gIGNvbnN0IHVzZXJDb21wcmVzc2VkUHJ2ID0gQnVmZmVyLmZyb20oc2pjbC5kZWNyeXB0KHdhbGxldFBhc3NwaHJhc2UsIHVzZXJQdWJsaWNPclByaXZhdGVLZXlTaGFyZSksICdiYXNlNjQnKTtcbiAgY29uc3QgYmFrY3VwQ29tcHJlc3NlZFBydiA9IEJ1ZmZlci5mcm9tKHNqY2wuZGVjcnlwdCh3YWxsZXRQYXNzcGhyYXNlLCBiYWNrdXBQcml2YXRlT3JQdWJsaWNLZXlTaGFyZSksICdiYXNlNjQnKTtcblxuICBjb25zdCB1c2VyUHJ2SlNPTjogRGtsc1R5cGVzLlJlZHVjZWRLZXlTaGFyZSA9IERrbHNUeXBlcy5nZXREZWNvZGVkUmVkdWNlZEtleVNoYXJlKHVzZXJDb21wcmVzc2VkUHJ2KTtcbiAgY29uc3QgYmFja3VwUHJ2SlNPTjogRGtsc1R5cGVzLlJlZHVjZWRLZXlTaGFyZSA9IERrbHNUeXBlcy5nZXREZWNvZGVkUmVkdWNlZEtleVNoYXJlKGJha2N1cENvbXByZXNzZWRQcnYpO1xuICBjb25zdCB1c2VyS2V5UmV0cm9maXQ6IERrbHNUeXBlcy5SZXRyb2ZpdERhdGEgPSB7XG4gICAgeFNoYXJlOiB7XG4gICAgICB4OiBCdWZmZXIuZnJvbSh1c2VyUHJ2SlNPTi5wcnYpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHk6IEJ1ZmZlci5mcm9tKHVzZXJQcnZKU09OLnB1YikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgY2hhaW5jb2RlOiBCdWZmZXIuZnJvbSh1c2VyUHJ2SlNPTi5yb290Q2hhaW5Db2RlKS50b1N0cmluZygnaGV4JyksXG4gICAgfSxcbiAgICB4aUxpc3Q6IHVzZXJQcnZKU09OLnhMaXN0LnNsaWNlKDAsIDIpLFxuICB9O1xuICBjb25zdCBiYWNrdXBLZXlSZXRyb2ZpdDogRGtsc1R5cGVzLlJldHJvZml0RGF0YSA9IHtcbiAgICB4U2hhcmU6IHtcbiAgICAgIHg6IEJ1ZmZlci5mcm9tKGJhY2t1cFBydkpTT04ucHJ2KS50b1N0cmluZygnaGV4JyksXG4gICAgICB5OiBCdWZmZXIuZnJvbShiYWNrdXBQcnZKU09OLnB1YikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgY2hhaW5jb2RlOiBCdWZmZXIuZnJvbShiYWNrdXBQcnZKU09OLnJvb3RDaGFpbkNvZGUpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICB9LFxuICAgIHhpTGlzdDogYmFja3VwUHJ2SlNPTi54TGlzdC5zbGljZSgwLCAyKSxcbiAgfTtcbiAgY29uc3QgW3VzZXIsIGJhY2t1cF0gPSBhd2FpdCBEa2xzVXRpbHMuZ2VuZXJhdGUyb2YyS2V5U2hhcmVzKHVzZXJLZXlSZXRyb2ZpdCwgYmFja3VwS2V5UmV0cm9maXQpO1xuICBjb25zdCB1c2VyS2V5U2hhcmUgPSB1c2VyLmdldEtleVNoYXJlKCk7XG4gIGNvbnN0IGJhY2t1cEtleVNoYXJlID0gYmFja3VwLmdldEtleVNoYXJlKCk7XG4gIGNvbnN0IGNvbW1vbktleUNoYWluID0gRGtsc1R5cGVzLmdldENvbW1vbktleWNoYWluKHVzZXJLZXlTaGFyZSk7XG4gIHJldHVybiB7IHVzZXJLZXlTaGFyZSwgYmFja3VwS2V5U2hhcmUsIGNvbW1vbktleUNoYWluIH07XG59XG5cbi8qKlxuICogU2lnbnMgYSBtZXNzYWdlIGhhc2ggdXNpbmcgTVBDIHYyIHJlY292ZXJ5IGtleSBzaGFyZXMuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VIYXNoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdXNlcktleVNoYXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYmFja3VwS2V5U2hhcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21tb25LZXlDaGFpblxuICogQHJldHVybnMge1Byb21pc2U8eyByZWNpZDogbnVtYmVyLCByOiBzdHJpbmcsIHM6IHN0cmluZywgeTogc3RyaW5nIH0+fVxuICpcbiAqIEBhc3luY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnblJlY292ZXJ5TXBjVjIoXG4gIG1lc3NhZ2VIYXNoOiBCdWZmZXIsXG4gIHVzZXJLZXlTaGFyZTogQnVmZmVyLFxuICBiYWNrdXBLZXlTaGFyZTogQnVmZmVyLFxuICBjb21tb25LZXlDaGFpbjogc3RyaW5nXG4pIHtcbiAgY29uc3QgdXNlckRzZyA9IG5ldyBEa2xzRHNnLkRzZyh1c2VyS2V5U2hhcmUsIDAsICdtLzAnLCBtZXNzYWdlSGFzaCk7XG4gIGNvbnN0IGJhY2t1cERzZyA9IG5ldyBEa2xzRHNnLkRzZyhiYWNrdXBLZXlTaGFyZSwgMSwgJ20vMCcsIG1lc3NhZ2VIYXNoKTtcblxuICBjb25zdCBzaWduYXR1cmVTdHJpbmcgPSBEa2xzVXRpbHMudmVyaWZ5QW5kQ29udmVydERrbHNTaWduYXR1cmUoXG4gICAgbWVzc2FnZUhhc2gsXG4gICAgKGF3YWl0IERrbHNVdGlscy5leGVjdXRlVGlsbFJvdW5kKDUsIHVzZXJEc2csIGJhY2t1cERzZykpIGFzIERrbHNUeXBlcy5EZXNlcmlhbGl6ZWREa2xzU2lnbmF0dXJlLFxuICAgIGNvbW1vbktleUNoYWluLFxuICAgICdtLzAnLFxuICAgIHVuZGVmaW5lZCxcbiAgICBmYWxzZVxuICApO1xuICBjb25zdCBzaWdQYXJ0cyA9IHNpZ25hdHVyZVN0cmluZy5zcGxpdCgnOicpO1xuXG4gIHJldHVybiB7XG4gICAgcmVjaWQ6IHBhcnNlSW50KHNpZ1BhcnRzWzBdLCAxMCksXG4gICAgcjogc2lnUGFydHNbMV0sXG4gICAgczogc2lnUGFydHNbMl0sXG4gICAgeTogc2lnUGFydHNbM10sXG4gIH07XG59XG4iXX0=