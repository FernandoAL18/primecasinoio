"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ada = exports.DEFAULT_SCAN_FACTOR = void 0;
const assert_1 = __importDefault(require("assert"));
const sdk_core_1 = require("@bitgo/sdk-core");
const lib_1 = require("./lib");
const statics_1 = require("@bitgo/statics");
const utils_1 = __importDefault(require("./lib/utils"));
const request = __importStar(require("superagent"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
exports.DEFAULT_SCAN_FACTOR = 20; // default number of receive addresses to scan for funds
class Ada extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Ada(bitgo, staticsCoin);
    }
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    getBaseFactor() {
        return 1e6;
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseChain() {
        return this.getChain();
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     *  A prebuild transaction has to be parsed correctly and intended recipients has to be
     *  in the transaction output
     *
     * @param params.txPrebuild prebuild transaction
     * @param params.txParams transaction parameters
     * @return true if verification success
     *
     */
    async verifyTransaction(params) {
        try {
            const coinConfig = statics_1.coins.get(this.getChain());
            const { txPrebuild: txPrebuild, txParams: txParams } = params;
            const transaction = new lib_1.Transaction(coinConfig);
            (0, assert_1.default)(txPrebuild.txHex, new Error('missing required tx prebuild property txHex'));
            const rawTx = txPrebuild.txHex;
            transaction.fromRawTransaction(rawTx);
            const explainedTx = transaction.explainTransaction();
            if (txParams.recipients !== undefined) {
                for (const recipient of txParams.recipients) {
                    let find = false;
                    for (const output of explainedTx.outputs) {
                        if (recipient.address === output.address && recipient.amount === output.amount) {
                            find = true;
                        }
                    }
                    if (!find) {
                        throw new Error('cannot find recipient in expected output');
                    }
                }
            }
        }
        catch (e) {
            if (e instanceof sdk_core_1.NodeEnvironmentError) {
                return true;
            }
            else {
                throw e;
            }
        }
        return true;
    }
    async isWalletAddress(params) {
        const { address } = params;
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`Invalid Cardano Address: ${address}`);
        }
        return true;
    }
    /** @inheritDoc */
    async signMessage(key, message) {
        const adaKeypair = new lib_1.KeyPair({ prv: key.prv });
        const messageHex = message instanceof Buffer ? message.toString('hex') : message;
        return Buffer.from(adaKeypair.signMessage(messageHex));
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params) {
        const factory = this.getBuilder();
        let rebuiltTransaction;
        const txRaw = params.txPrebuild.txHex;
        try {
            const transactionBuilder = factory.from(txRaw);
            rebuiltTransaction = await transactionBuilder.build();
        }
        catch {
            throw new Error('Invalid transaction');
        }
        return rebuiltTransaction.explainTransaction();
    }
    async parseTransaction(params) {
        const transactionExplanation = await this.explainTransaction({
            txPrebuild: params.txPrebuild,
        });
        if (!transactionExplanation) {
            throw new Error('Invalid transaction');
        }
        return transactionExplanation;
    }
    generateKeyPair(seed) {
        const keyPair = seed ? new lib_1.KeyPair({ seed }) : new lib_1.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return {
            pub: keys.pub,
            prv: keys.prv,
        };
    }
    isValidPub(pub) {
        return utils_1.default.isValidPublicKey(pub);
    }
    isValidPrv(prv) {
        return utils_1.default.isValidPrivateKey(prv);
    }
    isValidAddress(address) {
        return utils_1.default.isValidAddress(address);
    }
    async signTransaction(params) {
        const factory = this.getBuilder();
        const txBuilder = factory.from(params.txPrebuild.txHex);
        txBuilder.sign({ key: params.prv });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid transaction');
        }
        const serializedTx = transaction.toBroadcastFormat();
        return {
            txHex: serializedTx,
        };
    }
    getPublicNodeUrl() {
        return sdk_core_1.Environments[this.bitgo.getEnv()].adaNodeUrl;
    }
    async getDataFromNode(endpoint, requestBody) {
        const restEndpoint = this.getPublicNodeUrl() + '/' + endpoint;
        try {
            const res = await request.post(restEndpoint).send(requestBody);
            return res;
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint ${restEndpoint}`);
    }
    async getAddressInfo(walletAddr) {
        const requestBody = { _addresses: [walletAddr] };
        const res = await this.getDataFromNode('address_info', requestBody);
        if (res.status != 200) {
            throw new Error(`Failed to retrieve address info for address ${walletAddr}`);
        }
        const body = res.body[0];
        if (body === undefined) {
            return { balance: 0, utxoSet: [] };
        }
        return { balance: body.balance, utxoSet: body.utxo_set };
    }
    async getChainTipInfo() {
        const res = await this.getDataFromNode('tip');
        if (res.status != 200) {
            throw new Error('Failed to retrieve chain tip info');
        }
        const body = res.body[0];
        return body;
    }
    /** inherited doc */
    async createBroadcastableSweepTransaction(params) {
        var _a;
        const req = params.signatureShares;
        const broadcastableTransactions = [];
        let lastScanIndex = 0;
        for (let i = 0; i < req.length; i++) {
            const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
            const transaction = req[i].txRequest.transactions[0].unsignedTx;
            if (!req[i].ovc || !req[i].ovc[0].eddsaSignature) {
                throw new Error('Missing signature(s)');
            }
            const signature = req[i].ovc[0].eddsaSignature;
            if (!transaction.signableHex) {
                throw new Error('Missing signable hex');
            }
            const messageBuffer = Buffer.from(transaction.signableHex, 'hex');
            const result = MPC.verify(messageBuffer, signature);
            if (!result) {
                throw new Error('Invalid signature');
            }
            const signatureHex = Buffer.concat([Buffer.from(signature.R, 'hex'), Buffer.from(signature.sigma, 'hex')]);
            const txBuilder = this.getBuilder().from(transaction.serializedTx);
            if (!((_a = transaction.coinSpecific) === null || _a === void 0 ? void 0 : _a.commonKeychain)) {
                throw new Error('Missing common keychain');
            }
            const commonKeychain = transaction.coinSpecific.commonKeychain;
            if (!transaction.derivationPath) {
                throw new Error('Missing derivation path');
            }
            const derivationPath = transaction.derivationPath;
            const accountId = MPC.deriveUnhardened(commonKeychain, derivationPath).slice(0, 64);
            const adaKeyPair = new lib_1.KeyPair({ pub: accountId });
            // add combined signature from ovc
            txBuilder.addSignature({ pub: adaKeyPair.getKeys().pub }, signatureHex);
            const signedTransaction = await txBuilder.build();
            const serializedTx = signedTransaction.toBroadcastFormat();
            broadcastableTransactions.push({
                serializedTx: serializedTx,
                scanIndex: transaction.scanIndex,
            });
            if (i === req.length - 1 && transaction.coinSpecific.lastScanIndex) {
                lastScanIndex = transaction.coinSpecific.lastScanIndex;
            }
        }
        return { transactions: broadcastableTransactions, lastScanIndex };
    }
    /**
     * Builds funds recovery transaction(s) without BitGo
     *
     * @param {MPCRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {MPCTx | MPCSweepTxs} array of the serialized transaction hex strings and indices
     * of the addresses being swept
     */
    async recover(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        const index = params.index || 0;
        const currPath = params.seed ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${index}` : `m/${index}`;
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const addressParams = {
            bitgoKey: params.bitgoKey,
            index: index,
            seed: params.seed,
        };
        const { address: senderAddr, accountId } = await this.getAdaAddressAndAccountId(addressParams);
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        const { balance, utxoSet } = await this.getAddressInfo(senderAddr);
        if (balance <= 0) {
            throw new Error('Did not find address with funds to recover');
        }
        // first build the unsigned txn
        const tipAbsSlot = await this.getChainTipInfo();
        const txBuilder = this.getBuilder().getTransferBuilder();
        txBuilder.changeAddress(params.recoveryDestination, balance.toString());
        for (const utxo of utxoSet) {
            txBuilder.input({ transaction_id: utxo.tx_hash, transaction_index: utxo.tx_index });
        }
        // each slot is about 1 second, so this transaction should be valid for
        // 7 * 86,400 seconds (7 days) after creation
        txBuilder.ttl(Number(tipAbsSlot.abs_slot) + 7 * 86400);
        const unsignedTransaction = (await txBuilder.build());
        // sum up every output
        const amount = unsignedTransaction
            .toJson()
            .outputs.reduce((acc, output) => new bignumber_js_1.default(acc).plus(output.amount), new bignumber_js_1.default(0));
        if (amount.isLessThan(10000000)) {
            throw new Error('Insufficient funds to recover, minimum required is 1 ADA plus fees, got ' +
                amount.toString() +
                ' fees: ' +
                unsignedTransaction.getFee);
        }
        let serializedTx = unsignedTransaction.toBroadcastFormat();
        if (!isUnsignedSweep) {
            if (!params.userKey) {
                throw new Error('missing userKey');
            }
            if (!params.backupKey) {
                throw new Error('missing backupKey');
            }
            if (!params.walletPassphrase) {
                throw new Error('missing wallet passphrase');
            }
            // Clean up whitespace from entered values
            const userKey = params.userKey.replace(/\s/g, '');
            const backupKey = params.backupKey.replace(/\s/g, '');
            // Decrypt private keys from KeyCard values
            let userPrv;
            try {
                userPrv = this.bitgo.decrypt({
                    input: userKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting user keychain: ${e.message}`);
            }
            /** TODO BG-52419 Implement Codec for parsing */
            const userSigningMaterial = JSON.parse(userPrv);
            let backupPrv;
            try {
                backupPrv = this.bitgo.decrypt({
                    input: backupKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting backup keychain: ${e.message}`);
            }
            const backupSigningMaterial = JSON.parse(backupPrv);
            // add signature
            const signatureHex = await sdk_core_1.EDDSAMethods.getTSSSignature(userSigningMaterial, backupSigningMaterial, currPath, unsignedTransaction);
            const adaKeyPair = new lib_1.KeyPair({ pub: accountId });
            txBuilder.addSignature({ pub: adaKeyPair.getKeys().pub }, signatureHex);
            const signedTransaction = await txBuilder.build();
            serializedTx = signedTransaction.toBroadcastFormat();
        }
        else {
            const transactionPrebuild = { txHex: serializedTx };
            const parsedTx = await this.parseTransaction({ txPrebuild: transactionPrebuild });
            const walletCoin = this.getChain();
            const output = parsedTx.outputs[0];
            const inputs = [
                {
                    address: senderAddr,
                    valueString: output.amount,
                    value: new bignumber_js_1.default(output.amount).toNumber(),
                },
            ];
            const outputs = [
                {
                    address: output.address,
                    valueString: output.amount,
                    coinName: walletCoin,
                },
            ];
            const spendAmount = output.amount;
            const completedParsedTx = { inputs: inputs, outputs: outputs, spendAmount: spendAmount, type: '' };
            const fee = new bignumber_js_1.default(parsedTx.fee.fee);
            const feeInfo = { fee: fee.toNumber(), feeString: fee.toString() };
            const coinSpecific = { commonKeychain: bitgoKey };
            const transaction = {
                serializedTx: serializedTx,
                scanIndex: index,
                coin: walletCoin,
                signableHex: unsignedTransaction.signablePayload.toString('hex'),
                derivationPath: currPath,
                parsedTx: completedParsedTx,
                feeInfo: feeInfo,
                coinSpecific: coinSpecific,
            };
            const unsignedTx = { unsignedTx: transaction, signatureShares: [] };
            const transactions = [unsignedTx];
            const txRequest = {
                transactions: transactions,
                walletCoin: walletCoin,
            };
            const txRequests = { txRequests: [txRequest] };
            return txRequests;
        }
        const transaction = { serializedTx: serializedTx, scanIndex: index };
        return transaction;
    }
    /**
     * Builds native ADA recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     *
     * @param {MPCConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    async recoverConsolidations(params) {
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        const startIdx = params.startingScanIndex || 1;
        const endIdx = params.endingScanIndex || startIdx + exports.DEFAULT_SCAN_FACTOR;
        if (startIdx < 1 || endIdx <= startIdx || endIdx - startIdx > 10 * exports.DEFAULT_SCAN_FACTOR) {
            throw new Error(`Invalid starting or ending index to scan for addresses. startingScanIndex: ${startIdx}, endingScanIndex: ${endIdx}.`);
        }
        const addressParams = {
            bitgoKey: params.bitgoKey,
            index: 0,
            seed: params.seed,
        };
        const { address: baseAddress } = await this.getAdaAddressAndAccountId(addressParams);
        const consolidationTransactions = [];
        let lastScanIndex = startIdx;
        for (let i = startIdx; i < endIdx; i++) {
            const recoverParams = {
                userKey: params.userKey,
                backupKey: params.backupKey,
                bitgoKey: params.bitgoKey,
                walletPassphrase: params.walletPassphrase,
                recoveryDestination: baseAddress,
                seed: params.seed,
                index: i,
            };
            let recoveryTransaction;
            try {
                recoveryTransaction = await this.recover(recoverParams);
            }
            catch (e) {
                if (e.message === 'Did not find address with funds to recover') {
                    lastScanIndex = i;
                    continue;
                }
                throw e;
            }
            if (isUnsignedSweep) {
                consolidationTransactions.push(recoveryTransaction.txRequests[0]);
            }
            else {
                consolidationTransactions.push(recoveryTransaction);
            }
            lastScanIndex = i;
        }
        if (consolidationTransactions.length == 0) {
            throw new Error('Did not find an address with funds to recover');
        }
        if (isUnsignedSweep) {
            // lastScanIndex will be used to inform user the last address index scanned for available funds (so they can
            // appropriately adjust the scan range on the next iteration of consolidation recoveries). In the case of unsigned
            // sweep consolidations, this lastScanIndex will be provided in the coinSpecific of the last txn made.
            const lastTransactionCoinSpecific = {
                commonKeychain: consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific
                    .commonKeychain,
                lastScanIndex: lastScanIndex,
            };
            consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific =
                lastTransactionCoinSpecific;
            const consolidationSweepTransactions = { txRequests: consolidationTransactions };
            return consolidationSweepTransactions;
        }
        return { transactions: consolidationTransactions, lastScanIndex };
    }
    /**
     * Obtains ADA address and account id from provided bitgo key for the given index and seed (optional).
     *
     * @param {AdaAddressParams} params - params to obtain ada address and account id
     */
    async getAdaAddressAndAccountId(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        let addrFormat = sdk_core_1.AddressFormat.testnet;
        if (this.getChain() === 'ada') {
            addrFormat = sdk_core_1.AddressFormat.mainnet;
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        const derivationPathPrefix = params.seed ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) : 'm';
        const stakeKeyPair = new lib_1.KeyPair({
            pub: MPC.deriveUnhardened(bitgoKey, derivationPathPrefix + '/0').slice(0, 64),
        });
        const currPath = derivationPathPrefix + `/${params.index}`;
        const accountId = MPC.deriveUnhardened(bitgoKey, currPath).slice(0, 64);
        const paymentKeyPair = new lib_1.KeyPair({ pub: accountId });
        const address = lib_1.Utils.default.createBaseAddressWithStakeAndPaymentKey(stakeKeyPair, paymentKeyPair, addrFormat);
        return { address, accountId };
    }
    /** inherited doc */
    supportsTss() {
        return true;
    }
    /** inherited doc */
    getMPCAlgorithm() {
        return 'eddsa';
    }
    /** inherited doc */
    allowsAccountConsolidations() {
        return true;
    }
    getBuilder() {
        return new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getBaseChain()));
    }
}
exports.Ada = Ada;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRhLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2FkYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9EQUE0QjtBQUM1Qiw4Q0E0QnlCO0FBQ3pCLCtCQUE2RjtBQUM3Riw0Q0FBZ0Y7QUFDaEYsd0RBQW1DO0FBQ25DLG9EQUFzQztBQUN0QyxnRUFBcUM7QUFDckMsb0RBQXVEO0FBRTFDLFFBQUEsbUJBQW1CLEdBQUcsRUFBRSxDQUFDLENBQUMsd0RBQXdEO0FBZ0MvRixNQUFhLEdBQUksU0FBUSxtQkFBUTtJQUUvQixZQUFzQixLQUFnQixFQUFFLFdBQXVDO1FBQzdFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNiLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO1NBQ3ZFO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7SUFDbEMsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBZ0IsRUFBRSxXQUF1QztRQUM3RSxPQUFPLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxhQUFhO1FBQ2xCLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVNLFFBQVE7UUFDYixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQ2hDLENBQUM7SUFFTSxTQUFTO1FBQ2QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztJQUNsQyxDQUFDO0lBRU0sV0FBVztRQUNoQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDO0lBQ3BDLENBQUM7SUFFRCxZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUNEOzs7Ozs7Ozs7T0FTRztJ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U0FBUyxFQUFFLENBQUMsQ0FBQztRQUMxRCxNQUFNLE9BQU8sR0FBRyxXQUFLLENBQUMsT0FBTyxDQUFDLHVDQUF1QyxDQUFDLFlBQVksRUFBRSxjQUFjLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDaEgsT0FBTyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRUQsb0JBQW9CO0lBQ3BCLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxvQkFBb0I7SUFDcEIsZUFBZTtRQUNiLE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxvQkFBb0I7SUFDcEIsMkJBQTJCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVPLFVBQVU7UUFDaEIsT0FBTyxJQUFJLCtCQUF5QixDQUFDLGVBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2RSxDQUFDO0NBQ0Y7QUFsaUJELGtCQWtpQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQmFzZVRyYW5zYWN0aW9uLFxuICBCaXRHb0Jhc2UsXG4gIEludmFsaWRBZGRyZXNzRXJyb3IsXG4gIEtleVBhaXIsXG4gIE1QQ0FsZ29yaXRobSxcbiAgTm9kZUVudmlyb25tZW50RXJyb3IsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBFRERTQU1ldGhvZHMsXG4gIEVERFNBTWV0aG9kVHlwZXMsXG4gIEFkZHJlc3NGb3JtYXQsXG4gIEVudmlyb25tZW50cyxcbiAgSVRyYW5zYWN0aW9uUmVjaXBpZW50LFxuICBNUENUeCxcbiAgTVBDUmVjb3ZlcnlPcHRpb25zLFxuICBNUENDb25zb2xpZGF0aW9uUmVjb3ZlcnlPcHRpb25zLFxuICBNUENTd2VlcFR4cyxcbiAgUmVjb3ZlcnlUeFJlcXVlc3QsXG4gIE1QQ1Vuc2lnbmVkVHgsXG4gIE1QQ1N3ZWVwUmVjb3ZlcnlPcHRpb25zLFxuICBNUENUeHMsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBLZXlQYWlyIGFzIEFkYUtleVBhaXIsIFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5LCBVdGlscyB9IGZyb20gJy4vbGliJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiwgQ29pbkZhbWlseSwgY29pbnMgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgYWRhVXRpbHMgZnJvbSAnLi9saWIvdXRpbHMnO1xuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IGdldERlcml2YXRpb25QYXRoIH0gZnJvbSAnQGJpdGdvL3Nkay1saWItbXBjJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0NBTl9GQUNUT1IgPSAyMDsgLy8gZGVmYXVsdCBudW1iZXIgb2YgcmVjZWl2ZSBhZGRyZXNzZXMgdG8gc2NhbiBmb3IgZnVuZHNcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGFQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBBZGFBZGRyZXNzUGFyYW1zIHtcbiAgYml0Z29LZXk6IHN0cmluZztcbiAgaW5kZXg6IG51bWJlcjtcbiAgc2VlZD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEFkYUFkZHJlc3NBbmRBY2NvdW50SWQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGFjY291bnRJZDogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBBZGFUcmFuc2FjdGlvbkV4cGxhbmF0aW9uID0gVHJhbnNhY3Rpb25FeHBsYW5hdGlvbjtcblxuZXhwb3J0IGNsYXNzIEFkYSBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgICBpZiAoIXN0YXRpY3NDb2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29uc3RydWN0b3IgcGFyYW1ldGVyIHN0YXRpY3NDb2luJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGljc0NvaW4gPSBzdGF0aWNzQ29pbjtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBBZGEoYml0Z28sIHN0YXRpY3NDb2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3IgYmV0d2VlbiB0aGUgY29pbidzIGJhc2UgdW5pdCBhbmQgaXRzIHNtYWxsZXN0IHN1YmRpdmlzb25cbiAgICovXG4gIHB1YmxpYyBnZXRCYXNlRmFjdG9yKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIDFlNjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG5cbiAgcHVibGljIGdldEZhbWlseSgpOiBDb2luRmFtaWx5IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZmFtaWx5O1xuICB9XG5cbiAgcHVibGljIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZ1bGxOYW1lO1xuICB9XG5cbiAgZ2V0QmFzZUNoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhaW4oKTtcbiAgfVxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBjb21wbGllcyB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICogIEEgcHJlYnVpbGQgdHJhbnNhY3Rpb24gaGFzIHRvIGJlIHBhcnNlZCBjb3JyZWN0bHkgYW5kIGludGVuZGVkIHJlY2lwaWVudHMgaGFzIHRvIGJlXG4gICAqICBpbiB0aGUgdHJhbnNhY3Rpb24gb3V0cHV0XG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCBwcmVidWlsZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zLnR4UGFyYW1zIHRyYW5zYWN0aW9uIHBhcmFtZXRlcnNcbiAgICogQHJldHVybiB0cnVlIGlmIHZlcmlmaWNhdGlvbiBzdWNjZXNzXG4gICAqXG4gICAqL1xuICBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb2luQ29uZmlnID0gY29pbnMuZ2V0KHRoaXMuZ2V0Q2hhaW4oKSk7XG4gICAgICBjb25zdCB7IHR4UHJlYnVpbGQ6IHR4UHJlYnVpbGQsIHR4UGFyYW1zOiB0eFBhcmFtcyB9ID0gcGFyYW1zO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oY29pbkNvbmZpZyk7XG4gICAgICBhc3NlcnQodHhQcmVidWlsZC50eEhleCwgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4IHByZWJ1aWxkIHByb3BlcnR5IHR4SGV4JykpO1xuICAgICAgY29uc3QgcmF3VHggPSB0eFByZWJ1aWxkLnR4SGV4O1xuXG4gICAgICB0cmFuc2FjdGlvbi5mcm9tUmF3VHJhbnNhY3Rpb24ocmF3VHgpO1xuICAgICAgY29uc3QgZXhwbGFpbmVkVHggPSB0cmFuc2FjdGlvbi5leHBsYWluVHJhbnNhY3Rpb24oKTtcblxuICAgICAgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlY2lwaWVudCBvZiB0eFBhcmFtcy5yZWNpcGllbnRzKSB7XG4gICAgICAgICAgbGV0IGZpbmQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBleHBsYWluZWRUeC5vdXRwdXRzKSB7XG4gICAgICAgICAgICBpZiAocmVjaXBpZW50LmFkZHJlc3MgPT09IG91dHB1dC5hZGRyZXNzICYmIHJlY2lwaWVudC5hbW91bnQgPT09IG91dHB1dC5hbW91bnQpIHtcbiAgICAgICAgICAgICAgZmluZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZmluZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmluZCByZWNpcGllbnQgaW4gZXhwZWN0ZWQgb3V0cHV0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOb2RlRW52aXJvbm1lbnRFcnJvcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgaXNXYWxsZXRBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCB7IGFkZHJlc3MgfSA9IHBhcmFtcztcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBJbnZhbGlkIENhcmRhbm8gQWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBhc3luYyBzaWduTWVzc2FnZShrZXk6IEtleVBhaXIsIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcik6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgY29uc3QgYWRhS2V5cGFpciA9IG5ldyBBZGFLZXlQYWlyKHsgcHJ2OiBrZXkucHJ2IH0pO1xuICAgIGNvbnN0IG1lc3NhZ2VIZXggPSBtZXNzYWdlIGluc3RhbmNlb2YgQnVmZmVyID8gbWVzc2FnZS50b1N0cmluZygnaGV4JykgOiBtZXNzYWdlO1xuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFkYUtleXBhaXIuc2lnbk1lc3NhZ2UobWVzc2FnZUhleCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4vcGFyc2UgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8QWRhVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcbiAgICBsZXQgcmVidWlsdFRyYW5zYWN0aW9uOiBCYXNlVHJhbnNhY3Rpb247XG4gICAgY29uc3QgdHhSYXcgPSBwYXJhbXMudHhQcmVidWlsZC50eEhleDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkJ1aWxkZXIgPSBmYWN0b3J5LmZyb20odHhSYXcpO1xuICAgICAgcmVidWlsdFRyYW5zYWN0aW9uID0gYXdhaXQgdHJhbnNhY3Rpb25CdWlsZGVyLmJ1aWxkKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVidWlsdFRyYW5zYWN0aW9uLmV4cGxhaW5UcmFuc2FjdGlvbigpO1xuICB9XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IEFkYVBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24gPSBhd2FpdCB0aGlzLmV4cGxhaW5UcmFuc2FjdGlvbih7XG4gICAgICB0eFByZWJ1aWxkOiBwYXJhbXMudHhQcmVidWlsZCxcbiAgICB9KTtcblxuICAgIGlmICghdHJhbnNhY3Rpb25FeHBsYW5hdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uRXhwbGFuYXRpb24gYXMgdW5rbm93biBhcyBQYXJzZWRUcmFuc2FjdGlvbjtcbiAgfVxuXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3Qga2V5UGFpciA9IHNlZWQgPyBuZXcgQWRhS2V5UGFpcih7IHNlZWQgfSkgOiBuZXcgQWRhS2V5UGFpcigpO1xuICAgIGNvbnN0IGtleXMgPSBrZXlQYWlyLmdldEtleXMoKTtcbiAgICBpZiAoIWtleXMucHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJ2IGluIGtleSBnZW5lcmF0aW9uLicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBrZXlzLnB1YixcbiAgICAgIHBydjoga2V5cy5wcnYsXG4gICAgfTtcbiAgfVxuXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gYWRhVXRpbHMuaXNWYWxpZFB1YmxpY0tleShwdWIpO1xuICB9XG5cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBhZGFVdGlscy5pc1ZhbGlkUHJpdmF0ZUtleShwcnYpO1xuICB9XG5cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGFkYVV0aWxzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5nZXRCdWlsZGVyKCk7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5mcm9tKHBhcmFtcy50eFByZWJ1aWxkLnR4SGV4KTtcbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogcGFyYW1zLnBydiB9KTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbjogQmFzZVRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJpYWxpemVkVHggPSB0cmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR4SGV4OiBzZXJpYWxpemVkVHgsXG4gICAgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRQdWJsaWNOb2RlVXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEVudmlyb25tZW50c1t0aGlzLmJpdGdvLmdldEVudigpXS5hZGFOb2RlVXJsO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldERhdGFGcm9tTm9kZShlbmRwb2ludDogc3RyaW5nLCByZXF1ZXN0Qm9keT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUHJvbWlzZTxyZXF1ZXN0LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgcmVzdEVuZHBvaW50ID0gdGhpcy5nZXRQdWJsaWNOb2RlVXJsKCkgKyAnLycgKyBlbmRwb2ludDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdC5wb3N0KHJlc3RFbmRwb2ludCkuc2VuZChyZXF1ZXN0Qm9keSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNhbGwgZW5kcG9pbnQgJHtyZXN0RW5kcG9pbnR9YCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0QWRkcmVzc0luZm8oXG4gICAgd2FsbGV0QWRkcjogc3RyaW5nXG4gICk6IFByb21pc2U8eyBiYWxhbmNlOiBudW1iZXI7IHV0eG9TZXQ6IEFycmF5PFJlY29yZDxzdHJpbmcsIGFueT4+IH0+IHtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHsgX2FkZHJlc3NlczogW3dhbGxldEFkZHJdIH07XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXREYXRhRnJvbU5vZGUoJ2FkZHJlc3NfaW5mbycsIHJlcXVlc3RCb2R5KTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJldHJpZXZlIGFkZHJlc3MgaW5mbyBmb3IgYWRkcmVzcyAke3dhbGxldEFkZHJ9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSByZXMuYm9keVswXTtcbiAgICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4geyBiYWxhbmNlOiAwLCB1dHhvU2V0OiBbXSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBiYWxhbmNlOiBib2R5LmJhbGFuY2UsIHV0eG9TZXQ6IGJvZHkudXR4b19zZXQgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRDaGFpblRpcEluZm8oKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXREYXRhRnJvbU5vZGUoJ3RpcCcpO1xuICAgIGlmIChyZXMuc3RhdHVzICE9IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmV0cmlldmUgY2hhaW4gdGlwIGluZm8nKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHJlcy5ib2R5WzBdO1xuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgLyoqIGluaGVyaXRlZCBkb2MgKi9cbiAgYXN5bmMgY3JlYXRlQnJvYWRjYXN0YWJsZVN3ZWVwVHJhbnNhY3Rpb24ocGFyYW1zOiBNUENTd2VlcFJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8TVBDVHhzPiB7XG4gICAgY29uc3QgcmVxID0gcGFyYW1zLnNpZ25hdHVyZVNoYXJlcztcbiAgICBjb25zdCBicm9hZGNhc3RhYmxlVHJhbnNhY3Rpb25zOiBNUENUeFtdID0gW107XG4gICAgbGV0IGxhc3RTY2FuSW5kZXggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IE1QQyA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRJbml0aWFsaXplZE1wY0luc3RhbmNlKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHJlcVtpXS50eFJlcXVlc3QudHJhbnNhY3Rpb25zWzBdLnVuc2lnbmVkVHg7XG4gICAgICBpZiAoIXJlcVtpXS5vdmMgfHwgIXJlcVtpXS5vdmNbMF0uZWRkc2FTaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hdHVyZShzKScpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcmVxW2ldLm92Y1swXS5lZGRzYVNpZ25hdHVyZTtcbiAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmFibGVIZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hYmxlIGhleCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnNpZ25hYmxlSGV4ISwgJ2hleCcpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gTVBDLnZlcmlmeShtZXNzYWdlQnVmZmVyLCBzaWduYXR1cmUpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlSGV4ID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oc2lnbmF0dXJlLlIsICdoZXgnKSwgQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNpZ21hLCAnaGV4JyldKTtcbiAgICAgIGNvbnN0IHR4QnVpbGRlciA9IHRoaXMuZ2V0QnVpbGRlcigpLmZyb20odHJhbnNhY3Rpb24uc2VyaWFsaXplZFR4IGFzIHN0cmluZyk7XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYz8uY29tbW9uS2V5Y2hhaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNvbW1vbiBrZXljaGFpbicpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tbW9uS2V5Y2hhaW4gPSB0cmFuc2FjdGlvbi5jb2luU3BlY2lmaWMhLmNvbW1vbktleWNoYWluISBhcyBzdHJpbmc7XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uLmRlcml2YXRpb25QYXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkZXJpdmF0aW9uIHBhdGgnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gdHJhbnNhY3Rpb24uZGVyaXZhdGlvblBhdGggYXMgc3RyaW5nO1xuICAgICAgY29uc3QgYWNjb3VudElkID0gTVBDLmRlcml2ZVVuaGFyZGVuZWQoY29tbW9uS2V5Y2hhaW4sIGRlcml2YXRpb25QYXRoKS5zbGljZSgwLCA2NCk7XG4gICAgICBjb25zdCBhZGFLZXlQYWlyID0gbmV3IEFkYUtleVBhaXIoeyBwdWI6IGFjY291bnRJZCB9KTtcblxuICAgICAgLy8gYWRkIGNvbWJpbmVkIHNpZ25hdHVyZSBmcm9tIG92Y1xuICAgICAgdHhCdWlsZGVyLmFkZFNpZ25hdHVyZSh7IHB1YjogYWRhS2V5UGFpci5nZXRLZXlzKCkucHViIH0sIHNpZ25hdHVyZUhleCk7XG4gICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZFR4ID0gc2lnbmVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcblxuICAgICAgYnJvYWRjYXN0YWJsZVRyYW5zYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgc2VyaWFsaXplZFR4OiBzZXJpYWxpemVkVHgsXG4gICAgICAgIHNjYW5JbmRleDogdHJhbnNhY3Rpb24uc2NhbkluZGV4LFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpID09PSByZXEubGVuZ3RoIC0gMSAmJiB0cmFuc2FjdGlvbi5jb2luU3BlY2lmaWMhLmxhc3RTY2FuSW5kZXgpIHtcbiAgICAgICAgbGFzdFNjYW5JbmRleCA9IHRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYyEubGFzdFNjYW5JbmRleCBhcyBudW1iZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJhbnNhY3Rpb25zOiBicm9hZGNhc3RhYmxlVHJhbnNhY3Rpb25zLCBsYXN0U2NhbkluZGV4IH07XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uKHMpIHdpdGhvdXQgQml0R29cbiAgICpcbiAgICogQHBhcmFtIHtNUENSZWNvdmVyeU9wdGlvbnN9IHBhcmFtcyBwYXJhbWV0ZXJzIG5lZWRlZCB0byBjb25zdHJ1Y3QgYW5kXG4gICAqIChtYXliZSkgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge01QQ1R4IHwgTVBDU3dlZXBUeHN9IGFycmF5IG9mIHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGhleCBzdHJpbmdzIGFuZCBpbmRpY2VzXG4gICAqIG9mIHRoZSBhZGRyZXNzZXMgYmVpbmcgc3dlcHRcbiAgICovXG4gIGFzeW5jIHJlY292ZXIocGFyYW1zOiBNUENSZWNvdmVyeU9wdGlvbnMpOiBQcm9taXNlPE1QQ1R4IHwgTVBDU3dlZXBUeHM+IHtcbiAgICBpZiAoIXBhcmFtcy5iaXRnb0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJpdGdvS2V5Jyk7XG4gICAgfVxuICAgIGlmICghcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24gfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVjb3ZlcnlEZXN0aW5hdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gcGFyYW1zLmluZGV4IHx8IDA7XG4gICAgY29uc3QgY3VyclBhdGggPSBwYXJhbXMuc2VlZCA/IGdldERlcml2YXRpb25QYXRoKHBhcmFtcy5zZWVkKSArIGAvJHtpbmRleH1gIDogYG0vJHtpbmRleH1gO1xuICAgIGNvbnN0IGJpdGdvS2V5ID0gcGFyYW1zLmJpdGdvS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgICBjb25zdCBhZGRyZXNzUGFyYW1zID0ge1xuICAgICAgYml0Z29LZXk6IHBhcmFtcy5iaXRnb0tleSxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgIH07XG4gICAgY29uc3QgeyBhZGRyZXNzOiBzZW5kZXJBZGRyLCBhY2NvdW50SWQgfSA9IGF3YWl0IHRoaXMuZ2V0QWRhQWRkcmVzc0FuZEFjY291bnRJZChhZGRyZXNzUGFyYW1zKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSAhcGFyYW1zLnVzZXJLZXkgJiYgIXBhcmFtcy5iYWNrdXBLZXkgJiYgIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlO1xuICAgIGNvbnN0IHsgYmFsYW5jZSwgdXR4b1NldCB9ID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzSW5mbyhzZW5kZXJBZGRyKTtcbiAgICBpZiAoYmFsYW5jZSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBhZGRyZXNzIHdpdGggZnVuZHMgdG8gcmVjb3ZlcicpO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGJ1aWxkIHRoZSB1bnNpZ25lZCB0eG5cbiAgICBjb25zdCB0aXBBYnNTbG90ID0gYXdhaXQgdGhpcy5nZXRDaGFpblRpcEluZm8oKTtcbiAgICBjb25zdCB0eEJ1aWxkZXIgPSB0aGlzLmdldEJ1aWxkZXIoKS5nZXRUcmFuc2ZlckJ1aWxkZXIoKTtcbiAgICB0eEJ1aWxkZXIuY2hhbmdlQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiwgYmFsYW5jZS50b1N0cmluZygpKTtcbiAgICBmb3IgKGNvbnN0IHV0eG8gb2YgdXR4b1NldCkge1xuICAgICAgdHhCdWlsZGVyLmlucHV0KHsgdHJhbnNhY3Rpb25faWQ6IHV0eG8udHhfaGFzaCwgdHJhbnNhY3Rpb25faW5kZXg6IHV0eG8udHhfaW5kZXggfSk7XG4gICAgfVxuICAgIC8vIGVhY2ggc2xvdCBpcyBhYm91dCAxIHNlY29uZCwgc28gdGhpcyB0cmFuc2FjdGlvbiBzaG91bGQgYmUgdmFsaWQgZm9yXG4gICAgLy8gNyAqIDg2LDQwMCBzZWNvbmRzICg3IGRheXMpIGFmdGVyIGNyZWF0aW9uXG4gICAgdHhCdWlsZGVyLnR0bChOdW1iZXIodGlwQWJzU2xvdC5hYnNfc2xvdCkgKyA3ICogODY0MDApO1xuICAgIGNvbnN0IHVuc2lnbmVkVHJhbnNhY3Rpb24gPSAoYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCkpIGFzIFRyYW5zYWN0aW9uO1xuXG4gICAgLy8gc3VtIHVwIGV2ZXJ5IG91dHB1dFxuICAgIGNvbnN0IGFtb3VudCA9IHVuc2lnbmVkVHJhbnNhY3Rpb25cbiAgICAgIC50b0pzb24oKVxuICAgICAgLm91dHB1dHMucmVkdWNlKFxuICAgICAgICAoYWNjOiBCaWdOdW1iZXIsIG91dHB1dDogeyBhbW91bnQ6IHN0cmluZyB9KSA9PiBuZXcgQmlnTnVtYmVyKGFjYykucGx1cyhvdXRwdXQuYW1vdW50KSxcbiAgICAgICAgbmV3IEJpZ051bWJlcigwKVxuICAgICAgKTtcbiAgICBpZiAoYW1vdW50LmlzTGVzc1RoYW4oMTAwMDAwMDApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbnN1ZmZpY2llbnQgZnVuZHMgdG8gcmVjb3ZlciwgbWluaW11bSByZXF1aXJlZCBpcyAxIEFEQSBwbHVzIGZlZXMsIGdvdCAnICtcbiAgICAgICAgICBhbW91bnQudG9TdHJpbmcoKSArXG4gICAgICAgICAgJyBmZWVzOiAnICtcbiAgICAgICAgICB1bnNpZ25lZFRyYW5zYWN0aW9uLmdldEZlZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgc2VyaWFsaXplZFR4ID0gdW5zaWduZWRUcmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuICAgIGlmICghaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICBpZiAoIXBhcmFtcy51c2VyS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB1c2VyS2V5Jyk7XG4gICAgICB9XG4gICAgICBpZiAoIXBhcmFtcy5iYWNrdXBLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJhY2t1cEtleScpO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW4gdXAgd2hpdGVzcGFjZSBmcm9tIGVudGVyZWQgdmFsdWVzXG4gICAgICBjb25zdCB1c2VyS2V5ID0gcGFyYW1zLnVzZXJLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgIGNvbnN0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICAgICAgLy8gRGVjcnlwdCBwcml2YXRlIGtleXMgZnJvbSBLZXlDYXJkIHZhbHVlc1xuICAgICAgbGV0IHVzZXJQcnY7XG4gICAgICB0cnkge1xuICAgICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgICBpbnB1dDogdXNlcktleSxcbiAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgdXNlciBrZXljaGFpbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICAvKiogVE9ETyBCRy01MjQxOSBJbXBsZW1lbnQgQ29kZWMgZm9yIHBhcnNpbmcgKi9cbiAgICAgIGNvbnN0IHVzZXJTaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKHVzZXJQcnYpIGFzIEVERFNBTWV0aG9kVHlwZXMuVXNlclNpZ25pbmdNYXRlcmlhbDtcblxuICAgICAgbGV0IGJhY2t1cFBydjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJhY2t1cFBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgaW5wdXQ6IGJhY2t1cEtleSxcbiAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgYmFja3VwIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhY2t1cFNpZ25pbmdNYXRlcmlhbCA9IEpTT04ucGFyc2UoYmFja3VwUHJ2KSBhcyBFRERTQU1ldGhvZFR5cGVzLkJhY2t1cFNpZ25pbmdNYXRlcmlhbDtcblxuICAgICAgLy8gYWRkIHNpZ25hdHVyZVxuICAgICAgY29uc3Qgc2lnbmF0dXJlSGV4ID0gYXdhaXQgRUREU0FNZXRob2RzLmdldFRTU1NpZ25hdHVyZShcbiAgICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbCxcbiAgICAgICAgYmFja3VwU2lnbmluZ01hdGVyaWFsLFxuICAgICAgICBjdXJyUGF0aCxcbiAgICAgICAgdW5zaWduZWRUcmFuc2FjdGlvblxuICAgICAgKTtcbiAgICAgIGNvbnN0IGFkYUtleVBhaXIgPSBuZXcgQWRhS2V5UGFpcih7IHB1YjogYWNjb3VudElkIH0pO1xuICAgICAgdHhCdWlsZGVyLmFkZFNpZ25hdHVyZSh7IHB1YjogYWRhS2V5UGFpci5nZXRLZXlzKCkucHViIH0sIHNpZ25hdHVyZUhleCk7XG4gICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgICAgc2VyaWFsaXplZFR4ID0gc2lnbmVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25QcmVidWlsZCA9IHsgdHhIZXg6IHNlcmlhbGl6ZWRUeCB9O1xuICAgICAgY29uc3QgcGFyc2VkVHggPSBhd2FpdCB0aGlzLnBhcnNlVHJhbnNhY3Rpb24oeyB0eFByZWJ1aWxkOiB0cmFuc2FjdGlvblByZWJ1aWxkIH0pO1xuICAgICAgY29uc3Qgd2FsbGV0Q29pbiA9IHRoaXMuZ2V0Q2hhaW4oKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IChwYXJzZWRUeC5vdXRwdXRzIGFzIElUcmFuc2FjdGlvblJlY2lwaWVudClbMF07XG4gICAgICBjb25zdCBpbnB1dHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBhZGRyZXNzOiBzZW5kZXJBZGRyLFxuICAgICAgICAgIHZhbHVlU3RyaW5nOiBvdXRwdXQuYW1vdW50LFxuICAgICAgICAgIHZhbHVlOiBuZXcgQmlnTnVtYmVyKG91dHB1dC5hbW91bnQpLnRvTnVtYmVyKCksXG4gICAgICAgIH0sXG4gICAgICBdO1xuICAgICAgY29uc3Qgb3V0cHV0cyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGFkZHJlc3M6IG91dHB1dC5hZGRyZXNzLFxuICAgICAgICAgIHZhbHVlU3RyaW5nOiBvdXRwdXQuYW1vdW50LFxuICAgICAgICAgIGNvaW5OYW1lOiB3YWxsZXRDb2luLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICAgIGNvbnN0IHNwZW5kQW1vdW50ID0gb3V0cHV0LmFtb3VudDtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZFBhcnNlZFR4ID0geyBpbnB1dHM6IGlucHV0cywgb3V0cHV0czogb3V0cHV0cywgc3BlbmRBbW91bnQ6IHNwZW5kQW1vdW50LCB0eXBlOiAnJyB9O1xuICAgICAgY29uc3QgZmVlID0gbmV3IEJpZ051bWJlcigocGFyc2VkVHguZmVlIGFzIHsgZmVlOiBzdHJpbmcgfSkuZmVlKTtcbiAgICAgIGNvbnN0IGZlZUluZm8gPSB7IGZlZTogZmVlLnRvTnVtYmVyKCksIGZlZVN0cmluZzogZmVlLnRvU3RyaW5nKCkgfTtcbiAgICAgIGNvbnN0IGNvaW5TcGVjaWZpYyA9IHsgY29tbW9uS2V5Y2hhaW46IGJpdGdvS2V5IH07XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbjogTVBDVHggPSB7XG4gICAgICAgIHNlcmlhbGl6ZWRUeDogc2VyaWFsaXplZFR4LFxuICAgICAgICBzY2FuSW5kZXg6IGluZGV4LFxuICAgICAgICBjb2luOiB3YWxsZXRDb2luLFxuICAgICAgICBzaWduYWJsZUhleDogdW5zaWduZWRUcmFuc2FjdGlvbi5zaWduYWJsZVBheWxvYWQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBkZXJpdmF0aW9uUGF0aDogY3VyclBhdGgsXG4gICAgICAgIHBhcnNlZFR4OiBjb21wbGV0ZWRQYXJzZWRUeCxcbiAgICAgICAgZmVlSW5mbzogZmVlSW5mbyxcbiAgICAgICAgY29pblNwZWNpZmljOiBjb2luU3BlY2lmaWMsXG4gICAgICB9O1xuICAgICAgY29uc3QgdW5zaWduZWRUeDogTVBDVW5zaWduZWRUeCA9IHsgdW5zaWduZWRUeDogdHJhbnNhY3Rpb24sIHNpZ25hdHVyZVNoYXJlczogW10gfTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uczogTVBDVW5zaWduZWRUeFtdID0gW3Vuc2lnbmVkVHhdO1xuICAgICAgY29uc3QgdHhSZXF1ZXN0OiBSZWNvdmVyeVR4UmVxdWVzdCA9IHtcbiAgICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMsXG4gICAgICAgIHdhbGxldENvaW46IHdhbGxldENvaW4sXG4gICAgICB9O1xuICAgICAgY29uc3QgdHhSZXF1ZXN0czogTVBDU3dlZXBUeHMgPSB7IHR4UmVxdWVzdHM6IFt0eFJlcXVlc3RdIH07XG4gICAgICByZXR1cm4gdHhSZXF1ZXN0cztcbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb246IE1QQ1R4ID0geyBzZXJpYWxpemVkVHg6IHNlcmlhbGl6ZWRUeCwgc2NhbkluZGV4OiBpbmRleCB9O1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgbmF0aXZlIEFEQSByZWNvdmVyaWVzIG9mIHJlY2VpdmUgYWRkcmVzc2VzIGluIGJhdGNoIHdpdGhvdXQgQml0R28uXG4gICAqIEZ1bmRzIHdpbGwgYmUgcmVjb3ZlcmVkIHRvIGJhc2UgYWRkcmVzcyBmaXJzdC4gWW91IG5lZWQgdG8gaW5pdGlhdGUgYW5vdGhlciBzd2VlcCB0eG4gYWZ0ZXIgdGhhdC5cbiAgICpcbiAgICogQHBhcmFtIHtNUENDb25zb2xpZGF0aW9uUmVjb3ZlcnlPcHRpb25zfSBwYXJhbXMgLSBvcHRpb25zIGZvciBjb25zb2xpZGF0aW9uIHJlY292ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5zdGFydGluZ1NjYW5JbmRleF0gLSByZWNlaXZlIGFkZHJlc3MgaW5kZXggdG8gc3RhcnQgc2Nhbm5pbmcgZnJvbS4gZGVmYXVsdCB0byAxIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5lbmRpbmdTY2FuSW5kZXhdIC0gcmVjZWl2ZSBhZGRyZXNzIGluZGV4IHRvIGVuZCBzY2FubmluZyBhdC4gZGVmYXVsdCB0byBzdGFydGluZ1NjYW5JbmRleCArIDIwIChleGNsdXNpdmUpLlxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlckNvbnNvbGlkYXRpb25zKHBhcmFtczogTVBDQ29uc29saWRhdGlvblJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8TVBDVHhzIHwgTVBDU3dlZXBUeHM+IHtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSAhcGFyYW1zLnVzZXJLZXkgJiYgIXBhcmFtcy5iYWNrdXBLZXkgJiYgIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlO1xuICAgIGNvbnN0IHN0YXJ0SWR4ID0gcGFyYW1zLnN0YXJ0aW5nU2NhbkluZGV4IHx8IDE7XG4gICAgY29uc3QgZW5kSWR4ID0gcGFyYW1zLmVuZGluZ1NjYW5JbmRleCB8fCBzdGFydElkeCArIERFRkFVTFRfU0NBTl9GQUNUT1I7XG5cbiAgICBpZiAoc3RhcnRJZHggPCAxIHx8IGVuZElkeCA8PSBzdGFydElkeCB8fCBlbmRJZHggLSBzdGFydElkeCA+IDEwICogREVGQVVMVF9TQ0FOX0ZBQ1RPUikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBzdGFydGluZyBvciBlbmRpbmcgaW5kZXggdG8gc2NhbiBmb3IgYWRkcmVzc2VzLiBzdGFydGluZ1NjYW5JbmRleDogJHtzdGFydElkeH0sIGVuZGluZ1NjYW5JbmRleDogJHtlbmRJZHh9LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkcmVzc1BhcmFtcyA9IHtcbiAgICAgIGJpdGdvS2V5OiBwYXJhbXMuYml0Z29LZXksXG4gICAgICBpbmRleDogMCxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgIH07XG4gICAgY29uc3QgeyBhZGRyZXNzOiBiYXNlQWRkcmVzcyB9ID0gYXdhaXQgdGhpcy5nZXRBZGFBZGRyZXNzQW5kQWNjb3VudElkKGFkZHJlc3NQYXJhbXMpO1xuICAgIGNvbnN0IGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnM6IGFueVtdID0gW107XG4gICAgbGV0IGxhc3RTY2FuSW5kZXggPSBzdGFydElkeDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJZHg7IGkgPCBlbmRJZHg7IGkrKykge1xuICAgICAgY29uc3QgcmVjb3ZlclBhcmFtcyA9IHtcbiAgICAgICAgdXNlcktleTogcGFyYW1zLnVzZXJLZXksXG4gICAgICAgIGJhY2t1cEtleTogcGFyYW1zLmJhY2t1cEtleSxcbiAgICAgICAgYml0Z29LZXk6IHBhcmFtcy5iaXRnb0tleSxcbiAgICAgICAgd2FsbGV0UGFzc3BocmFzZTogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIHJlY292ZXJ5RGVzdGluYXRpb246IGJhc2VBZGRyZXNzLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICB9O1xuXG4gICAgICBsZXQgcmVjb3ZlcnlUcmFuc2FjdGlvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlY292ZXJ5VHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnJlY292ZXIocmVjb3ZlclBhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLm1lc3NhZ2UgPT09ICdEaWQgbm90IGZpbmQgYWRkcmVzcyB3aXRoIGZ1bmRzIHRvIHJlY292ZXInKSB7XG4gICAgICAgICAgbGFzdFNjYW5JbmRleCA9IGk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLnB1c2goKHJlY292ZXJ5VHJhbnNhY3Rpb24gYXMgTVBDU3dlZXBUeHMpLnR4UmVxdWVzdHNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29saWRhdGlvblRyYW5zYWN0aW9ucy5wdXNoKHJlY292ZXJ5VHJhbnNhY3Rpb24pO1xuICAgICAgfVxuICAgICAgbGFzdFNjYW5JbmRleCA9IGk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnMubGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBmaW5kIGFuIGFkZHJlc3Mgd2l0aCBmdW5kcyB0byByZWNvdmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgLy8gbGFzdFNjYW5JbmRleCB3aWxsIGJlIHVzZWQgdG8gaW5mb3JtIHVzZXIgdGhlIGxhc3QgYWRkcmVzcyBpbmRleCBzY2FubmVkIGZvciBhdmFpbGFibGUgZnVuZHMgKHNvIHRoZXkgY2FuXG4gICAgICAvLyBhcHByb3ByaWF0ZWx5IGFkanVzdCB0aGUgc2NhbiByYW5nZSBvbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgY29uc29saWRhdGlvbiByZWNvdmVyaWVzKS4gSW4gdGhlIGNhc2Ugb2YgdW5zaWduZWRcbiAgICAgIC8vIHN3ZWVwIGNvbnNvbGlkYXRpb25zLCB0aGlzIGxhc3RTY2FuSW5kZXggd2lsbCBiZSBwcm92aWRlZCBpbiB0aGUgY29pblNwZWNpZmljIG9mIHRoZSBsYXN0IHR4biBtYWRlLlxuICAgICAgY29uc3QgbGFzdFRyYW5zYWN0aW9uQ29pblNwZWNpZmljID0ge1xuICAgICAgICBjb21tb25LZXljaGFpbjpcbiAgICAgICAgICBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zW2NvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnMubGVuZ3RoIC0gMV0udHJhbnNhY3Rpb25zWzBdLnVuc2lnbmVkVHguY29pblNwZWNpZmljXG4gICAgICAgICAgICAuY29tbW9uS2V5Y2hhaW4sXG4gICAgICAgIGxhc3RTY2FuSW5kZXg6IGxhc3RTY2FuSW5kZXgsXG4gICAgICB9O1xuICAgICAgY29uc29saWRhdGlvblRyYW5zYWN0aW9uc1tjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLnRyYW5zYWN0aW9uc1swXS51bnNpZ25lZFR4LmNvaW5TcGVjaWZpYyA9XG4gICAgICAgIGxhc3RUcmFuc2FjdGlvbkNvaW5TcGVjaWZpYztcbiAgICAgIGNvbnN0IGNvbnNvbGlkYXRpb25Td2VlcFRyYW5zYWN0aW9uczogTVBDU3dlZXBUeHMgPSB7IHR4UmVxdWVzdHM6IGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnMgfTtcbiAgICAgIHJldHVybiBjb25zb2xpZGF0aW9uU3dlZXBUcmFuc2FjdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJhbnNhY3Rpb25zOiBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLCBsYXN0U2NhbkluZGV4IH07XG4gIH1cblxuICAvKipcbiAgICogT2J0YWlucyBBREEgYWRkcmVzcyBhbmQgYWNjb3VudCBpZCBmcm9tIHByb3ZpZGVkIGJpdGdvIGtleSBmb3IgdGhlIGdpdmVuIGluZGV4IGFuZCBzZWVkIChvcHRpb25hbCkuXG4gICAqXG4gICAqIEBwYXJhbSB7QWRhQWRkcmVzc1BhcmFtc30gcGFyYW1zIC0gcGFyYW1zIHRvIG9idGFpbiBhZGEgYWRkcmVzcyBhbmQgYWNjb3VudCBpZFxuICAgKi9cbiAgYXN5bmMgZ2V0QWRhQWRkcmVzc0FuZEFjY291bnRJZChwYXJhbXM6IEFkYUFkZHJlc3NQYXJhbXMpOiBQcm9taXNlPEFkYUFkZHJlc3NBbmRBY2NvdW50SWQ+IHtcbiAgICBpZiAoIXBhcmFtcy5iaXRnb0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJpdGdvS2V5Jyk7XG4gICAgfVxuXG4gICAgbGV0IGFkZHJGb3JtYXQgPSBBZGRyZXNzRm9ybWF0LnRlc3RuZXQ7XG4gICAgaWYgKHRoaXMuZ2V0Q2hhaW4oKSA9PT0gJ2FkYScpIHtcbiAgICAgIGFkZHJGb3JtYXQgPSBBZGRyZXNzRm9ybWF0Lm1haW5uZXQ7XG4gICAgfVxuXG4gICAgY29uc3QgYml0Z29LZXkgPSBwYXJhbXMuYml0Z29LZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBjb25zdCBNUEMgPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0SW5pdGlhbGl6ZWRNcGNJbnN0YW5jZSgpO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoUHJlZml4ID0gcGFyYW1zLnNlZWQgPyBnZXREZXJpdmF0aW9uUGF0aChwYXJhbXMuc2VlZCkgOiAnbSc7XG4gICAgY29uc3Qgc3Rha2VLZXlQYWlyID0gbmV3IEFkYUtleVBhaXIoe1xuICAgICAgcHViOiBNUEMuZGVyaXZlVW5oYXJkZW5lZChiaXRnb0tleSwgZGVyaXZhdGlvblBhdGhQcmVmaXggKyAnLzAnKS5zbGljZSgwLCA2NCksXG4gICAgfSk7XG5cbiAgICBjb25zdCBjdXJyUGF0aCA9IGRlcml2YXRpb25QYXRoUHJlZml4ICsgYC8ke3BhcmFtcy5pbmRleH1gO1xuICAgIGNvbnN0IGFjY291bnRJZCA9IE1QQy5kZXJpdmVVbmhhcmRlbmVkKGJpdGdvS2V5LCBjdXJyUGF0aCkuc2xpY2UoMCwgNjQpO1xuICAgIGNvbnN0IHBheW1lbnRLZXlQYWlyID0gbmV3IEFkYUtleVBhaXIoeyBwdWI6IGFjY291bnRJZCB9KTtcbiAgICBjb25zdCBhZGRyZXNzID0gVXRpbHMuZGVmYXVsdC5jcmVhdGVCYXNlQWRkcmVzc1dpdGhTdGFrZUFuZFBheW1lbnRLZXkoc3Rha2VLZXlQYWlyLCBwYXltZW50S2V5UGFpciwgYWRkckZvcm1hdCk7XG4gICAgcmV0dXJuIHsgYWRkcmVzcywgYWNjb3VudElkIH07XG4gIH1cblxuICAvKiogaW5oZXJpdGVkIGRvYyAqL1xuICBzdXBwb3J0c1RzcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBpbmhlcml0ZWQgZG9jICovXG4gIGdldE1QQ0FsZ29yaXRobSgpOiBNUENBbGdvcml0aG0ge1xuICAgIHJldHVybiAnZWRkc2EnO1xuICB9XG5cbiAgLyoqIGluaGVyaXRlZCBkb2MgKi9cbiAgYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRCdWlsZGVyKCk6IFRyYW5zYWN0aW9uQnVpbGRlckZhY3Rvcnkge1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2lucy5nZXQodGhpcy5nZXRCYXNlQ2hhaW4oKSkpO1xuICB9XG59XG4iXX0=