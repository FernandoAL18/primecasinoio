"use strict";
/**
 * @prettier
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sol = exports.DEFAULT_SCAN_FACTOR = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const base58 = __importStar(require("bs58"));
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const statics_1 = require("@bitgo/statics");
const _ = __importStar(require("lodash"));
const request = __importStar(require("superagent"));
const lib_1 = require("./lib");
const utils_1 = require("./lib/utils");
exports.DEFAULT_SCAN_FACTOR = 20; // default number of receive addresses to scan for funds
const HEX_REGEX = /^[0-9a-fA-F]+$/;
class Sol extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Sol(bitgo, staticsCoin);
    }
    allowsAccountConsolidations() {
        return true;
    }
    supportsTss() {
        return true;
    }
    getMPCAlgorithm() {
        return 'eddsa';
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getNetwork() {
        return this._staticsCoin.network;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    async verifyTransaction(params) {
        var _a, _b;
        // asset name to transfer amount map
        const totalAmount = {};
        const coinConfig = statics_1.coins.get(this.getChain());
        const { txParams: txParams, txPrebuild: txPrebuild, memo: memo, durableNonce: durableNonce } = params;
        const transaction = new lib_1.Transaction(coinConfig);
        const rawTx = txPrebuild.txBase64 || txPrebuild.txHex;
        const consolidateId = txPrebuild.consolidateId;
        const walletRootAddress = (_a = params.wallet.coinSpecific()) === null || _a === void 0 ? void 0 : _a.rootAddress;
        if (!rawTx) {
            throw new Error('missing required tx prebuild property txBase64 or txHex');
        }
        let rawTxBase64 = rawTx;
        if (HEX_REGEX.test(rawTx)) {
            rawTxBase64 = Buffer.from(rawTx, 'hex').toString('base64');
        }
        transaction.fromRawTransaction(rawTxBase64);
        const explainedTx = transaction.explainTransaction();
        // users do not input recipients for consolidation requests as they are generated by the server
        if (txParams.recipients !== undefined) {
            const filteredRecipients = (_b = txParams.recipients) === null || _b === void 0 ? void 0 : _b.map((recipient) => _.pick(recipient, ['address', 'amount', 'tokenName']));
            const filteredOutputs = explainedTx.outputs.map((output) => _.pick(output, ['address', 'amount', 'tokenName']));
            if (filteredRecipients.length !== filteredOutputs.length) {
                throw new Error('Number of tx outputs does not match with number of txParams recipients');
            }
            // For each recipient, check if it's a token tx (tokenName will exist if so)
            // If it is a token tx, verify that the recipient address equals the derived address from explainedTx
            // Derive the ATA if it is a native address and confirm it is equal to the explained tx recipient
            const recipientChecks = await Promise.all(filteredRecipients.map(async (recipientFromUser, index) => {
                const recipientFromTx = filteredOutputs[index]; // This address should be an ATA
                // Compare the BigNumber values because amount is (string | number)
                const userAmount = new bignumber_js_1.default(recipientFromUser.amount);
                const txAmount = new bignumber_js_1.default(recipientFromTx.amount);
                if (!userAmount.isEqualTo(txAmount)) {
                    return false;
                }
                // Compare the addresses and tokenNames
                // Else if the addresses are not the same, check the derived ATA for parity
                if (recipientFromUser.address === recipientFromTx.address &&
                    recipientFromUser.tokenName === recipientFromTx.tokenName) {
                    return true;
                }
                else if (recipientFromUser.address !== recipientFromTx.address && recipientFromUser.tokenName) {
                    // Try to check if the user's derived ATA is equal to the tx recipient address
                    // If getAssociatedTokenAccountAddress throws an error, then we are unable to derive the ATA for that address.
                    // Return false and throw an error if that is the case.
                    try {
                        const tokenMintAddress = (0, utils_1.getSolTokenFromTokenName)(recipientFromUser.tokenName);
                        return (0, utils_1.getAssociatedTokenAccountAddress)(tokenMintAddress.tokenAddress, recipientFromUser.address).then((ata) => {
                            return ata === recipientFromTx.address;
                        });
                    }
                    catch {
                        // Unable to derive ATA
                        return false;
                    }
                }
                return false;
            }));
            if (recipientChecks.includes(false)) {
                throw new Error('Tx outputs does not match with expected txParams recipients');
            }
        }
        const transactionJson = transaction.toJson();
        if (memo && memo.value !== explainedTx.memo) {
            throw new Error('Tx memo does not match with expected txParams recipient memo');
        }
        if (txParams.recipients) {
            for (const recipients of txParams.recipients) {
                // totalAmount based on each token
                const assetName = recipients.tokenName || this.getChain();
                const amount = totalAmount[assetName] || new bignumber_js_1.default(0);
                totalAmount[assetName] = amount.plus(recipients.amount);
            }
            // total output amount from explainedTx
            const explainedTxTotal = {};
            for (const output of explainedTx.outputs) {
                // total output amount based on each token
                const assetName = output.tokenName || this.getChain();
                const amount = explainedTxTotal[assetName] || new bignumber_js_1.default(0);
                explainedTxTotal[assetName] = amount.plus(output.amount);
            }
            if (!_.isEqual(explainedTxTotal, totalAmount)) {
                throw new Error('Tx total amount does not match with expected total amount field');
            }
        }
        // For non-consolidate transactions, feePayer must be the wallet's root address
        if (consolidateId === undefined && transactionJson.feePayer !== walletRootAddress) {
            throw new Error('Tx fee payer is not the wallet root address');
        }
        if (durableNonce && !_.isEqual(explainedTx.durableNonce, durableNonce)) {
            throw new Error('Tx durableNonce does not match with param durableNonce');
        }
        return true;
    }
    async isWalletAddress(params) {
        throw new sdk_core_1.MethodNotImplementedError();
    }
    /**
     * Generate Solana key pair
     *
     * @param {Buffer} seed - Seed from which the new SolKeyPair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed) {
        const result = seed ? new lib_1.KeyPair({ seed }).getKeys() : new lib_1.KeyPair().getKeys();
        return result;
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {string} pub the prv to be checked
     * @returns is it valid?
     */
    isValidPub(pub) {
        return (0, utils_1.isValidPublicKey)(pub);
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param {string} prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        return (0, utils_1.isValidPrivateKey)(prv);
    }
    isValidAddress(address) {
        return (0, utils_1.isValidAddress)(address);
    }
    async signMessage(key, message) {
        const solKeypair = new lib_1.KeyPair({ prv: key.prv });
        if (Buffer.isBuffer(message)) {
            message = base58.encode(message);
        }
        return Buffer.from(solKeypair.signMessage(message));
    }
    /**
     * Signs Solana transaction
     * @param params
     * @param callback
     */
    async signTransaction(params) {
        const factory = this.getBuilder();
        const rawTx = params.txPrebuild.txHex || params.txPrebuild.txBase64;
        const txBuilder = factory.from(rawTx);
        txBuilder.sign({ key: params.prv });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid transaction');
        }
        const serializedTx = transaction.toBroadcastFormat();
        return {
            txHex: serializedTx,
        };
    }
    async parseTransaction(params) {
        const transactionExplanation = await this.explainTransaction({
            txBase64: params.txBase64,
            feeInfo: params.feeInfo,
            tokenAccountRentExemptAmount: params.tokenAccountRentExemptAmount,
        });
        if (!transactionExplanation) {
            throw new Error('Invalid transaction');
        }
        const solTransaction = transactionExplanation;
        if (solTransaction.outputs.length <= 0) {
            return {
                inputs: [],
                outputs: [],
            };
        }
        const senderAddress = solTransaction.outputs[0].address;
        const feeAmount = new bignumber_js_1.default(solTransaction.fee.fee);
        // assume 1 sender, who is also the fee payer
        const inputs = [
            {
                address: senderAddress,
                amount: new bignumber_js_1.default(solTransaction.outputAmount).plus(feeAmount).toNumber(),
            },
        ];
        const outputs = solTransaction.outputs.map(({ address, amount, tokenName }) => {
            const output = { address, amount };
            if (tokenName) {
                output.tokenName = tokenName;
            }
            return output;
        });
        return {
            inputs,
            outputs,
        };
    }
    /**
     * Explain a Solana transaction from txBase64
     * @param params
     */
    async explainTransaction(params) {
        const factory = this.getBuilder();
        let rebuiltTransaction;
        try {
            const transactionBuilder = factory.from(params.txBase64);
            if (transactionBuilder instanceof lib_1.TransactionBuilder) {
                const txBuilder = transactionBuilder;
                txBuilder.fee({ amount: params.feeInfo.fee });
                if (params.tokenAccountRentExemptAmount) {
                    txBuilder.associatedTokenAccountRent(params.tokenAccountRentExemptAmount);
                }
            }
            rebuiltTransaction = await transactionBuilder.build();
        }
        catch (e) {
            console.log(e);
            throw new Error('Invalid transaction');
        }
        const explainedTransaction = rebuiltTransaction.explainTransaction();
        return explainedTransaction;
    }
    /** @inheritDoc */
    async getSignablePayload(serializedTx) {
        const factory = this.getBuilder();
        const rebuiltTransaction = await factory.from(serializedTx).build();
        return rebuiltTransaction.signablePayload;
    }
    /** @inheritDoc */
    async presignTransaction(params) {
        var _a, _b, _c;
        // Hot wallet txns are only valid for 1-2 minutes.
        // To buy more time, we rebuild the transaction with a new blockhash right before we sign.
        if (params.walletData.type !== 'hot') {
            return Promise.resolve(params);
        }
        const txRequestId = (_a = params.txPrebuild) === null || _a === void 0 ? void 0 : _a.txRequestId;
        if (txRequestId === undefined) {
            throw new Error('Missing txRequestId');
        }
        const { tssUtils } = params;
        await tssUtils.deleteSignatureShares(txRequestId);
        const recreated = await tssUtils.getTxRequest(txRequestId);
        let txHex = '';
        if (recreated.unsignedTxs) {
            txHex = (_b = recreated.unsignedTxs[0]) === null || _b === void 0 ? void 0 : _b.serializedTxHex;
        }
        else {
            txHex = recreated.transactions ? (_c = recreated.transactions[0]) === null || _c === void 0 ? void 0 : _c.unsignedTx.serializedTxHex : '';
        }
        if (!txHex) {
            throw new Error('Missing serialized tx hex');
        }
        return Promise.resolve({
            ...params,
            txPrebuild: recreated,
            txHex,
        });
    }
    getPublicNodeUrl() {
        return sdk_core_1.Environments[this.bitgo.getEnv()].solNodeUrl;
    }
    /**
     * Make a request to one of the public SOL nodes available
     * @param params.payload
     */
    async getDataFromNode(params) {
        const nodeUrl = this.getPublicNodeUrl();
        try {
            return await request.post(nodeUrl).send(params.payload);
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint: '/' from node: ${nodeUrl}`);
    }
    async getBlockhash() {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getLatestBlockhash',
                params: [
                    {
                        commitment: 'finalized',
                    },
                ],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.result.value.blockhash;
    }
    /** TODO Update to getFeeForMessage and make necssary changes in fee calculation, GetFees is deprecated */
    async getFees() {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getFees',
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.result.value.feeCalculator.lamportsPerSignature;
    }
    async getRentExemptAmount() {
        const response = await this.getDataFromNode({
            payload: {
                jsonrpc: '2.0',
                id: '1',
                method: 'getMinimumBalanceForRentExemption',
                params: [165],
            },
        });
        if (response.status !== 200 || response.error) {
            throw new Error(JSON.stringify(response.error));
        }
        return response.body.result;
    }
    async getAccountBalance(pubKey) {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getBalance',
                params: [pubKey],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.result.value;
    }
    async getAccountInfo(pubKey) {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getAccountInfo',
                params: [
                    pubKey,
                    {
                        encoding: 'jsonParsed',
                    },
                ],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return {
            authority: response.body.result.value.data.parsed.info.authority,
            blockhash: response.body.result.value.data.parsed.info.blockhash,
        };
    }
    async getTokenAccountsByOwner(pubKey = '') {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getTokenAccountsByOwner',
                params: [
                    pubKey,
                    {
                        programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
                    },
                    {
                        encoding: 'jsonParsed',
                    },
                ],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        if (response.body.result.value.length !== 0) {
            const tokenAccounts = [];
            for (const tokenAccount of response.body.result.value) {
                tokenAccounts.push({ info: tokenAccount.account.data.parsed.info, pubKey: tokenAccount.pubKey });
            }
            return tokenAccounts;
        }
        return [];
    }
    async getTokenAccountInfo(pubKey) {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getAccountInfo',
                params: [
                    pubKey,
                    {
                        encoding: 'jsonParsed',
                    },
                ],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return {
            pubKey: pubKey,
            info: response.body.result.value.data.parsed.info,
        };
    }
    /** inherited doc */
    async createBroadcastableSweepTransaction(params) {
        var _a;
        if (!params.signatureShares) {
            ('Missing transaction(s)');
        }
        const req = params.signatureShares;
        const broadcastableTransactions = [];
        let lastScanIndex = 0;
        for (let i = 0; i < req.length; i++) {
            const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
            const transaction = req[i].txRequest.transactions[0].unsignedTx;
            if (!req[i].ovc || !req[i].ovc[0].eddsaSignature) {
                throw new Error('Missing signature(s)');
            }
            const signature = req[i].ovc[0].eddsaSignature;
            if (!transaction.signableHex) {
                throw new Error('Missing signable hex');
            }
            const messageBuffer = Buffer.from(transaction.signableHex, 'hex');
            const result = MPC.verify(messageBuffer, signature);
            if (!result) {
                throw new Error('Invalid signature');
            }
            const signatureHex = Buffer.concat([Buffer.from(signature.R, 'hex'), Buffer.from(signature.sigma, 'hex')]);
            const txBuilder = this.getBuilder().from(transaction.serializedTx);
            if (!((_a = transaction.coinSpecific) === null || _a === void 0 ? void 0 : _a.commonKeychain)) {
                throw new Error('Missing common keychain');
            }
            const commonKeychain = transaction.coinSpecific.commonKeychain;
            if (!transaction.derivationPath) {
                throw new Error('Missing derivation path');
            }
            const derivationPath = transaction.derivationPath;
            const accountId = MPC.deriveUnhardened(commonKeychain, derivationPath).slice(0, 64);
            const bs58EncodedPublicKey = new lib_1.KeyPair({ pub: accountId }).getAddress();
            // add combined signature from ovc
            const publicKeyObj = { pub: bs58EncodedPublicKey };
            txBuilder.addSignature(publicKeyObj, signatureHex);
            const signedTransaction = await txBuilder.build();
            const serializedTx = signedTransaction.toBroadcastFormat();
            broadcastableTransactions.push({
                serializedTx: serializedTx,
                scanIndex: transaction.scanIndex,
            });
            if (i === req.length - 1 && transaction.coinSpecific.lastScanIndex) {
                lastScanIndex = transaction.coinSpecific.lastScanIndex;
            }
        }
        return { transactions: broadcastableTransactions, lastScanIndex };
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {SolRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {MPCTx | MPCSweepTxs} the serialized transaction hex string and index
     * of the address being swept
     */
    async recover(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        // Build the transaction
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        let balance = 0;
        const feePerSignature = await this.getFees();
        const baseFee = params.durableNonce ? feePerSignature * 2 : feePerSignature;
        let totalFee = new bignumber_js_1.default(baseFee);
        const index = params.index || 0;
        const currPath = params.seed ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${index}` : `m/${index}`;
        const accountId = MPC.deriveUnhardened(bitgoKey, currPath).slice(0, 64);
        const bs58EncodedPublicKey = new lib_1.KeyPair({ pub: accountId }).getAddress();
        balance = await this.getAccountBalance(bs58EncodedPublicKey);
        if (totalFee.gt(balance)) {
            throw Error('Did not find address with funds to recover');
        }
        const factory = this.getBuilder();
        const walletCoin = this.getChain();
        let txBuilder;
        let blockhash = await this.getBlockhash();
        let rentExemptAmount;
        let authority = '';
        if (params.durableNonce) {
            const durableNonceInfo = await this.getAccountInfo(params.durableNonce.publicKey);
            blockhash = durableNonceInfo.blockhash;
            authority = durableNonceInfo.authority;
        }
        // check for possible token recovery, recover the token provide by user
        if (params.tokenContractAddress) {
            const tokenAccounts = await this.getTokenAccountsByOwner(bs58EncodedPublicKey);
            if (tokenAccounts.length !== 0) {
                // there exists token accounts on the given address, but need to check certain conditions:
                // 1. if there is a recoverable balance
                // 2. if the token is supported by bitgo
                const recovereableTokenAccounts = [];
                for (const tokenAccount of tokenAccounts) {
                    if (params.tokenContractAddress === tokenAccount.info.mint) {
                        const tokenAmount = new bignumber_js_1.default(tokenAccount.info.tokenAmount.amount);
                        const network = this.getNetwork();
                        const token = (0, utils_1.getSolTokenFromAddress)(tokenAccount.info.mint, network);
                        if (!_.isUndefined(token) && tokenAmount.gt(new bignumber_js_1.default(0))) {
                            tokenAccount.tokenName = token.name;
                            recovereableTokenAccounts.push(tokenAccount);
                        }
                        break;
                    }
                }
                if (recovereableTokenAccounts.length !== 0) {
                    rentExemptAmount = await this.getRentExemptAmount();
                    txBuilder = factory
                        .getTokenTransferBuilder()
                        .nonce(blockhash)
                        .sender(bs58EncodedPublicKey)
                        .fee({ amount: feePerSignature })
                        .associatedTokenAccountRent(rentExemptAmount.toString())
                        .feePayer(bs58EncodedPublicKey);
                    // need to get all token accounts of the recipient address and need to create them if they do not exist
                    const recipientTokenAccounts = await this.getTokenAccountsByOwner(params.recoveryDestination);
                    for (const tokenAccount of recovereableTokenAccounts) {
                        let recipientTokenAccountExists = false;
                        for (const recipientTokenAccount of recipientTokenAccounts) {
                            if (recipientTokenAccount.info.mint === tokenAccount.info.mint) {
                                recipientTokenAccountExists = true;
                                break;
                            }
                        }
                        const recipientTokenAccount = await (0, utils_1.getAssociatedTokenAccountAddress)(tokenAccount.info.mint, params.recoveryDestination);
                        const tokenName = tokenAccount.tokenName;
                        txBuilder.send({
                            address: recipientTokenAccount,
                            amount: tokenAccount.info.tokenAmount.amount,
                            tokenName: tokenName,
                        });
                        if (!recipientTokenAccountExists) {
                            // recipient token account does not exist for token and must be created
                            txBuilder.createAssociatedTokenAccount({
                                ownerAddress: params.recoveryDestination,
                                tokenName: tokenName,
                            });
                            // add rent exempt amount to total fee for each token account that has to be created
                            totalFee = totalFee.plus(rentExemptAmount);
                        }
                    }
                    // there are recoverable token accounts, need to check if there is sufficient native solana to recover tokens
                    if (new bignumber_js_1.default(balance).lt(totalFee)) {
                        throw Error('Not enough funds to pay for recover tokens fees, have: ' + balance + ' need: ' + totalFee.toString());
                    }
                }
                else {
                    throw Error('Not enough token funds to recover');
                }
            }
            else {
                // there are no recoverable token accounts , need to check if there are tokens to recover
                throw Error('Did not find token account to recover tokens, please check token account');
            }
        }
        else {
            const netAmount = new bignumber_js_1.default(balance).minus(totalFee);
            txBuilder = factory
                .getTransferBuilder()
                .nonce(blockhash)
                .sender(bs58EncodedPublicKey)
                .send({ address: params.recoveryDestination, amount: netAmount.toString() })
                .fee({ amount: feePerSignature })
                .feePayer(bs58EncodedPublicKey);
        }
        if (params.durableNonce) {
            txBuilder.nonce(blockhash, {
                walletNonceAddress: params.durableNonce.publicKey,
                authWalletAddress: authority,
            });
        }
        if (!isUnsignedSweep) {
            // Sign the txn
            if (!params.userKey) {
                throw new Error('missing userKey');
            }
            if (!params.backupKey) {
                throw new Error('missing backupKey');
            }
            if (!params.walletPassphrase) {
                throw new Error('missing wallet passphrase');
            }
            const unsignedTransaction = (await txBuilder.build());
            const userKey = params.userKey.replace(/\s/g, '');
            const backupKey = params.backupKey.replace(/\s/g, '');
            // Decrypt private keys from KeyCard values
            let userPrv;
            try {
                userPrv = this.bitgo.decrypt({
                    input: userKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting user keychain: ${e.message}`);
            }
            const userSigningMaterial = JSON.parse(userPrv);
            let backupPrv;
            try {
                backupPrv = this.bitgo.decrypt({
                    input: backupKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting backup keychain: ${e.message}`);
            }
            const backupSigningMaterial = JSON.parse(backupPrv);
            const signatureHex = await sdk_core_1.EDDSAMethods.getTSSSignature(userSigningMaterial, backupSigningMaterial, currPath, unsignedTransaction);
            const publicKeyObj = { pub: bs58EncodedPublicKey };
            txBuilder.addSignature(publicKeyObj, signatureHex);
        }
        if (params.durableNonce) {
            // add durable nonce account signature
            txBuilder.sign({ key: params.durableNonce.secretKey });
        }
        const completedTransaction = await txBuilder.build();
        const serializedTx = completedTransaction.toBroadcastFormat();
        const derivationPath = params.seed ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${index}` : `m/${index}`;
        const inputs = [];
        for (const input of completedTransaction.inputs) {
            inputs.push({
                address: input.address,
                valueString: input.value,
                value: new bignumber_js_1.default(input.value).toNumber(),
            });
        }
        const outputs = [];
        for (const output of completedTransaction.outputs) {
            outputs.push({
                address: output.address,
                valueString: output.value,
                coinName: output.coin ? output.coin : walletCoin,
            });
        }
        const spendAmount = completedTransaction.inputs.length === 1 ? completedTransaction.inputs[0].value : 0;
        const parsedTx = { inputs: inputs, outputs: outputs, spendAmount: spendAmount, type: '' };
        const feeInfo = { fee: totalFee.toNumber(), feeString: totalFee.toString() };
        const coinSpecific = { commonKeychain: bitgoKey };
        if (isUnsignedSweep) {
            const transaction = {
                serializedTx: serializedTx,
                scanIndex: index,
                coin: walletCoin,
                signableHex: completedTransaction.signablePayload.toString('hex'),
                derivationPath: derivationPath,
                parsedTx: parsedTx,
                feeInfo: feeInfo,
                coinSpecific: coinSpecific,
            };
            const unsignedTx = { unsignedTx: transaction, signatureShares: [] };
            const transactions = [unsignedTx];
            const txRequest = {
                transactions: transactions,
                walletCoin: walletCoin,
            };
            const txRequests = { txRequests: [txRequest] };
            return txRequests;
        }
        const transaction = {
            serializedTx: serializedTx,
            scanIndex: index,
        };
        return transaction;
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {SolRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {BaseBroadcastTransactionResult[]} the serialized transaction hex string and index
     * of the address being swept
     */
    async recoverCloseATA(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        if (!params.closeAtaAddress || !this.isValidAddress(params.closeAtaAddress)) {
            throw new Error('invalid closeAtaAddress');
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        // Build the transaction
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        let balance = 0;
        const feePerSignature = await this.getFees();
        const baseFee = params.durableNonce ? feePerSignature * 2 : feePerSignature;
        const totalFee = new bignumber_js_1.default(baseFee);
        const index = params.index || 0;
        const currPath = params.seed ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${index}` : `m/${index}`;
        const accountId = MPC.deriveUnhardened(bitgoKey, currPath).slice(0, 64);
        const bs58EncodedPublicKey = new lib_1.KeyPair({ pub: accountId }).getAddress();
        balance = await this.getAccountBalance(bs58EncodedPublicKey);
        if (totalFee.gt(balance)) {
            throw Error('Did not find address with funds to recover');
        }
        balance = await this.getAccountBalance(params.closeAtaAddress);
        if (balance <= 0) {
            throw Error('Did not find closeAtaAddress with sol funds to recover');
        }
        const factory = this.getBuilder();
        let txBuilder;
        let blockhash;
        const recovertTxns = [];
        const rentExemptAmount = await this.getRentExemptAmount();
        // do token recovery before closing ATA address
        // check if any token is present on the closeAtaAddress
        const tokenInfo = await this.getTokenAccountInfo(params.closeAtaAddress);
        const tokenBalance = Number(tokenInfo.info.tokenAmount.amount);
        if (tokenBalance > 0) {
            // closeATA address has some token balance, it needs to be withdrawn before closing ATA
            console.log(`closeATA address ${params.closeAtaAddress} has token balance ${tokenBalance}, it needs to be withdrawn before closing ATA address`);
            if (!params.recoveryDestinationAtaAddress || !this.isValidAddress(params.recoveryDestinationAtaAddress)) {
                throw new Error('invalid recoveryDestinationAtaAddress');
            }
            blockhash = await this.getBlockhash();
            txBuilder = factory
                .getTokenTransferBuilder()
                .nonce(blockhash)
                .sender(bs58EncodedPublicKey)
                .fee({ amount: feePerSignature })
                .associatedTokenAccountRent(rentExemptAmount.toString())
                .feePayer(bs58EncodedPublicKey);
            const network = this.getNetwork();
            const token = (0, utils_1.getSolTokenFromAddress)(tokenInfo.info.mint, network);
            txBuilder.send({
                address: params.recoveryDestinationAtaAddress,
                amount: tokenBalance,
                tokenName: token === null || token === void 0 ? void 0 : token.name,
            });
            const tokenRecoveryTxn = await this.signAndGenerateBroadcastableTransaction(params, txBuilder, bs58EncodedPublicKey);
            const serializedTokenRecoveryTxn = (await tokenRecoveryTxn).serializedTx;
            const broadcastTokenRecoveryTxn = await this.broadcastTransaction({
                serializedSignedTransaction: serializedTokenRecoveryTxn,
            });
            console.log(broadcastTokenRecoveryTxn);
            recovertTxns.push(broadcastTokenRecoveryTxn);
        }
        // after recovering the token amount, attempting to close the ATA address
        if (params.closeAtaAddress) {
            blockhash = await this.getBlockhash();
            const ataCloseBuilder = () => {
                var _a;
                const txBuilder = factory.getCloseAtaInitializationBuilder();
                txBuilder.nonce(blockhash);
                txBuilder.sender(bs58EncodedPublicKey);
                txBuilder.accountAddress((_a = params.closeAtaAddress) !== null && _a !== void 0 ? _a : '');
                txBuilder.destinationAddress(params.recoveryDestination);
                txBuilder.authorityAddress(bs58EncodedPublicKey);
                txBuilder.associatedTokenAccountRent(rentExemptAmount.toString());
                return txBuilder;
            };
            txBuilder = ataCloseBuilder();
        }
        const closeATARecoveryTxn = await this.signAndGenerateBroadcastableTransaction(params, txBuilder, bs58EncodedPublicKey);
        const serializedCloseATARecoveryTxn = (await closeATARecoveryTxn).serializedTx;
        const broadcastCloseATARecoveryTxn = await this.broadcastTransaction({
            serializedSignedTransaction: serializedCloseATARecoveryTxn,
        });
        console.log(broadcastCloseATARecoveryTxn);
        recovertTxns.push(broadcastCloseATARecoveryTxn);
        return recovertTxns;
    }
    async signAndGenerateBroadcastableTransaction(params, txBuilder, bs58EncodedPublicKey) {
        // Sign the txn
        if (!params.userKey) {
            throw new Error('missing userKey');
        }
        if (!params.backupKey) {
            throw new Error('missing backupKey');
        }
        if (!params.walletPassphrase) {
            throw new Error('missing wallet passphrase');
        }
        const unsignedTransaction = (await txBuilder.build());
        const userKey = params.userKey.replace(/\s/g, '');
        const backupKey = params.backupKey.replace(/\s/g, '');
        // Decrypt private keys from KeyCard values
        let userPrv;
        try {
            userPrv = this.bitgo.decrypt({
                input: userKey,
                password: params.walletPassphrase,
            });
        }
        catch (e) {
            throw new Error(`Error decrypting user keychain: ${e.message}`);
        }
        const userSigningMaterial = JSON.parse(userPrv);
        let backupPrv;
        try {
            backupPrv = this.bitgo.decrypt({
                input: backupKey,
                password: params.walletPassphrase,
            });
        }
        catch (e) {
            throw new Error(`Error decrypting backup keychain: ${e.message}`);
        }
        const backupSigningMaterial = JSON.parse(backupPrv);
        const index = params.index || 0;
        const currPath = params.seed ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${index}` : `m/${index}`;
        const signatureHex = await sdk_core_1.EDDSAMethods.getTSSSignature(userSigningMaterial, backupSigningMaterial, currPath, unsignedTransaction);
        const publicKeyObj = { pub: bs58EncodedPublicKey };
        txBuilder.addSignature(publicKeyObj, signatureHex);
        const completedTransaction = await txBuilder.build();
        const serializedTx = completedTransaction.toBroadcastFormat();
        const transaction = {
            serializedTx: serializedTx,
            scanIndex: index,
        };
        return transaction;
    }
    /**
     * Builds native SOL recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     *
     * @param {SolConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    async recoverConsolidations(params) {
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        const startIdx = params.startingScanIndex || 1;
        const endIdx = params.endingScanIndex || startIdx + exports.DEFAULT_SCAN_FACTOR;
        if (startIdx < 1 || endIdx <= startIdx || endIdx - startIdx > 10 * exports.DEFAULT_SCAN_FACTOR) {
            throw new Error(`Invalid starting or ending index to scan for addresses. startingScanIndex: ${startIdx}, endingScanIndex: ${endIdx}.`);
        }
        // validate durable nonces array
        if (!params.durableNonces) {
            throw new Error('Missing durable nonces');
        }
        if (!params.durableNonces.publicKeys) {
            throw new Error('Invalid durable nonces: missing public keys');
        }
        if (!params.durableNonces.secretKey) {
            throw new Error('Invalid durable nonces array: missing secret key');
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        const baseAddressIndex = 0;
        const baseAddressPath = params.seed
            ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${baseAddressIndex}`
            : `m/${baseAddressIndex}`;
        const accountId = MPC.deriveUnhardened(bitgoKey, baseAddressPath).slice(0, 64);
        const baseAddress = new lib_1.KeyPair({ pub: accountId }).getAddress();
        let durableNoncePubKeysIndex = 0;
        const durableNoncePubKeysLength = params.durableNonces.publicKeys.length;
        const consolidationTransactions = [];
        let lastScanIndex = startIdx;
        for (let i = startIdx; i < endIdx; i++) {
            const recoverParams = {
                userKey: params.userKey,
                backupKey: params.backupKey,
                bitgoKey: params.bitgoKey,
                walletPassphrase: params.walletPassphrase,
                recoveryDestination: baseAddress,
                seed: params.seed,
                index: i,
                durableNonce: {
                    publicKey: params.durableNonces.publicKeys[durableNoncePubKeysIndex],
                    secretKey: params.durableNonces.secretKey,
                },
                tokenContractAddress: params.tokenContractAddress,
            };
            let recoveryTransaction;
            try {
                recoveryTransaction = await this.recover(recoverParams);
            }
            catch (e) {
                if (e.message === 'Did not find address with funds to recover' ||
                    e.message === 'Did not find token account to recover tokens, please check token account' ||
                    e.message === 'Not enough token funds to recover') {
                    lastScanIndex = i;
                    continue;
                }
                throw e;
            }
            if (isUnsignedSweep) {
                consolidationTransactions.push(recoveryTransaction.txRequests[0]);
            }
            else {
                consolidationTransactions.push(recoveryTransaction);
            }
            lastScanIndex = i;
            durableNoncePubKeysIndex++;
            if (durableNoncePubKeysIndex >= durableNoncePubKeysLength) {
                // no more available nonce accounts to create transactions
                break;
            }
        }
        if (consolidationTransactions.length === 0) {
            throw new Error('Did not find an address with funds to recover');
        }
        if (isUnsignedSweep) {
            // lastScanIndex will be used to inform user the last address index scanned for available funds (so they can
            // appropriately adjust the scan range on the next iteration of consolidation recoveries). In the case of unsigned
            // sweep consolidations, this lastScanIndex will be provided in the coinSpecific of the last txn made.
            const lastTransactionCoinSpecific = {
                commonKeychain: consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific
                    .commonKeychain,
                lastScanIndex: lastScanIndex,
            };
            consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific =
                lastTransactionCoinSpecific;
            const consolidationSweepTransactions = { txRequests: consolidationTransactions };
            return consolidationSweepTransactions;
        }
        return { transactions: consolidationTransactions, lastScanIndex };
    }
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: true,
            supportsMultipleTokenEnablements: true,
        };
    }
    getBuilder() {
        return new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
    }
    async broadcastTransaction({ serializedSignedTransaction, }) {
        (0, utils_1.validateRawTransaction)(serializedSignedTransaction, true, true);
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'sendTransaction',
                params: [
                    serializedSignedTransaction,
                    {
                        encoding: 'base64',
                    },
                ],
            },
        });
        if (response.body.error) {
            throw new Error('Error broadcasting transaction: ' + response.body.error.message);
        }
        return { txId: response.body.result };
    }
}
exports.Sol = Sol;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29sLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsZ0VBQXFDO0FBQ3JDLDZDQUErQjtBQUUvQiw4Q0FtQ3lCO0FBQ3pCLG9EQUF1RDtBQUN2RCw0Q0FBNkY7QUFDN0YsMENBQTRCO0FBQzVCLG9EQUFzQztBQUN0QywrQkFBMEc7QUFDMUcsdUNBUXFCO0FBQ1IsUUFBQSxtQkFBbUIsR0FBRyxFQUFFLENBQUMsQ0FBQyx3REFBd0Q7QUEwRy9GLE1BQU0sU0FBUyxHQUFHLGdCQUFnQixDQUFDO0FBRW5DLE1BQWEsR0FBSSxTQUFRLG1CQUFRO0lBRy9CLFlBQVksS0FBZ0IsRUFBRSxXQUF1QztRQUNuRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWdCLEVBQUUsV0FBdUM7UUFDN0UsT0FBTyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELDJCQUEyQjtRQUN6QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsZUFBZTtRQUNiLE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDbEMsQ0FBQztJQUVELFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDO0lBQ3BDLENBQUM7SUFFRCxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQztJQUNuQyxDQUFDO0lBRUQsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsS0FBSyxDQUFDLGlCQUFpQixDQUFDLE1BQW1DOztRQUN6RCxvQ0FBb0M7UUFDcEMsTUFBTSxXQUFXLEdBQThCLEVBQUUsQ0FBQztRQUNsRCxNQUFNLFVBQVUsR0FBRyxlQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQzlDLE1BQU0sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLEdBQUcsTUFBTSxDQUFDO1FBQ3RHLE1BQU0sV0FBVyxHQUFHLElBQUksaUJBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNoRCxNQUFNLEtBQUssR0FBRyxVQUFVLENBQUMsUUFBUSxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUM7UUFDdEQsTUFBTSxhQUFhLEdBQUcsVUFBVSxDQUFDLGFBQWEsQ0FBQztRQUUvQyxNQUFNLGlCQUFpQixHQUFHLE1BQUEsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsMENBQUUsV0FBVyxDQUFDO1FBRXBFLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDVixNQUFNLElBQUksS0FBSyxDQUFDLHlEQUF5RCxDQUFDLENBQUM7U0FDNUU7UUFFRCxJQUFJLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFDeEIsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3pCLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDNUQ7UUFDRCxXQUFXLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDNUMsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFFckQsK0ZBQStGO1FBQy9GLElBQUksUUFBUSxDQUFDLFVBQVUsS0FBSyxTQUFTLEVBQUU7WUFDckMsTUFBTSxrQkFBa0IsR0FBRyxNQUFBLFFBQVEsQ0FBQyxVQUFVLDBDQUFFLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQ2hFLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsU0FBUyxFQUFFLFFBQVEsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUN0RCxDQUFDO1lBQ0YsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsU0FBUyxFQUFFLFFBQVEsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFaEgsSUFBSSxrQkFBa0IsQ0FBQyxNQUFNLEtBQUssZUFBZSxDQUFDLE1BQU0sRUFBRTtnQkFDeEQsTUFBTSxJQUFJLEtBQUssQ0FBQyx3RUFBd0UsQ0FBQyxDQUFDO2FBQzNGO1lBRUQsNEVBQTRFO1lBQzVFLHFHQUFxRztZQUNyRyxpR0FBaUc7WUFDakcsTUFBTSxlQUFlLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUN2QyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLGlCQUFpQixFQUFFLEtBQUssRUFBRSxFQUFFO2dCQUN4RCxNQUFNLGVBQWUsR0FBRyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxnQ0FBZ0M7Z0JBRWhGLG1FQUFtRTtnQkFDbkUsTUFBTSxVQUFVLEdBQUcsSUFBSSxzQkFBUyxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUMzRCxNQUFNLFFBQVEsR0FBRyxJQUFJLHNCQUFTLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUN2RCxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsRUFBRTtvQkFDbkMsT0FBTyxLQUFLLENBQUM7aUJBQ2Q7Z0JBRUQsdUNBQXVDO2dCQUN2QywyRUFBMkU7Z0JBQzNFLElBQ0UsaUJBQWlCLENBQUMsT0FBTyxLQUFLLGVBQWUsQ0FBQyxPQUFPO29CQUNyRCxpQkFBaUIsQ0FBQyxTQUFTLEtBQUssZUFBZSxDQUFDLFNBQVMsRUFDekQ7b0JBQ0EsT0FBTyxJQUFJLENBQUM7aUJBQ2I7cUJBQU0sSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLEtBQUssZUFBZSxDQUFDLE9BQU8sSUFBSSxpQkFBaUIsQ0FBQyxTQUFTLEVBQUU7b0JBQy9GLDhFQUE4RTtvQkFDOUUsOEdBQThHO29CQUM5Ryx1REFBdUQ7b0JBQ3ZELElBQUk7d0JBQ0YsTUFBTSxnQkFBZ0IsR0FBRyxJQUFBLGdDQUF3QixFQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO3dCQUMvRSxPQUFPLElBQUEsd0NBQWdDLEVBQUMsZ0JBQWlCLENBQUMsWUFBWSxFQUFFLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FDckcsQ0FBQyxHQUFXLEVBQUUsRUFBRTs0QkFDZCxPQUFPLEdBQUcsS0FBSyxlQUFlLENBQUMsT0FBTyxDQUFDO3dCQUN6QyxDQUFDLENBQ0YsQ0FBQztxQkFDSDtvQkFBQyxNQUFNO3dCQUNOLHVCQUF1Qjt3QkFDdkIsT0FBTyxLQUFLLENBQUM7cUJBQ2Q7aUJBQ0Y7Z0JBQ0QsT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDLENBQUMsQ0FDSCxDQUFDO1lBRUYsSUFBSSxlQUFlLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLDZEQUE2RCxDQUFDLENBQUM7YUFDaEY7U0FDRjtRQUVELE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUM3QyxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLFdBQVcsQ0FBQyxJQUFJLEVBQUU7WUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO1NBQ2pGO1FBQ0QsSUFBSSxRQUFRLENBQUMsVUFBVSxFQUFFO1lBQ3ZCLEtBQUssTUFBTSxVQUFVLElBQUksUUFBUSxDQUFDLFVBQVUsRUFBRTtnQkFDNUMsa0NBQWtDO2dCQUNsQyxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDMUQsTUFBTSxNQUFNLEdBQUcsV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLElBQUksc0JBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDMUQsV0FBVyxDQUFDLFNBQVMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3pEO1lBRUQsdUNBQXVDO1lBQ3ZDLE1BQU0sZ0JBQWdCLEdBQThCLEVBQUUsQ0FBQztZQUV2RCxLQUFLLE1BQU0sTUFBTSxJQUFJLFdBQVcsQ0FBQyxPQUFPLEVBQUU7Z0JBQ3hDLDBDQUEwQztnQkFDMUMsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ3RELE1BQU0sTUFBTSxHQUFHLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxJQUFJLElBQUksc0JBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0QsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDMUQ7WUFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxXQUFXLENBQUMsRUFBRTtnQkFDN0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxpRUFBaUUsQ0FBQyxDQUFDO2FBQ3BGO1NBQ0Y7UUFFRCwrRUFBK0U7UUFDL0UsSUFBSSxhQUFhLEtBQUssU0FBUyxJQUFJLGVBQWUsQ0FBQyxRQUFRLEtBQUssaUJBQWlCLEVBQUU7WUFDakYsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO1NBQ2hFO1FBRUQsSUFBSSxZQUFZLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLEVBQUU7WUFDdEUsTUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO1NBQzNFO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUE0QjtRQUNoRCxNQUFNLElBQUksb0NBQXlCLEVBQUUsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxlQUFlLENBQUMsSUFBeUI7UUFDdkMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLGFBQVUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksYUFBVSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEYsT0FBTyxNQUFpQixDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFVBQVUsQ0FBQyxHQUFXO1FBQ3BCLE9BQU8sSUFBQSx3QkFBZ0IsRUFBQyxHQUFHLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxVQUFVLENBQUMsR0FBVztRQUNwQixPQUFPLElBQUEseUJBQWlCLEVBQUMsR0FBRyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVELGNBQWMsQ0FBQyxPQUFlO1FBQzVCLE9BQU8sSUFBQSxzQkFBYyxFQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxLQUFLLENBQUMsV0FBVyxDQUFDLEdBQVksRUFBRSxPQUF3QjtRQUN0RCxNQUFNLFVBQVUsR0FBRyxJQUFJLGFBQVUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUNwRCxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDNUIsT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDbEM7UUFFRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUFpQztRQUNyRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEMsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7UUFDcEUsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0QyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sV0FBVyxHQUFvQixNQUFNLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUU3RCxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUN4QztRQUVELE1BQU0sWUFBWSxHQUFJLFdBQStCLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUUxRSxPQUFPO1lBQ0wsS0FBSyxFQUFFLFlBQVk7U0FDYixDQUFDO0lBQ1gsQ0FBQztJQUVELEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFrQztRQUN2RCxNQUFNLHNCQUFzQixHQUFHLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDO1lBQzNELFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUTtZQUN6QixPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU87WUFDdkIsNEJBQTRCLEVBQUUsTUFBTSxDQUFDLDRCQUE0QjtTQUNsRSxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsc0JBQXNCLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1NBQ3hDO1FBRUQsTUFBTSxjQUFjLEdBQUcsc0JBQW1ELENBQUM7UUFDM0UsSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7WUFDdEMsT0FBTztnQkFDTCxNQUFNLEVBQUUsRUFBRTtnQkFDVixPQUFPLEVBQUUsRUFBRTthQUNaLENBQUM7U0FDSDtRQUVELE1BQU0sYUFBYSxHQUFHLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO1FBQ3hELE1BQU0sU0FBUyxHQUFHLElBQUksc0JBQVMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXhELDZDQUE2QztRQUM3QyxNQUFNLE1BQU0sR0FBRztZQUNiO2dCQUNFLE9BQU8sRUFBRSxhQUFhO2dCQUN0QixNQUFNLEVBQUUsSUFBSSxzQkFBUyxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxFQUFFO2FBQzlFO1NBQ0YsQ0FBQztRQUVGLE1BQU0sT0FBTyxHQUF3QixjQUFjLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsRUFBRSxFQUFFO1lBQ2pHLE1BQU0sTUFBTSxHQUFzQixFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQztZQUN0RCxJQUFJLFNBQVMsRUFBRTtnQkFDYixNQUFNLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQzthQUM5QjtZQUNELE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTztZQUNMLE1BQU07WUFDTixPQUFPO1NBQ1IsQ0FBQztJQUNKLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsa0JBQWtCLENBQUMsTUFBaUM7UUFDeEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2xDLElBQUksa0JBQWtCLENBQUM7UUFFdkIsSUFBSTtZQUNGLE1BQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDekQsSUFBSSxrQkFBa0IsWUFBWSx3QkFBa0IsRUFBRTtnQkFDcEQsTUFBTSxTQUFTLEdBQUcsa0JBQXdDLENBQUM7Z0JBQzNELFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUM5QyxJQUFJLE1BQU0sQ0FBQyw0QkFBNEIsRUFBRTtvQkFDdkMsU0FBUyxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO2lCQUMzRTthQUNGO1lBQ0Qsa0JBQWtCLEdBQUcsTUFBTSxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUN2RDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUN4QztRQUVELE1BQU0sb0JBQW9CLEdBQUksa0JBQXNDLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUUxRixPQUFPLG9CQUFpRCxDQUFDO0lBQzNELENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsS0FBSyxDQUFDLGtCQUFrQixDQUFDLFlBQW9CO1FBQzNDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNsQyxNQUFNLGtCQUFrQixHQUFHLE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNwRSxPQUFPLGtCQUFrQixDQUFDLGVBQWUsQ0FBQztJQUM1QyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxNQUFpQzs7UUFDeEQsa0RBQWtEO1FBQ2xELDBGQUEwRjtRQUMxRixJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxLQUFLLEtBQUssRUFBRTtZQUNwQyxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDaEM7UUFFRCxNQUFNLFdBQVcsR0FBRyxNQUFBLE1BQU0sQ0FBQyxVQUFVLDBDQUFFLFdBQVcsQ0FBQztRQUNuRCxJQUFJLFdBQVcsS0FBSyxTQUFTLEVBQUU7WUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1NBQ3hDO1FBRUQsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE1BQU0sQ0FBQztRQUU1QixNQUFNLFFBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNuRCxNQUFNLFNBQVMsR0FBRyxNQUFNLFFBQVMsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDNUQsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ2YsSUFBSSxTQUFTLENBQUMsV0FBVyxFQUFFO1lBQ3pCLEtBQUssR0FBRyxNQUFBLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLDBDQUFFLGVBQWUsQ0FBQztTQUNuRDthQUFNO1lBQ0wsS0FBSyxHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLE1BQUEsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsMENBQUUsVUFBVSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1NBQzdGO1FBRUQsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztTQUM5QztRQUVELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQztZQUNyQixHQUFHLE1BQU07WUFDVCxVQUFVLEVBQUUsU0FBUztZQUNyQixLQUFLO1NBQ04sQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVTLGdCQUFnQjtRQUN4QixPQUFPLHVCQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7OztPQUdHO0lBQ08sS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUE2QztRQUMzRSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN4QyxJQUFJO1lBQ0YsT0FBTyxNQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN6RDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNsQjtRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVTLEtBQUssQ0FBQyxZQUFZO1FBQzFCLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQztZQUMxQyxPQUFPLEVBQUU7Z0JBQ1AsRUFBRSxFQUFFLEdBQUc7Z0JBQ1AsT0FBTyxFQUFFLEtBQUs7Z0JBQ2QsTUFBTSxFQUFFLG9CQUFvQjtnQkFDNUIsTUFBTSxFQUFFO29CQUNOO3dCQUNFLFVBQVUsRUFBRSxXQUFXO3FCQUN4QjtpQkFDRjthQUNGO1NBQ0YsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDdEM7UUFFRCxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7SUFDOUMsQ0FBQztJQUVELDBHQUEwRztJQUNoRyxLQUFLLENBQUMsT0FBTztRQUNyQixNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDMUMsT0FBTyxFQUFFO2dCQUNQLEVBQUUsRUFBRSxHQUFHO2dCQUNQLE9BQU8sRUFBRSxLQUFLO2dCQUNkLE1BQU0sRUFBRSxTQUFTO2FBQ2xCO1NBQ0YsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDdEM7UUFFRCxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsb0JBQW9CLENBQUM7SUFDdkUsQ0FBQztJQUVTLEtBQUssQ0FBQyxtQkFBbUI7UUFDakMsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQzFDLE9BQU8sRUFBRTtnQkFDUCxPQUFPLEVBQUUsS0FBSztnQkFDZCxFQUFFLEVBQUUsR0FBRztnQkFDUCxNQUFNLEVBQUUsbUNBQW1DO2dCQUMzQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUM7YUFDZDtTQUNGLENBQUMsQ0FBQztRQUNILElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxHQUFHLElBQUksUUFBUSxDQUFDLEtBQUssRUFBRTtZQUM3QyxNQUFNLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDakQ7UUFFRCxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQzlCLENBQUM7SUFFUyxLQUFLLENBQUMsaUJBQWlCLENBQUMsTUFBYztRQUM5QyxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDMUMsT0FBTyxFQUFFO2dCQUNQLEVBQUUsRUFBRSxHQUFHO2dCQUNQLE9BQU8sRUFBRSxLQUFLO2dCQUNkLE1BQU0sRUFBRSxZQUFZO2dCQUNwQixNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUM7YUFDakI7U0FDRixDQUFDLENBQUM7UUFDSCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssR0FBRyxFQUFFO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztTQUN0QztRQUNELE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ3BDLENBQUM7SUFFUyxLQUFLLENBQUMsY0FBYyxDQUFDLE1BQWM7UUFDM0MsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQzFDLE9BQU8sRUFBRTtnQkFDUCxFQUFFLEVBQUUsR0FBRztnQkFDUCxPQUFPLEVBQUUsS0FBSztnQkFDZCxNQUFNLEVBQUUsZ0JBQWdCO2dCQUN4QixNQUFNLEVBQUU7b0JBQ04sTUFBTTtvQkFDTjt3QkFDRSxRQUFRLEVBQUUsWUFBWTtxQkFDdkI7aUJBQ0Y7YUFDRjtTQUNGLENBQUMsQ0FBQztRQUNILElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3RDO1FBQ0QsT0FBTztZQUNMLFNBQVMsRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUztZQUNoRSxTQUFTLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVM7U0FDakUsQ0FBQztJQUNKLENBQUM7SUFFUyxLQUFLLENBQUMsdUJBQXVCLENBQUMsTUFBTSxHQUFHLEVBQUU7UUFDakQsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQzFDLE9BQU8sRUFBRTtnQkFDUCxFQUFFLEVBQUUsR0FBRztnQkFDUCxPQUFPLEVBQUUsS0FBSztnQkFDZCxNQUFNLEVBQUUseUJBQXlCO2dCQUNqQyxNQUFNLEVBQUU7b0JBQ04sTUFBTTtvQkFDTjt3QkFDRSxTQUFTLEVBQUUsNkNBQTZDO3FCQUN6RDtvQkFDRDt3QkFDRSxRQUFRLEVBQUUsWUFBWTtxQkFDdkI7aUJBQ0Y7YUFDRjtTQUNGLENBQUMsQ0FBQztRQUNILElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3RDO1FBRUQsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMzQyxNQUFNLGFBQWEsR0FBbUIsRUFBRSxDQUFDO1lBQ3pDLEtBQUssTUFBTSxZQUFZLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFO2dCQUNyRCxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLFlBQVksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO2FBQ2xHO1lBQ0QsT0FBTyxhQUFhLENBQUM7U0FDdEI7UUFFRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFUyxLQUFLLENBQUMsbUJBQW1CLENBQUMsTUFBYztRQUNoRCxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDMUMsT0FBTyxFQUFFO2dCQUNQLEVBQUUsRUFBRSxHQUFHO2dCQUNQLE9BQU8sRUFBRSxLQUFLO2dCQUNkLE1BQU0sRUFBRSxnQkFBZ0I7Z0JBQ3hCLE1BQU0sRUFBRTtvQkFDTixNQUFNO29CQUNOO3dCQUNFLFFBQVEsRUFBRSxZQUFZO3FCQUN2QjtpQkFDRjthQUNGO1NBQ0YsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDdEM7UUFDRCxPQUFPO1lBQ0wsTUFBTSxFQUFFLE1BQU07WUFDZCxJQUFJLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSTtTQUNsRCxDQUFDO0lBQ0osQ0FBQztJQUVELG9CQUFvQjtJQUNwQixLQUFLLENBQUMsbUNBQW1DLENBQUMsTUFBK0I7O1FBQ3ZFLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFO1lBQzNCLENBQUMsd0JBQXdCLENBQUMsQ0FBQztTQUM1QjtRQUNELE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUM7UUFDbkMsTUFBTSx5QkFBeUIsR0FBWSxFQUFFLENBQUM7UUFDOUMsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO1FBRXRCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ25DLE1BQU0sR0FBRyxHQUFHLE1BQU0sdUJBQVksQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO1lBQzNELE1BQU0sV0FBVyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztZQUNoRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFO2dCQUNoRCxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7YUFDekM7WUFDRCxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQztZQUMvQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRTtnQkFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO2FBQ3pDO1lBQ0QsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ25FLE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ3BELElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ1gsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO2FBQ3RDO1lBQ0QsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNHLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQXNCLENBQUMsQ0FBQztZQUM3RSxJQUFJLENBQUMsQ0FBQSxNQUFBLFdBQVcsQ0FBQyxZQUFZLDBDQUFFLGNBQWMsQ0FBQSxFQUFFO2dCQUM3QyxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7YUFDNUM7WUFDRCxNQUFNLGNBQWMsR0FBRyxXQUFXLENBQUMsWUFBYSxDQUFDLGNBQXlCLENBQUM7WUFDM0UsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLEVBQUU7Z0JBQy9CLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQzthQUM1QztZQUNELE1BQU0sY0FBYyxHQUFHLFdBQVcsQ0FBQyxjQUF3QixDQUFDO1lBQzVELE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLEVBQUUsY0FBYyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNwRixNQUFNLG9CQUFvQixHQUFHLElBQUksYUFBVSxDQUFDLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUM7WUFFN0Usa0NBQWtDO1lBQ2xDLE1BQU0sWUFBWSxHQUFHLEVBQUUsR0FBRyxFQUFFLG9CQUFvQixFQUFFLENBQUM7WUFDbkQsU0FBUyxDQUFDLFlBQVksQ0FBQyxZQUF5QixFQUFFLFlBQVksQ0FBQyxDQUFDO1lBRWhFLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDbEQsTUFBTSxZQUFZLEdBQUcsaUJBQWlCLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUUzRCx5QkFBeUIsQ0FBQyxJQUFJLENBQUM7Z0JBQzdCLFlBQVksRUFBRSxZQUFZO2dCQUMxQixTQUFTLEVBQUUsV0FBVyxDQUFDLFNBQVM7YUFDakMsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksV0FBVyxDQUFDLFlBQWEsQ0FBQyxhQUFhLEVBQUU7Z0JBQ25FLGFBQWEsR0FBRyxXQUFXLENBQUMsWUFBYSxDQUFDLGFBQXVCLENBQUM7YUFDbkU7U0FDRjtRQUVELE9BQU8sRUFBRSxZQUFZLEVBQUUseUJBQXlCLEVBQUUsYUFBYSxFQUFFLENBQUM7SUFDcEUsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQTBCO1FBQ3RDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUNyQztRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO1lBQ25GLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztTQUNoRDtRQUVELE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNwRCxNQUFNLGVBQWUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDO1FBRXpGLHdCQUF3QjtRQUN4QixNQUFNLEdBQUcsR0FBRyxNQUFNLHVCQUFZLENBQUMseUJBQXlCLEVBQUUsQ0FBQztRQUMzRCxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDaEIsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDN0MsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDO1FBQzVFLElBQUksUUFBUSxHQUFHLElBQUksc0JBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV0QyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQztRQUNoQyxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFBLCtCQUFpQixFQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssRUFBRSxDQUFDO1FBQzNGLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUN4RSxNQUFNLG9CQUFvQixHQUFHLElBQUksYUFBVSxDQUFDLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFN0UsT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDN0QsSUFBSSxRQUFRLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3hCLE1BQU0sS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7U0FDM0Q7UUFFRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRW5DLElBQUksU0FBUyxDQUFDO1FBQ2QsSUFBSSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDMUMsSUFBSSxnQkFBZ0IsQ0FBQztRQUNyQixJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFFbkIsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFO1lBQ3ZCLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDbEYsU0FBUyxHQUFHLGdCQUFnQixDQUFDLFNBQVMsQ0FBQztZQUN2QyxTQUFTLEdBQUcsZ0JBQWdCLENBQUMsU0FBUyxDQUFDO1NBQ3hDO1FBRUQsdUVBQXVFO1FBQ3ZFLElBQUksTUFBTSxDQUFDLG9CQUFvQixFQUFFO1lBQy9CLE1BQU0sYUFBYSxHQUFHLE1BQU0sSUFBSSxDQUFDLHVCQUF1QixDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDL0UsSUFBSSxhQUFhLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDOUIsMEZBQTBGO2dCQUMxRix1Q0FBdUM7Z0JBQ3ZDLHdDQUF3QztnQkFDeEMsTUFBTSx5QkFBeUIsR0FBbUIsRUFBRSxDQUFDO2dCQUNyRCxLQUFLLE1BQU0sWUFBWSxJQUFJLGFBQWEsRUFBRTtvQkFDeEMsSUFBSSxNQUFNLENBQUMsb0JBQW9CLEtBQUssWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7d0JBQzFELE1BQU0sV0FBVyxHQUFHLElBQUksc0JBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDeEUsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO3dCQUNsQyxNQUFNLEtBQUssR0FBRyxJQUFBLDhCQUFzQixFQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO3dCQUV0RSxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxXQUFXLENBQUMsRUFBRSxDQUFDLElBQUksc0JBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFOzRCQUM3RCxZQUFZLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUM7NEJBQ3BDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQzt5QkFDOUM7d0JBQ0QsTUFBTTtxQkFDUDtpQkFDRjtnQkFFRCxJQUFJLHlCQUF5QixDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7b0JBQzFDLGdCQUFnQixHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7b0JBRXBELFNBQVMsR0FBRyxPQUFPO3lCQUNoQix1QkFBdUIsRUFBRTt5QkFDekIsS0FBSyxDQUFDLFNBQVMsQ0FBQzt5QkFDaEIsTUFBTSxDQUFDLG9CQUFvQixDQUFDO3lCQUM1QixHQUFHLENBQUMsRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLENBQUM7eUJBQ2hDLDBCQUEwQixDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxDQUFDO3lCQUN2RCxRQUFRLENBQUMsb0JBQW9CLENBQUMsQ0FBQztvQkFFbEMsdUdBQXVHO29CQUN2RyxNQUFNLHNCQUFzQixHQUFHLE1BQU0sSUFBSSxDQUFDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO29CQUU5RixLQUFLLE1BQU0sWUFBWSxJQUFJLHlCQUF5QixFQUFFO3dCQUNwRCxJQUFJLDJCQUEyQixHQUFHLEtBQUssQ0FBQzt3QkFDeEMsS0FBSyxNQUFNLHFCQUFxQixJQUFJLHNCQUF3QyxFQUFFOzRCQUM1RSxJQUFJLHFCQUFxQixDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0NBQzlELDJCQUEyQixHQUFHLElBQUksQ0FBQztnQ0FDbkMsTUFBTTs2QkFDUDt5QkFDRjt3QkFFRCxNQUFNLHFCQUFxQixHQUFHLE1BQU0sSUFBQSx3Q0FBZ0MsRUFDbEUsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQ3RCLE1BQU0sQ0FBQyxtQkFBbUIsQ0FDM0IsQ0FBQzt3QkFDRixNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUMsU0FBbUIsQ0FBQzt3QkFDbkQsU0FBUyxDQUFDLElBQUksQ0FBQzs0QkFDYixPQUFPLEVBQUUscUJBQXFCOzRCQUM5QixNQUFNLEVBQUUsWUFBWSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTTs0QkFDNUMsU0FBUyxFQUFFLFNBQVM7eUJBQ3JCLENBQUMsQ0FBQzt3QkFFSCxJQUFJLENBQUMsMkJBQTJCLEVBQUU7NEJBQ2hDLHVFQUF1RTs0QkFDdkUsU0FBUyxDQUFDLDRCQUE0QixDQUFDO2dDQUNyQyxZQUFZLEVBQUUsTUFBTSxDQUFDLG1CQUFtQjtnQ0FDeEMsU0FBUyxFQUFFLFNBQVM7NkJBQ3JCLENBQUMsQ0FBQzs0QkFDSCxvRkFBb0Y7NEJBQ3BGLFFBQVEsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7eUJBQzVDO3FCQUNGO29CQUVELDZHQUE2RztvQkFDN0csSUFBSSxJQUFJLHNCQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFO3dCQUN2QyxNQUFNLEtBQUssQ0FDVCx5REFBeUQsR0FBRyxPQUFPLEdBQUcsU0FBUyxHQUFHLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FDdEcsQ0FBQztxQkFDSDtpQkFDRjtxQkFBTTtvQkFDTCxNQUFNLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO2lCQUNsRDthQUNGO2lCQUFNO2dCQUNMLHlGQUF5RjtnQkFDekYsTUFBTSxLQUFLLENBQUMsMEVBQTBFLENBQUMsQ0FBQzthQUN6RjtTQUNGO2FBQU07WUFDTCxNQUFNLFNBQVMsR0FBRyxJQUFJLHNCQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXpELFNBQVMsR0FBRyxPQUFPO2lCQUNoQixrQkFBa0IsRUFBRTtpQkFDcEIsS0FBSyxDQUFDLFNBQVMsQ0FBQztpQkFDaEIsTUFBTSxDQUFDLG9CQUFvQixDQUFDO2lCQUM1QixJQUFJLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLG1CQUFtQixFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQztpQkFDM0UsR0FBRyxDQUFDLEVBQUUsTUFBTSxFQUFFLGVBQWUsRUFBRSxDQUFDO2lCQUNoQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsQ0FBQztTQUNuQztRQUVELElBQUksTUFBTSxDQUFDLFlBQVksRUFBRTtZQUN2QixTQUFTLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRTtnQkFDekIsa0JBQWtCLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxTQUFTO2dCQUNqRCxpQkFBaUIsRUFBRSxTQUFTO2FBQzdCLENBQUMsQ0FBQztTQUNKO1FBRUQsSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUNwQixlQUFlO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUU7Z0JBQ25CLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQzthQUNwQztZQUVELElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFO2dCQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7YUFDdEM7WUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFO2dCQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUM7YUFDOUM7WUFFRCxNQUFNLG1CQUFtQixHQUFHLENBQUMsTUFBTSxTQUFTLENBQUMsS0FBSyxFQUFFLENBQWdCLENBQUM7WUFFckUsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ2xELE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztZQUV0RCwyQ0FBMkM7WUFDM0MsSUFBSSxPQUFPLENBQUM7WUFFWixJQUFJO2dCQUNGLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztvQkFDM0IsS0FBSyxFQUFFLE9BQU87b0JBQ2QsUUFBUSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0I7aUJBQ2xDLENBQUMsQ0FBQzthQUNKO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7YUFDakU7WUFFRCxNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUF5QyxDQUFDO1lBRXhGLElBQUksU0FBUyxDQUFDO1lBQ2QsSUFBSTtnQkFDRixTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7b0JBQzdCLEtBQUssRUFBRSxTQUFTO29CQUNoQixRQUFRLEVBQUUsTUFBTSxDQUFDLGdCQUFnQjtpQkFDbEMsQ0FBQyxDQUFDO2FBQ0o7WUFBQyxPQUFPLENBQUMsRUFBRTtnQkFDVixNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQzthQUNuRTtZQUNELE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQTJDLENBQUM7WUFFOUYsTUFBTSxZQUFZLEdBQUcsTUFBTSx1QkFBWSxDQUFDLGVBQWUsQ0FDckQsbUJBQW1CLEVBQ25CLHFCQUFxQixFQUNyQixRQUFRLEVBQ1IsbUJBQW1CLENBQ3BCLENBQUM7WUFFRixNQUFNLFlBQVksR0FBRyxFQUFFLEdBQUcsRUFBRSxvQkFBb0IsRUFBRSxDQUFDO1lBQ25ELFNBQVMsQ0FBQyxZQUFZLENBQUMsWUFBeUIsRUFBRSxZQUFZLENBQUMsQ0FBQztTQUNqRTtRQUVELElBQUksTUFBTSxDQUFDLFlBQVksRUFBRTtZQUN2QixzQ0FBc0M7WUFDdEMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7U0FDeEQ7UUFFRCxNQUFNLG9CQUFvQixHQUFHLE1BQU0sU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3JELE1BQU0sWUFBWSxHQUFHLG9CQUFvQixDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDOUQsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBQSwrQkFBaUIsRUFBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLEVBQUUsQ0FBQztRQUNqRyxNQUFNLE1BQU0sR0FBZSxFQUFFLENBQUM7UUFDOUIsS0FBSyxNQUFNLEtBQUssSUFBSSxvQkFBb0IsQ0FBQyxNQUFNLEVBQUU7WUFDL0MsTUFBTSxDQUFDLElBQUksQ0FBQztnQkFDVixPQUFPLEVBQUUsS0FBSyxDQUFDLE9BQU87Z0JBQ3RCLFdBQVcsRUFBRSxLQUFLLENBQUMsS0FBSztnQkFDeEIsS0FBSyxFQUFFLElBQUksc0JBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxFQUFFO2FBQzdDLENBQUMsQ0FBQztTQUNKO1FBQ0QsTUFBTSxPQUFPLEdBQWdCLEVBQUUsQ0FBQztRQUNoQyxLQUFLLE1BQU0sTUFBTSxJQUFJLG9CQUFvQixDQUFDLE9BQU8sRUFBRTtZQUNqRCxPQUFPLENBQUMsSUFBSSxDQUFDO2dCQUNYLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTztnQkFDdkIsV0FBVyxFQUFFLE1BQU0sQ0FBQyxLQUFLO2dCQUN6QixRQUFRLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBVTthQUNqRCxDQUFDLENBQUM7U0FDSjtRQUNELE1BQU0sV0FBVyxHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEcsTUFBTSxRQUFRLEdBQUcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUM7UUFDMUYsTUFBTSxPQUFPLEdBQUcsRUFBRSxHQUFHLEVBQUUsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQztRQUM3RSxNQUFNLFlBQVksR0FBRyxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsQ0FBQztRQUNsRCxJQUFJLGVBQWUsRUFBRTtZQUNuQixNQUFNLFdBQVcsR0FBVTtnQkFDekIsWUFBWSxFQUFFLFlBQVk7Z0JBQzFCLFNBQVMsRUFBRSxLQUFLO2dCQUNoQixJQUFJLEVBQUUsVUFBVTtnQkFDaEIsV0FBVyxFQUFFLG9CQUFvQixDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO2dCQUNqRSxjQUFjLEVBQUUsY0FBYztnQkFDOUIsUUFBUSxFQUFFLFFBQVE7Z0JBQ2xCLE9BQU8sRUFBRSxPQUFPO2dCQUNoQixZQUFZLEVBQUUsWUFBWTthQUMzQixDQUFDO1lBQ0YsTUFBTSxVQUFVLEdBQWtCLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxlQUFlLEVBQUUsRUFBRSxFQUFFLENBQUM7WUFDbkYsTUFBTSxZQUFZLEdBQW9CLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbkQsTUFBTSxTQUFTLEdBQXNCO2dCQUNuQyxZQUFZLEVBQUUsWUFBWTtnQkFDMUIsVUFBVSxFQUFFLFVBQVU7YUFDdkIsQ0FBQztZQUNGLE1BQU0sVUFBVSxHQUFnQixFQUFFLFVBQVUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUM7WUFDNUQsT0FBTyxVQUFVLENBQUM7U0FDbkI7UUFDRCxNQUFNLFdBQVcsR0FBVTtZQUN6QixZQUFZLEVBQUUsWUFBWTtZQUMxQixTQUFTLEVBQUUsS0FBSztTQUNqQixDQUFDO1FBQ0YsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUFDLE1BQTBCO1FBQzlDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUNyQztRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO1lBQ25GLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztTQUNoRDtRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDM0UsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1NBQzVDO1FBRUQsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXBELHdCQUF3QjtRQUN4QixNQUFNLEdBQUcsR0FBRyxNQUFNLHVCQUFZLENBQUMseUJBQXlCLEVBQUUsQ0FBQztRQUMzRCxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDaEIsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDN0MsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDO1FBQzVFLE1BQU0sUUFBUSxHQUFHLElBQUksc0JBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV4QyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQztRQUNoQyxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFBLCtCQUFpQixFQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssRUFBRSxDQUFDO1FBQzNGLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUN4RSxNQUFNLG9CQUFvQixHQUFHLElBQUksYUFBVSxDQUFDLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFN0UsT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDN0QsSUFBSSxRQUFRLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3hCLE1BQU0sS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7U0FDM0Q7UUFFRCxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQy9ELElBQUksT0FBTyxJQUFJLENBQUMsRUFBRTtZQUNoQixNQUFNLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO1NBQ3ZFO1FBRUQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRWxDLElBQUksU0FBUyxDQUFDO1FBQ2QsSUFBSSxTQUFTLENBQUM7UUFDZCxNQUFNLFlBQVksR0FBcUMsRUFBRSxDQUFDO1FBRTFELE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUUxRCwrQ0FBK0M7UUFDL0MsdURBQXVEO1FBQ3ZELE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUN6RSxNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFL0QsSUFBSSxZQUFZLEdBQUcsQ0FBQyxFQUFFO1lBQ3BCLHVGQUF1RjtZQUN2RixPQUFPLENBQUMsR0FBRyxDQUNULG9CQUFvQixNQUFNLENBQUMsZUFBZSxzQkFBc0IsWUFBWSx1REFBdUQsQ0FDcEksQ0FBQztZQUVGLElBQUksQ0FBQyxNQUFNLENBQUMsNkJBQTZCLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyw2QkFBNkIsQ0FBQyxFQUFFO2dCQUN2RyxNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7YUFDMUQ7WUFFRCxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7WUFFdEMsU0FBUyxHQUFHLE9BQU87aUJBQ2hCLHVCQUF1QixFQUFFO2lCQUN6QixLQUFLLENBQUMsU0FBUyxDQUFDO2lCQUNoQixNQUFNLENBQUMsb0JBQW9CLENBQUM7aUJBQzVCLEdBQUcsQ0FBQyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsQ0FBQztpQkFDaEMsMEJBQTBCLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLENBQUM7aUJBQ3ZELFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1lBRWxDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUNsQyxNQUFNLEtBQUssR0FBRyxJQUFBLDhCQUFzQixFQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ25FLFNBQVMsQ0FBQyxJQUFJLENBQUM7Z0JBQ2IsT0FBTyxFQUFFLE1BQU0sQ0FBQyw2QkFBNkI7Z0JBQzdDLE1BQU0sRUFBRSxZQUFZO2dCQUNwQixTQUFTLEVBQUUsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLElBQUk7YUFDdkIsQ0FBQyxDQUFDO1lBRUgsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLElBQUksQ0FBQyx1Q0FBdUMsQ0FDekUsTUFBTSxFQUNOLFNBQVMsRUFDVCxvQkFBb0IsQ0FDckIsQ0FBQztZQUNGLE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxNQUFNLGdCQUFnQixDQUFDLENBQUMsWUFBWSxDQUFDO1lBQ3pFLE1BQU0seUJBQXlCLEdBQUcsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUM7Z0JBQ2hFLDJCQUEyQixFQUFFLDBCQUEwQjthQUN4RCxDQUFDLENBQUM7WUFDSCxPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUM7WUFDdkMsWUFBWSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1NBQzlDO1FBRUQseUVBQXlFO1FBQ3pFLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRTtZQUMxQixTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7WUFFdEMsTUFBTSxlQUFlLEdBQUcsR0FBRyxFQUFFOztnQkFDM0IsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLGdDQUFnQyxFQUFFLENBQUM7Z0JBQzdELFNBQVMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQzNCLFNBQVMsQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQztnQkFDdkMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxNQUFBLE1BQU0sQ0FBQyxlQUFlLG1DQUFJLEVBQUUsQ0FBQyxDQUFDO2dCQUN2RCxTQUFTLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUM7Z0JBQ3pELFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO2dCQUNqRCxTQUFTLENBQUMsMEJBQTBCLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztnQkFDbEUsT0FBTyxTQUFTLENBQUM7WUFDbkIsQ0FBQyxDQUFDO1lBQ0YsU0FBUyxHQUFHLGVBQWUsRUFBRSxDQUFDO1NBQy9CO1FBQ0QsTUFBTSxtQkFBbUIsR0FBRyxNQUFNLElBQUksQ0FBQyx1Q0FBdUMsQ0FDNUUsTUFBTSxFQUNOLFNBQVMsRUFDVCxvQkFBb0IsQ0FDckIsQ0FBQztRQUNGLE1BQU0sNkJBQTZCLEdBQUcsQ0FBQyxNQUFNLG1CQUFtQixDQUFDLENBQUMsWUFBWSxDQUFDO1FBQy9FLE1BQU0sNEJBQTRCLEdBQUcsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUM7WUFDbkUsMkJBQTJCLEVBQUUsNkJBQTZCO1NBQzNELENBQUMsQ0FBQztRQUNILE9BQU8sQ0FBQyxHQUFHLENBQUMsNEJBQTRCLENBQUMsQ0FBQztRQUMxQyxZQUFZLENBQUMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLENBQUM7UUFFaEQsT0FBTyxZQUFZLENBQUM7SUFDdEIsQ0FBQztJQUVELEtBQUssQ0FBQyx1Q0FBdUMsQ0FDM0MsTUFBMEIsRUFDMUIsU0FBYyxFQUNkLG9CQUE0QjtRQUU1QixlQUFlO1FBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUU7WUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ3BDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3RDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtZQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUM7U0FDOUM7UUFFRCxNQUFNLG1CQUFtQixHQUFHLENBQUMsTUFBTSxTQUFTLENBQUMsS0FBSyxFQUFFLENBQWdCLENBQUM7UUFFckUsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUV0RCwyQ0FBMkM7UUFDM0MsSUFBSSxPQUFPLENBQUM7UUFFWixJQUFJO1lBQ0YsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO2dCQUMzQixLQUFLLEVBQUUsT0FBTztnQkFDZCxRQUFRLEVBQUUsTUFBTSxDQUFDLGdCQUFnQjthQUNsQyxDQUFDLENBQUM7U0FDSjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDakU7UUFFRCxNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUF5QyxDQUFDO1FBRXhGLElBQUksU0FBUyxDQUFDO1FBQ2QsSUFBSTtZQUNGLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztnQkFDN0IsS0FBSyxFQUFFLFNBQVM7Z0JBQ2hCLFFBQVEsRUFBRSxNQUFNLENBQUMsZ0JBQWdCO2FBQ2xDLENBQUMsQ0FBQztTQUNKO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUNuRTtRQUNELE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQTJDLENBQUM7UUFFOUYsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUM7UUFDaEMsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBQSwrQkFBaUIsRUFBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLEVBQUUsQ0FBQztRQUUzRixNQUFNLFlBQVksR0FBRyxNQUFNLHVCQUFZLENBQUMsZUFBZSxDQUNyRCxtQkFBbUIsRUFDbkIscUJBQXFCLEVBQ3JCLFFBQVEsRUFDUixtQkFBbUIsQ0FDcEIsQ0FBQztRQUVGLE1BQU0sWUFBWSxHQUFHLEVBQUUsR0FBRyxFQUFFLG9CQUFvQixFQUFFLENBQUM7UUFDbkQsU0FBUyxDQUFDLFlBQVksQ0FBQyxZQUF5QixFQUFFLFlBQVksQ0FBQyxDQUFDO1FBRWhFLE1BQU0sb0JBQW9CLEdBQUcsTUFBTSxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDckQsTUFBTSxZQUFZLEdBQUcsb0JBQW9CLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUM5RCxNQUFNLFdBQVcsR0FBVTtZQUN6QixZQUFZLEVBQUUsWUFBWTtZQUMxQixTQUFTLEVBQUUsS0FBSztTQUNqQixDQUFDO1FBQ0YsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMscUJBQXFCLENBQUMsTUFBdUM7UUFDakUsTUFBTSxlQUFlLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztRQUN6RixNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsaUJBQWlCLElBQUksQ0FBQyxDQUFDO1FBQy9DLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxlQUFlLElBQUksUUFBUSxHQUFHLDJCQUFtQixDQUFDO1FBRXhFLElBQUksUUFBUSxHQUFHLENBQUMsSUFBSSxNQUFNLElBQUksUUFBUSxJQUFJLE1BQU0sR0FBRyxRQUFRLEdBQUcsRUFBRSxHQUFHLDJCQUFtQixFQUFFO1lBQ3RGLE1BQU0sSUFBSSxLQUFLLENBQ2IsOEVBQThFLFFBQVEsc0JBQXNCLE1BQU0sR0FBRyxDQUN0SCxDQUFDO1NBQ0g7UUFFRCxnQ0FBZ0M7UUFDaEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUU7WUFDekIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1NBQzNDO1FBQ0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsVUFBVSxFQUFFO1lBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMsNkNBQTZDLENBQUMsQ0FBQztTQUNoRTtRQUNELElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLFNBQVMsRUFBRTtZQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7U0FDckU7UUFFRCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDcEQsTUFBTSxHQUFHLEdBQUcsTUFBTSx1QkFBWSxDQUFDLHlCQUF5QixFQUFFLENBQUM7UUFDM0QsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLENBQUM7UUFDM0IsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLElBQUk7WUFDakMsQ0FBQyxDQUFDLElBQUEsK0JBQWlCLEVBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksZ0JBQWdCLEVBQUU7WUFDekQsQ0FBQyxDQUFDLEtBQUssZ0JBQWdCLEVBQUUsQ0FBQztRQUM1QixNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLGVBQWUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDL0UsTUFBTSxXQUFXLEdBQUcsSUFBSSxhQUFVLENBQUMsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUVwRSxJQUFJLHdCQUF3QixHQUFHLENBQUMsQ0FBQztRQUNqQyxNQUFNLHlCQUF5QixHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQztRQUN6RSxNQUFNLHlCQUF5QixHQUFVLEVBQUUsQ0FBQztRQUM1QyxJQUFJLGFBQWEsR0FBRyxRQUFRLENBQUM7UUFDN0IsS0FBSyxJQUFJLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN0QyxNQUFNLGFBQWEsR0FBRztnQkFDcEIsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPO2dCQUN2QixTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7Z0JBQzNCLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUTtnQkFDekIsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDLGdCQUFnQjtnQkFDekMsbUJBQW1CLEVBQUUsV0FBVztnQkFDaEMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJO2dCQUNqQixLQUFLLEVBQUUsQ0FBQztnQkFDUixZQUFZLEVBQUU7b0JBQ1osU0FBUyxFQUFFLE1BQU0sQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO29CQUNwRSxTQUFTLEVBQUUsTUFBTSxDQUFDLGFBQWEsQ0FBQyxTQUFTO2lCQUMxQztnQkFDRCxvQkFBb0IsRUFBRSxNQUFNLENBQUMsb0JBQW9CO2FBQ2xELENBQUM7WUFFRixJQUFJLG1CQUFtQixDQUFDO1lBQ3hCLElBQUk7Z0JBQ0YsbUJBQW1CLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ3pEO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsSUFDRSxDQUFDLENBQUMsT0FBTyxLQUFLLDRDQUE0QztvQkFDMUQsQ0FBQyxDQUFDLE9BQU8sS0FBSywwRUFBMEU7b0JBQ3hGLENBQUMsQ0FBQyxPQUFPLEtBQUssbUNBQW1DLEVBQ2pEO29CQUNBLGFBQWEsR0FBRyxDQUFDLENBQUM7b0JBQ2xCLFNBQVM7aUJBQ1Y7Z0JBQ0QsTUFBTSxDQUFDLENBQUM7YUFDVDtZQUVELElBQUksZUFBZSxFQUFFO2dCQUNuQix5QkFBeUIsQ0FBQyxJQUFJLENBQUUsbUJBQW1DLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDcEY7aUJBQU07Z0JBQ0wseUJBQXlCLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7YUFDckQ7WUFFRCxhQUFhLEdBQUcsQ0FBQyxDQUFDO1lBQ2xCLHdCQUF3QixFQUFFLENBQUM7WUFDM0IsSUFBSSx3QkFBd0IsSUFBSSx5QkFBeUIsRUFBRTtnQkFDekQsMERBQTBEO2dCQUMxRCxNQUFNO2FBQ1A7U0FDRjtRQUVELElBQUkseUJBQXlCLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7U0FDbEU7UUFFRCxJQUFJLGVBQWUsRUFBRTtZQUNuQiw0R0FBNEc7WUFDNUcsa0hBQWtIO1lBQ2xILHNHQUFzRztZQUN0RyxNQUFNLDJCQUEyQixHQUFHO2dCQUNsQyxjQUFjLEVBQ1oseUJBQXlCLENBQUMseUJBQXlCLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsWUFBWTtxQkFDcEcsY0FBYztnQkFDbkIsYUFBYSxFQUFFLGFBQWE7YUFDN0IsQ0FBQztZQUNGLHlCQUF5QixDQUFDLHlCQUF5QixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVk7Z0JBQ3JHLDJCQUEyQixDQUFDO1lBQzlCLE1BQU0sOEJBQThCLEdBQWdCLEVBQUUsVUFBVSxFQUFFLHlCQUF5QixFQUFFLENBQUM7WUFDOUYsT0FBTyw4QkFBOEIsQ0FBQztTQUN2QztRQUVELE9BQU8sRUFBRSxZQUFZLEVBQUUseUJBQXlCLEVBQUUsYUFBYSxFQUFFLENBQUM7SUFDcEUsQ0FBQztJQUVELHdCQUF3QjtRQUN0QixPQUFPO1lBQ0wsdUJBQXVCLEVBQUUsSUFBSTtZQUM3QixnQ0FBZ0MsRUFBRSxJQUFJO1NBQ3ZDLENBQUM7SUFDSixDQUFDO0lBRU8sVUFBVTtRQUNoQixPQUFPLElBQUksK0JBQXlCLENBQUMsZUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRCxLQUFLLENBQUMsb0JBQW9CLENBQUMsRUFDekIsMkJBQTJCLEdBQ0s7UUFDaEMsSUFBQSw4QkFBc0IsRUFBQywyQkFBMkIsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDaEUsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQzFDLE9BQU8sRUFBRTtnQkFDUCxFQUFFLEVBQUUsR0FBRztnQkFDUCxPQUFPLEVBQUUsS0FBSztnQkFDZCxNQUFNLEVBQUUsaUJBQWlCO2dCQUN6QixNQUFNLEVBQUU7b0JBQ04sMkJBQTJCO29CQUMzQjt3QkFDRSxRQUFRLEVBQUUsUUFBUTtxQkFDbkI7aUJBQ0Y7YUFDRjtTQUNGLENBQUMsQ0FBQztRQUVILElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNuRjtRQUVELE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUN4QyxDQUFDO0NBQ0Y7QUExcENELGtCQTBwQ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIGJhc2U1OCBmcm9tICdiczU4JztcblxuaW1wb3J0IHtcbiAgQmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgQmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uUmVzdWx0LFxuICBCYXNlQ29pbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMgYXMgQmFzZVBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBCYXNlVHJhbnNhY3Rpb24sXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQgYXMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIEJpdEdvQmFzZSxcbiAgRUREU0FNZXRob2RzLFxuICBFRERTQU1ldGhvZFR5cGVzLFxuICBFbnZpcm9ubWVudHMsXG4gIEtleVBhaXIsXG4gIE1lbW8sXG4gIE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IsXG4gIE1QQ0FsZ29yaXRobSxcbiAgTVBDQ29uc29saWRhdGlvblJlY292ZXJ5T3B0aW9ucyxcbiAgTVBDUmVjb3ZlcnlPcHRpb25zLFxuICBNUENTd2VlcFJlY292ZXJ5T3B0aW9ucyxcbiAgTVBDU3dlZXBUeHMsXG4gIE1QQ1R4LFxuICBNUENUeHMsXG4gIE1QQ1Vuc2lnbmVkVHgsXG4gIE92Y0lucHV0LFxuICBPdmNPdXRwdXQsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQcmVzaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBQdWJsaWNLZXksXG4gIFJlY292ZXJ5VHhSZXF1ZXN0LFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVG9rZW5FbmFibGVtZW50Q29uZmlnLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBUcmFuc2FjdGlvblJlY2lwaWVudCxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IGdldERlcml2YXRpb25QYXRoIH0gZnJvbSAnQGJpdGdvL3Nkay1saWItbXBjJztcbmltcG9ydCB7IEJhc2VOZXR3b3JrLCBDb2luRmFtaWx5LCBjb2lucywgQmFzZUNvaW4gYXMgU3RhdGljc0Jhc2VDb2luIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCB7IEtleVBhaXIgYXMgU29sS2V5UGFpciwgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uQnVpbGRlciwgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSB9IGZyb20gJy4vbGliJztcbmltcG9ydCB7XG4gIGdldEFzc29jaWF0ZWRUb2tlbkFjY291bnRBZGRyZXNzLFxuICBnZXRTb2xUb2tlbkZyb21BZGRyZXNzLFxuICBnZXRTb2xUb2tlbkZyb21Ub2tlbk5hbWUsXG4gIGlzVmFsaWRBZGRyZXNzLFxuICBpc1ZhbGlkUHJpdmF0ZUtleSxcbiAgaXNWYWxpZFB1YmxpY0tleSxcbiAgdmFsaWRhdGVSYXdUcmFuc2FjdGlvbixcbn0gZnJvbSAnLi9saWIvdXRpbHMnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0NBTl9GQUNUT1IgPSAyMDsgLy8gZGVmYXVsdCBudW1iZXIgb2YgcmVjZWl2ZSBhZGRyZXNzZXMgdG8gc2NhbiBmb3IgZnVuZHNcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkZlZSB7XG4gIGZlZTogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBTb2xUcmFuc2FjdGlvbkV4cGxhbmF0aW9uID0gVHJhbnNhY3Rpb25FeHBsYW5hdGlvbjtcblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhCYXNlNjQ6IHN0cmluZztcbiAgZmVlSW5mbzogVHJhbnNhY3Rpb25GZWU7XG4gIHRva2VuQWNjb3VudFJlbnRFeGVtcHRBbW91bnQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHhJbmZvIHtcbiAgcmVjaXBpZW50czogVHJhbnNhY3Rpb25SZWNpcGllbnRbXTtcbiAgZnJvbTogc3RyaW5nO1xuICB0eGlkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29sU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZyB8IHN0cmluZ1tdO1xuICBwdWJLZXlzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhCYXNlNjQ6IHN0cmluZztcbiAgdHhJbmZvOiBUeEluZm87XG4gIHNvdXJjZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNvbFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIG1lbW8/OiBNZW1vO1xuICBmZWVQYXllcjogc3RyaW5nO1xuICBibG9ja2hhc2g6IHN0cmluZztcbiAgZHVyYWJsZU5vbmNlPzogeyB3YWxsZXROb25jZUFkZHJlc3M6IHN0cmluZzsgYXV0aFdhbGxldEFkZHJlc3M6IG51bWJlciB9O1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25PdXRwdXQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogbnVtYmVyIHwgc3RyaW5nO1xuICB0b2tlbk5hbWU/OiBzdHJpbmc7XG59XG5cbnR5cGUgVHJhbnNhY3Rpb25JbnB1dCA9IFRyYW5zYWN0aW9uT3V0cHV0O1xuXG5leHBvcnQgaW50ZXJmYWNlIFNvbFBhcnNlZFRyYW5zYWN0aW9uIGV4dGVuZHMgUGFyc2VkVHJhbnNhY3Rpb24ge1xuICAvLyB0b3RhbCBhc3NldHMgYmVpbmcgbW92ZWQsIGluY2x1ZGluZyBmZWVzXG4gIGlucHV0czogVHJhbnNhY3Rpb25JbnB1dFtdO1xuXG4gIC8vIHdoZXJlIGFzc2V0cyBhcmUgbW92ZWQgdG9cbiAgb3V0cHV0czogVHJhbnNhY3Rpb25PdXRwdXRbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb2xQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4QmFzZTY0OiBzdHJpbmc7XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xuICB0b2tlbkFjY291bnRSZW50RXhlbXB0QW1vdW50Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU29sRHVyYWJsZU5vbmNlRnJvbU5vZGUge1xuICBhdXRob3JpdHk6IHN0cmluZztcbiAgYmxvY2toYXNoOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUb2tlbkFtb3VudCB7XG4gIGFtb3VudDogc3RyaW5nO1xuICBkZWNpbWFsczogbnVtYmVyO1xuICB1aUFtb3VudDogbnVtYmVyO1xuICB1aUFtb3VudFN0cmluZzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVG9rZW5BY2NvdW50SW5mbyB7XG4gIGlzTmF0aXZlOiBib29sZWFuO1xuICBtaW50OiBzdHJpbmc7XG4gIG93bmVyOiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIHRva2VuQW1vdW50OiBUb2tlbkFtb3VudDtcbn1cblxuaW50ZXJmYWNlIFRva2VuQWNjb3VudCB7XG4gIGluZm86IFRva2VuQWNjb3VudEluZm87XG4gIHB1YktleTogc3RyaW5nO1xuICB0b2tlbk5hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29sUmVjb3ZlcnlPcHRpb25zIGV4dGVuZHMgTVBDUmVjb3ZlcnlPcHRpb25zIHtcbiAgZHVyYWJsZU5vbmNlPzoge1xuICAgIHB1YmxpY0tleTogc3RyaW5nO1xuICAgIHNlY3JldEtleTogc3RyaW5nO1xuICB9O1xuICB0b2tlbkNvbnRyYWN0QWRkcmVzcz86IHN0cmluZztcbiAgY2xvc2VBdGFBZGRyZXNzPzogc3RyaW5nO1xuICAvLyBkZXN0aW5hdGlvbiBhZGRyZXNzIHdoZXJlIHRva2VuIHNob3VsZCBiZSBzZW50IGJlZm9yZSBjbG9zaW5nIHRoZSBBVEEgYWRkcmVzc1xuICByZWNvdmVyeURlc3RpbmF0aW9uQXRhQWRkcmVzcz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb2xDb25zb2xpZGF0aW9uUmVjb3ZlcnlPcHRpb25zIGV4dGVuZHMgTVBDQ29uc29saWRhdGlvblJlY292ZXJ5T3B0aW9ucyB7XG4gIGR1cmFibGVOb25jZXM6IHtcbiAgICBwdWJsaWNLZXlzOiBzdHJpbmdbXTtcbiAgICBzZWNyZXRLZXk6IHN0cmluZztcbiAgfTtcbiAgdG9rZW5Db250cmFjdEFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmNvbnN0IEhFWF9SRUdFWCA9IC9eWzAtOWEtZkEtRl0rJC87XG5cbmV4cG9ydCBjbGFzcyBTb2wgZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHByb3RlY3RlZCByZWFkb25seSBfc3RhdGljc0NvaW46IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuXG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgU29sKGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICBhbGxvd3NBY2NvdW50Q29uc29saWRhdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdXBwb3J0c1RzcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldE1QQ0FsZ29yaXRobSgpOiBNUENBbGdvcml0aG0ge1xuICAgIHJldHVybiAnZWRkc2EnO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmFtZTtcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBDb2luRmFtaWx5IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZmFtaWx5O1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZnVsbE5hbWU7XG4gIH1cblxuICBnZXROZXR3b3JrKCk6IEJhc2VOZXR3b3JrIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmV0d29yaztcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXRpY3NDb2luLmRlY2ltYWxQbGFjZXMpO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBTb2xWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIC8vIGFzc2V0IG5hbWUgdG8gdHJhbnNmZXIgYW1vdW50IG1hcFxuICAgIGNvbnN0IHRvdGFsQW1vdW50OiBSZWNvcmQ8c3RyaW5nLCBCaWdOdW1iZXI+ID0ge307XG4gICAgY29uc3QgY29pbkNvbmZpZyA9IGNvaW5zLmdldCh0aGlzLmdldENoYWluKCkpO1xuICAgIGNvbnN0IHsgdHhQYXJhbXM6IHR4UGFyYW1zLCB0eFByZWJ1aWxkOiB0eFByZWJ1aWxkLCBtZW1vOiBtZW1vLCBkdXJhYmxlTm9uY2U6IGR1cmFibGVOb25jZSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGNvaW5Db25maWcpO1xuICAgIGNvbnN0IHJhd1R4ID0gdHhQcmVidWlsZC50eEJhc2U2NCB8fCB0eFByZWJ1aWxkLnR4SGV4O1xuICAgIGNvbnN0IGNvbnNvbGlkYXRlSWQgPSB0eFByZWJ1aWxkLmNvbnNvbGlkYXRlSWQ7XG5cbiAgICBjb25zdCB3YWxsZXRSb290QWRkcmVzcyA9IHBhcmFtcy53YWxsZXQuY29pblNwZWNpZmljKCk/LnJvb3RBZGRyZXNzO1xuXG4gICAgaWYgKCFyYXdUeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4IHByZWJ1aWxkIHByb3BlcnR5IHR4QmFzZTY0IG9yIHR4SGV4Jyk7XG4gICAgfVxuXG4gICAgbGV0IHJhd1R4QmFzZTY0ID0gcmF3VHg7XG4gICAgaWYgKEhFWF9SRUdFWC50ZXN0KHJhd1R4KSkge1xuICAgICAgcmF3VHhCYXNlNjQgPSBCdWZmZXIuZnJvbShyYXdUeCwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24uZnJvbVJhd1RyYW5zYWN0aW9uKHJhd1R4QmFzZTY0KTtcbiAgICBjb25zdCBleHBsYWluZWRUeCA9IHRyYW5zYWN0aW9uLmV4cGxhaW5UcmFuc2FjdGlvbigpO1xuXG4gICAgLy8gdXNlcnMgZG8gbm90IGlucHV0IHJlY2lwaWVudHMgZm9yIGNvbnNvbGlkYXRpb24gcmVxdWVzdHMgYXMgdGhleSBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICBpZiAodHhQYXJhbXMucmVjaXBpZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZFJlY2lwaWVudHMgPSB0eFBhcmFtcy5yZWNpcGllbnRzPy5tYXAoKHJlY2lwaWVudCkgPT5cbiAgICAgICAgXy5waWNrKHJlY2lwaWVudCwgWydhZGRyZXNzJywgJ2Ftb3VudCcsICd0b2tlbk5hbWUnXSlcbiAgICAgICk7XG4gICAgICBjb25zdCBmaWx0ZXJlZE91dHB1dHMgPSBleHBsYWluZWRUeC5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiBfLnBpY2sob3V0cHV0LCBbJ2FkZHJlc3MnLCAnYW1vdW50JywgJ3Rva2VuTmFtZSddKSk7XG5cbiAgICAgIGlmIChmaWx0ZXJlZFJlY2lwaWVudHMubGVuZ3RoICE9PSBmaWx0ZXJlZE91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIHR4IG91dHB1dHMgZG9lcyBub3QgbWF0Y2ggd2l0aCBudW1iZXIgb2YgdHhQYXJhbXMgcmVjaXBpZW50cycpO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgZWFjaCByZWNpcGllbnQsIGNoZWNrIGlmIGl0J3MgYSB0b2tlbiB0eCAodG9rZW5OYW1lIHdpbGwgZXhpc3QgaWYgc28pXG4gICAgICAvLyBJZiBpdCBpcyBhIHRva2VuIHR4LCB2ZXJpZnkgdGhhdCB0aGUgcmVjaXBpZW50IGFkZHJlc3MgZXF1YWxzIHRoZSBkZXJpdmVkIGFkZHJlc3MgZnJvbSBleHBsYWluZWRUeFxuICAgICAgLy8gRGVyaXZlIHRoZSBBVEEgaWYgaXQgaXMgYSBuYXRpdmUgYWRkcmVzcyBhbmQgY29uZmlybSBpdCBpcyBlcXVhbCB0byB0aGUgZXhwbGFpbmVkIHR4IHJlY2lwaWVudFxuICAgICAgY29uc3QgcmVjaXBpZW50Q2hlY2tzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGZpbHRlcmVkUmVjaXBpZW50cy5tYXAoYXN5bmMgKHJlY2lwaWVudEZyb21Vc2VyLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlY2lwaWVudEZyb21UeCA9IGZpbHRlcmVkT3V0cHV0c1tpbmRleF07IC8vIFRoaXMgYWRkcmVzcyBzaG91bGQgYmUgYW4gQVRBXG5cbiAgICAgICAgICAvLyBDb21wYXJlIHRoZSBCaWdOdW1iZXIgdmFsdWVzIGJlY2F1c2UgYW1vdW50IGlzIChzdHJpbmcgfCBudW1iZXIpXG4gICAgICAgICAgY29uc3QgdXNlckFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50RnJvbVVzZXIuYW1vdW50KTtcbiAgICAgICAgICBjb25zdCB0eEFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50RnJvbVR4LmFtb3VudCk7XG4gICAgICAgICAgaWYgKCF1c2VyQW1vdW50LmlzRXF1YWxUbyh0eEFtb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb21wYXJlIHRoZSBhZGRyZXNzZXMgYW5kIHRva2VuTmFtZXNcbiAgICAgICAgICAvLyBFbHNlIGlmIHRoZSBhZGRyZXNzZXMgYXJlIG5vdCB0aGUgc2FtZSwgY2hlY2sgdGhlIGRlcml2ZWQgQVRBIGZvciBwYXJpdHlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByZWNpcGllbnRGcm9tVXNlci5hZGRyZXNzID09PSByZWNpcGllbnRGcm9tVHguYWRkcmVzcyAmJlxuICAgICAgICAgICAgcmVjaXBpZW50RnJvbVVzZXIudG9rZW5OYW1lID09PSByZWNpcGllbnRGcm9tVHgudG9rZW5OYW1lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY2lwaWVudEZyb21Vc2VyLmFkZHJlc3MgIT09IHJlY2lwaWVudEZyb21UeC5hZGRyZXNzICYmIHJlY2lwaWVudEZyb21Vc2VyLnRva2VuTmFtZSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGNoZWNrIGlmIHRoZSB1c2VyJ3MgZGVyaXZlZCBBVEEgaXMgZXF1YWwgdG8gdGhlIHR4IHJlY2lwaWVudCBhZGRyZXNzXG4gICAgICAgICAgICAvLyBJZiBnZXRBc3NvY2lhdGVkVG9rZW5BY2NvdW50QWRkcmVzcyB0aHJvd3MgYW4gZXJyb3IsIHRoZW4gd2UgYXJlIHVuYWJsZSB0byBkZXJpdmUgdGhlIEFUQSBmb3IgdGhhdCBhZGRyZXNzLlxuICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGFuZCB0aHJvdyBhbiBlcnJvciBpZiB0aGF0IGlzIHRoZSBjYXNlLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9rZW5NaW50QWRkcmVzcyA9IGdldFNvbFRva2VuRnJvbVRva2VuTmFtZShyZWNpcGllbnRGcm9tVXNlci50b2tlbk5hbWUpO1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0QXNzb2NpYXRlZFRva2VuQWNjb3VudEFkZHJlc3ModG9rZW5NaW50QWRkcmVzcyEudG9rZW5BZGRyZXNzLCByZWNpcGllbnRGcm9tVXNlci5hZGRyZXNzKS50aGVuKFxuICAgICAgICAgICAgICAgIChhdGE6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0YSA9PT0gcmVjaXBpZW50RnJvbVR4LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIC8vIFVuYWJsZSB0byBkZXJpdmUgQVRBXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgaWYgKHJlY2lwaWVudENoZWNrcy5pbmNsdWRlcyhmYWxzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCBvdXRwdXRzIGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdHhQYXJhbXMgcmVjaXBpZW50cycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uSnNvbiA9IHRyYW5zYWN0aW9uLnRvSnNvbigpO1xuICAgIGlmIChtZW1vICYmIG1lbW8udmFsdWUgIT09IGV4cGxhaW5lZFR4Lm1lbW8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHggbWVtbyBkb2VzIG5vdCBtYXRjaCB3aXRoIGV4cGVjdGVkIHR4UGFyYW1zIHJlY2lwaWVudCBtZW1vJyk7XG4gICAgfVxuICAgIGlmICh0eFBhcmFtcy5yZWNpcGllbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IHJlY2lwaWVudHMgb2YgdHhQYXJhbXMucmVjaXBpZW50cykge1xuICAgICAgICAvLyB0b3RhbEFtb3VudCBiYXNlZCBvbiBlYWNoIHRva2VuXG4gICAgICAgIGNvbnN0IGFzc2V0TmFtZSA9IHJlY2lwaWVudHMudG9rZW5OYW1lIHx8IHRoaXMuZ2V0Q2hhaW4oKTtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gdG90YWxBbW91bnRbYXNzZXROYW1lXSB8fCBuZXcgQmlnTnVtYmVyKDApO1xuICAgICAgICB0b3RhbEFtb3VudFthc3NldE5hbWVdID0gYW1vdW50LnBsdXMocmVjaXBpZW50cy5hbW91bnQpO1xuICAgICAgfVxuXG4gICAgICAvLyB0b3RhbCBvdXRwdXQgYW1vdW50IGZyb20gZXhwbGFpbmVkVHhcbiAgICAgIGNvbnN0IGV4cGxhaW5lZFR4VG90YWw6IFJlY29yZDxzdHJpbmcsIEJpZ051bWJlcj4gPSB7fTtcblxuICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2YgZXhwbGFpbmVkVHgub3V0cHV0cykge1xuICAgICAgICAvLyB0b3RhbCBvdXRwdXQgYW1vdW50IGJhc2VkIG9uIGVhY2ggdG9rZW5cbiAgICAgICAgY29uc3QgYXNzZXROYW1lID0gb3V0cHV0LnRva2VuTmFtZSB8fCB0aGlzLmdldENoYWluKCk7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IGV4cGxhaW5lZFR4VG90YWxbYXNzZXROYW1lXSB8fCBuZXcgQmlnTnVtYmVyKDApO1xuICAgICAgICBleHBsYWluZWRUeFRvdGFsW2Fzc2V0TmFtZV0gPSBhbW91bnQucGx1cyhvdXRwdXQuYW1vdW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzRXF1YWwoZXhwbGFpbmVkVHhUb3RhbCwgdG90YWxBbW91bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHggdG90YWwgYW1vdW50IGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdG90YWwgYW1vdW50IGZpZWxkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIG5vbi1jb25zb2xpZGF0ZSB0cmFuc2FjdGlvbnMsIGZlZVBheWVyIG11c3QgYmUgdGhlIHdhbGxldCdzIHJvb3QgYWRkcmVzc1xuICAgIGlmIChjb25zb2xpZGF0ZUlkID09PSB1bmRlZmluZWQgJiYgdHJhbnNhY3Rpb25Kc29uLmZlZVBheWVyICE9PSB3YWxsZXRSb290QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCBmZWUgcGF5ZXIgaXMgbm90IHRoZSB3YWxsZXQgcm9vdCBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgaWYgKGR1cmFibGVOb25jZSAmJiAhXy5pc0VxdWFsKGV4cGxhaW5lZFR4LmR1cmFibGVOb25jZSwgZHVyYWJsZU5vbmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCBkdXJhYmxlTm9uY2UgZG9lcyBub3QgbWF0Y2ggd2l0aCBwYXJhbSBkdXJhYmxlTm9uY2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBTb2xhbmEga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNlZWQgLSBTZWVkIGZyb20gd2hpY2ggdGhlIG5ldyBTb2xLZXlQYWlyIHNob3VsZCBiZSBnZW5lcmF0ZWQsIG90aGVyd2lzZSBhIHJhbmRvbSBzZWVkIGlzIHVzZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiBhbmQgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlciB8IHVuZGVmaW5lZCk6IEtleVBhaXIge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNlZWQgPyBuZXcgU29sS2V5UGFpcih7IHNlZWQgfSkuZ2V0S2V5cygpIDogbmV3IFNvbEtleVBhaXIoKS5nZXRLZXlzKCk7XG4gICAgcmV0dXJuIHJlc3VsdCBhcyBLZXlQYWlyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHViIHRoZSBwcnYgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNWYWxpZFB1YmxpY0tleShwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwcml2YXRlIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzVmFsaWRQcml2YXRlS2V5KHBydik7XG4gIH1cblxuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICBhc3luYyBzaWduTWVzc2FnZShrZXk6IEtleVBhaXIsIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcik6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgY29uc3Qgc29sS2V5cGFpciA9IG5ldyBTb2xLZXlQYWlyKHsgcHJ2OiBrZXkucHJ2IH0pO1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgIG1lc3NhZ2UgPSBiYXNlNTguZW5jb2RlKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzb2xLZXlwYWlyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBTb2xhbmEgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNvbFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZ2V0QnVpbGRlcigpO1xuICAgIGNvbnN0IHJhd1R4ID0gcGFyYW1zLnR4UHJlYnVpbGQudHhIZXggfHwgcGFyYW1zLnR4UHJlYnVpbGQudHhCYXNlNjQ7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5mcm9tKHJhd1R4KTtcbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogcGFyYW1zLnBydiB9KTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbjogQmFzZVRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJpYWxpemVkVHggPSAodHJhbnNhY3Rpb24gYXMgQmFzZVRyYW5zYWN0aW9uKS50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR4SGV4OiBzZXJpYWxpemVkVHgsXG4gICAgfSBhcyBhbnk7XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogU29sUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNvbFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IGF3YWl0IHRoaXMuZXhwbGFpblRyYW5zYWN0aW9uKHtcbiAgICAgIHR4QmFzZTY0OiBwYXJhbXMudHhCYXNlNjQsXG4gICAgICBmZWVJbmZvOiBwYXJhbXMuZmVlSW5mbyxcbiAgICAgIHRva2VuQWNjb3VudFJlbnRFeGVtcHRBbW91bnQ6IHBhcmFtcy50b2tlbkFjY291bnRSZW50RXhlbXB0QW1vdW50LFxuICAgIH0pO1xuXG4gICAgaWYgKCF0cmFuc2FjdGlvbkV4cGxhbmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzb2xUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24gYXMgU29sVHJhbnNhY3Rpb25FeHBsYW5hdGlvbjtcbiAgICBpZiAoc29sVHJhbnNhY3Rpb24ub3V0cHV0cy5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHNlbmRlckFkZHJlc3MgPSBzb2xUcmFuc2FjdGlvbi5vdXRwdXRzWzBdLmFkZHJlc3M7XG4gICAgY29uc3QgZmVlQW1vdW50ID0gbmV3IEJpZ051bWJlcihzb2xUcmFuc2FjdGlvbi5mZWUuZmVlKTtcblxuICAgIC8vIGFzc3VtZSAxIHNlbmRlciwgd2hvIGlzIGFsc28gdGhlIGZlZSBwYXllclxuICAgIGNvbnN0IGlucHV0cyA9IFtcbiAgICAgIHtcbiAgICAgICAgYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKHNvbFRyYW5zYWN0aW9uLm91dHB1dEFtb3VudCkucGx1cyhmZWVBbW91bnQpLnRvTnVtYmVyKCksXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBjb25zdCBvdXRwdXRzOiBUcmFuc2FjdGlvbk91dHB1dFtdID0gc29sVHJhbnNhY3Rpb24ub3V0cHV0cy5tYXAoKHsgYWRkcmVzcywgYW1vdW50LCB0b2tlbk5hbWUgfSkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0OiBUcmFuc2FjdGlvbk91dHB1dCA9IHsgYWRkcmVzcywgYW1vdW50IH07XG4gICAgICBpZiAodG9rZW5OYW1lKSB7XG4gICAgICAgIG91dHB1dC50b2tlbk5hbWUgPSB0b2tlbk5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0cyxcbiAgICAgIG91dHB1dHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgU29sYW5hIHRyYW5zYWN0aW9uIGZyb20gdHhCYXNlNjRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U29sVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcbiAgICBsZXQgcmVidWlsdFRyYW5zYWN0aW9uO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uQnVpbGRlciA9IGZhY3RvcnkuZnJvbShwYXJhbXMudHhCYXNlNjQpO1xuICAgICAgaWYgKHRyYW5zYWN0aW9uQnVpbGRlciBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uQnVpbGRlcikge1xuICAgICAgICBjb25zdCB0eEJ1aWxkZXIgPSB0cmFuc2FjdGlvbkJ1aWxkZXIgYXMgVHJhbnNhY3Rpb25CdWlsZGVyO1xuICAgICAgICB0eEJ1aWxkZXIuZmVlKHsgYW1vdW50OiBwYXJhbXMuZmVlSW5mby5mZWUgfSk7XG4gICAgICAgIGlmIChwYXJhbXMudG9rZW5BY2NvdW50UmVudEV4ZW1wdEFtb3VudCkge1xuICAgICAgICAgIHR4QnVpbGRlci5hc3NvY2lhdGVkVG9rZW5BY2NvdW50UmVudChwYXJhbXMudG9rZW5BY2NvdW50UmVudEV4ZW1wdEFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlYnVpbHRUcmFuc2FjdGlvbiA9IGF3YWl0IHRyYW5zYWN0aW9uQnVpbGRlci5idWlsZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhwbGFpbmVkVHJhbnNhY3Rpb24gPSAocmVidWlsdFRyYW5zYWN0aW9uIGFzIEJhc2VUcmFuc2FjdGlvbikuZXhwbGFpblRyYW5zYWN0aW9uKCk7XG5cbiAgICByZXR1cm4gZXhwbGFpbmVkVHJhbnNhY3Rpb24gYXMgU29sVHJhbnNhY3Rpb25FeHBsYW5hdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBhc3luYyBnZXRTaWduYWJsZVBheWxvYWQoc2VyaWFsaXplZFR4OiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcbiAgICBjb25zdCByZWJ1aWx0VHJhbnNhY3Rpb24gPSBhd2FpdCBmYWN0b3J5LmZyb20oc2VyaWFsaXplZFR4KS5idWlsZCgpO1xuICAgIHJldHVybiByZWJ1aWx0VHJhbnNhY3Rpb24uc2lnbmFibGVQYXlsb2FkO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGFzeW5jIHByZXNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnM+IHtcbiAgICAvLyBIb3Qgd2FsbGV0IHR4bnMgYXJlIG9ubHkgdmFsaWQgZm9yIDEtMiBtaW51dGVzLlxuICAgIC8vIFRvIGJ1eSBtb3JlIHRpbWUsIHdlIHJlYnVpbGQgdGhlIHRyYW5zYWN0aW9uIHdpdGggYSBuZXcgYmxvY2toYXNoIHJpZ2h0IGJlZm9yZSB3ZSBzaWduLlxuICAgIGlmIChwYXJhbXMud2FsbGV0RGF0YS50eXBlICE9PSAnaG90Jykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYXJhbXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHR4UmVxdWVzdElkID0gcGFyYW1zLnR4UHJlYnVpbGQ/LnR4UmVxdWVzdElkO1xuICAgIGlmICh0eFJlcXVlc3RJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHhSZXF1ZXN0SWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHRzc1V0aWxzIH0gPSBwYXJhbXM7XG5cbiAgICBhd2FpdCB0c3NVdGlscyEuZGVsZXRlU2lnbmF0dXJlU2hhcmVzKHR4UmVxdWVzdElkKTtcbiAgICBjb25zdCByZWNyZWF0ZWQgPSBhd2FpdCB0c3NVdGlscyEuZ2V0VHhSZXF1ZXN0KHR4UmVxdWVzdElkKTtcbiAgICBsZXQgdHhIZXggPSAnJztcbiAgICBpZiAocmVjcmVhdGVkLnVuc2lnbmVkVHhzKSB7XG4gICAgICB0eEhleCA9IHJlY3JlYXRlZC51bnNpZ25lZFR4c1swXT8uc2VyaWFsaXplZFR4SGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0eEhleCA9IHJlY3JlYXRlZC50cmFuc2FjdGlvbnMgPyByZWNyZWF0ZWQudHJhbnNhY3Rpb25zWzBdPy51bnNpZ25lZFR4LnNlcmlhbGl6ZWRUeEhleCA6ICcnO1xuICAgIH1cblxuICAgIGlmICghdHhIZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzZXJpYWxpemVkIHR4IGhleCcpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgdHhQcmVidWlsZDogcmVjcmVhdGVkLFxuICAgICAgdHhIZXgsXG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0UHVibGljTm9kZVVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBFbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0uc29sTm9kZVVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgcmVxdWVzdCB0byBvbmUgb2YgdGhlIHB1YmxpYyBTT0wgbm9kZXMgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSBwYXJhbXMucGF5bG9hZFxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGdldERhdGFGcm9tTm9kZShwYXJhbXM6IHsgcGF5bG9hZD86IFJlY29yZDxzdHJpbmcsIHVua25vd24+IH0pOiBQcm9taXNlPHJlcXVlc3QuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBub2RlVXJsID0gdGhpcy5nZXRQdWJsaWNOb2RlVXJsKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LnBvc3Qobm9kZVVybCkuc2VuZChwYXJhbXMucGF5bG9hZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY2FsbCBlbmRwb2ludDogJy8nIGZyb20gbm9kZTogJHtub2RlVXJsfWApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEJsb2NraGFzaCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXREYXRhRnJvbU5vZGUoe1xuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBpZDogJzEnLFxuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgbWV0aG9kOiAnZ2V0TGF0ZXN0QmxvY2toYXNoJyxcbiAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tbWl0bWVudDogJ2ZpbmFsaXplZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHkucmVzdWx0LnZhbHVlLmJsb2NraGFzaDtcbiAgfVxuXG4gIC8qKiBUT0RPIFVwZGF0ZSB0byBnZXRGZWVGb3JNZXNzYWdlIGFuZCBtYWtlIG5lY3NzYXJ5IGNoYW5nZXMgaW4gZmVlIGNhbGN1bGF0aW9uLCBHZXRGZWVzIGlzIGRlcHJlY2F0ZWQgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEZlZXMoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKHtcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ2dldEZlZXMnLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuYm9keS5yZXN1bHQudmFsdWUuZmVlQ2FsY3VsYXRvci5sYW1wb3J0c1BlclNpZ25hdHVyZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRSZW50RXhlbXB0QW1vdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldERhdGFGcm9tTm9kZSh7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogJzEnLFxuICAgICAgICBtZXRob2Q6ICdnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24nLFxuICAgICAgICBwYXJhbXM6IFsxNjVdLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDAgfHwgcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShyZXNwb25zZS5lcnJvcikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5ib2R5LnJlc3VsdDtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRBY2NvdW50QmFsYW5jZShwdWJLZXk6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldERhdGFGcm9tTm9kZSh7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGlkOiAnMScsXG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICdnZXRCYWxhbmNlJyxcbiAgICAgICAgcGFyYW1zOiBbcHViS2V5XSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5ib2R5LnJlc3VsdC52YWx1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRBY2NvdW50SW5mbyhwdWJLZXk6IHN0cmluZyk6IFByb21pc2U8U29sRHVyYWJsZU5vbmNlRnJvbU5vZGU+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKHtcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ2dldEFjY291bnRJbmZvJyxcbiAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgcHViS2V5LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVuY29kaW5nOiAnanNvblBhcnNlZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhdXRob3JpdHk6IHJlc3BvbnNlLmJvZHkucmVzdWx0LnZhbHVlLmRhdGEucGFyc2VkLmluZm8uYXV0aG9yaXR5LFxuICAgICAgYmxvY2toYXNoOiByZXNwb25zZS5ib2R5LnJlc3VsdC52YWx1ZS5kYXRhLnBhcnNlZC5pbmZvLmJsb2NraGFzaCxcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldFRva2VuQWNjb3VudHNCeU93bmVyKHB1YktleSA9ICcnKTogUHJvbWlzZTxbXSB8IFRva2VuQWNjb3VudFtdPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldERhdGFGcm9tTm9kZSh7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGlkOiAnMScsXG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICdnZXRUb2tlbkFjY291bnRzQnlPd25lcicsXG4gICAgICAgIHBhcmFtczogW1xuICAgICAgICAgIHB1YktleSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcm9ncmFtSWQ6ICdUb2tlbmtlZ1FmZVp5aU53QUpiTmJHS1BGWENXdUJ2ZjlTczYyM1ZRNURBJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVuY29kaW5nOiAnanNvblBhcnNlZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLmJvZHkucmVzdWx0LnZhbHVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgdG9rZW5BY2NvdW50czogVG9rZW5BY2NvdW50W10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgdG9rZW5BY2NvdW50IG9mIHJlc3BvbnNlLmJvZHkucmVzdWx0LnZhbHVlKSB7XG4gICAgICAgIHRva2VuQWNjb3VudHMucHVzaCh7IGluZm86IHRva2VuQWNjb3VudC5hY2NvdW50LmRhdGEucGFyc2VkLmluZm8sIHB1YktleTogdG9rZW5BY2NvdW50LnB1YktleSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbkFjY291bnRzO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRUb2tlbkFjY291bnRJbmZvKHB1YktleTogc3RyaW5nKTogUHJvbWlzZTxUb2tlbkFjY291bnQ+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKHtcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ2dldEFjY291bnRJbmZvJyxcbiAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgcHViS2V5LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVuY29kaW5nOiAnanNvblBhcnNlZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwdWJLZXk6IHB1YktleSxcbiAgICAgIGluZm86IHJlc3BvbnNlLmJvZHkucmVzdWx0LnZhbHVlLmRhdGEucGFyc2VkLmluZm8sXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBpbmhlcml0ZWQgZG9jICovXG4gIGFzeW5jIGNyZWF0ZUJyb2FkY2FzdGFibGVTd2VlcFRyYW5zYWN0aW9uKHBhcmFtczogTVBDU3dlZXBSZWNvdmVyeU9wdGlvbnMpOiBQcm9taXNlPE1QQ1R4cz4ge1xuICAgIGlmICghcGFyYW1zLnNpZ25hdHVyZVNoYXJlcykge1xuICAgICAgKCdNaXNzaW5nIHRyYW5zYWN0aW9uKHMpJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlcSA9IHBhcmFtcy5zaWduYXR1cmVTaGFyZXM7XG4gICAgY29uc3QgYnJvYWRjYXN0YWJsZVRyYW5zYWN0aW9uczogTVBDVHhbXSA9IFtdO1xuICAgIGxldCBsYXN0U2NhbkluZGV4ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBNUEMgPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0SW5pdGlhbGl6ZWRNcGNJbnN0YW5jZSgpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSByZXFbaV0udHhSZXF1ZXN0LnRyYW5zYWN0aW9uc1swXS51bnNpZ25lZFR4O1xuICAgICAgaWYgKCFyZXFbaV0ub3ZjIHx8ICFyZXFbaV0ub3ZjWzBdLmVkZHNhU2lnbmF0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzaWduYXR1cmUocyknKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHJlcVtpXS5vdmNbMF0uZWRkc2FTaWduYXR1cmU7XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uLnNpZ25hYmxlSGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzaWduYWJsZSBoZXgnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2VCdWZmZXIgPSBCdWZmZXIuZnJvbSh0cmFuc2FjdGlvbi5zaWduYWJsZUhleCEsICdoZXgnKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IE1QQy52ZXJpZnkobWVzc2FnZUJ1ZmZlciwgc2lnbmF0dXJlKTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25hdHVyZUhleCA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKHNpZ25hdHVyZS5SLCAnaGV4JyksIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZS5zaWdtYSwgJ2hleCcpXSk7XG4gICAgICBjb25zdCB0eEJ1aWxkZXIgPSB0aGlzLmdldEJ1aWxkZXIoKS5mcm9tKHRyYW5zYWN0aW9uLnNlcmlhbGl6ZWRUeCBhcyBzdHJpbmcpO1xuICAgICAgaWYgKCF0cmFuc2FjdGlvbi5jb2luU3BlY2lmaWM/LmNvbW1vbktleWNoYWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjb21tb24ga2V5Y2hhaW4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbW1vbktleWNoYWluID0gdHJhbnNhY3Rpb24uY29pblNwZWNpZmljIS5jb21tb25LZXljaGFpbiEgYXMgc3RyaW5nO1xuICAgICAgaWYgKCF0cmFuc2FjdGlvbi5kZXJpdmF0aW9uUGF0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGVyaXZhdGlvbiBwYXRoJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9IHRyYW5zYWN0aW9uLmRlcml2YXRpb25QYXRoIGFzIHN0cmluZztcbiAgICAgIGNvbnN0IGFjY291bnRJZCA9IE1QQy5kZXJpdmVVbmhhcmRlbmVkKGNvbW1vbktleWNoYWluLCBkZXJpdmF0aW9uUGF0aCkuc2xpY2UoMCwgNjQpO1xuICAgICAgY29uc3QgYnM1OEVuY29kZWRQdWJsaWNLZXkgPSBuZXcgU29sS2V5UGFpcih7IHB1YjogYWNjb3VudElkIH0pLmdldEFkZHJlc3MoKTtcblxuICAgICAgLy8gYWRkIGNvbWJpbmVkIHNpZ25hdHVyZSBmcm9tIG92Y1xuICAgICAgY29uc3QgcHVibGljS2V5T2JqID0geyBwdWI6IGJzNThFbmNvZGVkUHVibGljS2V5IH07XG4gICAgICB0eEJ1aWxkZXIuYWRkU2lnbmF0dXJlKHB1YmxpY0tleU9iaiBhcyBQdWJsaWNLZXksIHNpZ25hdHVyZUhleCk7XG5cbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgICBjb25zdCBzZXJpYWxpemVkVHggPSBzaWduZWRUcmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuXG4gICAgICBicm9hZGNhc3RhYmxlVHJhbnNhY3Rpb25zLnB1c2goe1xuICAgICAgICBzZXJpYWxpemVkVHg6IHNlcmlhbGl6ZWRUeCxcbiAgICAgICAgc2NhbkluZGV4OiB0cmFuc2FjdGlvbi5zY2FuSW5kZXgsXG4gICAgICB9KTtcblxuICAgICAgaWYgKGkgPT09IHJlcS5sZW5ndGggLSAxICYmIHRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYyEubGFzdFNjYW5JbmRleCkge1xuICAgICAgICBsYXN0U2NhbkluZGV4ID0gdHJhbnNhY3Rpb24uY29pblNwZWNpZmljIS5sYXN0U2NhbkluZGV4IGFzIG51bWJlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB0cmFuc2FjdGlvbnM6IGJyb2FkY2FzdGFibGVUcmFuc2FjdGlvbnMsIGxhc3RTY2FuSW5kZXggfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvXG4gICAqIEBwYXJhbSB7U29sUmVjb3ZlcnlPcHRpb25zfSBwYXJhbXMgcGFyYW1ldGVycyBuZWVkZWQgdG8gY29uc3RydWN0IGFuZFxuICAgKiAobWF5YmUpIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtNUENUeCB8IE1QQ1N3ZWVwVHhzfSB0aGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBoZXggc3RyaW5nIGFuZCBpbmRleFxuICAgKiBvZiB0aGUgYWRkcmVzcyBiZWluZyBzd2VwdFxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlcihwYXJhbXM6IFNvbFJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8TVBDVHggfCBNUENTd2VlcFR4cz4ge1xuICAgIGlmICghcGFyYW1zLmJpdGdvS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYml0Z29LZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBiaXRnb0tleSA9IHBhcmFtcy5iaXRnb0tleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9ICFwYXJhbXMudXNlcktleSAmJiAhcGFyYW1zLmJhY2t1cEtleSAmJiAhcGFyYW1zLndhbGxldFBhc3NwaHJhc2U7XG5cbiAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb25cbiAgICBjb25zdCBNUEMgPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0SW5pdGlhbGl6ZWRNcGNJbnN0YW5jZSgpO1xuICAgIGxldCBiYWxhbmNlID0gMDtcbiAgICBjb25zdCBmZWVQZXJTaWduYXR1cmUgPSBhd2FpdCB0aGlzLmdldEZlZXMoKTtcbiAgICBjb25zdCBiYXNlRmVlID0gcGFyYW1zLmR1cmFibGVOb25jZSA/IGZlZVBlclNpZ25hdHVyZSAqIDIgOiBmZWVQZXJTaWduYXR1cmU7XG4gICAgbGV0IHRvdGFsRmVlID0gbmV3IEJpZ051bWJlcihiYXNlRmVlKTtcblxuICAgIGNvbnN0IGluZGV4ID0gcGFyYW1zLmluZGV4IHx8IDA7XG4gICAgY29uc3QgY3VyclBhdGggPSBwYXJhbXMuc2VlZCA/IGdldERlcml2YXRpb25QYXRoKHBhcmFtcy5zZWVkKSArIGAvJHtpbmRleH1gIDogYG0vJHtpbmRleH1gO1xuICAgIGNvbnN0IGFjY291bnRJZCA9IE1QQy5kZXJpdmVVbmhhcmRlbmVkKGJpdGdvS2V5LCBjdXJyUGF0aCkuc2xpY2UoMCwgNjQpO1xuICAgIGNvbnN0IGJzNThFbmNvZGVkUHVibGljS2V5ID0gbmV3IFNvbEtleVBhaXIoeyBwdWI6IGFjY291bnRJZCB9KS5nZXRBZGRyZXNzKCk7XG5cbiAgICBiYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50QmFsYW5jZShiczU4RW5jb2RlZFB1YmxpY0tleSk7XG4gICAgaWYgKHRvdGFsRmVlLmd0KGJhbGFuY2UpKSB7XG4gICAgICB0aHJvdyBFcnJvcignRGlkIG5vdCBmaW5kIGFkZHJlc3Mgd2l0aCBmdW5kcyB0byByZWNvdmVyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZ2V0QnVpbGRlcigpO1xuICAgIGNvbnN0IHdhbGxldENvaW4gPSB0aGlzLmdldENoYWluKCk7XG5cbiAgICBsZXQgdHhCdWlsZGVyO1xuICAgIGxldCBibG9ja2hhc2ggPSBhd2FpdCB0aGlzLmdldEJsb2NraGFzaCgpO1xuICAgIGxldCByZW50RXhlbXB0QW1vdW50O1xuICAgIGxldCBhdXRob3JpdHkgPSAnJztcblxuICAgIGlmIChwYXJhbXMuZHVyYWJsZU5vbmNlKSB7XG4gICAgICBjb25zdCBkdXJhYmxlTm9uY2VJbmZvID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mbyhwYXJhbXMuZHVyYWJsZU5vbmNlLnB1YmxpY0tleSk7XG4gICAgICBibG9ja2hhc2ggPSBkdXJhYmxlTm9uY2VJbmZvLmJsb2NraGFzaDtcbiAgICAgIGF1dGhvcml0eSA9IGR1cmFibGVOb25jZUluZm8uYXV0aG9yaXR5O1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBwb3NzaWJsZSB0b2tlbiByZWNvdmVyeSwgcmVjb3ZlciB0aGUgdG9rZW4gcHJvdmlkZSBieSB1c2VyXG4gICAgaWYgKHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgY29uc3QgdG9rZW5BY2NvdW50cyA9IGF3YWl0IHRoaXMuZ2V0VG9rZW5BY2NvdW50c0J5T3duZXIoYnM1OEVuY29kZWRQdWJsaWNLZXkpO1xuICAgICAgaWYgKHRva2VuQWNjb3VudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZXJlIGV4aXN0cyB0b2tlbiBhY2NvdW50cyBvbiB0aGUgZ2l2ZW4gYWRkcmVzcywgYnV0IG5lZWQgdG8gY2hlY2sgY2VydGFpbiBjb25kaXRpb25zOlxuICAgICAgICAvLyAxLiBpZiB0aGVyZSBpcyBhIHJlY292ZXJhYmxlIGJhbGFuY2VcbiAgICAgICAgLy8gMi4gaWYgdGhlIHRva2VuIGlzIHN1cHBvcnRlZCBieSBiaXRnb1xuICAgICAgICBjb25zdCByZWNvdmVyZWFibGVUb2tlbkFjY291bnRzOiBUb2tlbkFjY291bnRbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuQWNjb3VudCBvZiB0b2tlbkFjY291bnRzKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyA9PT0gdG9rZW5BY2NvdW50LmluZm8ubWludCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5BbW91bnQgPSBuZXcgQmlnTnVtYmVyKHRva2VuQWNjb3VudC5pbmZvLnRva2VuQW1vdW50LmFtb3VudCk7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGdldFNvbFRva2VuRnJvbUFkZHJlc3ModG9rZW5BY2NvdW50LmluZm8ubWludCwgbmV0d29yayk7XG5cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh0b2tlbikgJiYgdG9rZW5BbW91bnQuZ3QobmV3IEJpZ051bWJlcigwKSkpIHtcbiAgICAgICAgICAgICAgdG9rZW5BY2NvdW50LnRva2VuTmFtZSA9IHRva2VuLm5hbWU7XG4gICAgICAgICAgICAgIHJlY292ZXJlYWJsZVRva2VuQWNjb3VudHMucHVzaCh0b2tlbkFjY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY292ZXJlYWJsZVRva2VuQWNjb3VudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgcmVudEV4ZW1wdEFtb3VudCA9IGF3YWl0IHRoaXMuZ2V0UmVudEV4ZW1wdEFtb3VudCgpO1xuXG4gICAgICAgICAgdHhCdWlsZGVyID0gZmFjdG9yeVxuICAgICAgICAgICAgLmdldFRva2VuVHJhbnNmZXJCdWlsZGVyKClcbiAgICAgICAgICAgIC5ub25jZShibG9ja2hhc2gpXG4gICAgICAgICAgICAuc2VuZGVyKGJzNThFbmNvZGVkUHVibGljS2V5KVxuICAgICAgICAgICAgLmZlZSh7IGFtb3VudDogZmVlUGVyU2lnbmF0dXJlIH0pXG4gICAgICAgICAgICAuYXNzb2NpYXRlZFRva2VuQWNjb3VudFJlbnQocmVudEV4ZW1wdEFtb3VudC50b1N0cmluZygpKVxuICAgICAgICAgICAgLmZlZVBheWVyKGJzNThFbmNvZGVkUHVibGljS2V5KTtcblxuICAgICAgICAgIC8vIG5lZWQgdG8gZ2V0IGFsbCB0b2tlbiBhY2NvdW50cyBvZiB0aGUgcmVjaXBpZW50IGFkZHJlc3MgYW5kIG5lZWQgdG8gY3JlYXRlIHRoZW0gaWYgdGhleSBkbyBub3QgZXhpc3RcbiAgICAgICAgICBjb25zdCByZWNpcGllbnRUb2tlbkFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRUb2tlbkFjY291bnRzQnlPd25lcihwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbik7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuQWNjb3VudCBvZiByZWNvdmVyZWFibGVUb2tlbkFjY291bnRzKSB7XG4gICAgICAgICAgICBsZXQgcmVjaXBpZW50VG9rZW5BY2NvdW50RXhpc3RzID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlY2lwaWVudFRva2VuQWNjb3VudCBvZiByZWNpcGllbnRUb2tlbkFjY291bnRzIGFzIFRva2VuQWNjb3VudFtdKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNpcGllbnRUb2tlbkFjY291bnQuaW5mby5taW50ID09PSB0b2tlbkFjY291bnQuaW5mby5taW50KSB7XG4gICAgICAgICAgICAgICAgcmVjaXBpZW50VG9rZW5BY2NvdW50RXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZWNpcGllbnRUb2tlbkFjY291bnQgPSBhd2FpdCBnZXRBc3NvY2lhdGVkVG9rZW5BY2NvdW50QWRkcmVzcyhcbiAgICAgICAgICAgICAgdG9rZW5BY2NvdW50LmluZm8ubWludCxcbiAgICAgICAgICAgICAgcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCB0b2tlbk5hbWUgPSB0b2tlbkFjY291bnQudG9rZW5OYW1lIGFzIHN0cmluZztcbiAgICAgICAgICAgIHR4QnVpbGRlci5zZW5kKHtcbiAgICAgICAgICAgICAgYWRkcmVzczogcmVjaXBpZW50VG9rZW5BY2NvdW50LFxuICAgICAgICAgICAgICBhbW91bnQ6IHRva2VuQWNjb3VudC5pbmZvLnRva2VuQW1vdW50LmFtb3VudCxcbiAgICAgICAgICAgICAgdG9rZW5OYW1lOiB0b2tlbk5hbWUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFyZWNpcGllbnRUb2tlbkFjY291bnRFeGlzdHMpIHtcbiAgICAgICAgICAgICAgLy8gcmVjaXBpZW50IHRva2VuIGFjY291bnQgZG9lcyBub3QgZXhpc3QgZm9yIHRva2VuIGFuZCBtdXN0IGJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgdHhCdWlsZGVyLmNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnQoe1xuICAgICAgICAgICAgICAgIG93bmVyQWRkcmVzczogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW5OYW1lOiB0b2tlbk5hbWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyBhZGQgcmVudCBleGVtcHQgYW1vdW50IHRvIHRvdGFsIGZlZSBmb3IgZWFjaCB0b2tlbiBhY2NvdW50IHRoYXQgaGFzIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgdG90YWxGZWUgPSB0b3RhbEZlZS5wbHVzKHJlbnRFeGVtcHRBbW91bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRoZXJlIGFyZSByZWNvdmVyYWJsZSB0b2tlbiBhY2NvdW50cywgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzdWZmaWNpZW50IG5hdGl2ZSBzb2xhbmEgdG8gcmVjb3ZlciB0b2tlbnNcbiAgICAgICAgICBpZiAobmV3IEJpZ051bWJlcihiYWxhbmNlKS5sdCh0b3RhbEZlZSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAnTm90IGVub3VnaCBmdW5kcyB0byBwYXkgZm9yIHJlY292ZXIgdG9rZW5zIGZlZXMsIGhhdmU6ICcgKyBiYWxhbmNlICsgJyBuZWVkOiAnICsgdG90YWxGZWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ05vdCBlbm91Z2ggdG9rZW4gZnVuZHMgdG8gcmVjb3ZlcicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSBhcmUgbm8gcmVjb3ZlcmFibGUgdG9rZW4gYWNjb3VudHMgLCBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGFyZSB0b2tlbnMgdG8gcmVjb3ZlclxuICAgICAgICB0aHJvdyBFcnJvcignRGlkIG5vdCBmaW5kIHRva2VuIGFjY291bnQgdG8gcmVjb3ZlciB0b2tlbnMsIHBsZWFzZSBjaGVjayB0b2tlbiBhY2NvdW50Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ldEFtb3VudCA9IG5ldyBCaWdOdW1iZXIoYmFsYW5jZSkubWludXModG90YWxGZWUpO1xuXG4gICAgICB0eEJ1aWxkZXIgPSBmYWN0b3J5XG4gICAgICAgIC5nZXRUcmFuc2ZlckJ1aWxkZXIoKVxuICAgICAgICAubm9uY2UoYmxvY2toYXNoKVxuICAgICAgICAuc2VuZGVyKGJzNThFbmNvZGVkUHVibGljS2V5KVxuICAgICAgICAuc2VuZCh7IGFkZHJlc3M6IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLCBhbW91bnQ6IG5ldEFtb3VudC50b1N0cmluZygpIH0pXG4gICAgICAgIC5mZWUoeyBhbW91bnQ6IGZlZVBlclNpZ25hdHVyZSB9KVxuICAgICAgICAuZmVlUGF5ZXIoYnM1OEVuY29kZWRQdWJsaWNLZXkpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZHVyYWJsZU5vbmNlKSB7XG4gICAgICB0eEJ1aWxkZXIubm9uY2UoYmxvY2toYXNoLCB7XG4gICAgICAgIHdhbGxldE5vbmNlQWRkcmVzczogcGFyYW1zLmR1cmFibGVOb25jZS5wdWJsaWNLZXksXG4gICAgICAgIGF1dGhXYWxsZXRBZGRyZXNzOiBhdXRob3JpdHksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgLy8gU2lnbiB0aGUgdHhuXG4gICAgICBpZiAoIXBhcmFtcy51c2VyS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB1c2VyS2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyYW1zLmJhY2t1cEtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYmFja3VwS2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyYW1zLndhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHdhbGxldCBwYXNzcGhyYXNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVuc2lnbmVkVHJhbnNhY3Rpb24gPSAoYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCkpIGFzIFRyYW5zYWN0aW9uO1xuXG4gICAgICBjb25zdCB1c2VyS2V5ID0gcGFyYW1zLnVzZXJLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgIGNvbnN0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICAgICAgLy8gRGVjcnlwdCBwcml2YXRlIGtleXMgZnJvbSBLZXlDYXJkIHZhbHVlc1xuICAgICAgbGV0IHVzZXJQcnY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHVzZXJQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgIGlucHV0OiB1c2VyS2V5LFxuICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyB1c2VyIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlclNpZ25pbmdNYXRlcmlhbCA9IEpTT04ucGFyc2UodXNlclBydikgYXMgRUREU0FNZXRob2RUeXBlcy5Vc2VyU2lnbmluZ01hdGVyaWFsO1xuXG4gICAgICBsZXQgYmFja3VwUHJ2O1xuICAgICAgdHJ5IHtcbiAgICAgICAgYmFja3VwUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgICBpbnB1dDogYmFja3VwS2V5LFxuICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyBiYWNrdXAga2V5Y2hhaW46ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFja3VwU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZShiYWNrdXBQcnYpIGFzIEVERFNBTWV0aG9kVHlwZXMuQmFja3VwU2lnbmluZ01hdGVyaWFsO1xuXG4gICAgICBjb25zdCBzaWduYXR1cmVIZXggPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0VFNTU2lnbmF0dXJlKFxuICAgICAgICB1c2VyU2lnbmluZ01hdGVyaWFsLFxuICAgICAgICBiYWNrdXBTaWduaW5nTWF0ZXJpYWwsXG4gICAgICAgIGN1cnJQYXRoLFxuICAgICAgICB1bnNpZ25lZFRyYW5zYWN0aW9uXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwdWJsaWNLZXlPYmogPSB7IHB1YjogYnM1OEVuY29kZWRQdWJsaWNLZXkgfTtcbiAgICAgIHR4QnVpbGRlci5hZGRTaWduYXR1cmUocHVibGljS2V5T2JqIGFzIFB1YmxpY0tleSwgc2lnbmF0dXJlSGV4KTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmR1cmFibGVOb25jZSkge1xuICAgICAgLy8gYWRkIGR1cmFibGUgbm9uY2UgYWNjb3VudCBzaWduYXR1cmVcbiAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBwYXJhbXMuZHVyYWJsZU5vbmNlLnNlY3JldEtleSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wbGV0ZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9IGNvbXBsZXRlZFRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCk7XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBwYXJhbXMuc2VlZCA/IGdldERlcml2YXRpb25QYXRoKHBhcmFtcy5zZWVkKSArIGAvJHtpbmRleH1gIDogYG0vJHtpbmRleH1gO1xuICAgIGNvbnN0IGlucHV0czogT3ZjSW5wdXRbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgY29tcGxldGVkVHJhbnNhY3Rpb24uaW5wdXRzKSB7XG4gICAgICBpbnB1dHMucHVzaCh7XG4gICAgICAgIGFkZHJlc3M6IGlucHV0LmFkZHJlc3MsXG4gICAgICAgIHZhbHVlU3RyaW5nOiBpbnB1dC52YWx1ZSxcbiAgICAgICAgdmFsdWU6IG5ldyBCaWdOdW1iZXIoaW5wdXQudmFsdWUpLnRvTnVtYmVyKCksXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0czogT3ZjT3V0cHV0W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBjb21wbGV0ZWRUcmFuc2FjdGlvbi5vdXRwdXRzKSB7XG4gICAgICBvdXRwdXRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzOiBvdXRwdXQuYWRkcmVzcyxcbiAgICAgICAgdmFsdWVTdHJpbmc6IG91dHB1dC52YWx1ZSxcbiAgICAgICAgY29pbk5hbWU6IG91dHB1dC5jb2luID8gb3V0cHV0LmNvaW4gOiB3YWxsZXRDb2luLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNwZW5kQW1vdW50ID0gY29tcGxldGVkVHJhbnNhY3Rpb24uaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGNvbXBsZXRlZFRyYW5zYWN0aW9uLmlucHV0c1swXS52YWx1ZSA6IDA7XG4gICAgY29uc3QgcGFyc2VkVHggPSB7IGlucHV0czogaW5wdXRzLCBvdXRwdXRzOiBvdXRwdXRzLCBzcGVuZEFtb3VudDogc3BlbmRBbW91bnQsIHR5cGU6ICcnIH07XG4gICAgY29uc3QgZmVlSW5mbyA9IHsgZmVlOiB0b3RhbEZlZS50b051bWJlcigpLCBmZWVTdHJpbmc6IHRvdGFsRmVlLnRvU3RyaW5nKCkgfTtcbiAgICBjb25zdCBjb2luU3BlY2lmaWMgPSB7IGNvbW1vbktleWNoYWluOiBiaXRnb0tleSB9O1xuICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBNUENUeCA9IHtcbiAgICAgICAgc2VyaWFsaXplZFR4OiBzZXJpYWxpemVkVHgsXG4gICAgICAgIHNjYW5JbmRleDogaW5kZXgsXG4gICAgICAgIGNvaW46IHdhbGxldENvaW4sXG4gICAgICAgIHNpZ25hYmxlSGV4OiBjb21wbGV0ZWRUcmFuc2FjdGlvbi5zaWduYWJsZVBheWxvYWQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBkZXJpdmF0aW9uUGF0aDogZGVyaXZhdGlvblBhdGgsXG4gICAgICAgIHBhcnNlZFR4OiBwYXJzZWRUeCxcbiAgICAgICAgZmVlSW5mbzogZmVlSW5mbyxcbiAgICAgICAgY29pblNwZWNpZmljOiBjb2luU3BlY2lmaWMsXG4gICAgICB9O1xuICAgICAgY29uc3QgdW5zaWduZWRUeDogTVBDVW5zaWduZWRUeCA9IHsgdW5zaWduZWRUeDogdHJhbnNhY3Rpb24sIHNpZ25hdHVyZVNoYXJlczogW10gfTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uczogTVBDVW5zaWduZWRUeFtdID0gW3Vuc2lnbmVkVHhdO1xuICAgICAgY29uc3QgdHhSZXF1ZXN0OiBSZWNvdmVyeVR4UmVxdWVzdCA9IHtcbiAgICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMsXG4gICAgICAgIHdhbGxldENvaW46IHdhbGxldENvaW4sXG4gICAgICB9O1xuICAgICAgY29uc3QgdHhSZXF1ZXN0czogTVBDU3dlZXBUeHMgPSB7IHR4UmVxdWVzdHM6IFt0eFJlcXVlc3RdIH07XG4gICAgICByZXR1cm4gdHhSZXF1ZXN0cztcbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb246IE1QQ1R4ID0ge1xuICAgICAgc2VyaWFsaXplZFR4OiBzZXJpYWxpemVkVHgsXG4gICAgICBzY2FuSW5kZXg6IGluZGV4LFxuICAgIH07XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHtTb2xSZWNvdmVyeU9wdGlvbnN9IHBhcmFtcyBwYXJhbWV0ZXJzIG5lZWRlZCB0byBjb25zdHJ1Y3QgYW5kXG4gICAqIChtYXliZSkgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge0Jhc2VCcm9hZGNhc3RUcmFuc2FjdGlvblJlc3VsdFtdfSB0aGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBoZXggc3RyaW5nIGFuZCBpbmRleFxuICAgKiBvZiB0aGUgYWRkcmVzcyBiZWluZyBzd2VwdFxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlckNsb3NlQVRBKHBhcmFtczogU29sUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxCYXNlQnJvYWRjYXN0VHJhbnNhY3Rpb25SZXN1bHRbXT4ge1xuICAgIGlmICghcGFyYW1zLmJpdGdvS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYml0Z29LZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbG9zZUF0YUFkZHJlc3MgfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLmNsb3NlQXRhQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjbG9zZUF0YUFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBjb25zdCBiaXRnb0tleSA9IHBhcmFtcy5iaXRnb0tleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuXG4gICAgLy8gQnVpbGQgdGhlIHRyYW5zYWN0aW9uXG4gICAgY29uc3QgTVBDID0gYXdhaXQgRUREU0FNZXRob2RzLmdldEluaXRpYWxpemVkTXBjSW5zdGFuY2UoKTtcbiAgICBsZXQgYmFsYW5jZSA9IDA7XG4gICAgY29uc3QgZmVlUGVyU2lnbmF0dXJlID0gYXdhaXQgdGhpcy5nZXRGZWVzKCk7XG4gICAgY29uc3QgYmFzZUZlZSA9IHBhcmFtcy5kdXJhYmxlTm9uY2UgPyBmZWVQZXJTaWduYXR1cmUgKiAyIDogZmVlUGVyU2lnbmF0dXJlO1xuICAgIGNvbnN0IHRvdGFsRmVlID0gbmV3IEJpZ051bWJlcihiYXNlRmVlKTtcblxuICAgIGNvbnN0IGluZGV4ID0gcGFyYW1zLmluZGV4IHx8IDA7XG4gICAgY29uc3QgY3VyclBhdGggPSBwYXJhbXMuc2VlZCA/IGdldERlcml2YXRpb25QYXRoKHBhcmFtcy5zZWVkKSArIGAvJHtpbmRleH1gIDogYG0vJHtpbmRleH1gO1xuICAgIGNvbnN0IGFjY291bnRJZCA9IE1QQy5kZXJpdmVVbmhhcmRlbmVkKGJpdGdvS2V5LCBjdXJyUGF0aCkuc2xpY2UoMCwgNjQpO1xuICAgIGNvbnN0IGJzNThFbmNvZGVkUHVibGljS2V5ID0gbmV3IFNvbEtleVBhaXIoeyBwdWI6IGFjY291bnRJZCB9KS5nZXRBZGRyZXNzKCk7XG5cbiAgICBiYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50QmFsYW5jZShiczU4RW5jb2RlZFB1YmxpY0tleSk7XG4gICAgaWYgKHRvdGFsRmVlLmd0KGJhbGFuY2UpKSB7XG4gICAgICB0aHJvdyBFcnJvcignRGlkIG5vdCBmaW5kIGFkZHJlc3Mgd2l0aCBmdW5kcyB0byByZWNvdmVyJyk7XG4gICAgfVxuXG4gICAgYmFsYW5jZSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEJhbGFuY2UocGFyYW1zLmNsb3NlQXRhQWRkcmVzcyk7XG4gICAgaWYgKGJhbGFuY2UgPD0gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0RpZCBub3QgZmluZCBjbG9zZUF0YUFkZHJlc3Mgd2l0aCBzb2wgZnVuZHMgdG8gcmVjb3ZlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcblxuICAgIGxldCB0eEJ1aWxkZXI7XG4gICAgbGV0IGJsb2NraGFzaDtcbiAgICBjb25zdCByZWNvdmVydFR4bnM6IEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvblJlc3VsdFtdID0gW107XG5cbiAgICBjb25zdCByZW50RXhlbXB0QW1vdW50ID0gYXdhaXQgdGhpcy5nZXRSZW50RXhlbXB0QW1vdW50KCk7XG5cbiAgICAvLyBkbyB0b2tlbiByZWNvdmVyeSBiZWZvcmUgY2xvc2luZyBBVEEgYWRkcmVzc1xuICAgIC8vIGNoZWNrIGlmIGFueSB0b2tlbiBpcyBwcmVzZW50IG9uIHRoZSBjbG9zZUF0YUFkZHJlc3NcbiAgICBjb25zdCB0b2tlbkluZm8gPSBhd2FpdCB0aGlzLmdldFRva2VuQWNjb3VudEluZm8ocGFyYW1zLmNsb3NlQXRhQWRkcmVzcyk7XG4gICAgY29uc3QgdG9rZW5CYWxhbmNlID0gTnVtYmVyKHRva2VuSW5mby5pbmZvLnRva2VuQW1vdW50LmFtb3VudCk7XG5cbiAgICBpZiAodG9rZW5CYWxhbmNlID4gMCkge1xuICAgICAgLy8gY2xvc2VBVEEgYWRkcmVzcyBoYXMgc29tZSB0b2tlbiBiYWxhbmNlLCBpdCBuZWVkcyB0byBiZSB3aXRoZHJhd24gYmVmb3JlIGNsb3NpbmcgQVRBXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYGNsb3NlQVRBIGFkZHJlc3MgJHtwYXJhbXMuY2xvc2VBdGFBZGRyZXNzfSBoYXMgdG9rZW4gYmFsYW5jZSAke3Rva2VuQmFsYW5jZX0sIGl0IG5lZWRzIHRvIGJlIHdpdGhkcmF3biBiZWZvcmUgY2xvc2luZyBBVEEgYWRkcmVzc2BcbiAgICAgICk7XG5cbiAgICAgIGlmICghcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb25BdGFBZGRyZXNzIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uQXRhQWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb25BdGFBZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NraGFzaCA9IGF3YWl0IHRoaXMuZ2V0QmxvY2toYXNoKCk7XG5cbiAgICAgIHR4QnVpbGRlciA9IGZhY3RvcnlcbiAgICAgICAgLmdldFRva2VuVHJhbnNmZXJCdWlsZGVyKClcbiAgICAgICAgLm5vbmNlKGJsb2NraGFzaClcbiAgICAgICAgLnNlbmRlcihiczU4RW5jb2RlZFB1YmxpY0tleSlcbiAgICAgICAgLmZlZSh7IGFtb3VudDogZmVlUGVyU2lnbmF0dXJlIH0pXG4gICAgICAgIC5hc3NvY2lhdGVkVG9rZW5BY2NvdW50UmVudChyZW50RXhlbXB0QW1vdW50LnRvU3RyaW5nKCkpXG4gICAgICAgIC5mZWVQYXllcihiczU4RW5jb2RlZFB1YmxpY0tleSk7XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgIGNvbnN0IHRva2VuID0gZ2V0U29sVG9rZW5Gcm9tQWRkcmVzcyh0b2tlbkluZm8uaW5mby5taW50LCBuZXR3b3JrKTtcbiAgICAgIHR4QnVpbGRlci5zZW5kKHtcbiAgICAgICAgYWRkcmVzczogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb25BdGFBZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IHRva2VuQmFsYW5jZSxcbiAgICAgICAgdG9rZW5OYW1lOiB0b2tlbj8ubmFtZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0b2tlblJlY292ZXJ5VHhuID0gYXdhaXQgdGhpcy5zaWduQW5kR2VuZXJhdGVCcm9hZGNhc3RhYmxlVHJhbnNhY3Rpb24oXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgdHhCdWlsZGVyLFxuICAgICAgICBiczU4RW5jb2RlZFB1YmxpY0tleVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUb2tlblJlY292ZXJ5VHhuID0gKGF3YWl0IHRva2VuUmVjb3ZlcnlUeG4pLnNlcmlhbGl6ZWRUeDtcbiAgICAgIGNvbnN0IGJyb2FkY2FzdFRva2VuUmVjb3ZlcnlUeG4gPSBhd2FpdCB0aGlzLmJyb2FkY2FzdFRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2VyaWFsaXplZFNpZ25lZFRyYW5zYWN0aW9uOiBzZXJpYWxpemVkVG9rZW5SZWNvdmVyeVR4bixcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coYnJvYWRjYXN0VG9rZW5SZWNvdmVyeVR4bik7XG4gICAgICByZWNvdmVydFR4bnMucHVzaChicm9hZGNhc3RUb2tlblJlY292ZXJ5VHhuKTtcbiAgICB9XG5cbiAgICAvLyBhZnRlciByZWNvdmVyaW5nIHRoZSB0b2tlbiBhbW91bnQsIGF0dGVtcHRpbmcgdG8gY2xvc2UgdGhlIEFUQSBhZGRyZXNzXG4gICAgaWYgKHBhcmFtcy5jbG9zZUF0YUFkZHJlc3MpIHtcbiAgICAgIGJsb2NraGFzaCA9IGF3YWl0IHRoaXMuZ2V0QmxvY2toYXNoKCk7XG5cbiAgICAgIGNvbnN0IGF0YUNsb3NlQnVpbGRlciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5nZXRDbG9zZUF0YUluaXRpYWxpemF0aW9uQnVpbGRlcigpO1xuICAgICAgICB0eEJ1aWxkZXIubm9uY2UoYmxvY2toYXNoKTtcbiAgICAgICAgdHhCdWlsZGVyLnNlbmRlcihiczU4RW5jb2RlZFB1YmxpY0tleSk7XG4gICAgICAgIHR4QnVpbGRlci5hY2NvdW50QWRkcmVzcyhwYXJhbXMuY2xvc2VBdGFBZGRyZXNzID8/ICcnKTtcbiAgICAgICAgdHhCdWlsZGVyLmRlc3RpbmF0aW9uQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbik7XG4gICAgICAgIHR4QnVpbGRlci5hdXRob3JpdHlBZGRyZXNzKGJzNThFbmNvZGVkUHVibGljS2V5KTtcbiAgICAgICAgdHhCdWlsZGVyLmFzc29jaWF0ZWRUb2tlbkFjY291bnRSZW50KHJlbnRFeGVtcHRBbW91bnQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0eEJ1aWxkZXI7XG4gICAgICB9O1xuICAgICAgdHhCdWlsZGVyID0gYXRhQ2xvc2VCdWlsZGVyKCk7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NlQVRBUmVjb3ZlcnlUeG4gPSBhd2FpdCB0aGlzLnNpZ25BbmRHZW5lcmF0ZUJyb2FkY2FzdGFibGVUcmFuc2FjdGlvbihcbiAgICAgIHBhcmFtcyxcbiAgICAgIHR4QnVpbGRlcixcbiAgICAgIGJzNThFbmNvZGVkUHVibGljS2V5XG4gICAgKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQ2xvc2VBVEFSZWNvdmVyeVR4biA9IChhd2FpdCBjbG9zZUFUQVJlY292ZXJ5VHhuKS5zZXJpYWxpemVkVHg7XG4gICAgY29uc3QgYnJvYWRjYXN0Q2xvc2VBVEFSZWNvdmVyeVR4biA9IGF3YWl0IHRoaXMuYnJvYWRjYXN0VHJhbnNhY3Rpb24oe1xuICAgICAgc2VyaWFsaXplZFNpZ25lZFRyYW5zYWN0aW9uOiBzZXJpYWxpemVkQ2xvc2VBVEFSZWNvdmVyeVR4bixcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZyhicm9hZGNhc3RDbG9zZUFUQVJlY292ZXJ5VHhuKTtcbiAgICByZWNvdmVydFR4bnMucHVzaChicm9hZGNhc3RDbG9zZUFUQVJlY292ZXJ5VHhuKTtcblxuICAgIHJldHVybiByZWNvdmVydFR4bnM7XG4gIH1cblxuICBhc3luYyBzaWduQW5kR2VuZXJhdGVCcm9hZGNhc3RhYmxlVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBTb2xSZWNvdmVyeU9wdGlvbnMsXG4gICAgdHhCdWlsZGVyOiBhbnksXG4gICAgYnM1OEVuY29kZWRQdWJsaWNLZXk6IHN0cmluZ1xuICApOiBQcm9taXNlPE1QQ1R4PiB7XG4gICAgLy8gU2lnbiB0aGUgdHhuXG4gICAgaWYgKCFwYXJhbXMudXNlcktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHVzZXJLZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5iYWNrdXBLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCB1bnNpZ25lZFRyYW5zYWN0aW9uID0gKGF3YWl0IHR4QnVpbGRlci5idWlsZCgpKSBhcyBUcmFuc2FjdGlvbjtcblxuICAgIGNvbnN0IHVzZXJLZXkgPSBwYXJhbXMudXNlcktleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGNvbnN0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICAgIC8vIERlY3J5cHQgcHJpdmF0ZSBrZXlzIGZyb20gS2V5Q2FyZCB2YWx1ZXNcbiAgICBsZXQgdXNlclBydjtcblxuICAgIHRyeSB7XG4gICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyB1c2VyIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZSh1c2VyUHJ2KSBhcyBFRERTQU1ldGhvZFR5cGVzLlVzZXJTaWduaW5nTWF0ZXJpYWw7XG5cbiAgICBsZXQgYmFja3VwUHJ2O1xuICAgIHRyeSB7XG4gICAgICBiYWNrdXBQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBpbnB1dDogYmFja3VwS2V5LFxuICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgYmFja3VwIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYmFja3VwU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZShiYWNrdXBQcnYpIGFzIEVERFNBTWV0aG9kVHlwZXMuQmFja3VwU2lnbmluZ01hdGVyaWFsO1xuXG4gICAgY29uc3QgaW5kZXggPSBwYXJhbXMuaW5kZXggfHwgMDtcbiAgICBjb25zdCBjdXJyUGF0aCA9IHBhcmFtcy5zZWVkID8gZ2V0RGVyaXZhdGlvblBhdGgocGFyYW1zLnNlZWQpICsgYC8ke2luZGV4fWAgOiBgbS8ke2luZGV4fWA7XG5cbiAgICBjb25zdCBzaWduYXR1cmVIZXggPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0VFNTU2lnbmF0dXJlKFxuICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbCxcbiAgICAgIGJhY2t1cFNpZ25pbmdNYXRlcmlhbCxcbiAgICAgIGN1cnJQYXRoLFxuICAgICAgdW5zaWduZWRUcmFuc2FjdGlvblxuICAgICk7XG5cbiAgICBjb25zdCBwdWJsaWNLZXlPYmogPSB7IHB1YjogYnM1OEVuY29kZWRQdWJsaWNLZXkgfTtcbiAgICB0eEJ1aWxkZXIuYWRkU2lnbmF0dXJlKHB1YmxpY0tleU9iaiBhcyBQdWJsaWNLZXksIHNpZ25hdHVyZUhleCk7XG5cbiAgICBjb25zdCBjb21wbGV0ZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9IGNvbXBsZXRlZFRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb246IE1QQ1R4ID0ge1xuICAgICAgc2VyaWFsaXplZFR4OiBzZXJpYWxpemVkVHgsXG4gICAgICBzY2FuSW5kZXg6IGluZGV4LFxuICAgIH07XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBuYXRpdmUgU09MIHJlY292ZXJpZXMgb2YgcmVjZWl2ZSBhZGRyZXNzZXMgaW4gYmF0Y2ggd2l0aG91dCBCaXRHby5cbiAgICogRnVuZHMgd2lsbCBiZSByZWNvdmVyZWQgdG8gYmFzZSBhZGRyZXNzIGZpcnN0LiBZb3UgbmVlZCB0byBpbml0aWF0ZSBhbm90aGVyIHN3ZWVwIHR4biBhZnRlciB0aGF0LlxuICAgKlxuICAgKiBAcGFyYW0ge1NvbENvbnNvbGlkYXRpb25SZWNvdmVyeU9wdGlvbnN9IHBhcmFtcyAtIG9wdGlvbnMgZm9yIGNvbnNvbGlkYXRpb24gcmVjb3ZlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnN0YXJ0aW5nU2NhbkluZGV4XSAtIHJlY2VpdmUgYWRkcmVzcyBpbmRleCB0byBzdGFydCBzY2FubmluZyBmcm9tLiBkZWZhdWx0IHRvIDEgKGluY2x1c2l2ZSkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmVuZGluZ1NjYW5JbmRleF0gLSByZWNlaXZlIGFkZHJlc3MgaW5kZXggdG8gZW5kIHNjYW5uaW5nIGF0LiBkZWZhdWx0IHRvIHN0YXJ0aW5nU2NhbkluZGV4ICsgMjAgKGV4Y2x1c2l2ZSkuXG4gICAqL1xuICBhc3luYyByZWNvdmVyQ29uc29saWRhdGlvbnMocGFyYW1zOiBTb2xDb25zb2xpZGF0aW9uUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxNUENUeHMgfCBNUENTd2VlcFR4cz4ge1xuICAgIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9ICFwYXJhbXMudXNlcktleSAmJiAhcGFyYW1zLmJhY2t1cEtleSAmJiAhcGFyYW1zLndhbGxldFBhc3NwaHJhc2U7XG4gICAgY29uc3Qgc3RhcnRJZHggPSBwYXJhbXMuc3RhcnRpbmdTY2FuSW5kZXggfHwgMTtcbiAgICBjb25zdCBlbmRJZHggPSBwYXJhbXMuZW5kaW5nU2NhbkluZGV4IHx8IHN0YXJ0SWR4ICsgREVGQVVMVF9TQ0FOX0ZBQ1RPUjtcblxuICAgIGlmIChzdGFydElkeCA8IDEgfHwgZW5kSWR4IDw9IHN0YXJ0SWR4IHx8IGVuZElkeCAtIHN0YXJ0SWR4ID4gMTAgKiBERUZBVUxUX1NDQU5fRkFDVE9SKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHN0YXJ0aW5nIG9yIGVuZGluZyBpbmRleCB0byBzY2FuIGZvciBhZGRyZXNzZXMuIHN0YXJ0aW5nU2NhbkluZGV4OiAke3N0YXJ0SWR4fSwgZW5kaW5nU2NhbkluZGV4OiAke2VuZElkeH0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBkdXJhYmxlIG5vbmNlcyBhcnJheVxuICAgIGlmICghcGFyYW1zLmR1cmFibGVOb25jZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkdXJhYmxlIG5vbmNlcycpO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5kdXJhYmxlTm9uY2VzLnB1YmxpY0tleXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkdXJhYmxlIG5vbmNlczogbWlzc2luZyBwdWJsaWMga2V5cycpO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5kdXJhYmxlTm9uY2VzLnNlY3JldEtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGR1cmFibGUgbm9uY2VzIGFycmF5OiBtaXNzaW5nIHNlY3JldCBrZXknKTtcbiAgICB9XG5cbiAgICBjb25zdCBiaXRnb0tleSA9IHBhcmFtcy5iaXRnb0tleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGNvbnN0IE1QQyA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRJbml0aWFsaXplZE1wY0luc3RhbmNlKCk7XG4gICAgY29uc3QgYmFzZUFkZHJlc3NJbmRleCA9IDA7XG4gICAgY29uc3QgYmFzZUFkZHJlc3NQYXRoID0gcGFyYW1zLnNlZWRcbiAgICAgID8gZ2V0RGVyaXZhdGlvblBhdGgocGFyYW1zLnNlZWQpICsgYC8ke2Jhc2VBZGRyZXNzSW5kZXh9YFxuICAgICAgOiBgbS8ke2Jhc2VBZGRyZXNzSW5kZXh9YDtcbiAgICBjb25zdCBhY2NvdW50SWQgPSBNUEMuZGVyaXZlVW5oYXJkZW5lZChiaXRnb0tleSwgYmFzZUFkZHJlc3NQYXRoKS5zbGljZSgwLCA2NCk7XG4gICAgY29uc3QgYmFzZUFkZHJlc3MgPSBuZXcgU29sS2V5UGFpcih7IHB1YjogYWNjb3VudElkIH0pLmdldEFkZHJlc3MoKTtcblxuICAgIGxldCBkdXJhYmxlTm9uY2VQdWJLZXlzSW5kZXggPSAwO1xuICAgIGNvbnN0IGR1cmFibGVOb25jZVB1YktleXNMZW5ndGggPSBwYXJhbXMuZHVyYWJsZU5vbmNlcy5wdWJsaWNLZXlzLmxlbmd0aDtcbiAgICBjb25zdCBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zOiBhbnlbXSA9IFtdO1xuICAgIGxldCBsYXN0U2NhbkluZGV4ID0gc3RhcnRJZHg7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SWR4OyBpIDwgZW5kSWR4OyBpKyspIHtcbiAgICAgIGNvbnN0IHJlY292ZXJQYXJhbXMgPSB7XG4gICAgICAgIHVzZXJLZXk6IHBhcmFtcy51c2VyS2V5LFxuICAgICAgICBiYWNrdXBLZXk6IHBhcmFtcy5iYWNrdXBLZXksXG4gICAgICAgIGJpdGdvS2V5OiBwYXJhbXMuYml0Z29LZXksXG4gICAgICAgIHdhbGxldFBhc3NwaHJhc2U6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICByZWNvdmVyeURlc3RpbmF0aW9uOiBiYXNlQWRkcmVzcyxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICBkdXJhYmxlTm9uY2U6IHtcbiAgICAgICAgICBwdWJsaWNLZXk6IHBhcmFtcy5kdXJhYmxlTm9uY2VzLnB1YmxpY0tleXNbZHVyYWJsZU5vbmNlUHViS2V5c0luZGV4XSxcbiAgICAgICAgICBzZWNyZXRLZXk6IHBhcmFtcy5kdXJhYmxlTm9uY2VzLnNlY3JldEtleSxcbiAgICAgICAgfSxcbiAgICAgICAgdG9rZW5Db250cmFjdEFkZHJlc3M6IHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIH07XG5cbiAgICAgIGxldCByZWNvdmVyeVRyYW5zYWN0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVjb3ZlcnlUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMucmVjb3ZlcihyZWNvdmVyUGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGUubWVzc2FnZSA9PT0gJ0RpZCBub3QgZmluZCBhZGRyZXNzIHdpdGggZnVuZHMgdG8gcmVjb3ZlcicgfHxcbiAgICAgICAgICBlLm1lc3NhZ2UgPT09ICdEaWQgbm90IGZpbmQgdG9rZW4gYWNjb3VudCB0byByZWNvdmVyIHRva2VucywgcGxlYXNlIGNoZWNrIHRva2VuIGFjY291bnQnIHx8XG4gICAgICAgICAgZS5tZXNzYWdlID09PSAnTm90IGVub3VnaCB0b2tlbiBmdW5kcyB0byByZWNvdmVyJ1xuICAgICAgICApIHtcbiAgICAgICAgICBsYXN0U2NhbkluZGV4ID0gaTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgIGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnMucHVzaCgocmVjb3ZlcnlUcmFuc2FjdGlvbiBhcyBNUENTd2VlcFR4cykudHhSZXF1ZXN0c1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLnB1c2gocmVjb3ZlcnlUcmFuc2FjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGxhc3RTY2FuSW5kZXggPSBpO1xuICAgICAgZHVyYWJsZU5vbmNlUHViS2V5c0luZGV4Kys7XG4gICAgICBpZiAoZHVyYWJsZU5vbmNlUHViS2V5c0luZGV4ID49IGR1cmFibGVOb25jZVB1YktleXNMZW5ndGgpIHtcbiAgICAgICAgLy8gbm8gbW9yZSBhdmFpbGFibGUgbm9uY2UgYWNjb3VudHMgdG8gY3JlYXRlIHRyYW5zYWN0aW9uc1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29uc29saWRhdGlvblRyYW5zYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBmaW5kIGFuIGFkZHJlc3Mgd2l0aCBmdW5kcyB0byByZWNvdmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgLy8gbGFzdFNjYW5JbmRleCB3aWxsIGJlIHVzZWQgdG8gaW5mb3JtIHVzZXIgdGhlIGxhc3QgYWRkcmVzcyBpbmRleCBzY2FubmVkIGZvciBhdmFpbGFibGUgZnVuZHMgKHNvIHRoZXkgY2FuXG4gICAgICAvLyBhcHByb3ByaWF0ZWx5IGFkanVzdCB0aGUgc2NhbiByYW5nZSBvbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgY29uc29saWRhdGlvbiByZWNvdmVyaWVzKS4gSW4gdGhlIGNhc2Ugb2YgdW5zaWduZWRcbiAgICAgIC8vIHN3ZWVwIGNvbnNvbGlkYXRpb25zLCB0aGlzIGxhc3RTY2FuSW5kZXggd2lsbCBiZSBwcm92aWRlZCBpbiB0aGUgY29pblNwZWNpZmljIG9mIHRoZSBsYXN0IHR4biBtYWRlLlxuICAgICAgY29uc3QgbGFzdFRyYW5zYWN0aW9uQ29pblNwZWNpZmljID0ge1xuICAgICAgICBjb21tb25LZXljaGFpbjpcbiAgICAgICAgICBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zW2NvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnMubGVuZ3RoIC0gMV0udHJhbnNhY3Rpb25zWzBdLnVuc2lnbmVkVHguY29pblNwZWNpZmljXG4gICAgICAgICAgICAuY29tbW9uS2V5Y2hhaW4sXG4gICAgICAgIGxhc3RTY2FuSW5kZXg6IGxhc3RTY2FuSW5kZXgsXG4gICAgICB9O1xuICAgICAgY29uc29saWRhdGlvblRyYW5zYWN0aW9uc1tjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLnRyYW5zYWN0aW9uc1swXS51bnNpZ25lZFR4LmNvaW5TcGVjaWZpYyA9XG4gICAgICAgIGxhc3RUcmFuc2FjdGlvbkNvaW5TcGVjaWZpYztcbiAgICAgIGNvbnN0IGNvbnNvbGlkYXRpb25Td2VlcFRyYW5zYWN0aW9uczogTVBDU3dlZXBUeHMgPSB7IHR4UmVxdWVzdHM6IGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnMgfTtcbiAgICAgIHJldHVybiBjb25zb2xpZGF0aW9uU3dlZXBUcmFuc2FjdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJhbnNhY3Rpb25zOiBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLCBsYXN0U2NhbkluZGV4IH07XG4gIH1cblxuICBnZXRUb2tlbkVuYWJsZW1lbnRDb25maWcoKTogVG9rZW5FbmFibGVtZW50Q29uZmlnIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWlyZXNUb2tlbkVuYWJsZW1lbnQ6IHRydWUsXG4gICAgICBzdXBwb3J0c011bHRpcGxlVG9rZW5FbmFibGVtZW50czogdHJ1ZSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRCdWlsZGVyKCk6IFRyYW5zYWN0aW9uQnVpbGRlckZhY3Rvcnkge1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2lucy5nZXQodGhpcy5nZXRDaGFpbigpKSk7XG4gIH1cblxuICBhc3luYyBicm9hZGNhc3RUcmFuc2FjdGlvbih7XG4gICAgc2VyaWFsaXplZFNpZ25lZFRyYW5zYWN0aW9uLFxuICB9OiBCYXNlQnJvYWRjYXN0VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxCYXNlQnJvYWRjYXN0VHJhbnNhY3Rpb25SZXN1bHQ+IHtcbiAgICB2YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHNlcmlhbGl6ZWRTaWduZWRUcmFuc2FjdGlvbiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldERhdGFGcm9tTm9kZSh7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGlkOiAnMScsXG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICdzZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICBzZXJpYWxpemVkU2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3BvbnNlLmJvZHkuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYnJvYWRjYXN0aW5nIHRyYW5zYWN0aW9uOiAnICsgcmVzcG9uc2UuYm9keS5lcnJvci5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eElkOiByZXNwb25zZS5ib2R5LnJlc3VsdCB9O1xuICB9XG59XG4iXX0=